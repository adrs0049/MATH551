import {
  ArrayExt,
  AttachedProperty,
  CommandRegistry,
  DisposableDelegate,
  ElementExt,
  ObservableJSON,
  ObservableList,
  ObservableString,
  Platform,
  Printing,
  Sanitizer,
  Selector,
  Signal,
  StringExt,
  VirtualDOM,
  WidgetTracker,
  __assign,
  __awaiter,
  __rest,
  __spreadArray,
  _arrayLikeToArray,
  _defineProperty,
  _extends,
  _typeof,
  _unsupportedIterableToArray,
  each,
  empty,
  every,
  find,
  getKeyboardLayout,
  h,
  init_arrayLikeToArray,
  init_defineProperty,
  init_extends,
  init_index_es6,
  init_index_es62,
  init_index_es63,
  init_index_es64,
  init_index_es65,
  init_index_es66,
  init_index_es67,
  init_index_es68,
  init_lib,
  init_lib3 as init_lib2,
  init_lib5 as init_lib3,
  init_toPropertyKey,
  init_tslib_es6,
  init_typeof,
  init_unsupportedIterableToArray,
  map,
  nullTranslator,
  require_cjs,
  require_dist,
  require_escape_string_regexp,
  require_isEqual,
  require_is_plain_object,
  require_jsx_runtime,
  require_lib,
  require_lib2,
  require_lib3,
  require_parse_srcset,
  require_postcss,
  retro,
  some,
  toPropertyKey,
  tslib_es6_exports
} from "/build/_shared/chunk-IW6XPN43.js";
import {
  MessageLoop,
  Panel,
  PanelLayout,
  TabBar,
  Widget,
  init_index_es6 as init_index_es69,
  init_index_es62 as init_index_es610
} from "/build/_shared/chunk-ZNGG4FXY.js";
import {
  color,
  init_src
} from "/build/_shared/chunk-2WW6JOYG.js";
import {
  SourceFileKind
} from "/build/_shared/chunk-IMMBAB6Q.js";
import {
  doi,
  validatePageFrontmatter
} from "/build/_shared/chunk-7SI5XUIQ.js";
import {
  dump,
  load
} from "/build/_shared/chunk-DOEQHMLC.js";
import {
  require_classnames
} from "/build/_shared/chunk-ZNG4DSCS.js";
import {
  VFile
} from "/build/_shared/chunk-MWXHQG25.js";
import {
  RuleId,
  extractPart,
  fileError,
  matches,
  select,
  selectAll,
  selectMdastNodes,
  slugToUrl
} from "/build/_shared/chunk-Q6DHUCUI.js";
import {
  Link,
  Links,
  LiveReload,
  Meta,
  NavLink,
  Scripts,
  ScrollRestoration,
  isRouteErrorResponse,
  require_jsx_dev_runtime,
  useFetcher,
  useLocation,
  useNavigate,
  useNavigation,
  useRouteError
} from "/build/_shared/chunk-2RVQXRZB.js";
import {
  require_client,
  require_react,
  require_react_dom
} from "/build/_shared/chunk-3RNZ6DIW.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "/build/_shared/chunk-CGOEG7L2.js";

// ../../node_modules/@babel/runtime/helpers/OverloadYield.js
var require_OverloadYield = __commonJS({
  "../../node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
    function _OverloadYield(e3, d6) {
      this.v = e3, this.k = d6;
    }
    module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorDefine.js
var require_regeneratorDefine = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
    function _regeneratorDefine(e3, r4, n5, t11) {
      var i6 = Object.defineProperty;
      try {
        i6({}, "", {});
      } catch (e4) {
        i6 = 0;
      }
      module.exports = _regeneratorDefine = function regeneratorDefine(e4, r5, n6, t12) {
        function o11(r6, n7) {
          _regeneratorDefine(e4, r6, function(e5) {
            return this._invoke(r6, n7, e5);
          });
        }
        r5 ? i6 ? i6(e4, r5, {
          value: n6,
          enumerable: !t12,
          configurable: !t12,
          writable: !t12
        }) : e4[r5] = n6 : (o11("next", 0), o11("throw", 1), o11("return", 2));
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e3, r4, n5, t11);
    }
    module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regenerator.js
var require_regenerator = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
    var regeneratorDefine = require_regeneratorDefine();
    function _regenerator() {
      var e3, t11, r4 = "function" == typeof Symbol ? Symbol : {}, n5 = r4.iterator || "@@iterator", o11 = r4.toStringTag || "@@toStringTag";
      function i6(r5, n6, o12, i7) {
        var c7 = n6 && n6.prototype instanceof Generator ? n6 : Generator, u7 = Object.create(c7.prototype);
        return regeneratorDefine(u7, "_invoke", function(r6, n7, o13) {
          var i8, c8, u8, f7 = 0, p3 = o13 || [], y4 = false, G2 = {
            p: 0,
            n: 0,
            v: e3,
            a: d6,
            f: d6.bind(e3, 4),
            d: function d7(t12, r7) {
              return i8 = t12, c8 = 0, u8 = e3, G2.n = r7, a3;
            }
          };
          function d6(r7, n8) {
            for (c8 = r7, u8 = n8, t11 = 0; !y4 && f7 && !o14 && t11 < p3.length; t11++) {
              var o14, i9 = p3[t11], d7 = G2.p, l7 = i9[2];
              r7 > 3 ? (o14 = l7 === n8) && (u8 = i9[(c8 = i9[4]) ? 5 : (c8 = 3, 3)], i9[4] = i9[5] = e3) : i9[0] <= d7 && ((o14 = r7 < 2 && d7 < i9[1]) ? (c8 = 0, G2.v = n8, G2.n = i9[1]) : d7 < l7 && (o14 = r7 < 3 || i9[0] > n8 || n8 > l7) && (i9[4] = r7, i9[5] = n8, G2.n = l7, c8 = 0));
            }
            if (o14 || r7 > 1)
              return a3;
            throw y4 = true, n8;
          }
          return function(o14, p4, l7) {
            if (f7 > 1)
              throw TypeError("Generator is already running");
            for (y4 && 1 === p4 && d6(p4, l7), c8 = p4, u8 = l7; (t11 = c8 < 2 ? e3 : u8) || !y4; ) {
              i8 || (c8 ? c8 < 3 ? (c8 > 1 && (G2.n = -1), d6(c8, u8)) : G2.n = u8 : G2.v = u8);
              try {
                if (f7 = 2, i8) {
                  if (c8 || (o14 = "next"), t11 = i8[o14]) {
                    if (!(t11 = t11.call(i8, u8)))
                      throw TypeError("iterator result is not an object");
                    if (!t11.done)
                      return t11;
                    u8 = t11.value, c8 < 2 && (c8 = 0);
                  } else
                    1 === c8 && (t11 = i8["return"]) && t11.call(i8), c8 < 2 && (u8 = TypeError("The iterator does not provide a '" + o14 + "' method"), c8 = 1);
                  i8 = e3;
                } else if ((t11 = (y4 = G2.n < 0) ? u8 : r6.call(n7, G2)) !== a3)
                  break;
              } catch (t12) {
                i8 = e3, c8 = 1, u8 = t12;
              } finally {
                f7 = 1;
              }
            }
            return {
              value: t11,
              done: y4
            };
          };
        }(r5, o12, i7), true), u7;
      }
      var a3 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t11 = Object.getPrototypeOf;
      var c6 = [][n5] ? t11(t11([][n5]())) : (regeneratorDefine(t11 = {}, n5, function() {
        return this;
      }), t11), u6 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c6);
      function f6(e4) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e4, GeneratorFunctionPrototype) : (e4.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e4, o11, "GeneratorFunction")), e4.prototype = Object.create(u6), e4;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u6, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o11, "GeneratorFunction"), regeneratorDefine(u6), regeneratorDefine(u6, o11, "Generator"), regeneratorDefine(u6, n5, function() {
        return this;
      }), regeneratorDefine(u6, "toString", function() {
        return "[object Generator]";
      }), (module.exports = _regenerator = function _regenerator2() {
        return {
          w: i6,
          m: f6
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
var require_regeneratorAsyncIterator = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regeneratorDefine = require_regeneratorDefine();
    function AsyncIterator(t11, e3) {
      function n5(r5, o11, i6, f6) {
        try {
          var c6 = t11[r5](o11), u6 = c6.value;
          return u6 instanceof OverloadYield ? e3.resolve(u6.v).then(function(t12) {
            n5("next", t12, i6, f6);
          }, function(t12) {
            n5("throw", t12, i6, f6);
          }) : e3.resolve(u6).then(function(t12) {
            c6.value = t12, i6(c6);
          }, function(t12) {
            return n5("throw", t12, i6, f6);
          });
        } catch (t12) {
          f6(t12);
        }
      }
      var r4;
      this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
        return this;
      })), regeneratorDefine(this, "_invoke", function(t12, o11, i6) {
        function f6() {
          return new e3(function(e4, r5) {
            n5(t12, i6, e4, r5);
          });
        }
        return r4 = r4 ? r4.then(f6, f6) : f6();
      }, true);
    }
    module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
var require_regeneratorAsyncGen = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
    var regenerator = require_regenerator();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    function _regeneratorAsyncGen(r4, e3, t11, o11, n5) {
      return new regeneratorAsyncIterator(regenerator().w(r4, e3, t11, o11), n5 || Promise);
    }
    module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorAsync.js
var require_regeneratorAsync = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    function _regeneratorAsync(n5, e3, r4, t11, o11) {
      var a3 = regeneratorAsyncGen(n5, e3, r4, t11, o11);
      return a3.next().then(function(n6) {
        return n6.done ? n6.value : a3.next();
      });
    }
    module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorKeys.js
var require_regeneratorKeys = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
    function _regeneratorKeys(e3) {
      var n5 = Object(e3), r4 = [];
      for (var t11 in n5)
        r4.unshift(t11);
      return function e4() {
        for (; r4.length; )
          if ((t11 = r4.pop()) in n5)
            return e4.value = t11, e4.done = false, e4;
        return e4.done = true, e4;
      };
    }
    module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../../node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof2(o11) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o12) {
        return typeof o12;
      } : function(o12) {
        return o12 && "function" == typeof Symbol && o12.constructor === Symbol && o12 !== Symbol.prototype ? "symbol" : typeof o12;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o11);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorValues.js
var require_regeneratorValues = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorValues(e3) {
      if (null != e3) {
        var t11 = e3["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r4 = 0;
        if (t11)
          return t11.call(e3);
        if ("function" == typeof e3.next)
          return e3;
        if (!isNaN(e3.length))
          return {
            next: function next() {
              return e3 && r4 >= e3.length && (e3 = void 0), {
                value: e3 && e3[r4++],
                done: !e3
              };
            }
          };
      }
      throw new TypeError(_typeof2(e3) + " is not iterable");
    }
    module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regenerator = require_regenerator();
    var regeneratorAsync = require_regeneratorAsync();
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    var regeneratorKeys = require_regeneratorKeys();
    var regeneratorValues = require_regeneratorValues();
    function _regeneratorRuntime3() {
      "use strict";
      var r4 = regenerator(), e3 = r4.m(_regeneratorRuntime3), t11 = (Object.getPrototypeOf ? Object.getPrototypeOf(e3) : e3.__proto__).constructor;
      function n5(r5) {
        var e4 = "function" == typeof r5 && r5.constructor;
        return !!e4 && (e4 === t11 || "GeneratorFunction" === (e4.displayName || e4.name));
      }
      var o11 = {
        "throw": 1,
        "return": 2,
        "break": 3,
        "continue": 3
      };
      function a3(r5) {
        var e4, t12;
        return function(n6) {
          e4 || (e4 = {
            stop: function stop() {
              return t12(n6.a, 2);
            },
            "catch": function _catch() {
              return n6.v;
            },
            abrupt: function abrupt(r6, e5) {
              return t12(n6.a, o11[r6], e5);
            },
            delegateYield: function delegateYield(r6, o12, a4) {
              return e4.resultName = o12, t12(n6.d, regeneratorValues(r6), a4);
            },
            finish: function finish(r6) {
              return t12(n6.f, r6);
            }
          }, t12 = function t13(r6, _t, o12) {
            n6.p = e4.prev, n6.n = e4.next;
            try {
              return r6(_t, o12);
            } finally {
              e4.next = n6.n;
            }
          }), e4.resultName && (e4[e4.resultName] = n6.v, e4.resultName = void 0), e4.sent = n6.v, e4.next = n6.n;
          try {
            return r5.call(this, e4);
          } finally {
            n6.p = e4.prev, n6.n = e4.next;
          }
        };
      }
      return (module.exports = _regeneratorRuntime3 = function _regeneratorRuntime4() {
        return {
          wrap: function wrap2(e4, t12, n6, o12) {
            return r4.w(a3(e4), t12, n6, o12 && o12.reverse());
          },
          isGeneratorFunction: n5,
          mark: r4.m,
          awrap: function awrap(r5, e4) {
            return new OverloadYield(r5, e4);
          },
          AsyncIterator: regeneratorAsyncIterator,
          async: function async(r5, e4, t12, o12, u6) {
            return (n5(e4) ? regeneratorAsyncGen : regeneratorAsync)(a3(r5), e4, t12, o12, u6);
          },
          keys: regeneratorKeys,
          values: regeneratorValues
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regeneratorRuntime3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/regenerator/index.js
var require_regenerator2 = __commonJS({
  "../../node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x2, y4) {
        return x2 === y4 && (0 !== x2 || 1 / x2 === 1 / y4) || x2 !== x2 && y4 !== y4;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React113.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState36({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect7(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect41(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React113 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useState36 = React113.useState, useEffect41 = React113.useEffect, useLayoutEffect7 = React113.useLayoutEffect, useDebugValue2 = React113.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React113.useSyncExternalStore ? React113.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root2.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject4(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result2 = func.apply(thisArg, args);
        return result2;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result2;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result2;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result2 : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result2;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle3(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject4(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle3;
  }
});

// empty-module:~/utils/loaders.server
var require_loaders = __commonJS({
  "empty-module:~/utils/loaders.server"(exports, module) {
    module.exports = {};
  }
});

// ../../node_modules/thebe-react/dist/OutputAreaByRef.js
var require_OutputAreaByRef = __commonJS({
  "../../node_modules/thebe-react/dist/OutputAreaByRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputAreaByRef = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importDefault(require_react());
    exports.OutputAreaByRef = react_1.default.forwardRef(({ busy, content }, ref) => {
      return (0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "m-1 hover:delay-15" }, { children: [(0, jsx_runtime_1.jsx)("div", Object.assign({ className: "p-1 rounded", ref }, { children: content ? content : "[Output Area]" })), busy && (0, jsx_runtime_1.jsx)("div", { children: "Cell is running..." })] })) });
    });
  }
});

// ../../node_modules/thebe-react/dist/version.js
var require_version = __commonJS({
  "../../node_modules/thebe-react/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var version3 = "0.5.0";
    exports.default = version3;
  }
});

// ../../node_modules/thebe-core/dist/esm/url.js
function makeDefaultStorageKey(storagePrefix, url) {
  const urlObj = new URL(url);
  return `${storagePrefix}-${urlObj.origin + urlObj.pathname}`;
}
function makeDefaultBuildSpec(storagePrefix, binderUrl, stub) {
  const build = `${binderUrl}/build/${stub}`;
  const launch = `${binderUrl}/v2/${stub}`;
  return {
    build,
    launch,
    storageKey: makeDefaultStorageKey(storagePrefix, build)
  };
}
function makeGitUrls(config) {
  if (!config.binder.repo)
    throw Error("repo is required for git provider");
  const { repo, binderUrl, ref } = config.binder;
  const encodedRepo = encodeURIComponent(repo.replace(/(^\/)|(\/?$)/g, ""));
  const base = binderUrl === null || binderUrl === void 0 ? void 0 : binderUrl.replace(/(\/?$)/g, "");
  const stub = `git/${encodedRepo}/${ref !== null && ref !== void 0 ? ref : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, base, stub);
}
function makeGitLabUrl(config) {
  var _a, _b, _c;
  if (!config.binder.repo)
    throw Error("repo is required for gitlab provider");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const repo = encodeURIComponent(((_b = config.binder.repo) !== null && _b !== void 0 ? _b : "").replace(/^(https?:\/\/)?gitlab.com\//, "").replace(/(^\/)|(\/?$)/g, ""));
  const stub = `gl/${repo}/${(_c = config.binder.ref) !== null && _c !== void 0 ? _c : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeGitHubUrl(config) {
  var _a, _b;
  if (!config.binder.repo)
    throw Error("repo is required for github provider");
  const repo = config.binder.repo.replace(/^(https?:\/\/)?github.com\//, "").replace(/(^\/)|(\/?$)/g, "");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const stub = `gh/${repo}/${(_b = config.binder.ref) !== null && _b !== void 0 ? _b : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeGistUrl(config) {
  var _a, _b;
  if (!config.binder.repo)
    throw Error("repo is required for gist provider");
  const repo = config.binder.repo.replace(/^(https?:\/\/)?github.com\//, "").replace(/(^\/)|(\/?$)/g, "");
  const binderUrl = (_a = config.binder.binderUrl) === null || _a === void 0 ? void 0 : _a.replace(/(\/?$)/g, "");
  const stub = `gist/${repo}/${(_b = config.binder.ref) !== null && _b !== void 0 ? _b : "HEAD"}`;
  return makeDefaultBuildSpec(config.savedSessions.storagePrefix, binderUrl, stub);
}
function makeBinderUrls(config, repoProviders) {
  var _a, _b;
  const providerMap = (_a = repoProviders.reduce((obj, spec) => Object.assign(Object.assign({}, obj), { [spec.name]: spec }), {})) !== null && _a !== void 0 ? _a : {};
  const provider = (_b = config.binder.repoProvider) !== null && _b !== void 0 ? _b : "github";
  if (!Object.keys(providerMap).includes(provider))
    throw Error(`Unknown provider ${config.binder.repoProvider}`);
  if (!providerMap[provider].makeUrls)
    throw Error(`No makeUrls function for ${provider}`);
  return providerMap[provider].makeUrls(config);
}
var GITHUB_SPEC, GITLAB_SPEC, GIT_SPEC, GIST_SPEC, WELL_KNOWN_REPO_PROVIDERS;
var init_url = __esm({
  "../../node_modules/thebe-core/dist/esm/url.js"() {
    GITHUB_SPEC = {
      name: "github",
      makeUrls: makeGitHubUrl
    };
    GITLAB_SPEC = {
      name: "gitlab",
      makeUrls: makeGitLabUrl
    };
    GIT_SPEC = {
      name: "git",
      makeUrls: makeGitUrls
    };
    GIST_SPEC = {
      name: "gist",
      makeUrls: makeGistUrl
    };
    WELL_KNOWN_REPO_PROVIDERS = [GITHUB_SPEC, GITLAB_SPEC, GIT_SPEC, GIST_SPEC];
  }
});

// ../../node_modules/thebe-core/dist/esm/sessions.js
function updateLastUsedTimestamp(storageKey) {
  const saved = window.localStorage.getItem(storageKey);
  if (!saved)
    return;
  const obj = JSON.parse(saved);
  window.localStorage.setItem(storageKey, JSON.stringify(Object.assign(Object.assign({}, obj), { lastUsed: /* @__PURE__ */ new Date() })));
}
function saveServerInfo(storageKey, id, serverSettings) {
  try {
    const { baseUrl, token, wsUrl } = serverSettings;
    window.localStorage.setItem(storageKey, JSON.stringify({
      id,
      baseUrl,
      token,
      wsUrl,
      lastUsed: /* @__PURE__ */ new Date()
    }));
  } catch (e3) {
    console.warn("Couldn't save thebe binder connection info to local storage", e3);
  }
}
function getExistingServer(savedSessionOptions, storageKey) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!savedSessionOptions.enabled)
      return null;
    const storedInfoJSON = window.localStorage.getItem(storageKey);
    if (storedInfoJSON == null) {
      console.debug("thebe:getExistingServer No session saved in ", storageKey);
      return null;
    }
    console.debug("thebe:getExistingServer Saved binder session found");
    const existingSettings = JSON.parse(storedInfoJSON !== null && storedInfoJSON !== void 0 ? storedInfoJSON : "");
    const lastUsed = new Date(existingSettings.lastUsed);
    const now = /* @__PURE__ */ new Date();
    const ageSeconds = (now.getTime() - lastUsed.getTime()) / 1e3;
    if (ageSeconds > savedSessionOptions.maxAge) {
      console.debug(`thebe:getExistingServer Not using expired binder session for ${existingSettings.baseUrl} from ${lastUsed}`);
      window.localStorage.removeItem(storageKey);
      return null;
    }
    try {
      yield import_services.KernelAPI.listRunning(import_services.ServerConnection.makeSettings(existingSettings));
    } catch (err) {
      console.debug("thebe:getExistingServer Saved binder connection appears to be invalid, requesting new session", err);
      window.localStorage.removeItem(storageKey);
      return null;
    }
    updateLastUsedTimestamp(storageKey);
    console.debug(`thebe:getExistingServer Saved binder session is valid and will be reused ${existingSettings.baseUrl}`);
    return existingSettings;
  });
}
function clearAllSavedSessions(storagePrefix = "thebe-binder") {
  const keysToRemove = [];
  for (let i6 = 0; i6 < window.localStorage.length; i6++) {
    const key = window.localStorage.key(i6);
    if (key === null || key === void 0 ? void 0 : key.startsWith(storagePrefix)) {
      keysToRemove.push(key);
    }
  }
  console.debug(`thebe:clearAllSavedSessions - removing ${keysToRemove.length} saved sessions`, keysToRemove.join(","));
  keysToRemove.forEach((key) => window.localStorage.removeItem(key));
}
function clearSavedSession(storageKey) {
  console.debug(`thebe:clearSavedSession - removing ${storageKey}`);
  window.localStorage.removeItem(storageKey);
}
var import_services;
var init_sessions = __esm({
  "../../node_modules/thebe-core/dist/esm/sessions.js"() {
    init_tslib_es6();
    import_services = __toESM(require_lib2());
  }
});

// ../../node_modules/thebe-core/dist/esm/events.js
function errorToMessage(json) {
  var _a;
  if (!json.traceback) {
    return json.evalue;
  } else if (Array.isArray(json.traceback)) {
    return `${json.evalue}
${((_a = json.traceback) !== null && _a !== void 0 ? _a : []).join("")}`;
  } else {
    return `${json.evalue}
${JSON.stringify(json.traceback)}`;
  }
}
var ServerStatusEvent, SessionStatusEvent, KernelStatusEvent, NotebookStatusEvent, CellStatusEvent, EventSubject, ErrorStatusEvent, ThebeEventType, ThebeEvents;
var init_events = __esm({
  "../../node_modules/thebe-core/dist/esm/events.js"() {
    (function(ServerStatusEvent2) {
      ServerStatusEvent2["launching"] = "launching";
      ServerStatusEvent2["ready"] = "server-ready";
      ServerStatusEvent2["closed"] = "closed";
      ServerStatusEvent2["unknown"] = "unknown";
    })(ServerStatusEvent || (ServerStatusEvent = {}));
    (function(SessionStatusEvent2) {
      SessionStatusEvent2["starting"] = "starting";
      SessionStatusEvent2["ready"] = "ready";
      SessionStatusEvent2["shutdown"] = "shutdown";
    })(SessionStatusEvent || (SessionStatusEvent = {}));
    (function(KernelStatusEvent2) {
      KernelStatusEvent2["starting"] = "starting";
      KernelStatusEvent2["ready"] = "ready";
      KernelStatusEvent2["shutdown"] = "shutdown";
    })(KernelStatusEvent || (KernelStatusEvent = {}));
    (function(NotebookStatusEvent2) {
      NotebookStatusEvent2["attached"] = "attached";
      NotebookStatusEvent2["detached"] = "detached";
      NotebookStatusEvent2["executing"] = "executing";
      NotebookStatusEvent2["idle"] = "idle";
    })(NotebookStatusEvent || (NotebookStatusEvent = {}));
    (function(CellStatusEvent2) {
      CellStatusEvent2["attached"] = "attached";
      CellStatusEvent2["detached"] = "detached";
      CellStatusEvent2["executing"] = "executing";
      CellStatusEvent2["idle"] = "idle";
    })(CellStatusEvent || (CellStatusEvent = {}));
    (function(EventSubject2) {
      EventSubject2["server"] = "server";
      EventSubject2["session"] = "session";
      EventSubject2["kernel"] = "kernel";
      EventSubject2["notebook"] = "notebook";
      EventSubject2["cell"] = "cell";
    })(EventSubject || (EventSubject = {}));
    (function(ErrorStatusEvent2) {
      ErrorStatusEvent2["warning"] = "warning";
      ErrorStatusEvent2["executeError"] = "execute-error";
      ErrorStatusEvent2["error"] = "error";
      ErrorStatusEvent2["server"] = "server-error";
      ErrorStatusEvent2["session"] = "session-error";
    })(ErrorStatusEvent || (ErrorStatusEvent = {}));
    (function(ThebeEventType2) {
      ThebeEventType2["status"] = "status";
      ThebeEventType2["error"] = "error";
    })(ThebeEventType || (ThebeEventType = {}));
    ThebeEvents = class {
      constructor() {
        this.listeners = {};
      }
      _ensureMap(event) {
        if (!(event in this.listeners))
          this.listeners[event] = /* @__PURE__ */ new Map();
      }
      trigger(event, evt) {
        if (!(event in this.listeners))
          return;
        this.listeners[event].forEach(({ unbind }, cb2) => {
          cb2(event, evt);
          if (unbind)
            this.listeners[event].delete(cb2);
        });
      }
      on(event, cb2) {
        this._ensureMap(event);
        this.listeners[event].set(cb2, { unbind: false });
        return () => this.off(event, cb2);
      }
      one(event, cb2) {
        this._ensureMap(event);
        this.listeners[event].set(cb2, { unbind: true });
        return () => this.off(event, cb2);
      }
      off(event, cb2) {
        if (!(event in this.listeners))
          return;
        this.listeners[event].delete(cb2);
      }
    };
  }
});

// ../../node_modules/thebe-core/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList, Private;
var init_index_es611 = __esm({
  "../../node_modules/thebe-core/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList5) {
      function from(values2) {
        let list = new LinkedList5();
        list.assign(values2);
        return list;
      }
      LinkedList5.from = from;
    })(LinkedList || (LinkedList = {}));
    (function(Private22) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private22.LinkedListNode = LinkedListNode;
    })(Private || (Private = {}));
  }
});

// ../../node_modules/thebe-core/node_modules/@lumino/messaging/dist/index.es6.js
var Message, ConflatableMessage, MessageLoop2;
var init_index_es612 = __esm({
  "../../node_modules/thebe-core/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es6();
    init_index_es611();
    Message = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    ConflatableMessage = class extends Message {
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * This property is always `true`.
       */
      get isConflatable() {
        return true;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * #### Notes
       * This method always returns `true`.
       */
      conflate(other) {
        return true;
      }
    };
    (function(MessageLoop6) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop6.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop6.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop6.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i6 = hooks.indexOf(hook);
        if (i6 === -1) {
          return;
        }
        hooks[i6] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop6.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop6.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop6.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop6.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop6.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt.removeAllWhere(hooks, isNull2);
      }
      function isNull2(value) {
        return value === null;
      }
    })(MessageLoop2 || (MessageLoop2 = {}));
  }
});

// ../../node_modules/thebe-core/node_modules/@lumino/dragdrop/dist/index.es6.js
var Drag, Private2;
var init_index_es613 = __esm({
  "../../node_modules/thebe-core/node_modules/@lumino/dragdrop/dist/index.es6.js"() {
    init_index_es63();
    Drag = class {
      /**
       * Construct a new drag object.
       *
       * @param options - The options for initializing the drag.
       */
      constructor(options) {
        this._onScrollFrame = () => {
          if (!this._scrollTarget) {
            return;
          }
          let { element: element2, edge, distance } = this._scrollTarget;
          let d6 = Private2.SCROLL_EDGE_SIZE - distance;
          let f6 = Math.pow(d6 / Private2.SCROLL_EDGE_SIZE, 2);
          let s8 = Math.max(1, Math.round(f6 * Private2.SCROLL_EDGE_SIZE));
          switch (edge) {
            case "top":
              element2.scrollTop -= s8;
              break;
            case "left":
              element2.scrollLeft -= s8;
              break;
            case "right":
              element2.scrollLeft += s8;
              break;
            case "bottom":
              element2.scrollTop += s8;
              break;
          }
          requestAnimationFrame(this._onScrollFrame);
        };
        this._disposed = false;
        this._dropAction = "none";
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._scrollTarget = null;
        this._resolve = null;
        this.document = options.document || document;
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || "copy";
        this.supportedActions = options.supportedActions || "all";
        this.source = options.source || null;
      }
      /**
       * Dispose of the resources held by the drag object.
       *
       * #### Notes
       * This will cancel the drag operation if it is active.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        if (this._currentTarget) {
          let event = new PointerEvent("pointerup", {
            bubbles: true,
            cancelable: true,
            clientX: -1,
            clientY: -1
          });
          Private2.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        this._finalize("none");
      }
      /**
       * Test whether the drag object is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Start the drag operation at the specified client position.
       *
       * @param clientX - The client X position for the drag start.
       *
       * @param clientY - The client Y position for the drag start.
       *
       * @returns A promise which resolves to the result of the drag.
       *
       * #### Notes
       * If the drag has already been started, the promise created by the
       * first call to `start` is returned.
       *
       * If the drag operation has ended, or if the drag object has been
       * disposed, the returned promise will resolve to `'none'`.
       *
       * The drag object will be automatically disposed when drag operation
       * completes. This means `Drag` objects are for single-use only.
       *
       * This method assumes the left mouse button is already held down.
       */
      start(clientX, clientY) {
        if (this._disposed) {
          return Promise.resolve("none");
        }
        if (this._promise) {
          return this._promise;
        }
        this._addListeners();
        this._attachDragImage(clientX, clientY);
        this._promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
        let event = new PointerEvent("pointermove", {
          bubbles: true,
          cancelable: true,
          clientX,
          clientY
        });
        document.dispatchEvent(event);
        return this._promise;
      }
      /**
       * Handle the DOM events for the drag operation.
       *
       * @param event - The DOM event sent to the drag object.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the document. It should not be
       * called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          default:
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * Move the drag image element to the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        let style = this.dragImage.style;
        style.transform = `translate(${clientX}px, ${clientY}px)`;
      }
      /**
       * Handle the `'pointermove'` event for the drag object.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        this._updateCurrentTarget(event);
        this._updateDragScroll(event);
        this.moveDragImage(event.clientX, event.clientY);
      }
      /**
       * Handle the `'pointerup'` event for the drag object.
       */
      _evtPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
          return;
        }
        this._updateCurrentTarget(event);
        if (!this._currentTarget) {
          this._finalize("none");
          return;
        }
        if (this._dropAction === "none") {
          Private2.dispatchDragLeave(this, this._currentTarget, null, event);
          this._finalize("none");
          return;
        }
        let action = Private2.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
      }
      /**
       * Handle the `'keydown'` event for the drag object.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this.dispose();
        }
      }
      /**
       * Add the document event listeners for the drag object.
       */
      _addListeners() {
        document.addEventListener("pointerdown", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointerenter", this, true);
        document.addEventListener("pointerleave", this, true);
        document.addEventListener("pointerover", this, true);
        document.addEventListener("pointerout", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("keyup", this, true);
        document.addEventListener("keypress", this, true);
        document.addEventListener("contextmenu", this, true);
      }
      /**
       * Remove the document event listeners for the drag object.
       */
      _removeListeners() {
        document.removeEventListener("pointerdown", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointerenter", this, true);
        document.removeEventListener("pointerleave", this, true);
        document.removeEventListener("pointerover", this, true);
        document.removeEventListener("pointerout", this, true);
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("keyup", this, true);
        document.removeEventListener("keypress", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Update the drag scroll element under the mouse.
       */
      _updateDragScroll(event) {
        let target = Private2.findScrollTarget(event);
        if (!this._scrollTarget && !target) {
          return;
        }
        if (!this._scrollTarget) {
          setTimeout(this._onScrollFrame, 500);
        }
        this._scrollTarget = target;
      }
      /**
       * Update the current target node using the given mouse event.
       */
      _updateCurrentTarget(event) {
        let prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        let prevElem = this._currentElement;
        let currElem = Private2.findElementBehindBackdrop(event, this.document);
        this._currentElement = currElem;
        if (currElem !== prevElem && currElem !== currTarget) {
          Private2.dispatchDragExit(this, currTarget, currElem, event);
        }
        if (currElem !== prevElem && currElem !== currTarget) {
          currTarget = Private2.dispatchDragEnter(this, currElem, currTarget, event);
        }
        if (currTarget !== prevTarget) {
          this._currentTarget = currTarget;
          Private2.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        let action = Private2.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
      }
      /**
       * Attach the drag image element at the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        this.dragImage.classList.add("lm-mod-drag-image");
        let style = this.dragImage.style;
        style.pointerEvents = "none";
        style.position = "fixed";
        style.transform = `translate(${clientX}px, ${clientY}px)`;
        const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
        body.appendChild(this.dragImage);
      }
      /**
       * Detach the drag image element from the DOM.
       *
       * This is a no-op if there is no drag image element.
       */
      _detachDragImage() {
        if (!this.dragImage) {
          return;
        }
        let parent = this.dragImage.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(this.dragImage);
      }
      /**
       * Set the internal drop action state and update the drag cursor.
       */
      _setDropAction(action) {
        action = Private2.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
          return;
        }
        switch (action) {
          case "none":
            this._dropAction = action;
            this._override = Drag.overrideCursor("no-drop", this.document);
            break;
          case "copy":
            this._dropAction = action;
            this._override = Drag.overrideCursor("copy", this.document);
            break;
          case "link":
            this._dropAction = action;
            this._override = Drag.overrideCursor("alias", this.document);
            break;
          case "move":
            this._dropAction = action;
            this._override = Drag.overrideCursor("move", this.document);
            break;
        }
      }
      /**
       * Finalize the drag operation and resolve the drag promise.
       */
      _finalize(action) {
        let resolve = this._resolve;
        this._removeListeners();
        this._detachDragImage();
        if (this._override) {
          this._override.dispose();
          this._override = null;
        }
        this.mimeData.clear();
        this._disposed = true;
        this._dropAction = "none";
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        if (resolve) {
          resolve(action);
        }
      }
    };
    (function(Drag5) {
      class Event2 extends DragEvent {
        constructor(event, options) {
          super(options.type, {
            bubbles: true,
            cancelable: true,
            altKey: event.altKey,
            button: event.button,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            detail: 0,
            metaKey: event.metaKey,
            relatedTarget: options.related,
            screenX: event.screenX,
            screenY: event.screenY,
            shiftKey: event.shiftKey,
            view: window
          });
          const { drag } = options;
          this.dropAction = "none";
          this.mimeData = drag.mimeData;
          this.proposedAction = drag.proposedAction;
          this.supportedActions = drag.supportedActions;
          this.source = drag.source;
        }
      }
      Drag5.Event = Event2;
      function overrideCursor(cursor, doc = document) {
        return Private2.overrideCursor(cursor, doc);
      }
      Drag5.overrideCursor = overrideCursor;
    })(Drag || (Drag = {}));
    (function(Private22) {
      Private22.SCROLL_EDGE_SIZE = 20;
      function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : "none";
      }
      Private22.validateAction = validateAction;
      function findElementBehindBackdrop(event, root2 = document) {
        if (event) {
          if (lastElementEventSearch && event == lastElementEventSearch.event) {
            return lastElementEventSearch.element;
          }
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(event.clientX, event.clientY);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementEventSearch = { event, element: element2 };
          return element2;
        } else {
          const transform = Private22.cursorBackdrop.style.transform;
          if (lastElementSearch && transform === lastElementSearch.transform) {
            return lastElementSearch.element;
          }
          const bbox = Private22.cursorBackdrop.getBoundingClientRect();
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementSearch = { transform, element: element2 };
          return element2;
        }
      }
      Private22.findElementBehindBackdrop = findElementBehindBackdrop;
      let lastElementEventSearch = null;
      let lastElementSearch = null;
      function findScrollTarget(event) {
        let x2 = event.clientX;
        let y4 = event.clientY;
        let element2 = findElementBehindBackdrop(event);
        for (; element2; element2 = element2.parentElement) {
          if (!element2.hasAttribute("data-lm-dragscroll")) {
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (element2 === document.body) {
            offsetX = window.pageXOffset;
            offsetY = window.pageYOffset;
          }
          let r4 = element2.getBoundingClientRect();
          let top = r4.top + offsetY;
          let left = r4.left + offsetX;
          let right = left + r4.width;
          let bottom = top + r4.height;
          if (x2 < left || x2 >= right || y4 < top || y4 >= bottom) {
            continue;
          }
          let dl = x2 - left + 1;
          let dt = y4 - top + 1;
          let dr = right - x2;
          let db = bottom - y4;
          let distance = Math.min(dl, dt, dr, db);
          if (distance > Private22.SCROLL_EDGE_SIZE) {
            continue;
          }
          let edge;
          switch (distance) {
            case db:
              edge = "bottom";
              break;
            case dt:
              edge = "top";
              break;
            case dr:
              edge = "right";
              break;
            case dl:
              edge = "left";
              break;
            default:
              throw "unreachable";
          }
          let dsw = element2.scrollWidth - element2.clientWidth;
          let dsh = element2.scrollHeight - element2.clientHeight;
          let shouldScroll;
          switch (edge) {
            case "top":
              shouldScroll = dsh > 0 && element2.scrollTop > 0;
              break;
            case "left":
              shouldScroll = dsw > 0 && element2.scrollLeft > 0;
              break;
            case "right":
              shouldScroll = dsw > 0 && element2.scrollLeft < dsw;
              break;
            case "bottom":
              shouldScroll = dsh > 0 && element2.scrollTop < dsh;
              break;
            default:
              throw "unreachable";
          }
          if (!shouldScroll) {
            continue;
          }
          return { element: element2, edge, distance };
        }
        return null;
      }
      Private22.findScrollTarget = findScrollTarget;
      function dispatchDragEnter(drag, currElem, currTarget, event) {
        if (!currElem) {
          return null;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        let canceled = !currElem.dispatchEvent(dragEvent);
        if (canceled) {
          return currElem;
        }
        const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
        if (currElem === body) {
          return currTarget;
        }
        dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        body.dispatchEvent(dragEvent);
        return body;
      }
      Private22.dispatchDragEnter = dispatchDragEnter;
      function dispatchDragExit(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragexit"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragExit = dispatchDragExit;
      function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragleave"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragLeave = dispatchDragLeave;
      function dispatchDragOver(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: null,
          type: "lm-dragover"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDragOver = dispatchDragOver;
      function dispatchDrop(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag.Event(event, {
          drag,
          related: null,
          type: "lm-drop"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDrop = dispatchDrop;
      const actionTable = {
        none: 0,
        copy: 1,
        link: 2,
        move: 4
      };
      const supportedTable = {
        none: actionTable["none"],
        copy: actionTable["copy"],
        link: actionTable["link"],
        move: actionTable["move"],
        "copy-link": actionTable["copy"] | actionTable["link"],
        "copy-move": actionTable["copy"] | actionTable["move"],
        "link-move": actionTable["link"] | actionTable["move"],
        all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
      };
      function overrideCursor(cursor, doc = document) {
        let id = ++overrideCursorID;
        const body = doc instanceof Document ? doc.body : doc.firstElementChild;
        if (!Private22.cursorBackdrop.isConnected) {
          Private22.cursorBackdrop.style.transform = "scale(0)";
          body.appendChild(Private22.cursorBackdrop);
          resetBackdropScroll();
          document.addEventListener("pointermove", alignBackdrop, {
            capture: true,
            passive: true
          });
          Private22.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
            capture: true,
            passive: true
          });
        }
        Private22.cursorBackdrop.style.cursor = cursor;
        return new DisposableDelegate(() => {
          if (id === overrideCursorID && Private22.cursorBackdrop.isConnected) {
            document.removeEventListener("pointermove", alignBackdrop, true);
            Private22.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
            body.removeChild(Private22.cursorBackdrop);
          }
        });
      }
      Private22.overrideCursor = overrideCursor;
      function alignBackdrop(event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        Private22.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
      }
      function propagateBackdropScroll(_event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        let element2 = findElementBehindBackdrop();
        if (!element2) {
          return;
        }
        const scrollTarget = element2.closest("[data-lm-dragscroll]");
        if (!scrollTarget) {
          return;
        }
        scrollTarget.scrollTop += Private22.cursorBackdrop.scrollTop - backdropScrollOrigin;
        scrollTarget.scrollLeft += Private22.cursorBackdrop.scrollLeft - backdropScrollOrigin;
        resetBackdropScroll();
      }
      function resetBackdropScroll() {
        Private22.cursorBackdrop.scrollTop = backdropScrollOrigin;
        Private22.cursorBackdrop.scrollLeft = backdropScrollOrigin;
      }
      const backdropScrollOrigin = 500;
      function createCursorBackdrop() {
        const backdrop = document.createElement("div");
        backdrop.classList.add("lm-cursor-backdrop");
        return backdrop;
      }
      let overrideCursorID = 0;
      Private22.cursorBackdrop = createCursorBackdrop();
    })(Private2 || (Private2 = {}));
  }
});

// ../../node_modules/thebe-core/node_modules/@lumino/widgets/dist/index.es6.js
var import_coreutils, BoxSizer, BoxEngine, Title2, Widget2, Private$j, Layout, LayoutItem, Private$i, PanelLayout2, Utils, Utils$1, SplitLayout, Private$h, AccordionLayout, Private$g, Panel2, Private$f, SplitPanel, Private$e, AccordionPanel, Private$d, BoxLayout, Private$c, BoxPanel, Private$b, CommandPalette, Private$a, Menu, Private$9, Private$8, ARROW_KEYS, TabBar2, Private$7, DockLayout, Private$6, DockPanel, Private$5, GridLayout, Private$4, MenuBar, Private$3, Private$2, SingletonLayout, StackedLayout, Private$1, Private3;
var init_index_es614 = __esm({
  "../../node_modules/thebe-core/node_modules/@lumino/widgets/dist/index.es6.js"() {
    init_index_es6();
    import_coreutils = __toESM(require_dist());
    init_index_es65();
    init_index_es612();
    init_index_es64();
    init_index_es62();
    init_index_es613();
    init_index_es67();
    init_index_es68();
    init_index_es63();
    init_index_es66();
    BoxSizer = class {
      constructor() {
        this.sizeHint = 0;
        this.minSize = 0;
        this.maxSize = Infinity;
        this.stretch = 1;
        this.size = 0;
        this.done = false;
      }
    };
    (function(BoxEngine5) {
      function calc(sizers, space) {
        let count3 = sizers.length;
        if (count3 === 0) {
          return space;
        }
        let totalMin = 0;
        let totalMax = 0;
        let totalSize = 0;
        let totalStretch = 0;
        let stretchCount = 0;
        for (let i6 = 0; i6 < count3; ++i6) {
          let sizer = sizers[i6];
          let min3 = sizer.minSize;
          let max4 = sizer.maxSize;
          let hint = sizer.sizeHint;
          sizer.done = false;
          sizer.size = Math.max(min3, Math.min(hint, max4));
          totalSize += sizer.size;
          totalMin += min3;
          totalMax += max4;
          if (sizer.stretch > 0) {
            totalStretch += sizer.stretch;
            stretchCount++;
          }
        }
        if (space === totalSize) {
          return 0;
        }
        if (space <= totalMin) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.minSize;
          }
          return space - totalMin;
        }
        if (space >= totalMax) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.maxSize;
          }
          return space - totalMax;
        }
        let nearZero = 0.01;
        let notDoneCount = count3;
        if (space < totalSize) {
          let freeSpace = totalSize - space;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
        } else {
          let freeSpace = space - totalSize;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
        }
        return 0;
      }
      BoxEngine5.calc = calc;
      function adjust(sizers, index2, delta) {
        if (sizers.length === 0 || delta === 0) {
          return;
        }
        if (delta > 0) {
          growSizer(sizers, index2, delta);
        } else {
          shrinkSizer(sizers, index2, -delta);
        }
      }
      BoxEngine5.adjust = adjust;
      function growSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2; i6 >= 0 && grow > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && shrink > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
      function shrinkSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && grow > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2; i6 >= 0 && shrink > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
    })(BoxEngine || (BoxEngine = {}));
    Title2 = class {
      /**
       * Construct a new title.
       *
       * @param options - The options for initializing the title.
       */
      constructor(options) {
        this._label = "";
        this._caption = "";
        this._mnemonic = -1;
        this._icon = void 0;
        this._iconClass = "";
        this._iconLabel = "";
        this._className = "";
        this._closable = false;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this.owner = options.owner;
        if (options.label !== void 0) {
          this._label = options.label;
        }
        if (options.mnemonic !== void 0) {
          this._mnemonic = options.mnemonic;
        }
        if (options.icon !== void 0) {
          this._icon = options.icon;
        }
        if (options.iconClass !== void 0) {
          this._iconClass = options.iconClass;
        }
        if (options.iconLabel !== void 0) {
          this._iconLabel = options.iconLabel;
        }
        if (options.caption !== void 0) {
          this._caption = options.caption;
        }
        if (options.className !== void 0) {
          this._className = options.className;
        }
        if (options.closable !== void 0) {
          this._closable = options.closable;
        }
        this._dataset = options.dataset || {};
      }
      /**
       * A signal emitted when the state of the title changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get label() {
        return this._label;
      }
      /**
       * Set the label for the title.
       */
      set label(value) {
        if (this._label === value) {
          return;
        }
        this._label = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the mnemonic index for the title.
       *
       * #### Notes
       * The default value is `-1`.
       */
      get mnemonic() {
        return this._mnemonic;
      }
      /**
       * Set the mnemonic index for the title.
       */
      set mnemonic(value) {
        if (this._mnemonic === value) {
          return;
        }
        this._mnemonic = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon renderer for the title.
       *
       * #### Notes
       * The default value is undefined.
       */
      get icon() {
        return this._icon;
      }
      /**
       * Set the icon renderer for the title.
       *
       * #### Notes
       * A renderer is an object that supplies a render and unrender function.
       */
      set icon(value) {
        if (this._icon === value) {
          return;
        }
        this._icon = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconClass() {
        return this._iconClass;
      }
      /**
       * Set the icon class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconClass(value) {
        if (this._iconClass === value) {
          return;
        }
        this._iconClass = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconLabel() {
        return this._iconLabel;
      }
      /**
       * Set the icon label for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconLabel(value) {
        if (this._iconLabel === value) {
          return;
        }
        this._iconLabel = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the caption for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get caption() {
        return this._caption;
      }
      /**
       * Set the caption for the title.
       */
      set caption(value) {
        if (this._caption === value) {
          return;
        }
        this._caption = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the extra class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get className() {
        return this._className;
      }
      /**
       * Set the extra class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set className(value) {
        if (this._className === value) {
          return;
        }
        this._className = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the closable state for the title.
       *
       * #### Notes
       * The default value is `false`.
       */
      get closable() {
        return this._closable;
      }
      /**
       * Set the closable state for the title.
       *
       * #### Notes
       * This controls the presence of a close icon when applicable.
       */
      set closable(value) {
        if (this._closable === value) {
          return;
        }
        this._closable = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the dataset for the title.
       *
       * #### Notes
       * The default value is an empty dataset.
       */
      get dataset() {
        return this._dataset;
      }
      /**
       * Set the dataset for the title.
       *
       * #### Notes
       * This controls the data attributes when applicable.
       */
      set dataset(value) {
        if (this._dataset === value) {
          return;
        }
        this._dataset = value;
        this._changed.emit(void 0);
      }
      /**
       * Test whether the title has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the title.
       *
       * #### Notes
       * It is the responsibility of the owner to call the title disposal.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
    Widget2 = class {
      /**
       * Construct a new widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options = {}) {
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this._disposed = new Signal(this);
        this._hiddenMode = Widget2.HiddenMode.Display;
        this.node = Private$j.createNode(options);
        this.addClass("lm-Widget");
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.setFlag(Widget2.Flag.IsDisposed);
        this._disposed.emit(void 0);
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget2.detach(this);
        }
        if (this._layout) {
          this._layout.dispose();
          this._layout = null;
        }
        this.title.dispose();
        Signal.clearData(this);
        MessageLoop2.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * A signal emitted when the widget is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the widget has been disposed.
       */
      get isDisposed() {
        return this.testFlag(Widget2.Flag.IsDisposed);
      }
      /**
       * Test whether the widget's node is attached to the DOM.
       */
      get isAttached() {
        return this.testFlag(Widget2.Flag.IsAttached);
      }
      /**
       * Test whether the widget is explicitly hidden.
       *
       * #### Notes
       * You should prefer `!{@link isVisible}` over `{@link isHidden}` if you want to know if the
       * widget is hidden as this does not test if the widget is hidden because one of its ancestors is hidden.
       */
      get isHidden() {
        return this.testFlag(Widget2.Flag.IsHidden);
      }
      /**
       * Test whether the widget is visible.
       *
       * #### Notes
       * A widget is visible when it is attached to the DOM, is not
       * explicitly hidden, and has no explicitly hidden ancestors.
       *
       * Since 2.7.0, this does not rely on the {@link Widget.Flag.IsVisible} flag.
       * It recursively checks the visibility of all parent widgets.
       */
      get isVisible() {
        let parent = this;
        do {
          if (parent.isHidden || !parent.isAttached) {
            return false;
          }
          parent = parent.parent;
        } while (parent != null);
        return true;
      }
      /**
       * The title object for the widget.
       *
       * #### Notes
       * The title object is used by some container widgets when displaying
       * the widget alongside some title, such as a tab panel or side bar.
       *
       * Since not all widgets will use the title, it is created on demand.
       *
       * The `owner` property of the title is set to this widget.
       */
      get title() {
        return Private$j.titleProperty.get(this);
      }
      /**
       * Get the id of the widget's DOM node.
       */
      get id() {
        return this.node.id;
      }
      /**
       * Set the id of the widget's DOM node.
       */
      set id(value) {
        this.node.id = value;
      }
      /**
       * The dataset for the widget's DOM node.
       */
      get dataset() {
        return this.node.dataset;
      }
      /**
       * Get the method for hiding the widget.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding the widget.
       */
      set hiddenMode(value) {
        if (this._hiddenMode === value) {
          return;
        }
        if (this.isHidden) {
          this._toggleHidden(false);
        }
        if (value == Widget2.HiddenMode.Scale) {
          this.node.style.willChange = "transform";
        } else {
          this.node.style.willChange = "auto";
        }
        this._hiddenMode = value;
        if (this.isHidden) {
          this._toggleHidden(true);
        }
      }
      /**
       * Get the parent of the widget.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the widget.
       *
       * #### Notes
       * Children are typically added to a widget by using a layout, which
       * means user code will not normally set the parent widget directly.
       *
       * The widget will be automatically removed from its old parent.
       *
       * This is a no-op if there is no effective parent change.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (value && this.contains(value)) {
          throw new Error("Invalid parent widget.");
        }
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget2.ChildMessage("child-removed", this);
          MessageLoop2.sendMessage(this._parent, msg);
        }
        this._parent = value;
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget2.ChildMessage("child-added", this);
          MessageLoop2.sendMessage(this._parent, msg);
        }
        if (!this.isDisposed) {
          MessageLoop2.sendMessage(this, Widget2.Msg.ParentChanged);
        }
      }
      /**
       * Get the layout for the widget.
       */
      get layout() {
        return this._layout;
      }
      /**
       * Set the layout for the widget.
       *
       * #### Notes
       * The layout is single-use only. It cannot be changed after the
       * first assignment.
       *
       * The layout is disposed automatically when the widget is disposed.
       */
      set layout(value) {
        if (this._layout === value) {
          return;
        }
        if (this.testFlag(Widget2.Flag.DisallowLayout)) {
          throw new Error("Cannot set widget layout.");
        }
        if (this._layout) {
          throw new Error("Cannot change widget layout.");
        }
        if (value.parent) {
          throw new Error("Cannot change layout parent.");
        }
        this._layout = value;
        value.parent = this;
      }
      /**
       * Create an iterator over the widget's children.
       *
       * @returns A new iterator over the children of the widget.
       *
       * #### Notes
       * The widget must have a populated layout in order to have children.
       *
       * If a layout is not installed, the returned iterator will be empty.
       */
      *children() {
        if (this._layout) {
          yield* this._layout;
        }
      }
      /**
       * Test whether a widget is a descendant of this widget.
       *
       * @param widget - The descendant widget of interest.
       *
       * @returns `true` if the widget is a descendant, `false` otherwise.
       */
      contains(widget) {
        for (let value = widget; value; value = value._parent) {
          if (value === this) {
            return true;
          }
        }
        return false;
      }
      /**
       * Test whether the widget's DOM node has the given class name.
       *
       * @param name - The class name of interest.
       *
       * @returns `true` if the node has the class, `false` otherwise.
       */
      hasClass(name) {
        return this.node.classList.contains(name);
      }
      /**
       * Add a class name to the widget's DOM node.
       *
       * @param name - The class name to add to the node.
       *
       * #### Notes
       * If the class name is already added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      addClass(name) {
        this.node.classList.add(name);
      }
      /**
       * Remove a class name from the widget's DOM node.
       *
       * @param name - The class name to remove from the node.
       *
       * #### Notes
       * If the class name is not yet added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      removeClass(name) {
        this.node.classList.remove(name);
      }
      /**
       * Toggle a class name on the widget's DOM node.
       *
       * @param name - The class name to toggle on the node.
       *
       * @param force - Whether to force add the class (`true`) or force
       *   remove the class (`false`). If not provided, the presence of
       *   the class will be toggled from its current state.
       *
       * @returns `true` if the class is now present, `false` otherwise.
       *
       * #### Notes
       * The class name must not contain whitespace.
       */
      toggleClass(name, force) {
        if (force === true) {
          this.node.classList.add(name);
          return true;
        }
        if (force === false) {
          this.node.classList.remove(name);
          return false;
        }
        return this.node.classList.toggle(name);
      }
      /**
       * Post an `'update-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      update() {
        MessageLoop2.postMessage(this, Widget2.Msg.UpdateRequest);
      }
      /**
       * Post a `'fit-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      fit() {
        MessageLoop2.postMessage(this, Widget2.Msg.FitRequest);
      }
      /**
       * Post an `'activate-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      activate() {
        MessageLoop2.postMessage(this, Widget2.Msg.ActivateRequest);
      }
      /**
       * Send a `'close-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for sending the message.
       */
      close() {
        MessageLoop2.sendMessage(this, Widget2.Msg.CloseRequest);
      }
      /**
       * Show the widget and make it visible to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `false`.
       *
       * If the widget is not explicitly hidden, this is a no-op.
       */
      show() {
        if (!this.testFlag(Widget2.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop2.sendMessage(this, Widget2.Msg.BeforeShow);
        }
        this.clearFlag(Widget2.Flag.IsHidden);
        this._toggleHidden(false);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop2.sendMessage(this, Widget2.Msg.AfterShow);
        }
        if (this.parent) {
          let msg = new Widget2.ChildMessage("child-shown", this);
          MessageLoop2.sendMessage(this.parent, msg);
        }
      }
      /**
       * Hide the widget and make it hidden to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `true`.
       *
       * If the widget is explicitly hidden, this is a no-op.
       */
      hide() {
        if (this.testFlag(Widget2.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop2.sendMessage(this, Widget2.Msg.BeforeHide);
        }
        this.setFlag(Widget2.Flag.IsHidden);
        this._toggleHidden(true);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop2.sendMessage(this, Widget2.Msg.AfterHide);
        }
        if (this.parent) {
          let msg = new Widget2.ChildMessage("child-hidden", this);
          MessageLoop2.sendMessage(this.parent, msg);
        }
      }
      /**
       * Show or hide the widget according to a boolean value.
       *
       * @param hidden - `true` to hide the widget, or `false` to show it.
       *
       * #### Notes
       * This is a convenience method for `hide()` and `show()`.
       */
      setHidden(hidden) {
        if (hidden) {
          this.hide();
        } else {
          this.show();
        }
      }
      /**
       * Test whether the given widget flag is set.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      testFlag(flag) {
        return (this._flags & flag) !== 0;
      }
      /**
       * Set the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      setFlag(flag) {
        this._flags |= flag;
      }
      /**
       * Clear the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      clearFlag(flag) {
        this._flags &= ~flag;
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       *
       * #### Notes
       * Subclasses may reimplement this method as needed.
       */
      processMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.notifyLayout(msg);
            this.onResize(msg);
            break;
          case "update-request":
            this.notifyLayout(msg);
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.notifyLayout(msg);
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.notifyLayout(msg);
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.setFlag(Widget2.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.notifyLayout(msg);
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.clearFlag(Widget2.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.notifyLayout(msg);
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
              this.setFlag(Widget2.Flag.IsVisible);
            }
            this.setFlag(Widget2.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.notifyLayout(msg);
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.clearFlag(Widget2.Flag.IsVisible);
            this.clearFlag(Widget2.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterDetach(msg);
            break;
          case "activate-request":
            this.notifyLayout(msg);
            this.onActivateRequest(msg);
            break;
          case "close-request":
            this.notifyLayout(msg);
            this.onCloseRequest(msg);
            break;
          case "child-added":
            this.notifyLayout(msg);
            this.onChildAdded(msg);
            break;
          case "child-removed":
            this.notifyLayout(msg);
            this.onChildRemoved(msg);
            break;
          default:
            this.notifyLayout(msg);
            break;
        }
      }
      /**
       * Invoke the message processing routine of the widget's layout.
       *
       * @param msg - The message to dispatch to the layout.
       *
       * #### Notes
       * This is a no-op if the widget does not have a layout.
       *
       * This will not typically be called directly by user code.
       */
      notifyLayout(msg) {
        if (this._layout) {
          this._layout.processParentMessage(msg);
        }
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       *
       * #### Notes
       * The default implementation unparents or detaches the widget.
       */
      onCloseRequest(msg) {
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget2.detach(this);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onResize(msg) {
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onActivateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeShow(msg) {
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterShow(msg) {
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeHide(msg) {
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterHide(msg) {
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeAttach(msg) {
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterAttach(msg) {
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeDetach(msg) {
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterDetach(msg) {
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildAdded(msg) {
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildRemoved(msg) {
      }
      _toggleHidden(hidden) {
        if (hidden) {
          switch (this._hiddenMode) {
            case Widget2.HiddenMode.Display:
              this.addClass("lm-mod-hidden");
              break;
            case Widget2.HiddenMode.Scale:
              this.node.style.transform = "scale(0)";
              this.node.setAttribute("aria-hidden", "true");
              break;
            case Widget2.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "hidden";
              this.node.style.zIndex = "-1";
              break;
          }
        } else {
          switch (this._hiddenMode) {
            case Widget2.HiddenMode.Display:
              this.removeClass("lm-mod-hidden");
              break;
            case Widget2.HiddenMode.Scale:
              this.node.style.transform = "";
              this.node.removeAttribute("aria-hidden");
              break;
            case Widget2.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "";
              this.node.style.zIndex = "";
              break;
          }
        }
      }
    };
    (function(Widget6) {
      (function(HiddenMode) {
        HiddenMode[HiddenMode["Display"] = 0] = "Display";
        HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
        HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
      })(Widget6.HiddenMode || (Widget6.HiddenMode = {}));
      (function(Flag) {
        Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
        Flag[Flag["IsAttached"] = 2] = "IsAttached";
        Flag[Flag["IsHidden"] = 4] = "IsHidden";
        Flag[Flag["IsVisible"] = 8] = "IsVisible";
        Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
      })(Widget6.Flag || (Widget6.Flag = {}));
      (function(Msg) {
        Msg.BeforeShow = new Message("before-show");
        Msg.AfterShow = new Message("after-show");
        Msg.BeforeHide = new Message("before-hide");
        Msg.AfterHide = new Message("after-hide");
        Msg.BeforeAttach = new Message("before-attach");
        Msg.AfterAttach = new Message("after-attach");
        Msg.BeforeDetach = new Message("before-detach");
        Msg.AfterDetach = new Message("after-detach");
        Msg.ParentChanged = new Message("parent-changed");
        Msg.UpdateRequest = new ConflatableMessage("update-request");
        Msg.FitRequest = new ConflatableMessage("fit-request");
        Msg.ActivateRequest = new ConflatableMessage("activate-request");
        Msg.CloseRequest = new ConflatableMessage("close-request");
      })(Widget6.Msg || (Widget6.Msg = {}));
      class ChildMessage extends Message {
        /**
         * Construct a new child message.
         *
         * @param type - The message type.
         *
         * @param child - The child widget for the message.
         */
        constructor(type, child) {
          super(type);
          this.child = child;
        }
      }
      Widget6.ChildMessage = ChildMessage;
      class ResizeMessage extends Message {
        /**
         * Construct a new resize message.
         *
         * @param width - The **offset width** of the widget, or `-1` if
         *   the width is not known.
         *
         * @param height - The **offset height** of the widget, or `-1` if
         *   the height is not known.
         */
        constructor(width, height) {
          super("resize");
          this.width = width;
          this.height = height;
        }
      }
      Widget6.ResizeMessage = ResizeMessage;
      (function(ResizeMessage2) {
        ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
      })(ResizeMessage = Widget6.ResizeMessage || (Widget6.ResizeMessage = {}));
      function attach(widget, host, ref = null) {
        if (widget.parent) {
          throw new Error("Cannot attach a child widget.");
        }
        if (widget.isAttached || widget.node.isConnected) {
          throw new Error("Widget is already attached.");
        }
        if (!host.isConnected) {
          throw new Error("Host is not attached.");
        }
        MessageLoop2.sendMessage(widget, Widget6.Msg.BeforeAttach);
        host.insertBefore(widget.node, ref);
        MessageLoop2.sendMessage(widget, Widget6.Msg.AfterAttach);
      }
      Widget6.attach = attach;
      function detach(widget) {
        if (widget.parent) {
          throw new Error("Cannot detach a child widget.");
        }
        if (!widget.isAttached || !widget.node.isConnected) {
          throw new Error("Widget is not attached.");
        }
        MessageLoop2.sendMessage(widget, Widget6.Msg.BeforeDetach);
        widget.node.parentNode.removeChild(widget.node);
        MessageLoop2.sendMessage(widget, Widget6.Msg.AfterDetach);
      }
      Widget6.detach = detach;
    })(Widget2 || (Widget2 = {}));
    (function(Private22) {
      Private22.titleProperty = new AttachedProperty({
        name: "title",
        create: (owner) => new Title2({ owner })
      });
      function createNode(options) {
        return options.node || document.createElement(options.tag || "div");
      }
      Private22.createNode = createNode;
    })(Private$j || (Private$j = {}));
    Layout = class {
      /**
       * Construct a new layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        this._disposed = false;
        this._parent = null;
        this._fitPolicy = options.fitPolicy || "set-min-size";
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This should be reimplemented to clear and dispose of the widgets.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        this._parent = null;
        this._disposed = true;
        Signal.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * Test whether the layout is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Get the parent widget of the layout.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent widget of the layout.
       *
       * #### Notes
       * This is set automatically when installing the layout on the parent
       * widget. The parent widget should not be set directly by user code.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (this._parent) {
          throw new Error("Cannot change parent widget.");
        }
        if (value.layout !== this) {
          throw new Error("Invalid parent widget.");
        }
        this._parent = value;
        this.init();
      }
      /**
       * Get the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       */
      get fitPolicy() {
        return this._fitPolicy;
      }
      /**
       * Set the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       *
       * Changing the fit policy will clear the current size constraint
       * for the parent widget and then re-fit the parent.
       */
      set fitPolicy(value) {
        if (this._fitPolicy === value) {
          return;
        }
        this._fitPolicy = value;
        if (this._parent) {
          let style = this._parent.node.style;
          style.minWidth = "";
          style.minHeight = "";
          style.maxWidth = "";
          style.maxHeight = "";
          this._parent.fit();
        }
      }
      /**
       * Process a message sent to the parent widget.
       *
       * @param msg - The message sent to the parent widget.
       *
       * #### Notes
       * This method is called by the parent widget to process a message.
       *
       * Subclasses may reimplement this method as needed.
       */
      processParentMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.onResize(msg);
            break;
          case "update-request":
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.onAfterDetach(msg);
            break;
          case "child-removed":
            this.onChildRemoved(msg);
            break;
          case "child-shown":
            this.onChildShown(msg);
            break;
          case "child-hidden":
            this.onChildHidden(msg);
            break;
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       *
       * #### Notes
       * This method is invoked immediately after the layout is installed
       * on the parent widget.
       *
       * The default implementation reparents all of the widgets to the
       * layout parent widget.
       *
       * Subclasses should reimplement this method and attach the child
       * widget nodes to the parent widget's node.
       */
      init() {
        for (const widget of this) {
          widget.parent = this.parent;
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the specified layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onResize(msg) {
        for (const widget of this) {
          MessageLoop2.sendMessage(widget, Widget2.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the available layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onUpdateRequest(msg) {
        for (const widget of this) {
          MessageLoop2.sendMessage(widget, Widget2.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeAttach(msg) {
        for (const widget of this) {
          MessageLoop2.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterAttach(msg) {
        for (const widget of this) {
          MessageLoop2.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeDetach(msg) {
        for (const widget of this) {
          MessageLoop2.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterDetach(msg) {
        for (const widget of this) {
          MessageLoop2.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop2.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop2.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop2.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop2.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * This will remove the child widget from the layout.
       *
       * Subclasses should **not** typically reimplement this method.
       */
      onChildRemoved(msg) {
        this.removeWidget(msg.child);
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildShown(msg) {
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildHidden(msg) {
      }
    };
    (function(Layout5) {
      function getHorizontalAlignment(widget) {
        return Private$i.horizontalAlignmentProperty.get(widget);
      }
      Layout5.getHorizontalAlignment = getHorizontalAlignment;
      function setHorizontalAlignment(widget, value) {
        Private$i.horizontalAlignmentProperty.set(widget, value);
      }
      Layout5.setHorizontalAlignment = setHorizontalAlignment;
      function getVerticalAlignment(widget) {
        return Private$i.verticalAlignmentProperty.get(widget);
      }
      Layout5.getVerticalAlignment = getVerticalAlignment;
      function setVerticalAlignment(widget, value) {
        Private$i.verticalAlignmentProperty.set(widget, value);
      }
      Layout5.setVerticalAlignment = setVerticalAlignment;
    })(Layout || (Layout = {}));
    LayoutItem = class {
      /**
       * Construct a new layout item.
       *
       * @param widget - The widget to be managed by the item.
       *
       * #### Notes
       * The widget will be set to absolute positioning.
       * The widget will use strict CSS containment.
       */
      constructor(widget) {
        this._top = NaN;
        this._left = NaN;
        this._width = NaN;
        this._height = NaN;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = Infinity;
        this._maxHeight = Infinity;
        this._disposed = false;
        this.widget = widget;
        this.widget.node.style.position = "absolute";
        this.widget.node.style.contain = "strict";
      }
      /**
       * Dispose of the the layout item.
       *
       * #### Notes
       * This will reset the positioning of the widget.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        let style = this.widget.node.style;
        style.position = "";
        style.top = "";
        style.left = "";
        style.width = "";
        style.height = "";
        style.contain = "";
      }
      /**
       * The computed minimum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minWidth() {
        return this._minWidth;
      }
      /**
       * The computed minimum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minHeight() {
        return this._minHeight;
      }
      /**
       * The computed maximum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxWidth() {
        return this._maxWidth;
      }
      /**
       * The computed maximum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxHeight() {
        return this._maxHeight;
      }
      /**
       * Whether the layout item is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Whether the managed widget is hidden.
       */
      get isHidden() {
        return this.widget.isHidden;
      }
      /**
       * Whether the managed widget is visible.
       */
      get isVisible() {
        return this.widget.isVisible;
      }
      /**
       * Whether the managed widget is attached.
       */
      get isAttached() {
        return this.widget.isAttached;
      }
      /**
       * Update the computed size limits of the managed widget.
       */
      fit() {
        let limits = ElementExt.sizeLimits(this.widget.node);
        this._minWidth = limits.minWidth;
        this._minHeight = limits.minHeight;
        this._maxWidth = limits.maxWidth;
        this._maxHeight = limits.maxHeight;
      }
      /**
       * Update the position and size of the managed widget.
       *
       * @param left - The left edge position of the layout box.
       *
       * @param top - The top edge position of the layout box.
       *
       * @param width - The width of the layout box.
       *
       * @param height - The height of the layout box.
       */
      update(left, top, width, height) {
        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
        if (clampW < width) {
          switch (Layout.getHorizontalAlignment(this.widget)) {
            case "left":
              break;
            case "center":
              left += (width - clampW) / 2;
              break;
            case "right":
              left += width - clampW;
              break;
            default:
              throw "unreachable";
          }
        }
        if (clampH < height) {
          switch (Layout.getVerticalAlignment(this.widget)) {
            case "top":
              break;
            case "center":
              top += (height - clampH) / 2;
              break;
            case "bottom":
              top += height - clampH;
              break;
            default:
              throw "unreachable";
          }
        }
        let resized = false;
        let style = this.widget.node.style;
        if (this._top !== top) {
          this._top = top;
          style.top = `${top}px`;
        }
        if (this._left !== left) {
          this._left = left;
          style.left = `${left}px`;
        }
        if (this._width !== clampW) {
          resized = true;
          this._width = clampW;
          style.width = `${clampW}px`;
        }
        if (this._height !== clampH) {
          resized = true;
          this._height = clampH;
          style.height = `${clampH}px`;
        }
        if (resized) {
          let msg = new Widget2.ResizeMessage(clampW, clampH);
          MessageLoop2.sendMessage(this.widget, msg);
        }
      }
    };
    (function(Private22) {
      Private22.horizontalAlignmentProperty = new AttachedProperty({
        name: "horizontalAlignment",
        create: () => "center",
        changed: onAlignmentChanged
      });
      Private22.verticalAlignmentProperty = new AttachedProperty({
        name: "verticalAlignment",
        create: () => "top",
        changed: onAlignmentChanged
      });
      function onAlignmentChanged(child) {
        if (child.parent && child.parent.layout) {
          child.parent.update();
        }
      }
    })(Private$i || (Private$i = {}));
    PanelLayout2 = class extends Layout {
      constructor() {
        super(...arguments);
        this._widgets = [];
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        while (this._widgets.length > 0) {
          this._widgets.pop().dispose();
        }
        super.dispose();
      }
      /**
       * A read-only array of the widgets in the layout.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        yield* this._widgets;
      }
      /**
       * Add a widget to the end of the layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, it will be moved.
       */
      addWidget(widget) {
        this.insertWidget(this._widgets.length, widget);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        widget.parent = this.parent;
        let i6 = this._widgets.indexOf(widget);
        let j2 = Math.max(0, Math.min(index2, this._widgets.length));
        if (i6 === -1) {
          ArrayExt.insert(this._widgets, j2, widget);
          if (this.parent) {
            this.attachWidget(j2, widget);
          }
          return;
        }
        if (j2 === this._widgets.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._widgets, i6, j2);
        if (this.parent) {
          this.moveWidget(i6, j2, widget);
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this.removeWidgetAt(this._widgets.indexOf(widget));
      }
      /**
       * Remove the widget at a given index from the layout.
       *
       * @param index - The index of the widget to remove.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      removeWidgetAt(index2) {
        let widget = ArrayExt.removeAt(this._widgets, index2);
        if (widget && this.parent) {
          this.detachWidget(index2, widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        let index2 = 0;
        for (const widget of this) {
          this.attachWidget(index2++, widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index2, widget) {
        let ref = this.parent.node.children[index2];
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
        let ref = this.parent.node.children[toIndex];
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index2, widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
      }
    };
    (function(Utils5) {
      function clampDimension(value) {
        return Math.max(0, Math.floor(value));
      }
      Utils5.clampDimension = clampDimension;
    })(Utils || (Utils = {}));
    Utils$1 = Utils;
    SplitLayout = class extends PanelLayout2 {
      /**
       * Construct a new split layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this.widgetOffset = 0;
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._hasNormedSizes = false;
        this._sizers = [];
        this._items = [];
        this._handles = [];
        this._box = null;
        this._alignment = "start";
        this._orientation = "horizontal";
        this.renderer = options.renderer;
        if (options.orientation !== void 0) {
          this._orientation = options.orientation;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        this._handles.length = 0;
        super.dispose();
      }
      /**
       * Get the layout orientation for the split layout.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the layout orientation for the split layout.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._orientation = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["orientation"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the split layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the split layout.
       */
      set spacing(value) {
        value = Utils.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the split handles in the layout.
       */
      get handles() {
        return this._handles;
      }
      /**
       * Get the absolute sizes of the widgets in the layout.
       *
       * @returns A new array of the absolute sizes of the widgets.
       *
       * This method **does not** measure the DOM nodes.
       */
      absoluteSizes() {
        return this._sizers.map((sizer) => sizer.size);
      }
      /**
       * Get the relative sizes of the widgets in the layout.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return Private$h.normalize(this._sizers.map((sizer) => sizer.size));
      }
      /**
       * Set the relative sizes for the widgets in the layout.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        let n5 = this._sizers.length;
        let temp = sizes.slice(0, n5);
        while (temp.length < n5) {
          temp.push(0);
        }
        let normed = Private$h.normalize(temp);
        for (let i6 = 0; i6 < n5; ++i6) {
          let sizer = this._sizers[i6];
          sizer.sizeHint = normed[i6];
          sizer.size = normed[i6];
        }
        this._hasNormedSizes = true;
        if (update && this.parent) {
          this.parent.update();
        }
      }
      /**
       * Move the offset position of a split handle.
       *
       * @param index - The index of the handle of the interest.
       *
       * @param position - The desired offset position of the handle.
       *
       * #### Notes
       * The position is relative to the offset parent.
       *
       * This will move the handle as close as possible to the desired
       * position. The sibling widgets will be adjusted as necessary.
       */
      moveHandle(index2, position) {
        let handle = this._handles[index2];
        if (!handle || handle.classList.contains("lm-mod-hidden")) {
          return;
        }
        let delta;
        if (this._orientation === "horizontal") {
          delta = position - handle.offsetLeft;
        } else {
          delta = position - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        for (let sizer of this._sizers) {
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
        }
        BoxEngine.adjust(this._sizers, index2, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["orientation"] = this.orientation;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        let item = new LayoutItem(widget);
        let handle = Private$h.createHandle(this.renderer);
        let average = Private$h.averageSize(this._sizers);
        let sizer = Private$h.createSizer(average);
        ArrayExt.insert(this._items, index2, item);
        ArrayExt.insert(this._sizers, index2, sizer);
        ArrayExt.insert(this._handles, index2, handle);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        ArrayExt.move(this._handles, fromIndex, toIndex);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        let handle = ArrayExt.removeAt(this._handles, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        this.parent.node.removeChild(handle);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const item = this._items[i6];
        if (item.isHidden) {
          return;
        }
        let handleStyle = this._handles[i6].style;
        if (isHorizontal) {
          left += this.widgetOffset;
          item.update(left, top, size5, height);
          left += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${this._spacing}px`;
          handleStyle.height = `${height}px`;
        } else {
          top += this.widgetOffset;
          item.update(left, top, width, size5);
          top += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${this._spacing}px`;
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        let lastHandleIndex = -1;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          if (this._items[i6].isHidden) {
            this._handles[i6].classList.add("lm-mod-hidden");
          } else {
            this._handles[i6].classList.remove("lm-mod-hidden");
            lastHandleIndex = i6;
            nVisible++;
          }
        }
        if (lastHandleIndex !== -1) {
          this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
        let horz = this._orientation === "horizontal";
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.stretch = SplitLayout.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget2.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget2.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0 && this.widgetOffset === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let extra = 0;
        let offset4 = 0;
        let horz = this._orientation === "horizontal";
        if (nVisible > 0) {
          let space;
          if (horz) {
            space = Math.max(0, width - this._fixed);
          } else {
            space = Math.max(0, height - this._fixed);
          }
          if (this._hasNormedSizes) {
            for (let sizer of this._sizers) {
              sizer.sizeHint *= space;
            }
            this._hasNormedSizes = false;
          }
          let delta = BoxEngine.calc(this._sizers, space);
          if (delta > 0) {
            switch (this._alignment) {
              case "start":
                break;
              case "center":
                extra = 0;
                offset4 = delta / 2;
                break;
              case "end":
                extra = 0;
                offset4 = delta;
                break;
              case "justify":
                extra = delta / nVisible;
                offset4 = 0;
                break;
              default:
                throw "unreachable";
            }
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          const item = this._items[i6];
          const size5 = item.isHidden ? 0 : this._sizers[i6].size + extra;
          this.updateItemPosition(i6, horz, horz ? left + offset4 : left, horz ? top : top + offset4, height, width, size5);
          const fullOffset = this.widgetOffset + (this._handles[i6].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
          if (horz) {
            left += size5 + fullOffset;
          } else {
            top += size5 + fullOffset;
          }
        }
      }
    };
    (function(SplitLayout5) {
      function getStretch(widget) {
        return Private$h.stretchProperty.get(widget);
      }
      SplitLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$h.stretchProperty.set(widget, value);
      }
      SplitLayout5.setStretch = setStretch;
    })(SplitLayout || (SplitLayout = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function createSizer(size5) {
        let sizer = new BoxSizer();
        sizer.sizeHint = Math.floor(size5);
        return sizer;
      }
      Private22.createSizer = createSizer;
      function createHandle(renderer) {
        let handle = renderer.createHandle();
        handle.style.position = "absolute";
        handle.style.contain = "style";
        return handle;
      }
      Private22.createHandle = createHandle;
      function averageSize(sizers) {
        return sizers.reduce((v4, s8) => v4 + s8.size, 0) / sizers.length || 0;
      }
      Private22.averageSize = averageSize;
      function normalize2(values2) {
        let n5 = values2.length;
        if (n5 === 0) {
          return [];
        }
        let sum = values2.reduce((a3, b2) => a3 + Math.abs(b2), 0);
        return sum === 0 ? values2.map((v4) => 1 / n5) : values2.map((v4) => v4 / sum);
      }
      Private22.normalize = normalize2;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof SplitLayout) {
          child.parent.fit();
        }
      }
    })(Private$h || (Private$h = {}));
    AccordionLayout = class extends SplitLayout {
      /**
       * Construct a new accordion layout.
       *
       * @param options - The options for initializing the layout.
       *
       * #### Notes
       * The default orientation will be vertical.
       *
       * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
       */
      constructor(options) {
        super({ ...options, orientation: options.orientation || "vertical" });
        this._titles = [];
        this.titleSpace = options.titleSpace || 22;
      }
      /**
       * The section title height or width depending on the orientation.
       */
      get titleSpace() {
        return this.widgetOffset;
      }
      set titleSpace(value) {
        value = Utils$1.clampDimension(value);
        if (this.widgetOffset === value) {
          return;
        }
        this.widgetOffset = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this._titles;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._titles.length = 0;
        super.dispose();
      }
      updateTitle(index2, widget) {
        const oldTitle = this._titles[index2];
        const expanded = oldTitle.classList.contains("lm-mod-expanded");
        const newTitle = Private$g.createTitle(this.renderer, widget.title, expanded);
        this._titles[index2] = newTitle;
        this.parent.node.replaceChild(newTitle, oldTitle);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        if (!widget.id) {
          widget.id = `id-${import_coreutils.UUID.uuid4()}`;
        }
        super.insertWidget(index2, widget);
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(index2, widget) {
        const title = Private$g.createTitle(this.renderer, widget.title);
        ArrayExt.insert(this._titles, index2, title);
        this.parent.node.appendChild(title);
        widget.node.setAttribute("role", "region");
        widget.node.setAttribute("aria-labelledby", title.id);
        super.attachWidget(index2, widget);
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._titles, fromIndex, toIndex);
        super.moveWidget(fromIndex, toIndex, widget);
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        const title = ArrayExt.removeAt(this._titles, index2);
        this.parent.node.removeChild(title);
        super.detachWidget(index2, widget);
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const titleStyle = this._titles[i6].style;
        titleStyle.top = `${top}px`;
        titleStyle.left = `${left}px`;
        titleStyle.height = `${this.widgetOffset}px`;
        if (isHorizontal) {
          titleStyle.width = `${height}px`;
        } else {
          titleStyle.width = `${width}px`;
        }
        super.updateItemPosition(i6, isHorizontal, left, top, height, width, size5);
      }
    };
    (function(Private22) {
      function createTitle(renderer, data, expanded = true) {
        const title = renderer.createSectionTitle(data);
        title.style.position = "absolute";
        title.style.contain = "strict";
        title.setAttribute("aria-label", `${data.label} Section`);
        title.setAttribute("aria-expanded", expanded ? "true" : "false");
        title.setAttribute("aria-controls", data.owner.id);
        if (expanded) {
          title.classList.add("lm-mod-expanded");
        }
        return title;
      }
      Private22.createTitle = createTitle;
    })(Private$g || (Private$g = {}));
    Panel2 = class extends Widget2 {
      /**
       * Construct a new panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this.addClass("lm-Panel");
        this.layout = Private$f.createLayout(options);
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        this.layout.addWidget(widget);
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        this.layout.insertWidget(index2, widget);
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new PanelLayout2();
      }
      Private22.createLayout = createLayout;
    })(Private$f || (Private$f = {}));
    SplitPanel = class extends Panel2 {
      /**
       * Construct a new split panel.
       *
       * @param options - The options for initializing the split panel.
       */
      constructor(options = {}) {
        super({ layout: Private$e.createLayout(options) });
        this._handleMoved = new Signal(this);
        this._pressData = null;
        this.addClass("lm-SplitPanel");
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        super.dispose();
      }
      /**
       * Get the layout orientation for the split panel.
       */
      get orientation() {
        return this.layout.orientation;
      }
      /**
       * Set the layout orientation for the split panel.
       */
      set orientation(value) {
        this.layout.orientation = value;
      }
      /**
       * Get the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the split panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the split panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * The renderer used by the split panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * A signal emitted when a split handle has moved.
       */
      get handleMoved() {
        return this._handleMoved;
      }
      /**
       * A read-only array of the split handles in the panel.
       */
      get handles() {
        return this.layout.handles;
      }
      /**
       * Get the relative sizes of the widgets in the panel.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return this.layout.relativeSizes();
      }
      /**
       * Set the relative sizes for the widgets in the panel.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        this.layout.setRelativeSizes(sizes, update);
      }
      /**
       * Handle the DOM events for the split panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * Handle the `'keydown'` event for the split panel.
       */
      _evtKeyDown(event) {
        if (this._pressData) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (event.keyCode === 27) {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'pointerdown'` event for the split panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let index2 = ArrayExt.findFirstIndex(layout.handles, (handle2) => {
          return handle2.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("contextmenu", this, true);
        let delta;
        let handle = layout.handles[index2];
        let rect = handle.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          delta = event.clientX - rect.left;
        } else {
          delta = event.clientY - rect.top;
        }
        let style = window.getComputedStyle(handle);
        let override = Drag.overrideCursor(style.cursor);
        this._pressData = { index: index2, delta, override };
      }
      /**
       * Handle the `'pointermove'` event for the split panel.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        let pos;
        let layout = this.layout;
        let rect = this.node.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          pos = event.clientX - rect.left - this._pressData.delta;
        } else {
          pos = event.clientY - rect.top - this._pressData.delta;
        }
        layout.moveHandle(this._pressData.index, pos);
      }
      /**
       * Handle the `'pointerup'` event for the split panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
      }
      /**
       * Release the mouse grab for the split panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._handleMoved.emit();
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
    };
    (function(SplitPanel5) {
      class Renderer {
        /**
         * Create a new handle for use with a split panel.
         *
         * @returns A new handle element for a split panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-SplitPanel-handle";
          return handle;
        }
      }
      SplitPanel5.Renderer = Renderer;
      SplitPanel5.defaultRenderer = new Renderer();
      function getStretch(widget) {
        return SplitLayout.getStretch(widget);
      }
      SplitPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        SplitLayout.setStretch(widget, value);
      }
      SplitPanel5.setStretch = setStretch;
    })(SplitPanel || (SplitPanel = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new SplitLayout({
          renderer: options.renderer || SplitPanel.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing
        });
      }
      Private22.createLayout = createLayout;
    })(Private$e || (Private$e = {}));
    AccordionPanel = class extends SplitPanel {
      /**
       * Construct a new accordion panel.
       *
       * @param options - The options for initializing the accordion panel.
       *
       */
      constructor(options = {}) {
        super({ ...options, layout: Private$d.createLayout(options) });
        this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
        this._expansionToggled = new Signal(this);
        this.addClass("lm-AccordionPanel");
      }
      /**
       * The renderer used by the accordion panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * The section title space.
       *
       * This is the height if the panel is vertical and the width if it is
       * horizontal.
       */
      get titleSpace() {
        return this.layout.titleSpace;
      }
      set titleSpace(value) {
        this.layout.titleSpace = value;
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this.layout.titles;
      }
      /**
       * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
       */
      get expansionToggled() {
        return this._expansionToggled;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        super.addWidget(widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Collapse the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      collapse(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && !widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Expand the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      expand(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        super.insertWidget(index2, widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Handle the DOM events for the accordion panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        super.handleEvent(event);
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._eventKeyDown(event);
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        super.onBeforeAttach(msg);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        super.onAfterDetach(msg);
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        const index2 = ArrayExt.findFirstIndex(this.widgets, (widget) => {
          return widget.contains(sender.owner);
        });
        if (index2 >= 0) {
          this.layout.updateTitle(index2, sender.owner);
          this.update();
        }
      }
      /**
       * Compute the size of widgets in this panel on the title click event.
       * On closing, the size of the widget is cached and we will try to expand
       * the last opened widget.
       * On opening, we will use the cached size if it is available to restore the
       * widget.
       * In both cases, if we can not compute the size of widgets, we will let
       * `SplitLayout` decide.
       *
       * @param index - The index of widget to be opened of closed
       *
       * @returns Relative size of widgets in this panel, if this size can
       * not be computed, return `undefined`
       */
      _computeWidgetSize(index2) {
        const layout = this.layout;
        const widget = layout.widgets[index2];
        if (!widget) {
          return void 0;
        }
        const isHidden2 = widget.isHidden;
        const widgetSizes = layout.absoluteSizes();
        const delta = (isHidden2 ? -1 : 1) * this.spacing;
        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
        let newSize = [...widgetSizes];
        if (!isHidden2) {
          const currentSize = widgetSizes[index2];
          this._widgetSizesCache.set(widget, currentSize);
          newSize[index2] = 0;
          const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            return void 0;
          }
          newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
        } else {
          const previousSize = this._widgetSizesCache.get(widget);
          if (!previousSize) {
            return void 0;
          }
          newSize[index2] += previousSize;
          const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            newSize.forEach((_4, idx) => {
              if (idx !== index2) {
                newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
              }
            });
          } else {
            newSize[widgetToCollapse] -= previousSize - delta;
          }
        }
        return newSize.map((sz) => sz / (totalSize + delta));
      }
      /**
       * Handle the `'click'` event for the accordion panel
       */
      _evtClick(event) {
        const target = event.target;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            event.preventDefault();
            event.stopPropagation();
            this._toggleExpansion(index2);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the accordion panel.
       */
      _eventKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const target = event.target;
        let handled = false;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            const keyCode = event.keyCode.toString();
            if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
              target.click();
              handled = true;
            } else if (this.orientation === "horizontal" ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
              const direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
              const length = this.titles.length;
              const newIndex = (index2 + length + direction) % length;
              this.titles[newIndex].focus();
              handled = true;
            } else if (event.key === "End" || keyCode === "35") {
              this.titles[this.titles.length - 1].focus();
              handled = true;
            } else if (event.key === "Home" || keyCode === "36") {
              this.titles[0].focus();
              handled = true;
            }
          }
          if (handled) {
            event.preventDefault();
          }
        }
      }
      _toggleExpansion(index2) {
        const title = this.titles[index2];
        const widget = this.layout.widgets[index2];
        const newSize = this._computeWidgetSize(index2);
        if (newSize) {
          this.setRelativeSizes(newSize, false);
        }
        if (widget.isHidden) {
          title.classList.add("lm-mod-expanded");
          title.setAttribute("aria-expanded", "true");
          widget.show();
        } else {
          title.classList.remove("lm-mod-expanded");
          title.setAttribute("aria-expanded", "false");
          widget.hide();
        }
        this._expansionToggled.emit(index2);
      }
    };
    (function(AccordionPanel5) {
      class Renderer extends SplitPanel.Renderer {
        constructor() {
          super();
          this.titleClassName = "lm-AccordionPanel-title";
          this._titleID = 0;
          this._titleKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the collapse indicator for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the collapse indicator.
         */
        createCollapseIcon(data) {
          return document.createElement("span");
        }
        /**
         * Render the element for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the section title.
         */
        createSectionTitle(data) {
          const handle = document.createElement("h3");
          handle.setAttribute("tabindex", "0");
          handle.id = this.createTitleKey(data);
          handle.className = this.titleClassName;
          for (const aData in data.dataset) {
            handle.dataset[aData] = data.dataset[aData];
          }
          const collapser = handle.appendChild(this.createCollapseIcon(data));
          collapser.className = "lm-AccordionPanel-titleCollapser";
          const label = handle.appendChild(document.createElement("span"));
          label.className = "lm-AccordionPanel-titleLabel";
          label.textContent = data.label;
          label.title = data.caption || data.label;
          return handle;
        }
        /**
         * Create a unique render key for the title.
         *
         * @param data - The data to use for the title.
         *
         * @returns The unique render key for the title.
         *
         * #### Notes
         * This method caches the key against the section title the first time
         * the key is generated.
         */
        createTitleKey(data) {
          let key = this._titleKeys.get(data);
          if (key === void 0) {
            key = `title-key-${this._uuid}-${this._titleID++}`;
            this._titleKeys.set(data, key);
          }
          return key;
        }
      }
      Renderer._nInstance = 0;
      AccordionPanel5.Renderer = Renderer;
      AccordionPanel5.defaultRenderer = new Renderer();
    })(AccordionPanel || (AccordionPanel = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new AccordionLayout({
          renderer: options.renderer || AccordionPanel.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing,
          titleSpace: options.titleSpace
        });
      }
      Private22.createLayout = createLayout;
    })(Private$d || (Private$d = {}));
    BoxLayout = class extends PanelLayout2 {
      /**
       * Construct a new box layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super();
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._sizers = [];
        this._items = [];
        this._box = null;
        this._alignment = "start";
        this._direction = "top-to-bottom";
        if (options.direction !== void 0) {
          this._direction = options.direction;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils$1.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        super.dispose();
      }
      /**
       * Get the layout direction for the box layout.
       */
      get direction() {
        return this._direction;
      }
      /**
       * Set the layout direction for the box layout.
       */
      set direction(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["direction"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the box layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the box layout.
       */
      set spacing(value) {
        value = Utils$1.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["direction"] = this.direction;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        ArrayExt.insert(this._items, index2, new LayoutItem(widget));
        ArrayExt.insert(this._sizers, index2, new BoxSizer());
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        let horz = Private$c.isHorizontal(this._direction);
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.sizeHint = BoxLayout.getSizeBasis(item.widget);
          sizer.stretch = BoxLayout.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget2.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget2.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let delta;
        switch (this._direction) {
          case "left-to-right":
            delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
            break;
          case "top-to-bottom":
            delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
            break;
          case "right-to-left":
            delta = BoxEngine.calc(this._sizers, Math.max(0, width - this._fixed));
            left += width;
            break;
          case "bottom-to-top":
            delta = BoxEngine.calc(this._sizers, Math.max(0, height - this._fixed));
            top += height;
            break;
          default:
            throw "unreachable";
        }
        let extra = 0;
        let offset4 = 0;
        if (delta > 0) {
          switch (this._alignment) {
            case "start":
              break;
            case "center":
              extra = 0;
              offset4 = delta / 2;
              break;
            case "end":
              extra = 0;
              offset4 = delta;
              break;
            case "justify":
              extra = delta / nVisible;
              offset4 = 0;
              break;
            default:
              throw "unreachable";
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let size5 = this._sizers[i6].size;
          switch (this._direction) {
            case "left-to-right":
              item.update(left + offset4, top, size5 + extra, height);
              left += size5 + extra + this._spacing;
              break;
            case "top-to-bottom":
              item.update(left, top + offset4, width, size5 + extra);
              top += size5 + extra + this._spacing;
              break;
            case "right-to-left":
              item.update(left - offset4 - size5 - extra, top, size5 + extra, height);
              left -= size5 + extra + this._spacing;
              break;
            case "bottom-to-top":
              item.update(left, top - offset4 - size5 - extra, width, size5 + extra);
              top -= size5 + extra + this._spacing;
              break;
            default:
              throw "unreachable";
          }
        }
      }
    };
    (function(BoxLayout5) {
      function getStretch(widget) {
        return Private$c.stretchProperty.get(widget);
      }
      BoxLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$c.stretchProperty.set(widget, value);
      }
      BoxLayout5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return Private$c.sizeBasisProperty.get(widget);
      }
      BoxLayout5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        Private$c.sizeBasisProperty.set(widget, value);
      }
      BoxLayout5.setSizeBasis = setSizeBasis;
    })(BoxLayout || (BoxLayout = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      Private22.sizeBasisProperty = new AttachedProperty({
        name: "sizeBasis",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function isHorizontal(dir) {
        return dir === "left-to-right" || dir === "right-to-left";
      }
      Private22.isHorizontal = isHorizontal;
      function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampSpacing = clampSpacing;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof BoxLayout) {
          child.parent.fit();
        }
      }
    })(Private$c || (Private$c = {}));
    BoxPanel = class extends Panel2 {
      /**
       * Construct a new box panel.
       *
       * @param options - The options for initializing the box panel.
       */
      constructor(options = {}) {
        super({ layout: Private$b.createLayout(options) });
        this.addClass("lm-BoxPanel");
      }
      /**
       * Get the layout direction for the box panel.
       */
      get direction() {
        return this.layout.direction;
      }
      /**
       * Set the layout direction for the box panel.
       */
      set direction(value) {
        this.layout.direction = value;
      }
      /**
       * Get the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the box panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the box panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-BoxPanel-child");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-BoxPanel-child");
      }
    };
    (function(BoxPanel5) {
      function getStretch(widget) {
        return BoxLayout.getStretch(widget);
      }
      BoxPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        BoxLayout.setStretch(widget, value);
      }
      BoxPanel5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return BoxLayout.getSizeBasis(widget);
      }
      BoxPanel5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        BoxLayout.setSizeBasis(widget, value);
      }
      BoxPanel5.setSizeBasis = setSizeBasis;
    })(BoxPanel || (BoxPanel = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new BoxLayout(options);
      }
      Private22.createLayout = createLayout;
    })(Private$b || (Private$b = {}));
    CommandPalette = class extends Widget2 {
      /**
       * Construct a new command palette.
       *
       * @param options - The options for initializing the palette.
       */
      constructor(options) {
        super({ node: Private$a.createNode() });
        this._activeIndex = -1;
        this._items = [];
        this._results = null;
        this.addClass("lm-CommandPalette");
        this.setFlag(Widget2.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || CommandPalette.defaultRenderer;
        this.commands.commandChanged.connect(this._onGenericChange, this);
        this.commands.keyBindingChanged.connect(this._onGenericChange, this);
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._items.length = 0;
        this._results = null;
        super.dispose();
      }
      /**
       * The command palette search node.
       *
       * #### Notes
       * This is the node which contains the search-related elements.
       */
      get searchNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
      }
      /**
       * The command palette input node.
       *
       * #### Notes
       * This is the actual input node for the search area.
       */
      get inputNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
      }
      /**
       * The command palette content node.
       *
       * #### Notes
       * This is the node which holds the command item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
      }
      /**
       * A read-only array of the command items in the palette.
       */
      get items() {
        return this._items;
      }
      /**
       * Add a command item to the command palette.
       *
       * @param options - The options for creating the command item.
       *
       * @returns The command item added to the palette.
       */
      addItem(options) {
        let item = Private$a.createItem(this.commands, options);
        this._items.push(item);
        this.refresh();
        return item;
      }
      /**
       * Adds command items to the command palette.
       *
       * @param items - An array of options for creating each command item.
       *
       * @returns The command items added to the palette.
       */
      addItems(items) {
        const newItems = items.map((item) => Private$a.createItem(this.commands, item));
        newItems.forEach((item) => this._items.push(item));
        this.refresh();
        return newItems;
      }
      /**
       * Remove an item from the command palette.
       *
       * @param item - The item to remove from the palette.
       *
       * #### Notes
       * This is a no-op if the item is not in the palette.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the command palette.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.refresh();
      }
      /**
       * Remove all items from the command palette.
       */
      clearItems() {
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.refresh();
      }
      /**
       * Clear the search results and schedule an update.
       *
       * #### Notes
       * This should be called whenever the search results of the palette
       * should be updated.
       *
       * This is typically called automatically by the palette as needed,
       * but can be called manually if the input text is programatically
       * changed.
       *
       * The rendered results are updated asynchronously.
       */
      refresh() {
        this._results = null;
        if (this.inputNode.value !== "") {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "inherit";
        } else {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "none";
        }
        this.update();
      }
      /**
       * Handle the DOM events for the command palette.
       *
       * @param event - The DOM event sent to the command palette.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the command palette's DOM node.
       * It should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "input":
            this.refresh();
            break;
          case "focus":
          case "blur":
            this._toggleFocused();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("input", this);
        this.node.addEventListener("focus", this, true);
        this.node.addEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("input", this);
        this.node.removeEventListener("focus", this, true);
        this.node.removeEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       */
      onAfterShow(msg) {
        this.update();
        super.onAfterShow(msg);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          let input = this.inputNode;
          input.focus();
          input.select();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (!this.isVisible) {
          VirtualDOM.render(null, this.contentNode);
          return;
        }
        let query = this.inputNode.value;
        let contentNode = this.contentNode;
        let results = this._results;
        if (!results) {
          results = this._results = Private$a.search(this._items, query);
          this._activeIndex = query ? ArrayExt.findFirstIndex(results, Private$a.canActivate) : -1;
        }
        if (!query && results.length === 0) {
          VirtualDOM.render(null, contentNode);
          return;
        }
        if (query && results.length === 0) {
          let content2 = this.renderer.renderEmptyMessage({ query });
          VirtualDOM.render(content2, contentNode);
          return;
        }
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let content = new Array(results.length);
        for (let i6 = 0, n5 = results.length; i6 < n5; ++i6) {
          let result2 = results[i6];
          if (result2.type === "header") {
            let indices = result2.indices;
            let category = result2.category;
            content[i6] = renderer.renderHeader({ category, indices });
          } else {
            let item = result2.item;
            let indices = result2.indices;
            let active = i6 === activeIndex;
            content[i6] = renderer.renderItem({ item, indices, active });
          }
        }
        VirtualDOM.render(content, contentNode);
        if (activeIndex < 0 || activeIndex >= results.length) {
          contentNode.scrollTop = 0;
        } else {
          let element2 = contentNode.children[activeIndex];
          ElementExt.scrollIntoViewIfNeeded(contentNode, element2);
        }
      }
      /**
       * Handle the `'click'` event for the command palette.
       */
      _evtClick(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.target.classList.contains("lm-close-icon")) {
          this.inputNode.value = "";
          this.refresh();
          return;
        }
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return node.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._execute(index2);
      }
      /**
       * Handle the `'keydown'` event for the command palette.
       */
      _evtKeyDown(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        switch (event.keyCode) {
          case 13:
            event.preventDefault();
            event.stopPropagation();
            this._execute(this._activeIndex);
            break;
          case 38:
            event.preventDefault();
            event.stopPropagation();
            this._activatePreviousItem();
            break;
          case 40:
            event.preventDefault();
            event.stopPropagation();
            this._activateNextItem();
            break;
        }
      }
      /**
       * Activate the next enabled command item.
       */
      _activateNextItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this._activeIndex = ArrayExt.findFirstIndex(this._results, Private$a.canActivate, start, stop);
        this.update();
      }
      /**
       * Activate the previous enabled command item.
       */
      _activatePreviousItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this._activeIndex = ArrayExt.findLastIndex(this._results, Private$a.canActivate, start, stop);
        this.update();
      }
      /**
       * Execute the command item at the given index, if possible.
       */
      _execute(index2) {
        if (!this._results) {
          return;
        }
        let part = this._results[index2];
        if (!part) {
          return;
        }
        if (part.type === "header") {
          let input = this.inputNode;
          input.value = `${part.category.toLowerCase()} `;
          input.focus();
          this.refresh();
          return;
        }
        if (!part.item.isEnabled) {
          return;
        }
        this.commands.execute(part.item.command, part.item.args);
        this.inputNode.value = "";
        this.refresh();
      }
      /**
       * Toggle the focused modifier based on the input node focus state.
       */
      _toggleFocused() {
        let focused = document.activeElement === this.inputNode;
        this.toggleClass("lm-mod-focused", focused);
      }
      /**
       * A signal handler for generic command changes.
       */
      _onGenericChange() {
        this.refresh();
      }
    };
    (function(CommandPalette5) {
      class Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          let content = this.formatHeader(data);
          return h.li({ className: "lm-CommandPalette-header" }, content);
        }
        /**
         * Render the virtual element for a command palette item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          if (data.item.isToggleable) {
            return h.li({
              className,
              dataset,
              role: "menuitemcheckbox",
              "aria-checked": `${data.item.isToggled}`
            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
          }
          return h.li({
            className,
            dataset,
            role: "menuitem"
          }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
        }
        /**
         * Render the empty results message for a command palette.
         *
         * @param data - The data to use for rendering the message.
         *
         * @returns A virtual element representing the message.
         */
        renderEmptyMessage(data) {
          let content = this.formatEmptyMessage(data);
          return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the content for a command palette item.
         *
         * @param data - The data to use for rendering the content.
         *
         * @returns A virtual element representing the content.
         */
        renderItemContent(data) {
          return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
        }
        /**
         * Render the label for a command palette item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the label.
         */
        renderItemLabel(data) {
          let content = this.formatItemLabel(data);
          return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
        }
        /**
         * Render the caption for a command palette item.
         *
         * @param data - The data to use for rendering the caption.
         *
         * @returns A virtual element representing the caption.
         */
        renderItemCaption(data) {
          let content = this.formatItemCaption(data);
          return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
        }
        /**
         * Render the shortcut for a command palette item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the shortcut.
         */
        renderItemShortcut(data) {
          let content = this.formatItemShortcut(data);
          return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
        }
        /**
         * Create the class name for the command palette item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the command palette item.
         */
        createItemClass(data) {
          let name = "lm-CommandPalette-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the command palette item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the command palette item.
         */
        createItemDataset(data) {
          return { ...data.item.dataset, command: data.item.command };
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-CommandPalette-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the header node.
         *
         * @param data - The data to use for the header content.
         *
         * @returns The content to add to the header node.
         */
        formatHeader(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.category;
          }
          return StringExt.highlight(data.category, data.indices, h.mark);
        }
        /**
         * Create the render content for the empty message node.
         *
         * @param data - The data to use for the empty message content.
         *
         * @returns The content to add to the empty message node.
         */
        formatEmptyMessage(data) {
          return `No commands found that match '${data.query}'`;
        }
        /**
         * Create the render content for the item shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatItemShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
        /**
         * Create the render content for the item label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatItemLabel(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.item.label;
          }
          return StringExt.highlight(data.item.label, data.indices, h.mark);
        }
        /**
         * Create the render content for the item caption node.
         *
         * @param data - The data to use for the caption content.
         *
         * @returns The content to add to the caption node.
         */
        formatItemCaption(data) {
          return data.item.caption;
        }
      }
      CommandPalette5.Renderer = Renderer;
      CommandPalette5.defaultRenderer = new Renderer();
    })(CommandPalette || (CommandPalette = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let search2 = document.createElement("div");
        let wrapper = document.createElement("div");
        let input = document.createElement("input");
        let content = document.createElement("ul");
        let clear = document.createElement("button");
        search2.className = "lm-CommandPalette-search";
        wrapper.className = "lm-CommandPalette-wrapper";
        input.className = "lm-CommandPalette-input";
        clear.className = "lm-close-icon";
        content.className = "lm-CommandPalette-content";
        content.setAttribute("role", "menu");
        input.spellcheck = false;
        wrapper.appendChild(input);
        wrapper.appendChild(clear);
        search2.appendChild(wrapper);
        node.appendChild(search2);
        node.appendChild(content);
        return node;
      }
      Private22.createNode = createNode;
      function createItem(commands, options) {
        return new CommandItem(commands, options);
      }
      Private22.createItem = createItem;
      function search(items, query) {
        let scores = matchItems(items, query);
        scores.sort(scoreCmp);
        return createResults(scores);
      }
      Private22.search = search;
      function canActivate(result2) {
        return result2.type === "item" && result2.item.isEnabled;
      }
      Private22.canActivate = canActivate;
      function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, " ");
      }
      function normalizeQuery(text) {
        return text.replace(/\s+/g, "").toLowerCase();
      }
      function matchItems(items, query) {
        query = normalizeQuery(query);
        let scores = [];
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          if (!item.isVisible) {
            continue;
          }
          if (!query) {
            scores.push({
              matchType: 3,
              categoryIndices: null,
              labelIndices: null,
              score: 0,
              item
            });
            continue;
          }
          let score = fuzzySearch(item, query);
          if (!score) {
            continue;
          }
          if (!item.isEnabled) {
            score.score += 1e3;
          }
          scores.push(score);
        }
        return scores;
      }
      function fuzzySearch(item, query) {
        let category = item.category.toLowerCase();
        let label = item.label.toLowerCase();
        let source = `${category} ${label}`;
        let score = Infinity;
        let indices = null;
        let rgx = /\b\w/g;
        while (true) {
          let rgxMatch = rgx.exec(source);
          if (!rgxMatch) {
            break;
          }
          let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);
          if (!match) {
            break;
          }
          if (match.score <= score) {
            score = match.score;
            indices = match.indices;
          }
        }
        if (!indices || score === Infinity) {
          return null;
        }
        let pivot = category.length + 1;
        let j2 = ArrayExt.lowerBound(indices, pivot, (a3, b2) => a3 - b2);
        let categoryIndices = indices.slice(0, j2);
        let labelIndices = indices.slice(j2);
        for (let i6 = 0, n5 = labelIndices.length; i6 < n5; ++i6) {
          labelIndices[i6] -= pivot;
        }
        if (categoryIndices.length === 0) {
          return {
            matchType: 0,
            categoryIndices: null,
            labelIndices,
            score,
            item
          };
        }
        if (labelIndices.length === 0) {
          return {
            matchType: 1,
            categoryIndices,
            labelIndices: null,
            score,
            item
          };
        }
        return {
          matchType: 2,
          categoryIndices,
          labelIndices,
          score,
          item
        };
      }
      function scoreCmp(a3, b2) {
        let m1 = a3.matchType - b2.matchType;
        if (m1 !== 0) {
          return m1;
        }
        let d1 = a3.score - b2.score;
        if (d1 !== 0) {
          return d1;
        }
        let i1 = 0;
        let i22 = 0;
        switch (a3.matchType) {
          case 0:
            i1 = a3.labelIndices[0];
            i22 = b2.labelIndices[0];
            break;
          case 1:
          case 2:
            i1 = a3.categoryIndices[0];
            i22 = b2.categoryIndices[0];
            break;
        }
        if (i1 !== i22) {
          return i1 - i22;
        }
        let d22 = a3.item.category.localeCompare(b2.item.category);
        if (d22 !== 0) {
          return d22;
        }
        let r1 = a3.item.rank;
        let r22 = b2.item.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.item.label.localeCompare(b2.item.label);
      }
      function createResults(scores) {
        let results = [];
        for (let i6 = 0, n5 = scores.length; i6 < n5; ++i6) {
          let { item, categoryIndices, labelIndices } = scores[i6];
          let category = item.category;
          if (i6 === 0 || category !== scores[i6 - 1].item.category) {
            results.push({ type: "header", category, indices: categoryIndices });
          }
          results.push({ type: "item", item, indices: labelIndices });
        }
        return results;
      }
      class CommandItem {
        /**
         * Construct a new command item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.category = normalizeCategory(options.category);
          this.command = options.command;
          this.args = options.args || import_coreutils.JSONExt.emptyObject;
          this.rank = options.rank !== void 0 ? options.rank : Infinity;
        }
        /**
         * The display label for the command item.
         */
        get label() {
          return this._commands.label(this.command, this.args);
        }
        /**
         * The icon renderer for the command item.
         */
        get icon() {
          return this._commands.icon(this.command, this.args);
        }
        /**
         * The icon class for the command item.
         */
        get iconClass() {
          return this._commands.iconClass(this.command, this.args);
        }
        /**
         * The icon label for the command item.
         */
        get iconLabel() {
          return this._commands.iconLabel(this.command, this.args);
        }
        /**
         * The display caption for the command item.
         */
        get caption() {
          return this._commands.caption(this.command, this.args);
        }
        /**
         * The extra class name for the command item.
         */
        get className() {
          return this._commands.className(this.command, this.args);
        }
        /**
         * The dataset for the command item.
         */
        get dataset() {
          return this._commands.dataset(this.command, this.args);
        }
        /**
         * Whether the command item is enabled.
         */
        get isEnabled() {
          return this._commands.isEnabled(this.command, this.args);
        }
        /**
         * Whether the command item is toggled.
         */
        get isToggled() {
          return this._commands.isToggled(this.command, this.args);
        }
        /**
         * Whether the command item is toggleable.
         */
        get isToggleable() {
          return this._commands.isToggleable(this.command, this.args);
        }
        /**
         * Whether the command item is visible.
         */
        get isVisible() {
          return this._commands.isVisible(this.command, this.args);
        }
        /**
         * The key binding for the command item.
         */
        get keyBinding() {
          let { command, args } = this;
          return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
            return kb.command === command && import_coreutils.JSONExt.deepEqual(kb.args, args);
          }) || null;
        }
      }
    })(Private$a || (Private$a = {}));
    Menu = class extends Widget2 {
      /**
       * Construct a new menu.
       *
       * @param options - The options for initializing the menu.
       */
      constructor(options) {
        super({ node: Private$9.createNode() });
        this._childIndex = -1;
        this._activeIndex = -1;
        this._openTimerID = 0;
        this._closeTimerID = 0;
        this._items = [];
        this._childMenu = null;
        this._parentMenu = null;
        this._aboutToClose = new Signal(this);
        this._menuRequested = new Signal(this);
        this.addClass("lm-Menu");
        this.setFlag(Widget2.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || Menu.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the menu.
       */
      dispose() {
        this.close();
        this._items.length = 0;
        super.dispose();
      }
      /**
       * A signal emitted just before the menu is closed.
       *
       * #### Notes
       * This signal is emitted when the menu receives a `'close-request'`
       * message, just before it removes itself from the DOM.
       *
       * This signal is not emitted if the menu is already detached from
       * the DOM when it receives the `'close-request'` message.
       */
      get aboutToClose() {
        return this._aboutToClose;
      }
      /**
       * A signal emitted when a new menu is requested by the user.
       *
       * #### Notes
       * This signal is emitted whenever the user presses the right or left
       * arrow keys, and a submenu cannot be opened or closed in response.
       *
       * This signal is useful when implementing menu bars in order to open
       * the next or previous menu in response to a user key press.
       *
       * This signal is only emitted for the root menu in a hierarchy.
       */
      get menuRequested() {
        return this._menuRequested;
      }
      /**
       * The parent menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu is an open submenu.
       */
      get parentMenu() {
        return this._parentMenu;
      }
      /**
       * The child menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu has an open submenu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The root menu of the menu hierarchy.
       */
      get rootMenu() {
        let menu = this;
        while (menu._parentMenu) {
          menu = menu._parentMenu;
        }
        return menu;
      }
      /**
       * The leaf menu of the menu hierarchy.
       */
      get leafMenu() {
        let menu = this;
        while (menu._childMenu) {
          menu = menu._childMenu;
        }
        return menu;
      }
      /**
       * The menu content node.
       *
       * #### Notes
       * This is the node which holds the menu item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-Menu-content")[0];
      }
      /**
       * Get the currently active menu item.
       */
      get activeItem() {
        return this._items[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the item will be set to `null`.
       */
      set activeItem(value) {
        this.activeIndex = value ? this._items.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu item.
       *
       * #### Notes
       * This will be `-1` if no menu item is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._items.length) {
          value = -1;
        }
        if (value !== -1 && !Private$9.canActivate(this._items[value])) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
          this.contentNode.childNodes[this._activeIndex].focus();
        }
        this.update();
      }
      /**
       * A read-only array of the menu items in the menu.
       */
      get items() {
        return this._items;
      }
      /**
       * Activate the next selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activateNextItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this.activeIndex = ArrayExt.findFirstIndex(this._items, Private$9.canActivate, start, stop);
      }
      /**
       * Activate the previous selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activatePreviousItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this.activeIndex = ArrayExt.findLastIndex(this._items, Private$9.canActivate, start, stop);
      }
      /**
       * Trigger the active menu item.
       *
       * #### Notes
       * If the active item is a submenu, it will be opened and the first
       * item will be activated.
       *
       * If the active item is a command, the command will be executed.
       *
       * If the menu is not attached, this is a no-op.
       *
       * If there is no active item, this is a no-op.
       */
      triggerActiveItem() {
        if (!this.isAttached) {
          return;
        }
        let item = this.activeItem;
        if (!item) {
          return;
        }
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        if (item.type === "submenu") {
          this._openChildMenu(true);
          return;
        }
        this.rootMenu.close();
        let { command, args } = item;
        if (this.commands.isEnabled(command, args)) {
          this.commands.execute(command, args);
        } else {
          console.log(`Command '${command}' is disabled.`);
        }
      }
      /**
       * Add a menu item to the end of the menu.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       */
      addItem(options) {
        return this.insertItem(this._items.length, options);
      }
      /**
       * Insert a menu item into the menu at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index2, options) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let i6 = Math.max(0, Math.min(index2, this._items.length));
        let item = Private$9.createItem(this, options);
        ArrayExt.insert(this._items, i6, item);
        this.update();
        return item;
      }
      /**
       * Remove an item from the menu.
       *
       * @param item - The item to remove from the menu.
       *
       * #### Notes
       * This is a no-op if the item is not in the menu.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the menu.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.update();
      }
      /**
       * Remove all menu items from the menu.
       */
      clearItems() {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.update();
      }
      /**
       * Open the menu at the specified location.
       *
       * @param x - The client X coordinate of the menu location.
       *
       * @param y - The client Y coordinate of the menu location.
       *
       * @param options - The additional options for opening the menu.
       *
       * #### Notes
       * The menu will be opened at the given location unless it will not
       * fully fit on the screen. If it will not fit, it will be adjusted
       * to fit naturally on the screen.
       *
       * The menu will be attached under the `host` element in the DOM
       * (or `document.body` if `host` is `null`) and before the `ref`
       * element (or as the last child of `host` if `ref` is `null`).
       * The menu may be displayed outside of the `host` element
       * following the rules of CSS absolute positioning.
       *
       * This is a no-op if the menu is already attached to the DOM.
       */
      open(x2, y4, options = {}) {
        var _a, _b, _c;
        if (this.isAttached) {
          return;
        }
        let forceX = options.forceX || false;
        let forceY = options.forceY || false;
        const host = (_a = options.host) !== null && _a !== void 0 ? _a : null;
        const ref = (_b = options.ref) !== null && _b !== void 0 ? _b : null;
        const horizontalAlignment = (_c = options.horizontalAlignment) !== null && _c !== void 0 ? _c : document.documentElement.dir === "rtl" ? "right" : "left";
        Private$9.openRootMenu(this, x2, y4, forceX, forceY, horizontalAlignment, host, ref);
        this.activate();
      }
      /**
       * Handle the DOM events for the menu.
       *
       * @param event - The DOM event sent to the menu.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu's DOM nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mouseup":
            this._evtMouseUp(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "mouseenter":
            this._evtMouseEnter(event);
            break;
          case "mouseleave":
            this._evtMouseLeave(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mouseup", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseenter", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("contextmenu", this);
        document.addEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mouseup", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseenter", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("contextmenu", this);
        document.removeEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this.node.focus();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        let items = this._items;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let collapsedFlags = Private$9.computeCollapsed(items);
        let content = new Array(items.length);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let active = i6 === activeIndex;
          let collapsed = collapsedFlags[i6];
          content[i6] = renderer.renderItem({
            item,
            active,
            collapsed,
            onfocus: () => {
              this.activeIndex = i6;
            }
          });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        this.activeIndex = -1;
        let childMenu = this._childMenu;
        if (childMenu) {
          this._childIndex = -1;
          this._childMenu = null;
          childMenu._parentMenu = null;
          childMenu.close();
        }
        let parentMenu = this._parentMenu;
        if (parentMenu) {
          this._parentMenu = null;
          parentMenu._childIndex = -1;
          parentMenu._childMenu = null;
          parentMenu.activate();
        }
        if (this.isAttached) {
          this._aboutToClose.emit(void 0);
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'keydown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        let kc = event.keyCode;
        if (kc === 13) {
          this.triggerActiveItem();
          return;
        }
        if (kc === 27) {
          this.close();
          return;
        }
        if (kc === 37) {
          if (this._parentMenu) {
            this.close();
          } else {
            this._menuRequested.emit("previous");
          }
          return;
        }
        if (kc === 38) {
          this.activatePreviousItem();
          return;
        }
        if (kc === 39) {
          let item = this.activeItem;
          if (item && item.type === "submenu") {
            this.triggerActiveItem();
          } else {
            this.rootMenu._menuRequested.emit("next");
          }
          return;
        }
        if (kc === 40) {
          this.activateNextItem();
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$9.findMnemonic(this._items, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.triggerActiveItem();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
        }
      }
      /**
       * Handle the `'mouseup'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
      }
      /**
       * Handle the `'mousemove'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        this.activeIndex = index2;
        index2 = this.activeIndex;
        if (index2 === this._childIndex) {
          this._cancelOpenTimer();
          this._cancelCloseTimer();
          return;
        }
        if (this._childIndex !== -1) {
          this._startCloseTimer();
        }
        this._cancelOpenTimer();
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          return;
        }
        this._startOpenTimer();
      }
      /**
       * Handle the `'mouseenter'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseEnter(event) {
        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
          menu._cancelOpenTimer();
          menu._cancelCloseTimer();
          menu.activeIndex = menu._childIndex;
        }
      }
      /**
       * Handle the `'mouseleave'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseLeave(event) {
        this._cancelOpenTimer();
        if (!this._childMenu) {
          this.activeIndex = -1;
          return;
        }
        let { clientX, clientY } = event;
        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
          this._cancelCloseTimer();
          return;
        }
        this.activeIndex = -1;
        this._startCloseTimer();
      }
      /**
       * Handle the `'mousedown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the document node.
       */
      _evtMouseDown(event) {
        if (this._parentMenu) {
          return;
        }
        if (Private$9.hitTestMenus(this, event.clientX, event.clientY)) {
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.close();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if the active item is not a valid submenu.
       */
      _openChildMenu(activateFirst = false) {
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          this._closeChildMenu();
          return;
        }
        let submenu = item.submenu;
        if (submenu === this._childMenu) {
          return;
        }
        Menu.saveWindowData();
        this._closeChildMenu();
        this._childMenu = submenu;
        this._childIndex = this._activeIndex;
        submenu._parentMenu = this;
        MessageLoop2.sendMessage(this, Widget2.Msg.UpdateRequest);
        let itemNode = this.contentNode.children[this._activeIndex];
        Private$9.openSubmenu(submenu, itemNode);
        if (activateFirst) {
          submenu.activeIndex = -1;
          submenu.activateNextItem();
        }
        submenu.activate();
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (this._childMenu) {
          this._childMenu.close();
        }
      }
      /**
       * Start the open timer, unless it is already pending.
       */
      _startOpenTimer() {
        if (this._openTimerID === 0) {
          this._openTimerID = window.setTimeout(() => {
            this._openTimerID = 0;
            this._openChildMenu();
          }, Private$9.TIMER_DELAY);
        }
      }
      /**
       * Start the close timer, unless it is already pending.
       */
      _startCloseTimer() {
        if (this._closeTimerID === 0) {
          this._closeTimerID = window.setTimeout(() => {
            this._closeTimerID = 0;
            this._closeChildMenu();
          }, Private$9.TIMER_DELAY);
        }
      }
      /**
       * Cancel the open timer, if the timer is pending.
       */
      _cancelOpenTimer() {
        if (this._openTimerID !== 0) {
          clearTimeout(this._openTimerID);
          this._openTimerID = 0;
        }
      }
      /**
       * Cancel the close timer, if the timer is pending.
       */
      _cancelCloseTimer() {
        if (this._closeTimerID !== 0) {
          clearTimeout(this._closeTimerID);
          this._closeTimerID = 0;
        }
      }
      /**
       * Save window data used for menu positioning in transient cache.
       *
       * In order to avoid layout trashing it is recommended to invoke this
       * method immediately prior to opening the menu and any DOM modifications
       * (like closing previously visible menu, or adding a class to menu widget).
       *
       * The transient cache will be released upon `open()` call.
       */
      static saveWindowData() {
        Private$9.saveWindowData();
      }
    };
    (function(Menu5) {
      class Renderer {
        /**
         * Render the virtual element for a menu item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            tabindex: "0",
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
        }
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-Menu-itemLabel" }, content);
        }
        /**
         * Render the shortcut element for a menu item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the item shortcut.
         */
        renderShortcut(data) {
          let content = this.formatShortcut(data);
          return h.div({ className: "lm-Menu-itemShortcut" }, content);
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          return h.div({ className: "lm-Menu-itemSubmenuIcon" });
        }
        /**
         * Create the class name for the menu item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-Menu-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (!data.item.isVisible) {
            name += " lm-mod-hidden";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          if (data.collapsed) {
            name += " lm-mod-collapsed";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the menu item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the menu item.
         */
        createItemDataset(data) {
          let result2;
          let { type, command, dataset } = data.item;
          if (type === "command") {
            result2 = { ...dataset, type, command };
          } else {
            result2 = { ...dataset, type };
          }
          return result2;
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-Menu-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the aria attributes for menu item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          let aria = {};
          switch (data.item.type) {
            case "separator":
              aria.role = "presentation";
              break;
            case "submenu":
              aria["aria-haspopup"] = "true";
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              break;
            default:
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              if (data.item.isToggled) {
                aria.role = "menuitemcheckbox";
                aria["aria-checked"] = "true";
              } else {
                aria.role = "menuitem";
              }
          }
          return aria;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.item;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
        /**
         * Create the render content for the shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
      }
      Menu5.Renderer = Renderer;
      Menu5.defaultRenderer = new Renderer();
    })(Menu || (Menu = {}));
    (function(Private22) {
      Private22.TIMER_DELAY = 300;
      Private22.SUBMENU_OVERLAP = 3;
      let transientWindowDataCache = null;
      let transientCacheCounter = 0;
      function getWindowData() {
        if (transientCacheCounter > 0) {
          transientCacheCounter--;
          return transientWindowDataCache;
        }
        return _getWindowData();
      }
      function saveWindowData() {
        transientWindowDataCache = _getWindowData();
        transientCacheCounter++;
      }
      Private22.saveWindowData = saveWindowData;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-Menu-content";
        node.appendChild(content);
        content.setAttribute("role", "menu");
        node.tabIndex = 0;
        return node;
      }
      Private22.createNode = createNode;
      function canActivate(item) {
        return item.type !== "separator" && item.isEnabled && item.isVisible;
      }
      Private22.canActivate = canActivate;
      function createItem(owner, options) {
        return new MenuItem(owner.commands, options);
      }
      Private22.createItem = createItem;
      function hitTestMenus(menu, x2, y4) {
        for (let temp = menu; temp; temp = temp.childMenu) {
          if (ElementExt.hitTest(temp.node, x2, y4)) {
            return true;
          }
        }
        return false;
      }
      Private22.hitTestMenus = hitTestMenus;
      function computeCollapsed(items) {
        let result2 = new Array(items.length);
        ArrayExt.fill(result2, false);
        let k1 = 0;
        let n5 = items.length;
        for (; k1 < n5; ++k1) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k1] = true;
        }
        let k2 = n5 - 1;
        for (; k2 >= 0; --k2) {
          let item = items[k2];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k2] = true;
        }
        let hide4 = false;
        while (++k1 < k2) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            hide4 = false;
          } else if (hide4) {
            result2[k1] = true;
          } else {
            hide4 = true;
          }
        }
        return result2;
      }
      Private22.computeCollapsed = computeCollapsed;
      function _getWindowData() {
        return {
          pageXOffset: window.pageXOffset,
          pageYOffset: window.pageYOffset,
          clientWidth: document.documentElement.clientWidth,
          clientHeight: document.documentElement.clientHeight
        };
      }
      function openRootMenu(menu, x2, y4, forceX, forceY, horizontalAlignment, host, ref) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop2.sendMessage(menu, Widget2.Msg.UpdateRequest);
        let maxHeight = ch - (forceY ? y4 : 0);
        let node = menu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget2.attach(menu, host || document.body, ref);
        let { width, height } = node.getBoundingClientRect();
        if (horizontalAlignment === "right") {
          x2 -= width;
        }
        if (!forceX && x2 + width > px + cw) {
          x2 = px + cw - width;
        }
        if (!forceY && y4 + height > py + ch) {
          if (y4 > py + ch) {
            y4 = py + ch - height;
          } else {
            y4 = y4 - height;
          }
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openRootMenu = openRootMenu;
      function openSubmenu(submenu, itemNode) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop2.sendMessage(submenu, Widget2.Msg.UpdateRequest);
        let maxHeight = ch;
        let node = submenu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget2.attach(submenu, document.body);
        let { width, height } = node.getBoundingClientRect();
        let box = ElementExt.boxSizing(submenu.node);
        let itemRect = itemNode.getBoundingClientRect();
        let x2 = itemRect.right - Private22.SUBMENU_OVERLAP;
        if (x2 + width > px + cw) {
          x2 = itemRect.left + Private22.SUBMENU_OVERLAP - width;
        }
        let y4 = itemRect.top - box.borderTop - box.paddingTop;
        if (y4 + height > py + ch) {
          y4 = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openSubmenu = openSubmenu;
      function findMnemonic(items, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let item = items[k2];
          if (!canActivate(item)) {
            continue;
          }
          let label = item.label;
          if (label.length === 0) {
            continue;
          }
          let mn = item.mnemonic;
          if (mn >= 0 && mn < label.length) {
            if (label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
      class MenuItem {
        /**
         * Construct a new menu item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.type = options.type || "command";
          this.command = options.command || "";
          this.args = options.args || import_coreutils.JSONExt.emptyObject;
          this.submenu = options.submenu || null;
        }
        /**
         * The display label for the menu item.
         */
        get label() {
          if (this.type === "command") {
            return this._commands.label(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.label;
          }
          return "";
        }
        /**
         * The mnemonic index for the menu item.
         */
        get mnemonic() {
          if (this.type === "command") {
            return this._commands.mnemonic(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.mnemonic;
          }
          return -1;
        }
        /**
         * The icon renderer for the menu item.
         */
        get icon() {
          if (this.type === "command") {
            return this._commands.icon(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.icon;
          }
          return void 0;
        }
        /**
         * The icon class for the menu item.
         */
        get iconClass() {
          if (this.type === "command") {
            return this._commands.iconClass(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconClass;
          }
          return "";
        }
        /**
         * The icon label for the menu item.
         */
        get iconLabel() {
          if (this.type === "command") {
            return this._commands.iconLabel(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconLabel;
          }
          return "";
        }
        /**
         * The display caption for the menu item.
         */
        get caption() {
          if (this.type === "command") {
            return this._commands.caption(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.caption;
          }
          return "";
        }
        /**
         * The extra class name for the menu item.
         */
        get className() {
          if (this.type === "command") {
            return this._commands.className(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.className;
          }
          return "";
        }
        /**
         * The dataset for the menu item.
         */
        get dataset() {
          if (this.type === "command") {
            return this._commands.dataset(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.dataset;
          }
          return {};
        }
        /**
         * Whether the menu item is enabled.
         */
        get isEnabled() {
          if (this.type === "command") {
            return this._commands.isEnabled(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * Whether the menu item is toggled.
         */
        get isToggled() {
          if (this.type === "command") {
            return this._commands.isToggled(this.command, this.args);
          }
          return false;
        }
        /**
         * Whether the menu item is visible.
         */
        get isVisible() {
          if (this.type === "command") {
            return this._commands.isVisible(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * The key binding for the menu item.
         */
        get keyBinding() {
          if (this.type === "command") {
            let { command, args } = this;
            return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
              return kb.command === command && import_coreutils.JSONExt.deepEqual(kb.args, args);
            }) || null;
          }
          return null;
        }
      }
    })(Private$9 || (Private$9 = {}));
    (function(Private22) {
      function createItem(options, id) {
        let selector = validateSelector(options.selector);
        let rank = options.rank !== void 0 ? options.rank : Infinity;
        return { ...options, selector, rank, id };
      }
      Private22.createItem = createItem;
      function matchItems(items, event, groupByTarget, sortBySelector) {
        let target = event.target;
        if (!target) {
          return null;
        }
        let currentTarget = event.currentTarget;
        if (!currentTarget) {
          return null;
        }
        if (!currentTarget.contains(target)) {
          target = document.elementFromPoint(event.clientX, event.clientY);
          if (!target || !currentTarget.contains(target)) {
            return null;
          }
        }
        let result2 = [];
        let availableItems = items.slice();
        while (target !== null) {
          let matches2 = [];
          for (let i6 = 0, n5 = availableItems.length; i6 < n5; ++i6) {
            let item = availableItems[i6];
            if (!item) {
              continue;
            }
            if (!Selector.matches(target, item.selector)) {
              continue;
            }
            matches2.push(item);
            availableItems[i6] = null;
          }
          if (matches2.length !== 0) {
            if (groupByTarget) {
              matches2.sort(sortBySelector ? itemCmp : itemCmpRank);
            }
            result2.push(...matches2);
          }
          if (target === currentTarget) {
            break;
          }
          target = target.parentElement;
        }
        if (!groupByTarget) {
          result2.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        return result2;
      }
      Private22.matchItems = matchItems;
      function validateSelector(selector) {
        if (selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${selector}`);
        }
        if (!Selector.isValid(selector)) {
          throw new Error(`Invalid selector: ${selector}`);
        }
        return selector;
      }
      function itemCmpRank(a3, b2) {
        let r1 = a3.rank;
        let r22 = b2.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.id - b2.id;
      }
      function itemCmp(a3, b2) {
        let s1 = Selector.calculateSpecificity(a3.selector);
        let s22 = Selector.calculateSpecificity(b2.selector);
        if (s1 !== s22) {
          return s22 - s1;
        }
        return itemCmpRank(a3, b2);
      }
    })(Private$8 || (Private$8 = {}));
    ARROW_KEYS = [
      "ArrowLeft",
      "ArrowUp",
      "ArrowRight",
      "ArrowDown",
      "Home",
      "End"
    ];
    TabBar2 = class extends Widget2 {
      /**
       * Construct a new tab bar.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        super({ node: Private$7.createNode() });
        this._currentIndex = -1;
        this._titles = [];
        this._titlesEditable = false;
        this._previousTitle = null;
        this._dragData = null;
        this._addButtonEnabled = false;
        this._tabMoved = new Signal(this);
        this._currentChanged = new Signal(this);
        this._addRequested = new Signal(this);
        this._tabCloseRequested = new Signal(this);
        this._tabDetachRequested = new Signal(this);
        this._tabActivateRequested = new Signal(this);
        this.addClass("lm-TabBar");
        this.contentNode.setAttribute("role", "tablist");
        this.setFlag(Widget2.Flag.DisallowLayout);
        this._document = options.document || document;
        this.tabsMovable = options.tabsMovable || false;
        this.titlesEditable = options.titlesEditable || false;
        this.allowDeselect = options.allowDeselect || false;
        this.addButtonEnabled = options.addButtonEnabled || false;
        this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
        this.name = options.name || "";
        this.orientation = options.orientation || "horizontal";
        this.removeBehavior = options.removeBehavior || "select-tab-after";
        this.renderer = options.renderer || TabBar2.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._releaseMouse();
        this._titles.length = 0;
        this._previousTitle = null;
        super.dispose();
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when a tab is moved by the user.
       *
       * #### Notes
       * This signal is emitted when a tab is moved by user interaction.
       *
       * This signal is not emitted when a tab is moved programmatically.
       */
      get tabMoved() {
        return this._tabMoved;
      }
      /**
       * A signal emitted when a tab is clicked by the user.
       *
       * #### Notes
       * If the clicked tab is not the current tab, the clicked tab will be
       * made current and the `currentChanged` signal will be emitted first.
       *
       * This signal is emitted even if the clicked tab is the current tab.
       */
      get tabActivateRequested() {
        return this._tabActivateRequested;
      }
      /**
       * A signal emitted when the tab bar add button is clicked.
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * A signal emitted when a tab close icon is clicked.
       *
       * #### Notes
       * This signal is not emitted unless the tab title is `closable`.
       */
      get tabCloseRequested() {
        return this._tabCloseRequested;
      }
      /**
       * A signal emitted when a tab is dragged beyond the detach threshold.
       *
       * #### Notes
       * This signal is emitted when the user drags a tab with the mouse,
       * and mouse is dragged beyond the detach threshold.
       *
       * The consumer of the signal should call `releaseMouse` and remove
       * the tab in order to complete the detach.
       *
       * This signal is only emitted once per drag cycle.
       */
      get tabDetachRequested() {
        return this._tabDetachRequested;
      }
      /**
       * The document to use with the tab bar.
       *
       * The default is the global `document` instance.
       */
      get document() {
        return this._document;
      }
      /**
       * Whether the titles can be user-edited.
       *
       */
      get titlesEditable() {
        return this._titlesEditable;
      }
      /**
       * Set whether titles can be user edited.
       *
       */
      set titlesEditable(value) {
        this._titlesEditable = value;
      }
      /**
       * Get the currently selected title.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentTitle() {
        return this._titles[this._currentIndex] || null;
      }
      /**
       * Set the currently selected title.
       *
       * #### Notes
       * If the title does not exist, the title will be set to `null`.
       */
      set currentTitle(value) {
        this.currentIndex = value ? this._titles.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `-1` if no tab is selected.
       */
      get currentIndex() {
        return this._currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `-1`.
       */
      set currentIndex(value) {
        if (value < 0 || value >= this._titles.length) {
          value = -1;
        }
        if (this._currentIndex === value) {
          return;
        }
        let pi = this._currentIndex;
        let pt = this._titles[pi] || null;
        let ci = value;
        let ct = this._titles[ci] || null;
        this._currentIndex = ci;
        this._previousTitle = pt;
        this.update();
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: ci,
          currentTitle: ct
        });
      }
      /**
       * Get the name of the tab bar.
       */
      get name() {
        return this._name;
      }
      /**
       * Set the name of the tab bar.
       */
      set name(value) {
        this._name = value;
        if (value) {
          this.contentNode.setAttribute("aria-label", value);
        } else {
          this.contentNode.removeAttribute("aria-label");
        }
      }
      /**
       * Get the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._releaseMouse();
        this._orientation = value;
        this.dataset["orientation"] = value;
        this.contentNode.setAttribute("aria-orientation", value);
      }
      /**
       * Whether the add button is enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add button is enabled.
       */
      set addButtonEnabled(value) {
        if (this._addButtonEnabled === value) {
          return;
        }
        this._addButtonEnabled = value;
        if (value) {
          this.addButtonNode.classList.remove("lm-mod-hidden");
        } else {
          this.addButtonNode.classList.add("lm-mod-hidden");
        }
      }
      /**
       * A read-only array of the titles in the tab bar.
       */
      get titles() {
        return this._titles;
      }
      /**
       * The tab bar content node.
       *
       * #### Notes
       * This is the node which holds the tab nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-TabBar-content")[0];
      }
      /**
       * The tab bar add button node.
       *
       * #### Notes
       * This is the node which holds the add button.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get addButtonNode() {
        return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
      }
      /**
       * Add a tab to the end of the tab bar.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * If the title is already added to the tab bar, it will be moved.
       */
      addTab(value) {
        return this.insertTab(this._titles.length, value);
      }
      /**
       * Insert a tab into the tab bar at the specified index.
       *
       * @param index - The index at which to insert the tab.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the tabs.
       *
       * If the title is already added to the tab bar, it will be moved.
       */
      insertTab(index2, value) {
        this._releaseMouse();
        let title = Private$7.asTitle(value);
        let i6 = this._titles.indexOf(title);
        let j2 = Math.max(0, Math.min(index2, this._titles.length));
        if (i6 === -1) {
          ArrayExt.insert(this._titles, j2, title);
          title.changed.connect(this._onTitleChanged, this);
          this.update();
          this._adjustCurrentForInsert(j2, title);
          return title;
        }
        if (j2 === this._titles.length) {
          j2--;
        }
        if (i6 === j2) {
          return title;
        }
        ArrayExt.move(this._titles, i6, j2);
        this.update();
        this._adjustCurrentForMove(i6, j2);
        return title;
      }
      /**
       * Remove a tab from the tab bar.
       *
       * @param title - The title for the tab to remove.
       *
       * #### Notes
       * This is a no-op if the title is not in the tab bar.
       */
      removeTab(title) {
        this.removeTabAt(this._titles.indexOf(title));
      }
      /**
       * Remove the tab at a given index from the tab bar.
       *
       * @param index - The index of the tab to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeTabAt(index2) {
        this._releaseMouse();
        let title = ArrayExt.removeAt(this._titles, index2);
        if (!title) {
          return;
        }
        title.changed.disconnect(this._onTitleChanged, this);
        if (title === this._previousTitle) {
          this._previousTitle = null;
        }
        this.update();
        this._adjustCurrentForRemove(index2, title);
      }
      /**
       * Remove all tabs from the tab bar.
       */
      clearTabs() {
        if (this._titles.length === 0) {
          return;
        }
        this._releaseMouse();
        for (let title of this._titles) {
          title.changed.disconnect(this._onTitleChanged, this);
        }
        let pi = this.currentIndex;
        let pt = this.currentTitle;
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles.length = 0;
        this.update();
        if (pi === -1) {
          return;
        }
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       *
       * #### Notes
       * This will cause the tab bar to stop handling mouse events and to
       * restore the tabs to their non-dragged positions.
       */
      releaseMouse() {
        this._releaseMouse();
      }
      /**
       * Handle the DOM events for the tab bar.
       *
       * @param event - The DOM event sent to the tab bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tab bar's DOM node.
       *
       * This should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "dblclick":
            this._evtDblClick(event);
            break;
          case "keydown":
            event.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event) : this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
        this.node.addEventListener("dblclick", this);
        this.node.addEventListener("keydown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this.node.removeEventListener("dblclick", this);
        this.node.removeEventListener("keydown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let titles = this._titles;
        let renderer = this.renderer;
        let currentTitle = this.currentTitle;
        let content = new Array(titles.length);
        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
        for (let i6 = 0, n5 = titles.length; i6 < n5; ++i6) {
          let title = titles[i6];
          let current = title === currentTitle;
          let zIndex = current ? n5 : n5 - i6 - 1;
          let tabIndex = tabHandlingTabindex === i6 ? 0 : -1;
          content[i6] = renderer.renderTab({ title, current, zIndex, tabIndex });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * Get the index of the tab which handles tabindex="0".
       * If the add button handles tabindex="0", -1 is returned.
       * If none of the previous handles tabindex="0", null is returned.
       */
      _getCurrentTabindex() {
        let index2 = null;
        const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
        if (elemTabindex) {
          index2 = [...this.contentNode.children].indexOf(elemTabindex);
        } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
          index2 = -1;
        }
        return index2;
      }
      /**
       * Handle the `'dblclick'` event for the tab bar.
       */
      _evtDblClick(event) {
        if (!this.titlesEditable) {
          return;
        }
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          return;
        }
        let title = this.titles[index2];
        let label = tabs[index2].querySelector(".lm-TabBar-tabLabel");
        if (label && label.contains(event.target)) {
          let value = title.label || "";
          let oldValue = label.innerHTML;
          label.innerHTML = "";
          let input = document.createElement("input");
          input.classList.add("lm-TabBar-tabInput");
          input.value = value;
          label.appendChild(input);
          let onblur = () => {
            input.removeEventListener("blur", onblur);
            label.innerHTML = oldValue;
            this.node.addEventListener("keydown", this);
          };
          input.addEventListener("dblclick", (event2) => event2.stopPropagation());
          input.addEventListener("blur", onblur);
          input.addEventListener("keydown", (event2) => {
            if (event2.key === "Enter") {
              if (input.value !== "") {
                title.label = title.caption = input.value;
              }
              onblur();
            } else if (event2.key === "Escape") {
              onblur();
            }
          });
          this.node.removeEventListener("keydown", this);
          input.select();
          input.focus();
          if (label.children.length > 0) {
            label.children[0].focus();
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at capturing phase.
       */
      _evtKeyDownCapturing(event) {
        if (event.eventPhase !== Event.CAPTURING_PHASE) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "Escape") {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at target phase.
       */
      _evtKeyDown(event) {
        var _a, _b, _c;
        if (event.key === "Tab" || event.eventPhase === Event.CAPTURING_PHASE) {
          return;
        }
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
          const focusedElement = document.activeElement;
          if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
            event.preventDefault();
            event.stopPropagation();
            this._addRequested.emit();
          } else {
            const index2 = ArrayExt.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
            if (index2 >= 0) {
              event.preventDefault();
              event.stopPropagation();
              this.currentIndex = index2;
            }
          }
        } else if (ARROW_KEYS.includes(event.key)) {
          const focusable = [...this.contentNode.children];
          if (this.addButtonEnabled) {
            focusable.push(this.addButtonNode);
          }
          if (focusable.length <= 1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          let focusedIndex = focusable.indexOf(document.activeElement);
          if (focusedIndex === -1) {
            focusedIndex = this._currentIndex;
          }
          let nextFocused;
          if (event.key === "ArrowRight" && this._orientation === "horizontal" || event.key === "ArrowDown" && this._orientation === "vertical") {
            nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
          } else if (event.key === "ArrowLeft" && this._orientation === "horizontal" || event.key === "ArrowUp" && this._orientation === "vertical") {
            nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
          } else if (event.key === "Home") {
            nextFocused = focusable[0];
          } else if (event.key === "End") {
            nextFocused = focusable[focusable.length - 1];
          }
          if (nextFocused) {
            (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
            nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
            nextFocused.focus();
          }
        }
      }
      /**
       * Handle the `'pointerdown'` event for the tab bar.
       */
      _evtPointerDown(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        if (this._dragData) {
          return;
        }
        if (event.target.classList.contains("lm-TabBar-tabInput")) {
          return;
        }
        let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1 && !addButtonClicked) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._dragData = {
          tab: tabs[index2],
          index: index2,
          pressX: event.clientX,
          pressY: event.clientY,
          tabPos: -1,
          tabSize: -1,
          tabPressPos: -1,
          targetIndex: -1,
          tabLayout: null,
          contentRect: null,
          override: null,
          dragActive: false,
          dragAborted: false,
          detachRequested: false
        };
        this.document.addEventListener("pointerup", this, true);
        if (event.button === 1 || addButtonClicked) {
          return;
        }
        let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
          return;
        }
        if (this.tabsMovable) {
          this.document.addEventListener("pointermove", this, true);
          this.document.addEventListener("keydown", this, true);
          this.document.addEventListener("contextmenu", this, true);
        }
        if (this.allowDeselect && this.currentIndex === index2) {
          this.currentIndex = -1;
        } else {
          this.currentIndex = index2;
        }
        if (this.currentIndex === -1) {
          return;
        }
        this._tabActivateRequested.emit({
          index: this.currentIndex,
          title: this.currentTitle
        });
      }
      /**
       * Handle the `'pointermove'` event for the tab bar.
       */
      _evtPointerMove(event) {
        let data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let tabs = this.contentNode.children;
        if (!data.dragActive && !Private$7.dragExceeded(data, event)) {
          return;
        }
        if (!data.dragActive) {
          let tabRect = data.tab.getBoundingClientRect();
          if (this._orientation === "horizontal") {
            data.tabPos = data.tab.offsetLeft;
            data.tabSize = tabRect.width;
            data.tabPressPos = data.pressX - tabRect.left;
          } else {
            data.tabPos = data.tab.offsetTop;
            data.tabSize = tabRect.height;
            data.tabPressPos = data.pressY - tabRect.top;
          }
          data.tabPressOffset = {
            x: data.pressX - tabRect.left,
            y: data.pressY - tabRect.top
          };
          data.tabLayout = Private$7.snapTabLayout(tabs, this._orientation);
          data.contentRect = this.contentNode.getBoundingClientRect();
          data.override = Drag.overrideCursor("default");
          data.tab.classList.add("lm-mod-dragging");
          this.addClass("lm-mod-dragging");
          data.dragActive = true;
        }
        if (!data.detachRequested && Private$7.detachExceeded(data, event)) {
          data.detachRequested = true;
          let index2 = data.index;
          let clientX = event.clientX;
          let clientY = event.clientY;
          let tab = tabs[index2];
          let title = this._titles[index2];
          this._tabDetachRequested.emit({
            index: index2,
            title,
            tab,
            clientX,
            clientY,
            offset: data.tabPressOffset
          });
          if (data.dragAborted) {
            return;
          }
        }
        Private$7.layoutTabs(tabs, data, event, this._orientation);
      }
      /**
       * Handle the `'pointerup'` event for the document.
       */
      _evtPointerUp(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        const data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        if (!data.dragActive) {
          this._dragData = null;
          let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
          if (addButtonClicked) {
            this._addRequested.emit(void 0);
            return;
          }
          let tabs = this.contentNode.children;
          let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
            return ElementExt.hitTest(tab, event.clientX, event.clientY);
          });
          if (index2 !== data.index) {
            return;
          }
          let title = this._titles[index2];
          if (!title.closable) {
            return;
          }
          if (event.button === 1) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
          if (icon && icon.contains(event.target)) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          return;
        }
        if (event.button !== 0) {
          return;
        }
        Private$7.finalizeTabPosition(data, this._orientation);
        data.tab.classList.remove("lm-mod-dragging");
        let duration = Private$7.parseTransitionDuration(data.tab);
        setTimeout(() => {
          if (data.dragAborted) {
            return;
          }
          this._dragData = null;
          Private$7.resetTabPositions(this.contentNode.children, this._orientation);
          data.override.dispose();
          this.removeClass("lm-mod-dragging");
          let i6 = data.index;
          let j2 = data.targetIndex;
          if (j2 === -1 || i6 === j2) {
            return;
          }
          ArrayExt.move(this._titles, i6, j2);
          this._adjustCurrentForMove(i6, j2);
          this._tabMoved.emit({
            fromIndex: i6,
            toIndex: j2,
            title: this._titles[j2]
          });
          MessageLoop2.sendMessage(this, Widget2.Msg.UpdateRequest);
        }, duration);
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       */
      _releaseMouse() {
        let data = this._dragData;
        if (!data) {
          return;
        }
        this._dragData = null;
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        data.dragAborted = true;
        if (!data.dragActive) {
          return;
        }
        Private$7.resetTabPositions(this.contentNode.children, this._orientation);
        data.override.dispose();
        data.tab.classList.remove("lm-mod-dragging");
        this.removeClass("lm-mod-dragging");
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * This method accounts for the tab bar's insertion behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForInsert(i6, title) {
        let ct = this.currentTitle;
        let ci = this._currentIndex;
        let bh = this.insertBehavior;
        if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
          this._currentIndex = i6;
          this._previousTitle = ct;
          this._currentChanged.emit({
            previousIndex: ci,
            previousTitle: ct,
            currentIndex: i6,
            currentTitle: title
          });
          return;
        }
        if (ci >= i6) {
          this._currentIndex++;
        }
      }
      /**
       * Adjust the current index for a tab move operation.
       *
       * This method will not cause the actual current tab to change.
       * It silently adjusts the index to account for the given move.
       */
      _adjustCurrentForMove(i6, j2) {
        if (this._currentIndex === i6) {
          this._currentIndex = j2;
        } else if (this._currentIndex < i6 && this._currentIndex >= j2) {
          this._currentIndex++;
        } else if (this._currentIndex > i6 && this._currentIndex <= j2) {
          this._currentIndex--;
        }
      }
      /**
       * Adjust the current index for a tab remove operation.
       *
       * This method accounts for the tab bar's remove behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForRemove(i6, title) {
        let ci = this._currentIndex;
        let bh = this.removeBehavior;
        if (ci !== i6) {
          if (ci > i6) {
            this._currentIndex--;
          }
          return;
        }
        if (this._titles.length === 0) {
          this._currentIndex = -1;
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: -1,
            currentTitle: null
          });
          return;
        }
        if (bh === "select-tab-after") {
          this._currentIndex = Math.min(i6, this._titles.length - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-tab-before") {
          this._currentIndex = Math.max(0, i6 - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-previous-tab") {
          if (this._previousTitle) {
            this._currentIndex = this._titles.indexOf(this._previousTitle);
            this._previousTitle = null;
          } else {
            this._currentIndex = Math.min(i6, this._titles.length - 1);
          }
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        this._currentIndex = -1;
        this._currentChanged.emit({
          previousIndex: i6,
          previousTitle: title,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this.update();
      }
    };
    (function(TabBar6) {
      class Renderer {
        constructor() {
          this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
          this._tabID = 0;
          this._tabKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the virtual element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab.
         */
        renderTab(data) {
          let title = data.title.caption;
          let key = this.createTabKey(data);
          let id = key;
          let style = this.createTabStyle(data);
          let className = this.createTabClass(data);
          let dataset = this.createTabDataset(data);
          let aria = this.createTabARIA(data);
          if (data.title.closable) {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
          } else {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
          }
        }
        /**
         * Render the icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab icon.
         */
        renderIcon(data) {
          const { title } = data;
          let className = this.createIconClass(data);
          return h.div({ className }, title.icon, title.iconLabel);
        }
        /**
         * Render the label element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab label.
         */
        renderLabel(data) {
          return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
        }
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          return h.div({ className: "lm-TabBar-tabCloseIcon" });
        }
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        createTabKey(data) {
          let key = this._tabKeys.get(data.title);
          if (key === void 0) {
            key = `tab-key-${this._uuid}-${this._tabID++}`;
            this._tabKeys.set(data.title, key);
          }
          return key;
        }
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        createTabStyle(data) {
          return { zIndex: `${data.zIndex}` };
        }
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        createTabClass(data) {
          let name = "lm-TabBar-tab";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.title.closable) {
            name += " lm-mod-closable";
          }
          if (data.current) {
            name += " lm-mod-current";
          }
          return name;
        }
        /**
         * Create the dataset for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The dataset for the tab.
         */
        createTabDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the ARIA attributes for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The ARIA attributes for the tab.
         */
        createTabARIA(data) {
          var _a;
          return {
            role: "tab",
            "aria-selected": data.current.toString(),
            tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
          };
        }
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        createIconClass(data) {
          let name = "lm-TabBar-tabIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
      }
      Renderer._nInstance = 0;
      TabBar6.Renderer = Renderer;
      TabBar6.defaultRenderer = new Renderer();
      TabBar6.addButtonSelector = ".lm-TabBar-addButton";
    })(TabBar2 || (TabBar2 = {}));
    (function(Private22) {
      Private22.DRAG_THRESHOLD = 5;
      Private22.DETACH_THRESHOLD = 20;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.setAttribute("role", "tablist");
        content.className = "lm-TabBar-content";
        node.appendChild(content);
        let add = document.createElement("div");
        add.className = "lm-TabBar-addButton lm-mod-hidden";
        add.setAttribute("tabindex", "-1");
        add.setAttribute("role", "button");
        node.appendChild(add);
        return node;
      }
      Private22.createNode = createNode;
      function asTitle(value) {
        return value instanceof Title2 ? value : new Title2(value);
      }
      Private22.asTitle = asTitle;
      function parseTransitionDuration(tab) {
        let style = window.getComputedStyle(tab);
        return 1e3 * (parseFloat(style.transitionDuration) || 0);
      }
      Private22.parseTransitionDuration = parseTransitionDuration;
      function snapTabLayout(tabs, orientation) {
        let layout = new Array(tabs.length);
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let node = tabs[i6];
          let style = window.getComputedStyle(node);
          if (orientation === "horizontal") {
            layout[i6] = {
              pos: node.offsetLeft,
              size: node.offsetWidth,
              margin: parseFloat(style.marginLeft) || 0
            };
          } else {
            layout[i6] = {
              pos: node.offsetTop,
              size: node.offsetHeight,
              margin: parseFloat(style.marginTop) || 0
            };
          }
        }
        return layout;
      }
      Private22.snapTabLayout = snapTabLayout;
      function dragExceeded(data, event) {
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        return dx >= Private22.DRAG_THRESHOLD || dy >= Private22.DRAG_THRESHOLD;
      }
      Private22.dragExceeded = dragExceeded;
      function detachExceeded(data, event) {
        let rect = data.contentRect;
        return event.clientX < rect.left - Private22.DETACH_THRESHOLD || event.clientX >= rect.right + Private22.DETACH_THRESHOLD || event.clientY < rect.top - Private22.DETACH_THRESHOLD || event.clientY >= rect.bottom + Private22.DETACH_THRESHOLD;
      }
      Private22.detachExceeded = detachExceeded;
      function layoutTabs(tabs, data, event, orientation) {
        let pressPos;
        let localPos;
        let clientPos;
        let clientSize;
        if (orientation === "horizontal") {
          pressPos = data.pressX;
          localPos = event.clientX - data.contentRect.left;
          clientPos = event.clientX;
          clientSize = data.contentRect.width;
        } else {
          pressPos = data.pressY;
          localPos = event.clientY - data.contentRect.top;
          clientPos = event.clientY;
          clientSize = data.contentRect.height;
        }
        let targetIndex = data.index;
        let targetPos = localPos - data.tabPressPos;
        let targetEnd = targetPos + data.tabSize;
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let pxPos;
          let layout = data.tabLayout[i6];
          let threshold = layout.pos + (layout.size >> 1);
          if (i6 < data.index && targetPos < threshold) {
            pxPos = `${data.tabSize + data.tabLayout[i6 + 1].margin}px`;
            targetIndex = Math.min(targetIndex, i6);
          } else if (i6 > data.index && targetEnd > threshold) {
            pxPos = `${-data.tabSize - layout.margin}px`;
            targetIndex = Math.max(targetIndex, i6);
          } else if (i6 === data.index) {
            let ideal = clientPos - pressPos;
            let limit = clientSize - (data.tabPos + data.tabSize);
            pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;
          } else {
            pxPos = "";
          }
          if (orientation === "horizontal") {
            tabs[i6].style.left = pxPos;
          } else {
            tabs[i6].style.top = pxPos;
          }
        }
        data.targetIndex = targetIndex;
      }
      Private22.layoutTabs = layoutTabs;
      function finalizeTabPosition(data, orientation) {
        let clientSize;
        if (orientation === "horizontal") {
          clientSize = data.contentRect.width;
        } else {
          clientSize = data.contentRect.height;
        }
        let ideal;
        if (data.targetIndex === data.index) {
          ideal = 0;
        } else if (data.targetIndex > data.index) {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        } else {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos - data.tabPos;
        }
        let limit = clientSize - (data.tabPos + data.tabSize);
        let final = Math.max(-data.tabPos, Math.min(ideal, limit));
        if (orientation === "horizontal") {
          data.tab.style.left = `${final}px`;
        } else {
          data.tab.style.top = `${final}px`;
        }
      }
      Private22.finalizeTabPosition = finalizeTabPosition;
      function resetTabPositions(tabs, orientation) {
        for (const tab of tabs) {
          if (orientation === "horizontal") {
            tab.style.left = "";
          } else {
            tab.style.top = "";
          }
        }
      }
      Private22.resetTabPositions = resetTabPositions;
    })(Private$7 || (Private$7 = {}));
    DockLayout = class extends Layout {
      /**
       * Construct a new dock layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this._spacing = 4;
        this._dirty = false;
        this._root = null;
        this._box = null;
        this._items = /* @__PURE__ */ new Map();
        this.renderer = options.renderer;
        if (options.spacing !== void 0) {
          this._spacing = Utils$1.clampDimension(options.spacing);
        }
        this._document = options.document || document;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget2.HiddenMode.Display;
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       */
      dispose() {
        let widgets = this[Symbol.iterator]();
        this._items.forEach((item) => {
          item.dispose();
        });
        this._box = null;
        this._root = null;
        this._items.clear();
        for (const widget of widgets) {
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding child widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        for (const bar of this.tabBars()) {
          if (bar.titles.length > 1) {
            for (const title of bar.titles) {
              title.owner.hiddenMode = this._hiddenMode;
            }
          }
        }
      }
      /**
       * Get the inter-element spacing for the dock layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the dock layout.
       */
      set spacing(value) {
        value = Utils$1.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Whether the dock layout is empty.
       */
      get isEmpty() {
        return this._root === null;
      }
      /**
       * Create an iterator over all widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       *
       * #### Notes
       * This iterator includes the generated tab bars.
       */
      [Symbol.iterator]() {
        return this._root ? this._root.iterAllWidgets() : empty();
      }
      /**
       * Create an iterator over the user widgets in the layout.
       *
       * @returns A new iterator over the user widgets in the layout.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      widgets() {
        return this._root ? this._root.iterUserWidgets() : empty();
      }
      /**
       * Create an iterator over the selected widgets in the layout.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the layout.
       */
      selectedWidgets() {
        return this._root ? this._root.iterSelectedWidgets() : empty();
      }
      /**
       * Create an iterator over the tab bars in the layout.
       *
       * @returns A new iterator over the tab bars in the layout.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      tabBars() {
        return this._root ? this._root.iterTabBars() : empty();
      }
      /**
       * Create an iterator over the handles in the layout.
       *
       * @returns A new iterator over the handles in the layout.
       */
      handles() {
        return this._root ? this._root.iterHandles() : empty();
      }
      /**
       * Move a handle to the given offset position.
       *
       * @param handle - The handle to move.
       *
       * @param offsetX - The desired offset X position of the handle.
       *
       * @param offsetY - The desired offset Y position of the handle.
       *
       * #### Notes
       * If the given handle is not contained in the layout, this is no-op.
       *
       * The handle will be moved as close as possible to the desired
       * position without violating any of the layout constraints.
       *
       * Only one of the coordinates is used depending on the orientation
       * of the handle. This method accepts both coordinates to make it
       * easy to invoke from a mouse move event without needing to know
       * the handle orientation.
       */
      moveHandle(handle, offsetX, offsetY) {
        let hidden = handle.classList.contains("lm-mod-hidden");
        if (!this._root || hidden) {
          return;
        }
        let data = this._root.findSplitNode(handle);
        if (!data) {
          return;
        }
        let delta;
        if (data.node.orientation === "horizontal") {
          delta = offsetX - handle.offsetLeft;
        } else {
          delta = offsetY - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        data.node.holdSizes();
        BoxEngine.adjust(data.node.sizers, data.index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Save the current configuration of the dock layout.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        if (!this._root) {
          return { main: null };
        }
        this._root.holdAllSizes();
        return { main: this._root.createConfig() };
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       */
      restoreLayout(config) {
        let widgetSet = /* @__PURE__ */ new Set();
        let mainConfig;
        if (config.main) {
          mainConfig = Private$6.normalizeAreaConfig(config.main, widgetSet);
        } else {
          mainConfig = null;
        }
        let oldWidgets = this.widgets();
        let oldTabBars = this.tabBars();
        let oldHandles = this.handles();
        this._root = null;
        for (const widget of oldWidgets) {
          if (!widgetSet.has(widget)) {
            widget.parent = null;
          }
        }
        for (const tabBar of oldTabBars) {
          tabBar.dispose();
        }
        for (const handle of oldHandles) {
          if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
          }
        }
        for (const widget of widgetSet) {
          widget.parent = this.parent;
        }
        if (mainConfig) {
          this._root = Private$6.realizeAreaConfig(mainConfig, {
            // Ignoring optional `document` argument as we must reuse `this._document`
            createTabBar: (document2) => this._createTabBar(),
            createHandle: () => this._createHandle()
          }, this._document);
        } else {
          this._root = null;
        }
        if (!this.parent) {
          return;
        }
        widgetSet.forEach((widget) => {
          this.attachWidget(widget);
        });
        this.parent.fit();
      }
      /**
       * Add a widget to the dock layout.
       *
       * @param widget - The widget to add to the dock layout.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * The widget will be moved if it is already contained in the layout.
       *
       * An error will be thrown if the reference widget is invalid.
       */
      addWidget(widget, options = {}) {
        let ref = options.ref || null;
        let mode = options.mode || "tab-after";
        let refNode = null;
        if (this._root && ref) {
          refNode = this._root.findTabNode(ref);
        }
        if (ref && !refNode) {
          throw new Error("Reference widget is not in the layout.");
        }
        widget.parent = this.parent;
        switch (mode) {
          case "tab-after":
            this._insertTab(widget, ref, refNode, true);
            break;
          case "tab-before":
            this._insertTab(widget, ref, refNode, false);
            break;
          case "split-top":
            this._insertSplit(widget, ref, refNode, "vertical", false);
            break;
          case "split-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false);
            break;
          case "split-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true);
            break;
          case "split-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true);
            break;
          case "merge-top":
            this._insertSplit(widget, ref, refNode, "vertical", false, true);
            break;
          case "merge-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false, true);
            break;
          case "merge-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true, true);
            break;
          case "merge-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true, true);
            break;
        }
        if (!this.parent) {
          return;
        }
        this.attachWidget(widget);
        this.parent.fit();
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this._removeWidget(widget);
        if (!this.parent) {
          return;
        }
        this.detachWidget(widget);
        this.parent.fit();
      }
      /**
       * Find the tab area which contains the given client position.
       *
       * @param clientX - The client X position of interest.
       *
       * @param clientY - The client Y position of interest.
       *
       * @returns The geometry of the tab area at the given position, or
       *   `null` if there is no tab area at the given position.
       */
      hitTestTabAreas(clientX, clientY) {
        if (!this._root || !this.parent || !this.parent.isVisible) {
          return null;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let rect = this.parent.node.getBoundingClientRect();
        let x2 = clientX - rect.left - this._box.borderLeft;
        let y4 = clientY - rect.top - this._box.borderTop;
        let tabNode = this._root.hitTestTabNodes(x2, y4);
        if (!tabNode) {
          return null;
        }
        let { tabBar, top, left, width, height } = tabNode;
        let borderWidth = this._box.borderLeft + this._box.borderRight;
        let borderHeight = this._box.borderTop + this._box.borderBottom;
        let right = rect.width - borderWidth - (left + width);
        let bottom = rect.height - borderHeight - (top + height);
        return { tabBar, x: x2, y: y4, top, left, right, bottom, width, height };
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
        for (const handle of this.handles()) {
          this.parent.node.appendChild(handle);
        }
        this.parent.fit();
      }
      /**
       * Attach the widget to the layout parent widget.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a no-op if the widget is already attached.
       */
      attachWidget(widget) {
        if (this.parent.node === widget.node.parentNode) {
          return;
        }
        this._items.set(widget, new LayoutItem(widget));
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
      }
      /**
       * Detach the widget from the layout parent widget.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a no-op if the widget is not attached.
       */
      detachWidget(widget) {
        if (this.parent.node !== widget.node.parentNode) {
          return;
        }
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
        let item = this._items.get(widget);
        if (item) {
          this._items.delete(widget);
          item.dispose();
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Remove the specified widget from the layout structure.
       *
       * #### Notes
       * This is a no-op if the widget is not in the layout tree.
       *
       * This does not detach the widget from the parent node.
       */
      _removeWidget(widget) {
        if (!this._root) {
          return;
        }
        let tabNode = this._root.findTabNode(widget);
        if (!tabNode) {
          return;
        }
        Private$6.removeAria(widget);
        if (tabNode.tabBar.titles.length > 1) {
          tabNode.tabBar.removeTab(widget.title);
          if (this._hiddenMode === Widget2.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
            const existingWidget = tabNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget2.HiddenMode.Display;
          }
          return;
        }
        tabNode.tabBar.dispose();
        if (this._root === tabNode) {
          this._root = null;
          return;
        }
        this._root.holdAllSizes();
        let splitNode = tabNode.parent;
        tabNode.parent = null;
        let i6 = ArrayExt.removeFirstOf(splitNode.children, tabNode);
        let handle = ArrayExt.removeAt(splitNode.handles, i6);
        ArrayExt.removeAt(splitNode.sizers, i6);
        if (handle.parentNode) {
          handle.parentNode.removeChild(handle);
        }
        if (splitNode.children.length > 1) {
          splitNode.syncHandles();
          return;
        }
        let maybeParent = splitNode.parent;
        splitNode.parent = null;
        let childNode = splitNode.children[0];
        let childHandle = splitNode.handles[0];
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        if (childHandle.parentNode) {
          childHandle.parentNode.removeChild(childHandle);
        }
        if (this._root === splitNode) {
          childNode.parent = null;
          this._root = childNode;
          return;
        }
        let parentNode = maybeParent;
        let j2 = parentNode.children.indexOf(splitNode);
        if (childNode instanceof Private$6.TabLayoutNode) {
          childNode.parent = parentNode;
          parentNode.children[j2] = childNode;
          return;
        }
        let splitHandle = ArrayExt.removeAt(parentNode.handles, j2);
        ArrayExt.removeAt(parentNode.children, j2);
        ArrayExt.removeAt(parentNode.sizers, j2);
        if (splitHandle.parentNode) {
          splitHandle.parentNode.removeChild(splitHandle);
        }
        for (let i7 = 0, n5 = childNode.children.length; i7 < n5; ++i7) {
          let gChild = childNode.children[i7];
          let gHandle = childNode.handles[i7];
          let gSizer = childNode.sizers[i7];
          ArrayExt.insert(parentNode.children, j2 + i7, gChild);
          ArrayExt.insert(parentNode.handles, j2 + i7, gHandle);
          ArrayExt.insert(parentNode.sizers, j2 + i7, gSizer);
          gChild.parent = parentNode;
        }
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        parentNode.syncHandles();
      }
      /**
       * Create the tab layout node to hold the widget.
       */
      _createTabNode(widget) {
        let tabNode = new Private$6.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        Private$6.addAria(widget, tabNode.tabBar);
        return tabNode;
      }
      /**
       * Insert a widget next to an existing tab.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertTab(widget, ref, refNode, after2) {
        if (widget === ref) {
          return;
        }
        if (!this._root) {
          let tabNode = new Private$6.TabLayoutNode(this._createTabBar());
          tabNode.tabBar.addTab(widget.title);
          this._root = tabNode;
          Private$6.addAria(widget, tabNode.tabBar);
          return;
        }
        if (!refNode) {
          refNode = this._root.findFirstTabNode();
        }
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
          this._removeWidget(widget);
          widget.hide();
        }
        let index2;
        if (ref) {
          index2 = refNode.tabBar.titles.indexOf(ref.title);
        } else {
          index2 = refNode.tabBar.currentIndex;
        }
        if (this._hiddenMode === Widget2.HiddenMode.Scale) {
          if (refNode.tabBar.titles.length === 0) {
            widget.hiddenMode = Widget2.HiddenMode.Display;
          } else if (refNode.tabBar.titles.length == 1) {
            const existingWidget = refNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget2.HiddenMode.Scale;
          } else {
            widget.hiddenMode = Widget2.HiddenMode.Scale;
          }
        } else {
          widget.hiddenMode = this._hiddenMode;
        }
        refNode.tabBar.insertTab(index2 + (after2 ? 1 : 0), widget.title);
        Private$6.addAria(widget, refNode.tabBar);
      }
      /**
       * Insert a widget as a new split area.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertSplit(widget, ref, refNode, orientation, after2, merge = false) {
        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {
          return;
        }
        this._removeWidget(widget);
        if (!this._root) {
          this._root = this._createTabNode(widget);
          return;
        }
        if (!refNode || !refNode.parent) {
          let root2 = this._splitRoot(orientation);
          let i7 = after2 ? root2.children.length : 0;
          root2.normalizeSizes();
          let sizer = Private$6.createSizer(refNode ? 1 : Private$6.GOLDEN_RATIO);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(root2.children, i7, tabNode2);
          ArrayExt.insert(root2.sizers, i7, sizer);
          ArrayExt.insert(root2.handles, i7, this._createHandle());
          tabNode2.parent = root2;
          root2.normalizeSizes();
          root2.syncHandles();
          return;
        }
        let splitNode = refNode.parent;
        if (splitNode.orientation === orientation) {
          let i7 = splitNode.children.indexOf(refNode);
          if (merge) {
            let j4 = i7 + (after2 ? 1 : -1);
            let sibling = splitNode.children[j4];
            if (sibling instanceof Private$6.TabLayoutNode) {
              this._insertTab(widget, null, sibling, true);
              ++sibling.tabBar.currentIndex;
              return;
            }
          }
          splitNode.normalizeSizes();
          let s8 = splitNode.sizers[i7].sizeHint /= 2;
          let j3 = i7 + (after2 ? 1 : 0);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(splitNode.children, j3, tabNode2);
          ArrayExt.insert(splitNode.sizers, j3, Private$6.createSizer(s8));
          ArrayExt.insert(splitNode.handles, j3, this._createHandle());
          tabNode2.parent = splitNode;
          splitNode.syncHandles();
          return;
        }
        let i6 = ArrayExt.removeFirstOf(splitNode.children, refNode);
        let childNode = new Private$6.SplitLayoutNode(orientation);
        childNode.normalized = true;
        childNode.children.push(refNode);
        childNode.sizers.push(Private$6.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        let j2 = after2 ? 1 : 0;
        let tabNode = this._createTabNode(widget);
        ArrayExt.insert(childNode.children, j2, tabNode);
        ArrayExt.insert(childNode.sizers, j2, Private$6.createSizer(0.5));
        ArrayExt.insert(childNode.handles, j2, this._createHandle());
        tabNode.parent = childNode;
        childNode.syncHandles();
        ArrayExt.insert(splitNode.children, i6, childNode);
        childNode.parent = splitNode;
      }
      /**
       * Ensure the root is a split node with the given orientation.
       */
      _splitRoot(orientation) {
        let oldRoot = this._root;
        if (oldRoot instanceof Private$6.SplitLayoutNode) {
          if (oldRoot.orientation === orientation) {
            return oldRoot;
          }
        }
        let newRoot = this._root = new Private$6.SplitLayoutNode(orientation);
        if (oldRoot) {
          newRoot.children.push(oldRoot);
          newRoot.sizers.push(Private$6.createSizer(0));
          newRoot.handles.push(this._createHandle());
          oldRoot.parent = newRoot;
        }
        return newRoot;
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        if (this._root) {
          let limits = this._root.fit(this._spacing, this._items);
          minW = limits.minWidth;
          minH = limits.minHeight;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget2.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget2.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (!this._root) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let x2 = this._box.paddingTop;
        let y4 = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        this._root.update(x2, y4, width, height, this._spacing, this._items);
      }
      /**
       * Create a new tab bar for use by the dock layout.
       *
       * #### Notes
       * The tab bar will be attached to the parent if it exists.
       */
      _createTabBar() {
        let tabBar = this.renderer.createTabBar(this._document);
        tabBar.orientation = "horizontal";
        if (this.parent) {
          this.attachWidget(tabBar);
        }
        return tabBar;
      }
      /**
       * Create a new handle for the dock layout.
       *
       * #### Notes
       * The handle will be attached to the parent if it exists.
       */
      _createHandle() {
        let handle = this.renderer.createHandle();
        let style = handle.style;
        style.position = "absolute";
        style.contain = "strict";
        style.top = "0";
        style.left = "0";
        style.width = "0";
        style.height = "0";
        if (this.parent) {
          this.parent.node.appendChild(handle);
        }
        return handle;
      }
    };
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      function createSizer(hint) {
        let sizer = new BoxSizer();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
      }
      Private22.createSizer = createSizer;
      function normalizeAreaConfig(config, widgetSet) {
        let result2;
        if (config.type === "tab-area") {
          result2 = normalizeTabAreaConfig(config, widgetSet);
        } else {
          result2 = normalizeSplitAreaConfig(config, widgetSet);
        }
        return result2;
      }
      Private22.normalizeAreaConfig = normalizeAreaConfig;
      function realizeAreaConfig(config, renderer, document2) {
        let node;
        if (config.type === "tab-area") {
          node = realizeTabAreaConfig(config, renderer, document2);
        } else {
          node = realizeSplitAreaConfig(config, renderer, document2);
        }
        return node;
      }
      Private22.realizeAreaConfig = realizeAreaConfig;
      class TabLayoutNode {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        constructor(tabBar) {
          this.parent = null;
          this._top = 0;
          this._left = 0;
          this._width = 0;
          this._height = 0;
          let tabSizer = new BoxSizer();
          let widgetSizer = new BoxSizer();
          tabSizer.stretch = 0;
          widgetSizer.stretch = 1;
          this.tabBar = tabBar;
          this.sizers = [tabSizer, widgetSizer];
        }
        /**
         * The most recent value for the `top` edge of the layout box.
         */
        get top() {
          return this._top;
        }
        /**
         * The most recent value for the `left` edge of the layout box.
         */
        get left() {
          return this._left;
        }
        /**
         * The most recent value for the `width` of the layout box.
         */
        get width() {
          return this._width;
        }
        /**
         * The most recent value for the `height` of the layout box.
         */
        get height() {
          return this._height;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          yield this.tabBar;
          yield* this.iterUserWidgets();
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const title of this.tabBar.titles) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          let title = this.tabBar.currentTitle;
          if (title) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          yield this.tabBar;
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        // eslint-disable-next-line require-yield
        *iterHandles() {
          return;
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          return this;
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          if (x2 < this._left || x2 >= this._left + this._width) {
            return null;
          }
          if (y4 < this._top || y4 >= this._top + this._height) {
            return null;
          }
          return this;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let widgets = this.tabBar.titles.map((title) => title.owner);
          let currentIndex = this.tabBar.currentIndex;
          return { type: "tab-area", widgets, currentIndex };
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          return;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let minWidth = 0;
          let minHeight = 0;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          let [tabBarSizer, widgetSizer] = this.sizers;
          if (tabBarItem) {
            tabBarItem.fit();
          }
          if (widgetItem) {
            widgetItem.fit();
          }
          if (tabBarItem && !tabBarItem.isHidden) {
            minWidth = Math.max(minWidth, tabBarItem.minWidth);
            minHeight += tabBarItem.minHeight;
            tabBarSizer.minSize = tabBarItem.minHeight;
            tabBarSizer.maxSize = tabBarItem.maxHeight;
          } else {
            tabBarSizer.minSize = 0;
            tabBarSizer.maxSize = 0;
          }
          if (widgetItem && !widgetItem.isHidden) {
            minWidth = Math.max(minWidth, widgetItem.minWidth);
            minHeight += widgetItem.minHeight;
            widgetSizer.minSize = widgetItem.minHeight;
            widgetSizer.maxSize = Infinity;
          } else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = Infinity;
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          this._top = top;
          this._left = left;
          this._width = width;
          this._height = height;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          BoxEngine.calc(this.sizers, height);
          if (tabBarItem && !tabBarItem.isHidden) {
            let size5 = this.sizers[0].size;
            tabBarItem.update(left, top, width, size5);
            top += size5;
          }
          if (widgetItem && !widgetItem.isHidden) {
            let size5 = this.sizers[1].size;
            widgetItem.update(left, top, width, size5);
          }
        }
      }
      Private22.TabLayoutNode = TabLayoutNode;
      class SplitLayoutNode {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        constructor(orientation) {
          this.parent = null;
          this.normalized = false;
          this.children = [];
          this.sizers = [];
          this.handles = [];
          this.orientation = orientation;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          for (const child of this.children) {
            yield* child.iterAllWidgets();
          }
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const child of this.children) {
            yield* child.iterUserWidgets();
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          for (const child of this.children) {
            yield* child.iterSelectedWidgets();
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          for (const child of this.children) {
            yield* child.iterTabBars();
          }
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        *iterHandles() {
          yield* this.handles;
          for (const child of this.children) {
            yield* child.iterHandles();
          }
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findTabNode(widget);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          let index2 = this.handles.indexOf(handle);
          if (index2 !== -1) {
            return { index: index2, node: this };
          }
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findSplitNode(handle);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          if (this.children.length === 0) {
            return null;
          }
          return this.children[0].findFirstTabNode();
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].hitTestTabNodes(x2, y4);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let orientation = this.orientation;
          let sizes = this.createNormalizedSizes();
          let children = this.children.map((child) => child.createConfig());
          return { type: "split-area", orientation, children, sizes };
        }
        /**
         * Sync the visibility and orientation of the handles.
         */
        syncHandles() {
          this.handles.forEach((handle, i6) => {
            handle.setAttribute("data-orientation", this.orientation);
            if (i6 === this.handles.length - 1) {
              handle.classList.add("lm-mod-hidden");
            } else {
              handle.classList.remove("lm-mod-hidden");
            }
          });
        }
        /**
         * Hold the current sizes of the box sizers.
         *
         * This sets the size hint of each sizer to its current size.
         */
        holdSizes() {
          for (const sizer of this.sizers) {
            sizer.sizeHint = sizer.size;
          }
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          for (const child of this.children) {
            child.holdAllSizes();
          }
          this.holdSizes();
        }
        /**
         * Normalize the sizes of the split layout node.
         */
        normalizeSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return;
          }
          this.holdSizes();
          let sum = this.sizers.reduce((v4, sizer) => v4 + sizer.sizeHint, 0);
          if (sum === 0) {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint = 1 / n5;
            }
          } else {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint /= sum;
            }
          }
          this.normalized = true;
        }
        /**
         * Snap the normalized sizes of the split layout node.
         */
        createNormalizedSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return [];
          }
          let sizes = this.sizers.map((sizer) => sizer.size);
          let sum = sizes.reduce((v4, size5) => v4 + size5, 0);
          if (sum === 0) {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] = 1 / n5;
            }
          } else {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] /= sum;
            }
          }
          return sizes;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let minWidth = horizontal ? fixed : 0;
          let minHeight = horizontal ? 0 : fixed;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let limits = this.children[i6].fit(spacing, items);
            if (horizontal) {
              minHeight = Math.max(minHeight, limits.minHeight);
              minWidth += limits.minWidth;
              this.sizers[i6].minSize = limits.minWidth;
            } else {
              minWidth = Math.max(minWidth, limits.minWidth);
              minHeight += limits.minHeight;
              this.sizers[i6].minSize = limits.minHeight;
            }
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let space = Math.max(0, (horizontal ? width : height) - fixed);
          if (this.normalized) {
            for (const sizer of this.sizers) {
              sizer.sizeHint *= space;
            }
            this.normalized = false;
          }
          BoxEngine.calc(this.sizers, space);
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let child = this.children[i6];
            let size5 = this.sizers[i6].size;
            let handleStyle = this.handles[i6].style;
            if (horizontal) {
              child.update(left, top, size5, height, spacing, items);
              left += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${spacing}px`;
              handleStyle.height = `${height}px`;
              left += spacing;
            } else {
              child.update(left, top, width, size5, spacing, items);
              top += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${width}px`;
              handleStyle.height = `${spacing}px`;
              top += spacing;
            }
          }
        }
      }
      Private22.SplitLayoutNode = SplitLayoutNode;
      function addAria(widget, tabBar) {
        widget.node.setAttribute("role", "tabpanel");
        let renderer = tabBar.renderer;
        if (renderer instanceof TabBar2.Renderer) {
          let tabId = renderer.createTabKey({
            title: widget.title,
            current: false,
            zIndex: 0
          });
          widget.node.setAttribute("aria-labelledby", tabId);
        }
      }
      Private22.addAria = addAria;
      function removeAria(widget) {
        widget.node.removeAttribute("role");
        widget.node.removeAttribute("aria-labelledby");
      }
      Private22.removeAria = removeAria;
      function normalizeTabAreaConfig(config, widgetSet) {
        if (config.widgets.length === 0) {
          return null;
        }
        let widgets = [];
        for (const widget of config.widgets) {
          if (!widgetSet.has(widget)) {
            widgetSet.add(widget);
            widgets.push(widget);
          }
        }
        if (widgets.length === 0) {
          return null;
        }
        let index2 = config.currentIndex;
        if (index2 !== -1 && (index2 < 0 || index2 >= widgets.length)) {
          index2 = 0;
        }
        return { type: "tab-area", widgets, currentIndex: index2 };
      }
      function normalizeSplitAreaConfig(config, widgetSet) {
        let orientation = config.orientation;
        let children = [];
        let sizes = [];
        for (let i6 = 0, n5 = config.children.length; i6 < n5; ++i6) {
          let child = normalizeAreaConfig(config.children[i6], widgetSet);
          if (!child) {
            continue;
          }
          if (child.type === "tab-area" || child.orientation !== orientation) {
            children.push(child);
            sizes.push(Math.abs(config.sizes[i6] || 0));
          } else {
            children.push(...child.children);
            sizes.push(...child.sizes);
          }
        }
        if (children.length === 0) {
          return null;
        }
        if (children.length === 1) {
          return children[0];
        }
        return { type: "split-area", orientation, children, sizes };
      }
      function realizeTabAreaConfig(config, renderer, document2) {
        let tabBar = renderer.createTabBar(document2);
        for (const widget of config.widgets) {
          widget.hide();
          tabBar.addTab(widget.title);
          Private22.addAria(widget, tabBar);
        }
        tabBar.currentIndex = config.currentIndex;
        return new TabLayoutNode(tabBar);
      }
      function realizeSplitAreaConfig(config, renderer, document2) {
        let node = new SplitLayoutNode(config.orientation);
        config.children.forEach((child, i6) => {
          let childNode = realizeAreaConfig(child, renderer, document2);
          let sizer = createSizer(config.sizes[i6]);
          let handle = renderer.createHandle();
          node.children.push(childNode);
          node.handles.push(handle);
          node.sizers.push(sizer);
          childNode.parent = node;
        });
        node.syncHandles();
        node.normalizeSizes();
        return node;
      }
    })(Private$6 || (Private$6 = {}));
    DockPanel = class extends Widget2 {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this._drag = null;
        this._tabsMovable = true;
        this._tabsConstrained = false;
        this._addButtonEnabled = false;
        this._pressData = null;
        this._layoutModified = new Signal(this);
        this._addRequested = new Signal(this);
        this.addClass("lm-DockPanel");
        this._document = options.document || document;
        this._mode = options.mode || "multiple-document";
        this._renderer = options.renderer || DockPanel.defaultRenderer;
        this._edges = options.edges || Private$5.DEFAULT_EDGES;
        if (options.tabsMovable !== void 0) {
          this._tabsMovable = options.tabsMovable;
        }
        if (options.tabsConstrained !== void 0) {
          this._tabsConstrained = options.tabsConstrained;
        }
        if (options.addButtonEnabled !== void 0) {
          this._addButtonEnabled = options.addButtonEnabled;
        }
        this.dataset["mode"] = this._mode;
        let renderer = {
          createTabBar: () => this._createTabBar(),
          createHandle: () => this._createHandle()
        };
        this.layout = new DockLayout({
          document: this._document,
          renderer,
          spacing: options.spacing,
          hiddenMode: options.hiddenMode
        });
        this.overlay = options.overlay || new DockPanel.Overlay();
        this.node.appendChild(this.overlay.node);
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        this.overlay.hide(0);
        if (this._drag) {
          this._drag.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding widgets.
       */
      get hiddenMode() {
        return this.layout.hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       */
      set hiddenMode(v4) {
        this.layout.hiddenMode = v4;
      }
      /**
       * A signal emitted when the layout configuration is modified.
       *
       * #### Notes
       * This signal is emitted whenever the current layout configuration
       * may have changed.
       *
       * This signal is emitted asynchronously in a collapsed fashion, so
       * that multiple synchronous modifications results in only a single
       * emit of the signal.
       */
      get layoutModified() {
        return this._layoutModified;
      }
      /**
       * A signal emitted when the add button on a tab bar is clicked.
       *
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * The renderer used by the dock panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * Get the spacing between the widgets.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the spacing between the widgets.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * Get the mode for the dock panel.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Set the mode for the dock panel.
       *
       * #### Notes
       * Changing the mode is a destructive operation with respect to the
       * panel's layout configuration. If layout state must be preserved,
       * save the current layout config before changing the mode.
       */
      set mode(value) {
        if (this._mode === value) {
          return;
        }
        this._mode = value;
        this.dataset["mode"] = value;
        let layout = this.layout;
        switch (value) {
          case "multiple-document":
            for (const tabBar of layout.tabBars()) {
              tabBar.show();
            }
            break;
          case "single-document":
            layout.restoreLayout(Private$5.createSingleDocumentConfig(this));
            break;
          default:
            throw "unreachable";
        }
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Whether the tabs can be dragged / moved at runtime.
       */
      get tabsMovable() {
        return this._tabsMovable;
      }
      /**
       * Enable / Disable draggable / movable tabs.
       */
      set tabsMovable(value) {
        this._tabsMovable = value;
        for (const tabBar of this.tabBars()) {
          tabBar.tabsMovable = value;
        }
      }
      /**
       * Whether the tabs are constrained to their source dock panel
       */
      get tabsConstrained() {
        return this._tabsConstrained;
      }
      /**
       * Constrain/Allow tabs to be dragged outside of this dock panel
       */
      set tabsConstrained(value) {
        this._tabsConstrained = value;
      }
      /**
       * Whether the add buttons for each tab bar are enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add buttons for each tab bar are enabled.
       */
      set addButtonEnabled(value) {
        this._addButtonEnabled = value;
        for (const tabBar of this.tabBars()) {
          tabBar.addButtonEnabled = value;
        }
      }
      /**
       * Whether the dock panel is empty.
       */
      get isEmpty() {
        return this.layout.isEmpty;
      }
      /**
       * Create an iterator over the user widgets in the panel.
       *
       * @returns A new iterator over the user widgets in the panel.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      *widgets() {
        yield* this.layout.widgets();
      }
      /**
       * Create an iterator over the selected widgets in the panel.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the panel.
       */
      *selectedWidgets() {
        yield* this.layout.selectedWidgets();
      }
      /**
       * Create an iterator over the tab bars in the panel.
       *
       * @returns A new iterator over the tab bars in the panel.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      *tabBars() {
        yield* this.layout.tabBars();
      }
      /**
       * Create an iterator over the handles in the panel.
       *
       * @returns A new iterator over the handles in the panel.
       */
      *handles() {
        yield* this.layout.handles();
      }
      /**
       * Select a specific widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will make the widget the current widget in its tab area.
       */
      selectWidget(widget) {
        let tabBar = find(this.tabBars(), (bar) => {
          return bar.titles.indexOf(widget.title) !== -1;
        });
        if (!tabBar) {
          throw new Error("Widget is not contained in the dock panel.");
        }
        tabBar.currentTitle = widget.title;
      }
      /**
       * Activate a specified widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will select and activate the given widget.
       */
      activateWidget(widget) {
        this.selectWidget(widget);
        widget.activate();
      }
      /**
       * Save the current layout configuration of the dock panel.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        return this.layout.saveLayout();
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       *
       * The dock panel automatically reverts to `'multiple-document'`
       * mode when a layout config is restored.
       */
      restoreLayout(config) {
        this._mode = "multiple-document";
        this.layout.restoreLayout(config);
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop2.flush();
        }
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Add a widget to the dock panel.
       *
       * @param widget - The widget to add to the dock panel.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * If the panel is in single document mode, the options are ignored
       * and the widget is always added as tab in the hidden tab bar.
       */
      addWidget(widget, options = {}) {
        if (this._mode === "single-document") {
          this.layout.addWidget(widget);
        } else {
          this.layout.addWidget(widget, options);
        }
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       */
      processMessage(msg) {
        if (msg.type === "layout-modified") {
          this._layoutModified.emit(void 0);
        } else {
          super.processMessage(msg);
        }
      }
      /**
       * Handle the DOM events for the dock panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "lm-dragenter":
            this._evtDragEnter(event);
            break;
          case "lm-dragleave":
            this._evtDragLeave(event);
            break;
          case "lm-dragover":
            this._evtDragOver(event);
            break;
          case "lm-drop":
            this._evtDrop(event);
            break;
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("lm-dragenter", this);
        this.node.addEventListener("lm-dragleave", this);
        this.node.addEventListener("lm-dragover", this);
        this.node.addEventListener("lm-drop", this);
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("lm-dragenter", this);
        this.node.removeEventListener("lm-dragleave", this);
        this.node.removeEventListener("lm-dragover", this);
        this.node.removeEventListener("lm-drop", this);
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.addClass("lm-DockPanel-widget");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        if (Private$5.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.removeClass("lm-DockPanel-widget");
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `'lm-dragenter'` event for the dock panel.
       */
      _evtDragEnter(event) {
        if (event.mimeData.hasData("application/vnd.lumino.widget-factory")) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /**
       * Handle the `'lm-dragleave'` event for the dock panel.
       */
      _evtDragLeave(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this)
          return;
        event.stopPropagation();
        this.overlay.hide(1);
      }
      /**
       * Handle the `'lm-dragover'` event for the dock panel.
       */
      _evtDragOver(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this || this._showOverlay(event.clientX, event.clientY) === "invalid") {
          event.dropAction = "none";
        } else {
          event.stopPropagation();
          event.dropAction = event.proposedAction;
        }
      }
      /**
       * Handle the `'lm-drop'` event for the dock panel.
       */
      _evtDrop(event) {
        event.preventDefault();
        this.overlay.hide(0);
        if (event.proposedAction === "none") {
          event.dropAction = "none";
          return;
        }
        let { clientX, clientY } = event;
        let { zone, target } = Private$5.findDropTarget(this, clientX, clientY, this._edges);
        if (this._tabsConstrained && event.source !== this || zone === "invalid") {
          event.dropAction = "none";
          return;
        }
        let mimeData = event.mimeData;
        let factory = mimeData.getData("application/vnd.lumino.widget-factory");
        if (typeof factory !== "function") {
          event.dropAction = "none";
          return;
        }
        let widget = factory();
        if (!(widget instanceof Widget2)) {
          event.dropAction = "none";
          return;
        }
        if (widget.contains(this)) {
          event.dropAction = "none";
          return;
        }
        let ref = target ? Private$5.getDropRef(target.tabBar) : null;
        switch (zone) {
          case "root-all":
            this.addWidget(widget);
            break;
          case "root-top":
            this.addWidget(widget, { mode: "split-top" });
            break;
          case "root-left":
            this.addWidget(widget, { mode: "split-left" });
            break;
          case "root-right":
            this.addWidget(widget, { mode: "split-right" });
            break;
          case "root-bottom":
            this.addWidget(widget, { mode: "split-bottom" });
            break;
          case "widget-all":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          case "widget-top":
            this.addWidget(widget, { mode: "split-top", ref });
            break;
          case "widget-left":
            this.addWidget(widget, { mode: "split-left", ref });
            break;
          case "widget-right":
            this.addWidget(widget, { mode: "split-right", ref });
            break;
          case "widget-bottom":
            this.addWidget(widget, { mode: "split-bottom", ref });
            break;
          case "widget-tab":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          default:
            throw "unreachable";
        }
        event.dropAction = event.proposedAction;
        event.stopPropagation();
        this.activateWidget(widget);
      }
      /**
       * Handle the `'keydown'` event for the dock panel.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this._releaseMouse();
          MessageLoop2.postMessage(this, Private$5.LayoutModified);
        }
      }
      /**
       * Handle the `'pointerdown'` event for the dock panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let target = event.target;
        let handle = find(layout.handles(), (handle2) => handle2.contains(target));
        if (!handle) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._document.addEventListener("keydown", this, true);
        this._document.addEventListener("pointerup", this, true);
        this._document.addEventListener("pointermove", this, true);
        this._document.addEventListener("contextmenu", this, true);
        let rect = handle.getBoundingClientRect();
        let deltaX = event.clientX - rect.left;
        let deltaY = event.clientY - rect.top;
        let style = window.getComputedStyle(handle);
        let override = Drag.overrideCursor(style.cursor, this._document);
        this._pressData = { handle, deltaX, deltaY, override };
      }
      /**
       * Handle the `'pointermove'` event for the dock panel.
       */
      _evtPointerMove(event) {
        if (!this._pressData) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let rect = this.node.getBoundingClientRect();
        let xPos = event.clientX - rect.left - this._pressData.deltaX;
        let yPos = event.clientY - rect.top - this._pressData.deltaY;
        let layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
      }
      /**
       * Handle the `'pointerup'` event for the dock panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Release the mouse grab for the dock panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._document.removeEventListener("keydown", this, true);
        this._document.removeEventListener("pointerup", this, true);
        this._document.removeEventListener("pointermove", this, true);
        this._document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Show the overlay indicator at the given client position.
       *
       * Returns the drop zone at the specified client position.
       *
       * #### Notes
       * If the position is not over a valid zone, the overlay is hidden.
       */
      _showOverlay(clientX, clientY) {
        let { zone, target } = Private$5.findDropTarget(this, clientX, clientY, this._edges);
        if (zone === "invalid") {
          this.overlay.hide(100);
          return zone;
        }
        let top;
        let left;
        let right;
        let bottom;
        let box = ElementExt.boxSizing(this.node);
        let rect = this.node.getBoundingClientRect();
        switch (zone) {
          case "root-all":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-top":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = rect.height * Private$5.GOLDEN_RATIO;
            break;
          case "root-left":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = rect.width * Private$5.GOLDEN_RATIO;
            bottom = box.paddingBottom;
            break;
          case "root-right":
            top = box.paddingTop;
            left = rect.width * Private$5.GOLDEN_RATIO;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-bottom":
            top = rect.height * Private$5.GOLDEN_RATIO;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "widget-all":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-top":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height / 2;
            break;
          case "widget-left":
            top = target.top;
            left = target.left;
            right = target.right + target.width / 2;
            bottom = target.bottom;
            break;
          case "widget-right":
            top = target.top;
            left = target.left + target.width / 2;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-bottom":
            top = target.top + target.height / 2;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-tab": {
            const tabHeight = target.tabBar.node.getBoundingClientRect().height;
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height - tabHeight;
            break;
          }
          default:
            throw "unreachable";
        }
        this.overlay.show({ top, left, right, bottom });
        return zone;
      }
      /**
       * Create a new tab bar for use by the panel.
       */
      _createTabBar() {
        let tabBar = this._renderer.createTabBar(this._document);
        Private$5.isGeneratedTabBarProperty.set(tabBar, true);
        if (this._mode === "single-document") {
          tabBar.hide();
        }
        tabBar.tabsMovable = this._tabsMovable;
        tabBar.allowDeselect = false;
        tabBar.addButtonEnabled = this._addButtonEnabled;
        tabBar.removeBehavior = "select-previous-tab";
        tabBar.insertBehavior = "select-tab-if-needed";
        tabBar.tabMoved.connect(this._onTabMoved, this);
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        tabBar.addRequested.connect(this._onTabAddRequested, this);
        return tabBar;
      }
      /**
       * Create a new handle for use by the panel.
       */
      _createHandle() {
        return this._renderer.createHandle();
      }
      /**
       * Handle the `tabMoved` signal from a tab bar.
       */
      _onTabMoved() {
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `currentChanged` signal from a tab bar.
       */
      _onCurrentChanged(sender, args) {
        let { previousTitle, currentTitle } = args;
        if (previousTitle) {
          previousTitle.owner.hide();
        }
        if (currentTitle) {
          currentTitle.owner.show();
        }
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop2.flush();
        }
        MessageLoop2.postMessage(this, Private$5.LayoutModified);
      }
      /**
       * Handle the `addRequested` signal from a tab bar.
       */
      _onTabAddRequested(sender) {
        this._addRequested.emit(sender);
      }
      /**
       * Handle the `tabActivateRequested` signal from a tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from a tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabDetachRequested` signal from a tab bar.
       */
      _onTabDetachRequested(sender, args) {
        if (this._drag) {
          return;
        }
        sender.releaseMouse();
        let { title, tab, clientX, clientY, offset: offset4 } = args;
        let mimeData = new import_coreutils.MimeData();
        let factory = () => title.owner;
        mimeData.setData("application/vnd.lumino.widget-factory", factory);
        let dragImage = tab.cloneNode(true);
        if (offset4) {
          dragImage.style.top = `-${offset4.y}px`;
          dragImage.style.left = `-${offset4.x}px`;
        }
        this._drag = new Drag({
          document: this._document,
          mimeData,
          dragImage,
          proposedAction: "move",
          supportedActions: "move",
          source: this
        });
        tab.classList.add("lm-mod-hidden");
        let cleanup = () => {
          this._drag = null;
          tab.classList.remove("lm-mod-hidden");
        };
        this._drag.start(clientX, clientY).then(cleanup);
      }
    };
    (function(DockPanel5) {
      class Overlay2 {
        /**
         * Construct a new overlay.
         */
        constructor() {
          this._timer = -1;
          this._hidden = true;
          this.node = document.createElement("div");
          this.node.classList.add("lm-DockPanel-overlay");
          this.node.classList.add("lm-mod-hidden");
          this.node.style.position = "absolute";
          this.node.style.contain = "strict";
        }
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo) {
          let style = this.node.style;
          style.top = `${geo.top}px`;
          style.left = `${geo.left}px`;
          style.right = `${geo.right}px`;
          style.bottom = `${geo.bottom}px`;
          clearTimeout(this._timer);
          this._timer = -1;
          if (!this._hidden) {
            return;
          }
          this._hidden = false;
          this.node.classList.remove("lm-mod-hidden");
        }
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay) {
          if (this._hidden) {
            return;
          }
          if (delay <= 0) {
            clearTimeout(this._timer);
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
            return;
          }
          if (this._timer !== -1) {
            return;
          }
          this._timer = window.setTimeout(() => {
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
          }, delay);
        }
      }
      DockPanel5.Overlay = Overlay2;
      class Renderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(document2) {
          let bar = new TabBar2({ document: document2 });
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-DockPanel-handle";
          return handle;
        }
      }
      DockPanel5.Renderer = Renderer;
      DockPanel5.defaultRenderer = new Renderer();
    })(DockPanel || (DockPanel = {}));
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      Private22.DEFAULT_EDGES = {
        /**
         * The size of the top edge dock zone for the root panel, in pixels.
         * This is different from the others to distinguish between the top
         * tab bar and the top root zone.
         */
        top: 12,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        right: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        bottom: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        left: 40
      };
      Private22.LayoutModified = new ConflatableMessage("layout-modified");
      Private22.isGeneratedTabBarProperty = new AttachedProperty({
        name: "isGeneratedTabBar",
        create: () => false
      });
      function createSingleDocumentConfig(panel) {
        if (panel.isEmpty) {
          return { main: null };
        }
        let widgets = Array.from(panel.widgets());
        let selected = panel.selectedWidgets().next().value;
        let currentIndex = selected ? widgets.indexOf(selected) : -1;
        return { main: { type: "tab-area", widgets, currentIndex } };
      }
      Private22.createSingleDocumentConfig = createSingleDocumentConfig;
      function findDropTarget(panel, clientX, clientY, edges) {
        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
          return { zone: "invalid", target: null };
        }
        let layout = panel.layout;
        if (layout.isEmpty) {
          return { zone: "root-all", target: null };
        }
        if (panel.mode === "multiple-document") {
          let panelRect = panel.node.getBoundingClientRect();
          let pl = clientX - panelRect.left + 1;
          let pt = clientY - panelRect.top + 1;
          let pr = panelRect.right - clientX;
          let pb = panelRect.bottom - clientY;
          let pd = Math.min(pt, pr, pb, pl);
          switch (pd) {
            case pt:
              if (pt < edges.top) {
                return { zone: "root-top", target: null };
              }
              break;
            case pr:
              if (pr < edges.right) {
                return { zone: "root-right", target: null };
              }
              break;
            case pb:
              if (pb < edges.bottom) {
                return { zone: "root-bottom", target: null };
              }
              break;
            case pl:
              if (pl < edges.left) {
                return { zone: "root-left", target: null };
              }
              break;
            default:
              throw "unreachable";
          }
        }
        let target = layout.hitTestTabAreas(clientX, clientY);
        if (!target) {
          return { zone: "invalid", target: null };
        }
        if (panel.mode === "single-document") {
          return { zone: "widget-all", target };
        }
        let al = target.x - target.left + 1;
        let at = target.y - target.top + 1;
        let ar = target.left + target.width - target.x;
        let ab = target.top + target.height - target.y;
        const tabHeight = target.tabBar.node.getBoundingClientRect().height;
        if (at < tabHeight) {
          return { zone: "widget-tab", target };
        }
        let rx = Math.round(target.width / 3);
        let ry = Math.round(target.height / 3);
        if (al > rx && ar > rx && at > ry && ab > ry) {
          return { zone: "widget-all", target };
        }
        al /= rx;
        at /= ry;
        ar /= rx;
        ab /= ry;
        let ad = Math.min(al, at, ar, ab);
        let zone;
        switch (ad) {
          case al:
            zone = "widget-left";
            break;
          case at:
            zone = "widget-top";
            break;
          case ar:
            zone = "widget-right";
            break;
          case ab:
            zone = "widget-bottom";
            break;
          default:
            throw "unreachable";
        }
        return { zone, target };
      }
      Private22.findDropTarget = findDropTarget;
      function getDropRef(tabBar) {
        if (tabBar.titles.length === 0) {
          return null;
        }
        if (tabBar.currentTitle) {
          return tabBar.currentTitle.owner;
        }
        return tabBar.titles[tabBar.titles.length - 1].owner;
      }
      Private22.getDropRef = getDropRef;
    })(Private$5 || (Private$5 = {}));
    GridLayout = class extends Layout {
      /**
       * Construct a new grid layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._rowSpacing = 4;
        this._columnSpacing = 4;
        this._items = [];
        this._rowStarts = [];
        this._columnStarts = [];
        this._rowSizers = [new BoxSizer()];
        this._columnSizers = [new BoxSizer()];
        this._box = null;
        if (options.rowCount !== void 0) {
          Private$4.reallocSizers(this._rowSizers, options.rowCount);
        }
        if (options.columnCount !== void 0) {
          Private$4.reallocSizers(this._columnSizers, options.columnCount);
        }
        if (options.rowSpacing !== void 0) {
          this._rowSpacing = Private$4.clampValue(options.rowSpacing);
        }
        if (options.columnSpacing !== void 0) {
          this._columnSpacing = Private$4.clampValue(options.columnSpacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          let widget = item.widget;
          item.dispose();
          widget.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._rowStarts.length = 0;
        this._rowSizers.length = 0;
        this._columnStarts.length = 0;
        this._columnSizers.length = 0;
        super.dispose();
      }
      /**
       * Get the number of rows in the layout.
       */
      get rowCount() {
        return this._rowSizers.length;
      }
      /**
       * Set the number of rows in the layout.
       *
       * #### Notes
       * The minimum row count is `1`.
       */
      set rowCount(value) {
        if (value === this.rowCount) {
          return;
        }
        Private$4.reallocSizers(this._rowSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the number of columns in the layout.
       */
      get columnCount() {
        return this._columnSizers.length;
      }
      /**
       * Set the number of columns in the layout.
       *
       * #### Notes
       * The minimum column count is `1`.
       */
      set columnCount(value) {
        if (value === this.columnCount) {
          return;
        }
        Private$4.reallocSizers(this._columnSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the row spacing for the layout.
       */
      get rowSpacing() {
        return this._rowSpacing;
      }
      /**
       * Set the row spacing for the layout.
       */
      set rowSpacing(value) {
        value = Private$4.clampValue(value);
        if (this._rowSpacing === value) {
          return;
        }
        this._rowSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the column spacing for the layout.
       */
      get columnSpacing() {
        return this._columnSpacing;
      }
      /**
       * Set the col spacing for the layout.
       */
      set columnSpacing(value) {
        value = Private$4.clampValue(value);
        if (this._columnSpacing === value) {
          return;
        }
        this._columnSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @returns The stretch factor for the row.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      rowStretch(index2) {
        let sizer = this._rowSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @param value - The stretch factor for the row.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setRowStretch(index2, value) {
        let sizer = this._rowSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$4.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Get the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @returns The stretch factor for the column.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      columnStretch(index2) {
        let sizer = this._columnSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @param value - The stretch factor for the column.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setColumnStretch(index2, value) {
        let sizer = this._columnSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$4.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        for (const item of this._items) {
          yield item.widget;
        }
      }
      /**
       * Add a widget to the grid layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, this is no-op.
       */
      addWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 !== -1) {
          return;
        }
        this._items.push(new LayoutItem(widget));
        if (this.parent) {
          this.attachWidget(widget);
        }
      }
      /**
       * Remove a widget from the grid layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 === -1) {
          return;
        }
        let item = ArrayExt.removeAt(this._items, i6);
        if (this.parent) {
          this.detachWidget(widget);
        }
        item.dispose();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowSizers[i6].minSize = 0;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnSizers[i6].minSize = 0;
        }
        let items = this._items.filter((it) => !it.isHidden);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          items[i6].fit();
        }
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        items.sort(Private$4.rowSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          Private$4.distributeMin(this._rowSizers, r1, r22, item.minHeight);
        }
        items.sort(Private$4.columnSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout.getCellConfig(item.widget);
          let c1 = Math.min(config.column, maxCol);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          Private$4.distributeMin(this._columnSizers, c1, c22, item.minWidth);
        }
        if (this.fitPolicy === "set-no-constraint") {
          MessageLoop2.sendMessage(this.parent, Widget2.Msg.UpdateRequest);
          return;
        }
        let minH = maxRow * this._rowSpacing;
        let minW = maxCol * this._columnSpacing;
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          minH += this._rowSizers[i6].minSize;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          minW += this._columnSizers[i6].minSize;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget2.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget2.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        let fixedRowSpace = maxRow * this._rowSpacing;
        let fixedColSpace = maxCol * this._columnSpacing;
        BoxEngine.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
        BoxEngine.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
        for (let i6 = 0, pos = top, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowStarts[i6] = pos;
          pos += this._rowSizers[i6].size + this._rowSpacing;
        }
        for (let i6 = 0, pos = left, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnStarts[i6] = pos;
          pos += this._columnSizers[i6].size + this._columnSpacing;
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let config = GridLayout.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let c1 = Math.min(config.column, maxCol);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          let x2 = this._columnStarts[c1];
          let y4 = this._rowStarts[r1];
          let w3 = this._columnStarts[c22] + this._columnSizers[c22].size - x2;
          let h4 = this._rowStarts[r22] + this._rowSizers[r22].size - y4;
          item.update(x2, y4, w3, h4);
        }
      }
    };
    (function(GridLayout5) {
      function getCellConfig(widget) {
        return Private$4.cellConfigProperty.get(widget);
      }
      GridLayout5.getCellConfig = getCellConfig;
      function setCellConfig(widget, value) {
        Private$4.cellConfigProperty.set(widget, Private$4.normalizeConfig(value));
      }
      GridLayout5.setCellConfig = setCellConfig;
    })(GridLayout || (GridLayout = {}));
    (function(Private22) {
      Private22.cellConfigProperty = new AttachedProperty({
        name: "cellConfig",
        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
        changed: onChildCellConfigChanged
      });
      function normalizeConfig(config) {
        let row = Math.max(0, Math.floor(config.row || 0));
        let column = Math.max(0, Math.floor(config.column || 0));
        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));
        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));
        return { row, column, rowSpan, columnSpan };
      }
      Private22.normalizeConfig = normalizeConfig;
      function clampValue(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampValue = clampValue;
      function rowSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.rowSpan - c22.rowSpan;
      }
      Private22.rowSpanCmp = rowSpanCmp;
      function columnSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.columnSpan - c22.columnSpan;
      }
      Private22.columnSpanCmp = columnSpanCmp;
      function reallocSizers(sizers, count3) {
        count3 = Math.max(1, Math.floor(count3));
        while (sizers.length < count3) {
          sizers.push(new BoxSizer());
        }
        if (sizers.length > count3) {
          sizers.length = count3;
        }
      }
      Private22.reallocSizers = reallocSizers;
      function distributeMin(sizers, i1, i22, minSize) {
        if (i22 < i1) {
          return;
        }
        if (i1 === i22) {
          let sizer = sizers[i1];
          sizer.minSize = Math.max(sizer.minSize, minSize);
          return;
        }
        let totalMin = 0;
        for (let i6 = i1; i6 <= i22; ++i6) {
          totalMin += sizers[i6].minSize;
        }
        if (totalMin >= minSize) {
          return;
        }
        let portion = (minSize - totalMin) / (i22 - i1 + 1);
        for (let i6 = i1; i6 <= i22; ++i6) {
          sizers[i6].minSize += portion;
        }
      }
      Private22.distributeMin = distributeMin;
      function onChildCellConfigChanged(child) {
        if (child.parent && child.parent.layout instanceof GridLayout) {
          child.parent.fit();
        }
      }
    })(Private$4 || (Private$4 = {}));
    MenuBar = class extends Widget2 {
      /**
       * Construct a new menu bar.
       *
       * @param options - The options for initializing the menu bar.
       */
      constructor(options = {}) {
        super({ node: Private$3.createNode() });
        this._activeIndex = -1;
        this._tabFocusIndex = 0;
        this._menus = [];
        this._childMenu = null;
        this._overflowMenu = null;
        this._menuItemSizes = [];
        this._overflowIndex = -1;
        this.addClass("lm-MenuBar");
        this.setFlag(Widget2.Flag.DisallowLayout);
        this.renderer = options.renderer || MenuBar.defaultRenderer;
        this._forceItemsPosition = options.forceItemsPosition || {
          forceX: true,
          forceY: true
        };
        this._overflowMenuOptions = options.overflowMenuOptions || {
          isVisible: true
        };
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._closeChildMenu();
        this._menus.length = 0;
        super.dispose();
      }
      /**
       * The child menu of the menu bar.
       *
       * #### Notes
       * This will be `null` if the menu bar does not have an open menu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The overflow index of the menu bar.
       */
      get overflowIndex() {
        return this._overflowIndex;
      }
      /**
       * The overflow menu of the menu bar.
       */
      get overflowMenu() {
        return this._overflowMenu;
      }
      /**
       * Get the menu bar content node.
       *
       * #### Notes
       * This is the node which holds the menu title nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-MenuBar-content")[0];
      }
      /**
       * Get the currently active menu.
       */
      get activeMenu() {
        return this._menus[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu.
       *
       * #### Notes
       * If the menu does not exist, the menu will be set to `null`.
       */
      set activeMenu(value) {
        this.activeIndex = value ? this._menus.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu.
       *
       * #### Notes
       * This will be `-1` if no menu is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu.
       *
       * #### Notes
       * If the menu cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._menus.length) {
          value = -1;
        }
        if (value > -1 && this._menus[value].items.length === 0) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        this.update();
      }
      /**
       * A read-only array of the menus in the menu bar.
       */
      get menus() {
        return this._menus;
      }
      /**
       * Open the active menu and activate its first menu item.
       *
       * #### Notes
       * If there is no active menu, this is a no-op.
       */
      openActiveMenu() {
        if (this._activeIndex === -1) {
          return;
        }
        this._openChildMenu();
        if (this._childMenu) {
          this._childMenu.activeIndex = -1;
          this._childMenu.activateNextItem();
        }
      }
      /**
       * Add a menu to the end of the menu bar.
       *
       * @param menu - The menu to add to the menu bar.
       *
       * #### Notes
       * If the menu is already added to the menu bar, it will be moved.
       */
      addMenu(menu, update = true) {
        this.insertMenu(this._menus.length, menu, update);
      }
      /**
       * Insert a menu into the menu bar at the specified index.
       *
       * @param index - The index at which to insert the menu.
       *
       * @param menu - The menu to insert into the menu bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the menus.
       *
       * If the menu is already added to the menu bar, it will be moved.
       */
      insertMenu(index2, menu, update = true) {
        this._closeChildMenu();
        let i6 = this._menus.indexOf(menu);
        let j2 = Math.max(0, Math.min(index2, this._menus.length));
        if (i6 === -1) {
          ArrayExt.insert(this._menus, j2, menu);
          menu.addClass("lm-MenuBar-menu");
          menu.aboutToClose.connect(this._onMenuAboutToClose, this);
          menu.menuRequested.connect(this._onMenuMenuRequested, this);
          menu.title.changed.connect(this._onTitleChanged, this);
          if (update) {
            this.update();
          }
          return;
        }
        if (j2 === this._menus.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._menus, i6, j2);
        if (update) {
          this.update();
        }
      }
      /**
       * Remove a menu from the menu bar.
       *
       * @param menu - The menu to remove from the menu bar.
       *
       * #### Notes
       * This is a no-op if the menu is not in the menu bar.
       */
      removeMenu(menu, update = true) {
        this.removeMenuAt(this._menus.indexOf(menu), update);
      }
      /**
       * Remove the menu at a given index from the menu bar.
       *
       * @param index - The index of the menu to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeMenuAt(index2, update = true) {
        this._closeChildMenu();
        let menu = ArrayExt.removeAt(this._menus, index2);
        if (!menu) {
          return;
        }
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        menu.removeClass("lm-MenuBar-menu");
        if (update) {
          this.update();
        }
      }
      /**
       * Remove all menus from the menu bar.
       */
      clearMenus() {
        if (this._menus.length === 0) {
          return;
        }
        this._closeChildMenu();
        for (let menu of this._menus) {
          menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
          menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
          menu.title.changed.disconnect(this._onTitleChanged, this);
          menu.removeClass("lm-MenuBar-menu");
        }
        this._menus.length = 0;
        this.update();
      }
      /**
       * Handle the DOM events for the menu bar.
       *
       * @param event - The DOM event sent to the menu bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu bar's DOM nodes. It
       * should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "mousemove":
          case "mouseleave":
            this._evtMouseMove(event);
            break;
          case "focusout":
            this._evtFocusOut(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mousedown", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("focusout", this);
        this.node.addEventListener("contextmenu", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mousedown", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("focusout", this);
        this.node.removeEventListener("contextmenu", this);
        this._closeChildMenu();
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this._focusItemAt(0);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        this.update();
        super.onResize(msg);
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let menus = this._menus;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
        let totalMenuSize = 0;
        let isVisible2 = false;
        length = this._overflowMenu !== null ? length - 1 : length;
        let content = new Array(length);
        for (let i6 = 0; i6 < length; ++i6) {
          content[i6] = renderer.renderItem({
            title: menus[i6].title,
            active: i6 === activeIndex,
            tabbable: i6 === tabFocusIndex,
            disabled: menus[i6].items.length === 0,
            onfocus: () => {
              this._tabFocusIndex = i6;
              this.activeIndex = i6;
            }
          });
          totalMenuSize += this._menuItemSizes[i6];
          if (menus[i6].title.label === this._overflowMenuOptions.title) {
            isVisible2 = true;
            length--;
          }
        }
        if (this._overflowMenuOptions.isVisible) {
          if (this._overflowIndex > -1 && !isVisible2) {
            if (this._overflowMenu === null) {
              const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
              this._overflowMenu = new Menu({ commands: new CommandRegistry() });
              this._overflowMenu.title.label = overflowMenuTitle;
              this._overflowMenu.title.mnemonic = 0;
              this.addMenu(this._overflowMenu, false);
            }
            for (let i6 = menus.length - 2; i6 >= length; i6--) {
              const submenu = this.menus[i6];
              submenu.title.mnemonic = 0;
              this._overflowMenu.insertItem(0, {
                type: "submenu",
                submenu
              });
              this.removeMenu(submenu, false);
            }
            content[length] = renderer.renderItem({
              title: this._overflowMenu.title,
              active: length === activeIndex && menus[length].items.length !== 0,
              tabbable: length === tabFocusIndex,
              disabled: menus[length].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length;
                this.activeIndex = length;
              }
            });
            length++;
          } else if (this._overflowMenu !== null) {
            let overflowMenuItems = this._overflowMenu.items;
            let screenSize = this.node.offsetWidth;
            let n5 = this._overflowMenu.items.length;
            for (let i6 = 0; i6 < n5; ++i6) {
              let index2 = menus.length - 1 - i6;
              if (screenSize - totalMenuSize > this._menuItemSizes[index2]) {
                let menu = overflowMenuItems[0].submenu;
                this._overflowMenu.removeItemAt(0);
                this.insertMenu(length, menu, false);
                content[length] = renderer.renderItem({
                  title: menu.title,
                  active: false,
                  tabbable: length === tabFocusIndex,
                  disabled: menus[length].items.length === 0,
                  onfocus: () => {
                    this._tabFocusIndex = length;
                    this.activeIndex = length;
                  }
                });
                length++;
              }
            }
            if (this._overflowMenu.items.length === 0) {
              this.removeMenu(this._overflowMenu, false);
              content.pop();
              this._overflowMenu = null;
              this._overflowIndex = -1;
            }
          }
        }
        VirtualDOM.render(content, this.contentNode);
        this._updateOverflowIndex();
      }
      /**
       * Calculate and update the current overflow index.
       */
      _updateOverflowIndex() {
        if (!this._overflowMenuOptions.isVisible) {
          return;
        }
        const itemMenus = this.contentNode.childNodes;
        let screenSize = this.node.offsetWidth;
        let totalMenuSize = 0;
        let index2 = -1;
        let n5 = itemMenus.length;
        if (this._menuItemSizes.length == 0) {
          for (let i6 = 0; i6 < n5; i6++) {
            let item = itemMenus[i6];
            totalMenuSize += item.offsetWidth;
            this._menuItemSizes.push(item.offsetWidth);
            if (totalMenuSize > screenSize && index2 === -1) {
              index2 = i6;
            }
          }
        } else {
          for (let i6 = 0; i6 < this._menuItemSizes.length; i6++) {
            totalMenuSize += this._menuItemSizes[i6];
            if (totalMenuSize > screenSize) {
              index2 = i6;
              break;
            }
          }
        }
        this._overflowIndex = index2;
      }
      /**
       * Handle the `'keydown'` event for the menu bar.
       *
       * #### Notes
       * All keys are trapped except the tab key that is ignored.
       */
      _evtKeyDown(event) {
        let kc = event.keyCode;
        if (kc === 9) {
          this.activeIndex = -1;
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
          this.activeIndex = this._tabFocusIndex;
          if (this.activeIndex !== this._tabFocusIndex) {
            return;
          }
          this.openActiveMenu();
          return;
        }
        if (kc === 27) {
          this._closeChildMenu();
          this._focusItemAt(this.activeIndex);
          return;
        }
        if (kc === 37 || kc === 39) {
          let direction = kc === 37 ? -1 : 1;
          let start2 = this._tabFocusIndex + direction;
          let n5 = this._menus.length;
          for (let i6 = 0; i6 < n5; i6++) {
            let index2 = (n5 + start2 + direction * i6) % n5;
            if (this._menus[index2].items.length) {
              this._focusItemAt(index2);
              return;
            }
          }
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$3.findMnemonic(this._menus, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.openActiveMenu();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
          this._focusItemAt(this.activeIndex);
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
          this._focusItemAt(this.activeIndex);
        }
      }
      /**
       * Handle the `'mousedown'` event for the menu bar.
       */
      _evtMouseDown(event) {
        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {
          return;
        }
        event.stopPropagation();
        event.stopImmediatePropagation();
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          this._closeChildMenu();
          return;
        }
        if (event.button !== 0) {
          return;
        }
        if (this._childMenu) {
          this._closeChildMenu();
          this.activeIndex = index2;
        } else {
          event.preventDefault();
          const position = this._positionForMenu(index2);
          Menu.saveWindowData();
          this.activeIndex = index2;
          this._openChildMenu(position);
        }
      }
      /**
       * Handle the `'mousemove'` event for the menu bar.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        if (index2 === -1 && this._childMenu) {
          return;
        }
        const position = index2 >= 0 && this._childMenu ? this._positionForMenu(index2) : null;
        Menu.saveWindowData();
        this.activeIndex = index2;
        if (position) {
          this._openChildMenu(position);
        }
      }
      /**
       * Find initial position for the menu based on menubar item position.
       *
       * NOTE: this should be called before updating active index to avoid
       * an additional layout and style invalidation as changing active
       * index modifies DOM.
       */
      _positionForMenu(index2) {
        let itemNode = this.contentNode.children[index2];
        let { left, bottom } = itemNode.getBoundingClientRect();
        return {
          top: bottom,
          left
        };
      }
      /**
       * Handle the `'focusout'` event for the menu bar.
       */
      _evtFocusOut(event) {
        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {
          this.activeIndex = -1;
        }
      }
      /**
       * Focus an item in the menu bar.
       *
       * #### Notes
       * Does not open the associated menu.
       */
      _focusItemAt(index2) {
        const itemNode = this.contentNode.childNodes[index2];
        if (itemNode) {
          itemNode.focus();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if there is no active menu.
       */
      _openChildMenu(options = {}) {
        let newMenu = this.activeMenu;
        if (!newMenu) {
          this._closeChildMenu();
          return;
        }
        let oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
          return;
        }
        this._childMenu = newMenu;
        if (oldMenu) {
          oldMenu.close();
        } else {
          document.addEventListener("mousedown", this, true);
        }
        this._tabFocusIndex = this.activeIndex;
        MessageLoop2.sendMessage(this, Widget2.Msg.UpdateRequest);
        let { left, top } = options;
        if (typeof left === "undefined" || typeof top === "undefined") {
          ({ left, top } = this._positionForMenu(this._activeIndex));
        }
        if (!oldMenu) {
          this.addClass("lm-mod-active");
        }
        if (newMenu.items.length > 0) {
          newMenu.open(left, top, this._forceItemsPosition);
        }
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (!this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        let menu = this._childMenu;
        this._childMenu = null;
        menu.close();
        this.activeIndex = -1;
      }
      /**
       * Handle the `aboutToClose` signal of a menu.
       */
      _onMenuAboutToClose(sender) {
        if (sender !== this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        this._childMenu = null;
        this.activeIndex = -1;
      }
      /**
       * Handle the `menuRequested` signal of a child menu.
       */
      _onMenuMenuRequested(sender, args) {
        if (sender !== this._childMenu) {
          return;
        }
        let i6 = this._activeIndex;
        let n5 = this._menus.length;
        switch (args) {
          case "next":
            this.activeIndex = i6 === n5 - 1 ? 0 : i6 + 1;
            break;
          case "previous":
            this.activeIndex = i6 === 0 ? n5 - 1 : i6 - 1;
            break;
        }
        this.openActiveMenu();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged() {
        this.update();
      }
    };
    (function(MenuBar5) {
      class Renderer {
        /**
         * Render the virtual element for a menu bar item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data));
        }
        /**
         * Render the icon element for a menu bar item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.title.icon, data.title.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-MenuBar-itemLabel" }, content);
        }
        /**
         * Create the class name for the menu bar item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-MenuBar-item";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.active && !data.disabled) {
            name += " lm-mod-active";
          }
          return name;
        }
        /**
         * Create the dataset for a menu bar item.
         *
         * @param data - The data to use for the item.
         *
         * @returns The dataset for the menu bar item.
         */
        createItemDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the aria attributes for menu bar item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          return {
            role: "menuitem",
            "aria-haspopup": "true",
            "aria-disabled": data.disabled ? "true" : "false"
          };
        }
        /**
         * Create the class name for the menu bar item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-MenuBar-itemIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.title;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
      }
      MenuBar5.Renderer = Renderer;
      MenuBar5.defaultRenderer = new Renderer();
    })(MenuBar || (MenuBar = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-MenuBar-content";
        node.appendChild(content);
        content.setAttribute("role", "menubar");
        return node;
      }
      Private22.createNode = createNode;
      function findMnemonic(menus, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = menus.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let title = menus[k2].title;
          if (title.label.length === 0) {
            continue;
          }
          let mn = title.mnemonic;
          if (mn >= 0 && mn < title.label.length) {
            if (title.label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
    })(Private$3 || (Private$3 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let decrement = document.createElement("div");
        let increment = document.createElement("div");
        let track = document.createElement("div");
        let thumb = document.createElement("div");
        decrement.className = "lm-ScrollBar-button";
        increment.className = "lm-ScrollBar-button";
        decrement.dataset["action"] = "decrement";
        increment.dataset["action"] = "increment";
        track.className = "lm-ScrollBar-track";
        thumb.className = "lm-ScrollBar-thumb";
        track.appendChild(thumb);
        node.appendChild(decrement);
        node.appendChild(track);
        node.appendChild(increment);
        return node;
      }
      Private22.createNode = createNode;
      function findPart(scrollBar, target) {
        if (scrollBar.thumbNode.contains(target)) {
          return "thumb";
        }
        if (scrollBar.trackNode.contains(target)) {
          return "track";
        }
        if (scrollBar.decrementNode.contains(target)) {
          return "decrement";
        }
        if (scrollBar.incrementNode.contains(target)) {
          return "increment";
        }
        return null;
      }
      Private22.findPart = findPart;
    })(Private$2 || (Private$2 = {}));
    SingletonLayout = class extends Layout {
      constructor() {
        super(...arguments);
        this._widget = null;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this._widget) {
          let widget = this._widget;
          this._widget = null;
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * Get the child widget for the layout.
       */
      get widget() {
        return this._widget;
      }
      /**
       * Set the child widget for the layout.
       *
       * #### Notes
       * Setting the child widget will cause the old child widget to be
       * automatically disposed. If that is not desired, set the parent
       * of the old child to `null` before assigning a new child.
       */
      set widget(widget) {
        if (widget) {
          widget.parent = this.parent;
        }
        if (this._widget === widget) {
          return;
        }
        if (this._widget) {
          this._widget.dispose();
        }
        this._widget = widget;
        if (this.parent && widget) {
          this.attachWidget(widget);
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        if (this._widget) {
          yield this._widget;
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        if (this._widget !== widget) {
          return;
        }
        this._widget = null;
        if (this.parent) {
          this.detachWidget(widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
      }
    };
    StackedLayout = class extends PanelLayout2 {
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._items = [];
        this._box = null;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget2.HiddenMode.Display;
      }
      /**
       * The method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        if (this.widgets.length > 1) {
          this.widgets.forEach((w3) => {
            w3.hiddenMode = this._hiddenMode;
          });
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        super.dispose();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        if (this._hiddenMode === Widget2.HiddenMode.Scale && this._items.length > 0) {
          if (this._items.length === 1) {
            this.widgets[0].hiddenMode = Widget2.HiddenMode.Scale;
          }
          widget.hiddenMode = Widget2.HiddenMode.Scale;
        } else {
          widget.hiddenMode = Widget2.HiddenMode.Display;
        }
        ArrayExt.insert(this._items, index2, new LayoutItem(widget));
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop2.sendMessage(widget, Widget2.Msg.AfterDetach);
        }
        item.widget.node.style.zIndex = "";
        if (this._hiddenMode === Widget2.HiddenMode.Scale) {
          widget.hiddenMode = Widget2.HiddenMode.Display;
          if (this._items.length === 1) {
            this._items[0].widget.hiddenMode = Widget2.HiddenMode.Display;
          }
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.fit();
          minW = Math.max(minW, item.minWidth);
          minH = Math.max(minH, item.minHeight);
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop2.sendMessage(this.parent.parent, Widget2.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop2.sendMessage(this.parent, Widget2.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.widget.node.style.zIndex = `${i6}`;
          item.update(left, top, width, height);
        }
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new StackedLayout();
      }
      Private22.createLayout = createLayout;
    })(Private$1 || (Private$1 = {}));
    (function(Private22) {
      function orientationFromPlacement(plc) {
        return placementToOrientationMap[plc];
      }
      Private22.orientationFromPlacement = orientationFromPlacement;
      function directionFromPlacement(plc) {
        return placementToDirectionMap[plc];
      }
      Private22.directionFromPlacement = directionFromPlacement;
      const placementToOrientationMap = {
        top: "horizontal",
        left: "vertical",
        right: "vertical",
        bottom: "horizontal"
      };
      const placementToDirectionMap = {
        top: "top-to-bottom",
        left: "left-to-right",
        right: "right-to-left",
        bottom: "bottom-to-top"
      };
    })(Private3 || (Private3 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime-interfaces/lib/index.js
var init_lib4 = __esm({
  "../../node_modules/@jupyterlab/rendermime-interfaces/lib/index.js"() {
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/attachmentmodel.js
var import_coreutils2, AttachmentModel, Private4;
var init_attachmentmodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/attachmentmodel.js"() {
    init_lib2();
    import_coreutils2 = __toESM(require_dist());
    init_index_es62();
    AttachmentModel = class {
      /**
       * Construct a new attachment model.
       */
      constructor(options) {
        this.trusted = false;
        this._changed = new Signal(this);
        this._raw = {};
        const data = Private4.getData(options.value);
        this._data = new ObservableJSON({ values: data });
        this._rawData = data;
        const value = options.value;
        for (const key in value) {
          switch (key) {
            case "data":
              break;
            default:
              this._raw[key] = Private4.extract(value, key);
          }
        }
      }
      /**
       * A signal emitted when the attachment model changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Dispose of the resources used by the attachment model.
       */
      dispose() {
        this._data.dispose();
        Signal.clearData(this);
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._rawData;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return {};
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        if (options.data) {
          this._updateObservable(this._data, options.data);
          this._rawData = options.data;
        }
        this._changed.emit(void 0);
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const attachment = {};
        for (const key in this._raw) {
          attachment[key] = Private4.extract(this._raw, key);
        }
        return attachment;
      }
      /**
       * Update an observable JSON object using a readonly JSON object.
       */
      _updateObservable(observable, data) {
        const oldKeys = observable.keys();
        const newKeys = Object.keys(data);
        for (const key of oldKeys) {
          if (newKeys.indexOf(key) === -1) {
            observable.delete(key);
          }
        }
        for (const key of newKeys) {
          const oldValue = observable.get(key);
          const newValue = data[key];
          if (oldValue !== newValue) {
            observable.set(key, newValue);
          }
        }
      }
    };
    (function(AttachmentModel2) {
      function getData(bundle) {
        return Private4.getData(bundle);
      }
      AttachmentModel2.getData = getData;
    })(AttachmentModel || (AttachmentModel = {}));
    (function(Private22) {
      function getData(bundle) {
        return convertBundle(bundle);
      }
      Private22.getData = getData;
      function getBundleOptions(options) {
        const data = getData(options.value);
        return { data };
      }
      Private22.getBundleOptions = getBundleOptions;
      function extract(value, key) {
        const item = value[key];
        if (item === void 0 || import_coreutils2.JSONExt.isPrimitive(item)) {
          return item;
        }
        return import_coreutils2.JSONExt.deepCopy(item);
      }
      Private22.extract = extract;
      function convertBundle(bundle) {
        const map4 = /* @__PURE__ */ Object.create(null);
        for (const mimeType in bundle) {
          map4[mimeType] = extract(bundle, mimeType);
        }
        return map4;
      }
    })(Private4 || (Private4 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList2, Private5;
var init_index_es615 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList2 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private5.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private5.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private5.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private5.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private5.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private5.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private5.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList5) {
      function from(values2) {
        let list = new LinkedList5();
        list.assign(values2);
        return list;
      }
      LinkedList5.from = from;
    })(LinkedList2 || (LinkedList2 = {}));
    (function(Private22) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private22.LinkedListNode = LinkedListNode;
    })(Private5 || (Private5 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/messaging/dist/index.es6.js
var Message2, ConflatableMessage2, MessageLoop3;
var init_index_es616 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es6();
    init_index_es615();
    Message2 = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    ConflatableMessage2 = class extends Message2 {
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * This property is always `true`.
       */
      get isConflatable() {
        return true;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * #### Notes
       * This method always returns `true`.
       */
      conflate(other) {
        return true;
      }
    };
    (function(MessageLoop6) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop6.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop6.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop6.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i6 = hooks.indexOf(hook);
        if (i6 === -1) {
          return;
        }
        hooks[i6] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop6.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop6.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop6.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop6.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop6.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList2();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt.removeAllWhere(hooks, isNull2);
      }
      function isNull2(value) {
        return value === null;
      }
    })(MessageLoop3 || (MessageLoop3 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/dragdrop/dist/index.es6.js
var Drag2, Private6;
var init_index_es617 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/dragdrop/dist/index.es6.js"() {
    init_index_es63();
    Drag2 = class {
      /**
       * Construct a new drag object.
       *
       * @param options - The options for initializing the drag.
       */
      constructor(options) {
        this._onScrollFrame = () => {
          if (!this._scrollTarget) {
            return;
          }
          let { element: element2, edge, distance } = this._scrollTarget;
          let d6 = Private6.SCROLL_EDGE_SIZE - distance;
          let f6 = Math.pow(d6 / Private6.SCROLL_EDGE_SIZE, 2);
          let s8 = Math.max(1, Math.round(f6 * Private6.SCROLL_EDGE_SIZE));
          switch (edge) {
            case "top":
              element2.scrollTop -= s8;
              break;
            case "left":
              element2.scrollLeft -= s8;
              break;
            case "right":
              element2.scrollLeft += s8;
              break;
            case "bottom":
              element2.scrollTop += s8;
              break;
          }
          requestAnimationFrame(this._onScrollFrame);
        };
        this._disposed = false;
        this._dropAction = "none";
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._scrollTarget = null;
        this._resolve = null;
        this.document = options.document || document;
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || "copy";
        this.supportedActions = options.supportedActions || "all";
        this.source = options.source || null;
      }
      /**
       * Dispose of the resources held by the drag object.
       *
       * #### Notes
       * This will cancel the drag operation if it is active.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        if (this._currentTarget) {
          let event = new PointerEvent("pointerup", {
            bubbles: true,
            cancelable: true,
            clientX: -1,
            clientY: -1
          });
          Private6.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        this._finalize("none");
      }
      /**
       * Test whether the drag object is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Start the drag operation at the specified client position.
       *
       * @param clientX - The client X position for the drag start.
       *
       * @param clientY - The client Y position for the drag start.
       *
       * @returns A promise which resolves to the result of the drag.
       *
       * #### Notes
       * If the drag has already been started, the promise created by the
       * first call to `start` is returned.
       *
       * If the drag operation has ended, or if the drag object has been
       * disposed, the returned promise will resolve to `'none'`.
       *
       * The drag object will be automatically disposed when drag operation
       * completes. This means `Drag` objects are for single-use only.
       *
       * This method assumes the left mouse button is already held down.
       */
      start(clientX, clientY) {
        if (this._disposed) {
          return Promise.resolve("none");
        }
        if (this._promise) {
          return this._promise;
        }
        this._addListeners();
        this._attachDragImage(clientX, clientY);
        this._promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
        let event = new PointerEvent("pointermove", {
          bubbles: true,
          cancelable: true,
          clientX,
          clientY
        });
        document.dispatchEvent(event);
        return this._promise;
      }
      /**
       * Handle the DOM events for the drag operation.
       *
       * @param event - The DOM event sent to the drag object.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the document. It should not be
       * called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          default:
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * Move the drag image element to the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        let style = this.dragImage.style;
        style.transform = `translate(${clientX}px, ${clientY}px)`;
      }
      /**
       * Handle the `'pointermove'` event for the drag object.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        this._updateCurrentTarget(event);
        this._updateDragScroll(event);
        this.moveDragImage(event.clientX, event.clientY);
      }
      /**
       * Handle the `'pointerup'` event for the drag object.
       */
      _evtPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
          return;
        }
        this._updateCurrentTarget(event);
        if (!this._currentTarget) {
          this._finalize("none");
          return;
        }
        if (this._dropAction === "none") {
          Private6.dispatchDragLeave(this, this._currentTarget, null, event);
          this._finalize("none");
          return;
        }
        let action = Private6.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
      }
      /**
       * Handle the `'keydown'` event for the drag object.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this.dispose();
        }
      }
      /**
       * Add the document event listeners for the drag object.
       */
      _addListeners() {
        document.addEventListener("pointerdown", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointerenter", this, true);
        document.addEventListener("pointerleave", this, true);
        document.addEventListener("pointerover", this, true);
        document.addEventListener("pointerout", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("keyup", this, true);
        document.addEventListener("keypress", this, true);
        document.addEventListener("contextmenu", this, true);
      }
      /**
       * Remove the document event listeners for the drag object.
       */
      _removeListeners() {
        document.removeEventListener("pointerdown", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointerenter", this, true);
        document.removeEventListener("pointerleave", this, true);
        document.removeEventListener("pointerover", this, true);
        document.removeEventListener("pointerout", this, true);
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("keyup", this, true);
        document.removeEventListener("keypress", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Update the drag scroll element under the mouse.
       */
      _updateDragScroll(event) {
        let target = Private6.findScrollTarget(event);
        if (!this._scrollTarget && !target) {
          return;
        }
        if (!this._scrollTarget) {
          setTimeout(this._onScrollFrame, 500);
        }
        this._scrollTarget = target;
      }
      /**
       * Update the current target node using the given mouse event.
       */
      _updateCurrentTarget(event) {
        let prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        let prevElem = this._currentElement;
        let currElem = Private6.findElementBehindBackdrop(event, this.document);
        this._currentElement = currElem;
        if (currElem !== prevElem && currElem !== currTarget) {
          Private6.dispatchDragExit(this, currTarget, currElem, event);
        }
        if (currElem !== prevElem && currElem !== currTarget) {
          currTarget = Private6.dispatchDragEnter(this, currElem, currTarget, event);
        }
        if (currTarget !== prevTarget) {
          this._currentTarget = currTarget;
          Private6.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        let action = Private6.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
      }
      /**
       * Attach the drag image element at the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        this.dragImage.classList.add("lm-mod-drag-image");
        let style = this.dragImage.style;
        style.pointerEvents = "none";
        style.position = "fixed";
        style.transform = `translate(${clientX}px, ${clientY}px)`;
        const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
        body.appendChild(this.dragImage);
      }
      /**
       * Detach the drag image element from the DOM.
       *
       * This is a no-op if there is no drag image element.
       */
      _detachDragImage() {
        if (!this.dragImage) {
          return;
        }
        let parent = this.dragImage.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(this.dragImage);
      }
      /**
       * Set the internal drop action state and update the drag cursor.
       */
      _setDropAction(action) {
        action = Private6.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
          return;
        }
        switch (action) {
          case "none":
            this._dropAction = action;
            this._override = Drag2.overrideCursor("no-drop", this.document);
            break;
          case "copy":
            this._dropAction = action;
            this._override = Drag2.overrideCursor("copy", this.document);
            break;
          case "link":
            this._dropAction = action;
            this._override = Drag2.overrideCursor("alias", this.document);
            break;
          case "move":
            this._dropAction = action;
            this._override = Drag2.overrideCursor("move", this.document);
            break;
        }
      }
      /**
       * Finalize the drag operation and resolve the drag promise.
       */
      _finalize(action) {
        let resolve = this._resolve;
        this._removeListeners();
        this._detachDragImage();
        if (this._override) {
          this._override.dispose();
          this._override = null;
        }
        this.mimeData.clear();
        this._disposed = true;
        this._dropAction = "none";
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        if (resolve) {
          resolve(action);
        }
      }
    };
    (function(Drag5) {
      class Event2 extends DragEvent {
        constructor(event, options) {
          super(options.type, {
            bubbles: true,
            cancelable: true,
            altKey: event.altKey,
            button: event.button,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            detail: 0,
            metaKey: event.metaKey,
            relatedTarget: options.related,
            screenX: event.screenX,
            screenY: event.screenY,
            shiftKey: event.shiftKey,
            view: window
          });
          const { drag } = options;
          this.dropAction = "none";
          this.mimeData = drag.mimeData;
          this.proposedAction = drag.proposedAction;
          this.supportedActions = drag.supportedActions;
          this.source = drag.source;
        }
      }
      Drag5.Event = Event2;
      function overrideCursor(cursor, doc = document) {
        return Private6.overrideCursor(cursor, doc);
      }
      Drag5.overrideCursor = overrideCursor;
    })(Drag2 || (Drag2 = {}));
    (function(Private22) {
      Private22.SCROLL_EDGE_SIZE = 20;
      function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : "none";
      }
      Private22.validateAction = validateAction;
      function findElementBehindBackdrop(event, root2 = document) {
        if (event) {
          if (lastElementEventSearch && event == lastElementEventSearch.event) {
            return lastElementEventSearch.element;
          }
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(event.clientX, event.clientY);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementEventSearch = { event, element: element2 };
          return element2;
        } else {
          const transform = Private22.cursorBackdrop.style.transform;
          if (lastElementSearch && transform === lastElementSearch.transform) {
            return lastElementSearch.element;
          }
          const bbox = Private22.cursorBackdrop.getBoundingClientRect();
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementSearch = { transform, element: element2 };
          return element2;
        }
      }
      Private22.findElementBehindBackdrop = findElementBehindBackdrop;
      let lastElementEventSearch = null;
      let lastElementSearch = null;
      function findScrollTarget(event) {
        let x2 = event.clientX;
        let y4 = event.clientY;
        let element2 = findElementBehindBackdrop(event);
        for (; element2; element2 = element2.parentElement) {
          if (!element2.hasAttribute("data-lm-dragscroll")) {
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (element2 === document.body) {
            offsetX = window.pageXOffset;
            offsetY = window.pageYOffset;
          }
          let r4 = element2.getBoundingClientRect();
          let top = r4.top + offsetY;
          let left = r4.left + offsetX;
          let right = left + r4.width;
          let bottom = top + r4.height;
          if (x2 < left || x2 >= right || y4 < top || y4 >= bottom) {
            continue;
          }
          let dl = x2 - left + 1;
          let dt = y4 - top + 1;
          let dr = right - x2;
          let db = bottom - y4;
          let distance = Math.min(dl, dt, dr, db);
          if (distance > Private22.SCROLL_EDGE_SIZE) {
            continue;
          }
          let edge;
          switch (distance) {
            case db:
              edge = "bottom";
              break;
            case dt:
              edge = "top";
              break;
            case dr:
              edge = "right";
              break;
            case dl:
              edge = "left";
              break;
            default:
              throw "unreachable";
          }
          let dsw = element2.scrollWidth - element2.clientWidth;
          let dsh = element2.scrollHeight - element2.clientHeight;
          let shouldScroll;
          switch (edge) {
            case "top":
              shouldScroll = dsh > 0 && element2.scrollTop > 0;
              break;
            case "left":
              shouldScroll = dsw > 0 && element2.scrollLeft > 0;
              break;
            case "right":
              shouldScroll = dsw > 0 && element2.scrollLeft < dsw;
              break;
            case "bottom":
              shouldScroll = dsh > 0 && element2.scrollTop < dsh;
              break;
            default:
              throw "unreachable";
          }
          if (!shouldScroll) {
            continue;
          }
          return { element: element2, edge, distance };
        }
        return null;
      }
      Private22.findScrollTarget = findScrollTarget;
      function dispatchDragEnter(drag, currElem, currTarget, event) {
        if (!currElem) {
          return null;
        }
        let dragEvent = new Drag2.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        let canceled = !currElem.dispatchEvent(dragEvent);
        if (canceled) {
          return currElem;
        }
        const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
        if (currElem === body) {
          return currTarget;
        }
        dragEvent = new Drag2.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        body.dispatchEvent(dragEvent);
        return body;
      }
      Private22.dispatchDragEnter = dispatchDragEnter;
      function dispatchDragExit(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag2.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragexit"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragExit = dispatchDragExit;
      function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag2.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragleave"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragLeave = dispatchDragLeave;
      function dispatchDragOver(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag2.Event(event, {
          drag,
          related: null,
          type: "lm-dragover"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDragOver = dispatchDragOver;
      function dispatchDrop(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag2.Event(event, {
          drag,
          related: null,
          type: "lm-drop"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDrop = dispatchDrop;
      const actionTable = {
        none: 0,
        copy: 1,
        link: 2,
        move: 4
      };
      const supportedTable = {
        none: actionTable["none"],
        copy: actionTable["copy"],
        link: actionTable["link"],
        move: actionTable["move"],
        "copy-link": actionTable["copy"] | actionTable["link"],
        "copy-move": actionTable["copy"] | actionTable["move"],
        "link-move": actionTable["link"] | actionTable["move"],
        all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
      };
      function overrideCursor(cursor, doc = document) {
        let id = ++overrideCursorID;
        const body = doc instanceof Document ? doc.body : doc.firstElementChild;
        if (!Private22.cursorBackdrop.isConnected) {
          Private22.cursorBackdrop.style.transform = "scale(0)";
          body.appendChild(Private22.cursorBackdrop);
          resetBackdropScroll();
          document.addEventListener("pointermove", alignBackdrop, {
            capture: true,
            passive: true
          });
          Private22.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
            capture: true,
            passive: true
          });
        }
        Private22.cursorBackdrop.style.cursor = cursor;
        return new DisposableDelegate(() => {
          if (id === overrideCursorID && Private22.cursorBackdrop.isConnected) {
            document.removeEventListener("pointermove", alignBackdrop, true);
            Private22.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
            body.removeChild(Private22.cursorBackdrop);
          }
        });
      }
      Private22.overrideCursor = overrideCursor;
      function alignBackdrop(event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        Private22.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
      }
      function propagateBackdropScroll(_event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        let element2 = findElementBehindBackdrop();
        if (!element2) {
          return;
        }
        const scrollTarget = element2.closest("[data-lm-dragscroll]");
        if (!scrollTarget) {
          return;
        }
        scrollTarget.scrollTop += Private22.cursorBackdrop.scrollTop - backdropScrollOrigin;
        scrollTarget.scrollLeft += Private22.cursorBackdrop.scrollLeft - backdropScrollOrigin;
        resetBackdropScroll();
      }
      function resetBackdropScroll() {
        Private22.cursorBackdrop.scrollTop = backdropScrollOrigin;
        Private22.cursorBackdrop.scrollLeft = backdropScrollOrigin;
      }
      const backdropScrollOrigin = 500;
      function createCursorBackdrop() {
        const backdrop = document.createElement("div");
        backdrop.classList.add("lm-cursor-backdrop");
        return backdrop;
      }
      let overrideCursorID = 0;
      Private22.cursorBackdrop = createCursorBackdrop();
    })(Private6 || (Private6 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/widgets/dist/index.es6.js
var import_coreutils3, BoxSizer2, BoxEngine2, Title3, Widget3, Private$j2, Layout2, LayoutItem2, Private$i2, PanelLayout3, Utils2, Utils$12, SplitLayout2, Private$h2, AccordionLayout2, Private$g2, Panel3, Private$f2, SplitPanel2, Private$e2, AccordionPanel2, Private$d2, BoxLayout2, Private$c2, BoxPanel2, Private$b2, CommandPalette2, Private$a2, Menu2, Private$92, Private$82, ARROW_KEYS2, TabBar3, Private$72, DockLayout2, Private$62, DockPanel2, Private$52, GridLayout2, Private$42, MenuBar2, Private$32, Private$22, SingletonLayout2, StackedLayout2, Private$12, Private7;
var init_index_es618 = __esm({
  "../../node_modules/@jupyterlab/rendermime/node_modules/@lumino/widgets/dist/index.es6.js"() {
    init_index_es6();
    import_coreutils3 = __toESM(require_dist());
    init_index_es65();
    init_index_es616();
    init_index_es64();
    init_index_es62();
    init_index_es617();
    init_index_es67();
    init_index_es68();
    init_index_es63();
    init_index_es66();
    BoxSizer2 = class {
      constructor() {
        this.sizeHint = 0;
        this.minSize = 0;
        this.maxSize = Infinity;
        this.stretch = 1;
        this.size = 0;
        this.done = false;
      }
    };
    (function(BoxEngine5) {
      function calc(sizers, space) {
        let count3 = sizers.length;
        if (count3 === 0) {
          return space;
        }
        let totalMin = 0;
        let totalMax = 0;
        let totalSize = 0;
        let totalStretch = 0;
        let stretchCount = 0;
        for (let i6 = 0; i6 < count3; ++i6) {
          let sizer = sizers[i6];
          let min3 = sizer.minSize;
          let max4 = sizer.maxSize;
          let hint = sizer.sizeHint;
          sizer.done = false;
          sizer.size = Math.max(min3, Math.min(hint, max4));
          totalSize += sizer.size;
          totalMin += min3;
          totalMax += max4;
          if (sizer.stretch > 0) {
            totalStretch += sizer.stretch;
            stretchCount++;
          }
        }
        if (space === totalSize) {
          return 0;
        }
        if (space <= totalMin) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.minSize;
          }
          return space - totalMin;
        }
        if (space >= totalMax) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.maxSize;
          }
          return space - totalMax;
        }
        let nearZero = 0.01;
        let notDoneCount = count3;
        if (space < totalSize) {
          let freeSpace = totalSize - space;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
        } else {
          let freeSpace = space - totalSize;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
        }
        return 0;
      }
      BoxEngine5.calc = calc;
      function adjust(sizers, index2, delta) {
        if (sizers.length === 0 || delta === 0) {
          return;
        }
        if (delta > 0) {
          growSizer(sizers, index2, delta);
        } else {
          shrinkSizer(sizers, index2, -delta);
        }
      }
      BoxEngine5.adjust = adjust;
      function growSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2; i6 >= 0 && grow > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && shrink > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
      function shrinkSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && grow > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2; i6 >= 0 && shrink > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
    })(BoxEngine2 || (BoxEngine2 = {}));
    Title3 = class {
      /**
       * Construct a new title.
       *
       * @param options - The options for initializing the title.
       */
      constructor(options) {
        this._label = "";
        this._caption = "";
        this._mnemonic = -1;
        this._icon = void 0;
        this._iconClass = "";
        this._iconLabel = "";
        this._className = "";
        this._closable = false;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this.owner = options.owner;
        if (options.label !== void 0) {
          this._label = options.label;
        }
        if (options.mnemonic !== void 0) {
          this._mnemonic = options.mnemonic;
        }
        if (options.icon !== void 0) {
          this._icon = options.icon;
        }
        if (options.iconClass !== void 0) {
          this._iconClass = options.iconClass;
        }
        if (options.iconLabel !== void 0) {
          this._iconLabel = options.iconLabel;
        }
        if (options.caption !== void 0) {
          this._caption = options.caption;
        }
        if (options.className !== void 0) {
          this._className = options.className;
        }
        if (options.closable !== void 0) {
          this._closable = options.closable;
        }
        this._dataset = options.dataset || {};
      }
      /**
       * A signal emitted when the state of the title changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get label() {
        return this._label;
      }
      /**
       * Set the label for the title.
       */
      set label(value) {
        if (this._label === value) {
          return;
        }
        this._label = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the mnemonic index for the title.
       *
       * #### Notes
       * The default value is `-1`.
       */
      get mnemonic() {
        return this._mnemonic;
      }
      /**
       * Set the mnemonic index for the title.
       */
      set mnemonic(value) {
        if (this._mnemonic === value) {
          return;
        }
        this._mnemonic = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon renderer for the title.
       *
       * #### Notes
       * The default value is undefined.
       */
      get icon() {
        return this._icon;
      }
      /**
       * Set the icon renderer for the title.
       *
       * #### Notes
       * A renderer is an object that supplies a render and unrender function.
       */
      set icon(value) {
        if (this._icon === value) {
          return;
        }
        this._icon = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconClass() {
        return this._iconClass;
      }
      /**
       * Set the icon class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconClass(value) {
        if (this._iconClass === value) {
          return;
        }
        this._iconClass = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconLabel() {
        return this._iconLabel;
      }
      /**
       * Set the icon label for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconLabel(value) {
        if (this._iconLabel === value) {
          return;
        }
        this._iconLabel = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the caption for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get caption() {
        return this._caption;
      }
      /**
       * Set the caption for the title.
       */
      set caption(value) {
        if (this._caption === value) {
          return;
        }
        this._caption = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the extra class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get className() {
        return this._className;
      }
      /**
       * Set the extra class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set className(value) {
        if (this._className === value) {
          return;
        }
        this._className = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the closable state for the title.
       *
       * #### Notes
       * The default value is `false`.
       */
      get closable() {
        return this._closable;
      }
      /**
       * Set the closable state for the title.
       *
       * #### Notes
       * This controls the presence of a close icon when applicable.
       */
      set closable(value) {
        if (this._closable === value) {
          return;
        }
        this._closable = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the dataset for the title.
       *
       * #### Notes
       * The default value is an empty dataset.
       */
      get dataset() {
        return this._dataset;
      }
      /**
       * Set the dataset for the title.
       *
       * #### Notes
       * This controls the data attributes when applicable.
       */
      set dataset(value) {
        if (this._dataset === value) {
          return;
        }
        this._dataset = value;
        this._changed.emit(void 0);
      }
      /**
       * Test whether the title has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the title.
       *
       * #### Notes
       * It is the responsibility of the owner to call the title disposal.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
    Widget3 = class {
      /**
       * Construct a new widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options = {}) {
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this._disposed = new Signal(this);
        this._hiddenMode = Widget3.HiddenMode.Display;
        this.node = Private$j2.createNode(options);
        this.addClass("lm-Widget");
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.setFlag(Widget3.Flag.IsDisposed);
        this._disposed.emit(void 0);
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget3.detach(this);
        }
        if (this._layout) {
          this._layout.dispose();
          this._layout = null;
        }
        this.title.dispose();
        Signal.clearData(this);
        MessageLoop3.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * A signal emitted when the widget is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the widget has been disposed.
       */
      get isDisposed() {
        return this.testFlag(Widget3.Flag.IsDisposed);
      }
      /**
       * Test whether the widget's node is attached to the DOM.
       */
      get isAttached() {
        return this.testFlag(Widget3.Flag.IsAttached);
      }
      /**
       * Test whether the widget is explicitly hidden.
       *
       * #### Notes
       * You should prefer `!{@link isVisible}` over `{@link isHidden}` if you want to know if the
       * widget is hidden as this does not test if the widget is hidden because one of its ancestors is hidden.
       */
      get isHidden() {
        return this.testFlag(Widget3.Flag.IsHidden);
      }
      /**
       * Test whether the widget is visible.
       *
       * #### Notes
       * A widget is visible when it is attached to the DOM, is not
       * explicitly hidden, and has no explicitly hidden ancestors.
       *
       * Since 2.7.0, this does not rely on the {@link Widget.Flag.IsVisible} flag.
       * It recursively checks the visibility of all parent widgets.
       */
      get isVisible() {
        let parent = this;
        do {
          if (parent.isHidden || !parent.isAttached) {
            return false;
          }
          parent = parent.parent;
        } while (parent != null);
        return true;
      }
      /**
       * The title object for the widget.
       *
       * #### Notes
       * The title object is used by some container widgets when displaying
       * the widget alongside some title, such as a tab panel or side bar.
       *
       * Since not all widgets will use the title, it is created on demand.
       *
       * The `owner` property of the title is set to this widget.
       */
      get title() {
        return Private$j2.titleProperty.get(this);
      }
      /**
       * Get the id of the widget's DOM node.
       */
      get id() {
        return this.node.id;
      }
      /**
       * Set the id of the widget's DOM node.
       */
      set id(value) {
        this.node.id = value;
      }
      /**
       * The dataset for the widget's DOM node.
       */
      get dataset() {
        return this.node.dataset;
      }
      /**
       * Get the method for hiding the widget.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding the widget.
       */
      set hiddenMode(value) {
        if (this._hiddenMode === value) {
          return;
        }
        if (this.isHidden) {
          this._toggleHidden(false);
        }
        if (value == Widget3.HiddenMode.Scale) {
          this.node.style.willChange = "transform";
        } else {
          this.node.style.willChange = "auto";
        }
        this._hiddenMode = value;
        if (this.isHidden) {
          this._toggleHidden(true);
        }
      }
      /**
       * Get the parent of the widget.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the widget.
       *
       * #### Notes
       * Children are typically added to a widget by using a layout, which
       * means user code will not normally set the parent widget directly.
       *
       * The widget will be automatically removed from its old parent.
       *
       * This is a no-op if there is no effective parent change.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (value && this.contains(value)) {
          throw new Error("Invalid parent widget.");
        }
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget3.ChildMessage("child-removed", this);
          MessageLoop3.sendMessage(this._parent, msg);
        }
        this._parent = value;
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget3.ChildMessage("child-added", this);
          MessageLoop3.sendMessage(this._parent, msg);
        }
        if (!this.isDisposed) {
          MessageLoop3.sendMessage(this, Widget3.Msg.ParentChanged);
        }
      }
      /**
       * Get the layout for the widget.
       */
      get layout() {
        return this._layout;
      }
      /**
       * Set the layout for the widget.
       *
       * #### Notes
       * The layout is single-use only. It cannot be changed after the
       * first assignment.
       *
       * The layout is disposed automatically when the widget is disposed.
       */
      set layout(value) {
        if (this._layout === value) {
          return;
        }
        if (this.testFlag(Widget3.Flag.DisallowLayout)) {
          throw new Error("Cannot set widget layout.");
        }
        if (this._layout) {
          throw new Error("Cannot change widget layout.");
        }
        if (value.parent) {
          throw new Error("Cannot change layout parent.");
        }
        this._layout = value;
        value.parent = this;
      }
      /**
       * Create an iterator over the widget's children.
       *
       * @returns A new iterator over the children of the widget.
       *
       * #### Notes
       * The widget must have a populated layout in order to have children.
       *
       * If a layout is not installed, the returned iterator will be empty.
       */
      *children() {
        if (this._layout) {
          yield* this._layout;
        }
      }
      /**
       * Test whether a widget is a descendant of this widget.
       *
       * @param widget - The descendant widget of interest.
       *
       * @returns `true` if the widget is a descendant, `false` otherwise.
       */
      contains(widget) {
        for (let value = widget; value; value = value._parent) {
          if (value === this) {
            return true;
          }
        }
        return false;
      }
      /**
       * Test whether the widget's DOM node has the given class name.
       *
       * @param name - The class name of interest.
       *
       * @returns `true` if the node has the class, `false` otherwise.
       */
      hasClass(name) {
        return this.node.classList.contains(name);
      }
      /**
       * Add a class name to the widget's DOM node.
       *
       * @param name - The class name to add to the node.
       *
       * #### Notes
       * If the class name is already added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      addClass(name) {
        this.node.classList.add(name);
      }
      /**
       * Remove a class name from the widget's DOM node.
       *
       * @param name - The class name to remove from the node.
       *
       * #### Notes
       * If the class name is not yet added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      removeClass(name) {
        this.node.classList.remove(name);
      }
      /**
       * Toggle a class name on the widget's DOM node.
       *
       * @param name - The class name to toggle on the node.
       *
       * @param force - Whether to force add the class (`true`) or force
       *   remove the class (`false`). If not provided, the presence of
       *   the class will be toggled from its current state.
       *
       * @returns `true` if the class is now present, `false` otherwise.
       *
       * #### Notes
       * The class name must not contain whitespace.
       */
      toggleClass(name, force) {
        if (force === true) {
          this.node.classList.add(name);
          return true;
        }
        if (force === false) {
          this.node.classList.remove(name);
          return false;
        }
        return this.node.classList.toggle(name);
      }
      /**
       * Post an `'update-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      update() {
        MessageLoop3.postMessage(this, Widget3.Msg.UpdateRequest);
      }
      /**
       * Post a `'fit-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      fit() {
        MessageLoop3.postMessage(this, Widget3.Msg.FitRequest);
      }
      /**
       * Post an `'activate-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      activate() {
        MessageLoop3.postMessage(this, Widget3.Msg.ActivateRequest);
      }
      /**
       * Send a `'close-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for sending the message.
       */
      close() {
        MessageLoop3.sendMessage(this, Widget3.Msg.CloseRequest);
      }
      /**
       * Show the widget and make it visible to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `false`.
       *
       * If the widget is not explicitly hidden, this is a no-op.
       */
      show() {
        if (!this.testFlag(Widget3.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop3.sendMessage(this, Widget3.Msg.BeforeShow);
        }
        this.clearFlag(Widget3.Flag.IsHidden);
        this._toggleHidden(false);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop3.sendMessage(this, Widget3.Msg.AfterShow);
        }
        if (this.parent) {
          let msg = new Widget3.ChildMessage("child-shown", this);
          MessageLoop3.sendMessage(this.parent, msg);
        }
      }
      /**
       * Hide the widget and make it hidden to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `true`.
       *
       * If the widget is explicitly hidden, this is a no-op.
       */
      hide() {
        if (this.testFlag(Widget3.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop3.sendMessage(this, Widget3.Msg.BeforeHide);
        }
        this.setFlag(Widget3.Flag.IsHidden);
        this._toggleHidden(true);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop3.sendMessage(this, Widget3.Msg.AfterHide);
        }
        if (this.parent) {
          let msg = new Widget3.ChildMessage("child-hidden", this);
          MessageLoop3.sendMessage(this.parent, msg);
        }
      }
      /**
       * Show or hide the widget according to a boolean value.
       *
       * @param hidden - `true` to hide the widget, or `false` to show it.
       *
       * #### Notes
       * This is a convenience method for `hide()` and `show()`.
       */
      setHidden(hidden) {
        if (hidden) {
          this.hide();
        } else {
          this.show();
        }
      }
      /**
       * Test whether the given widget flag is set.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      testFlag(flag) {
        return (this._flags & flag) !== 0;
      }
      /**
       * Set the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      setFlag(flag) {
        this._flags |= flag;
      }
      /**
       * Clear the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      clearFlag(flag) {
        this._flags &= ~flag;
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       *
       * #### Notes
       * Subclasses may reimplement this method as needed.
       */
      processMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.notifyLayout(msg);
            this.onResize(msg);
            break;
          case "update-request":
            this.notifyLayout(msg);
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.notifyLayout(msg);
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.notifyLayout(msg);
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.setFlag(Widget3.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.notifyLayout(msg);
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.clearFlag(Widget3.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.notifyLayout(msg);
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
              this.setFlag(Widget3.Flag.IsVisible);
            }
            this.setFlag(Widget3.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.notifyLayout(msg);
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.clearFlag(Widget3.Flag.IsVisible);
            this.clearFlag(Widget3.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterDetach(msg);
            break;
          case "activate-request":
            this.notifyLayout(msg);
            this.onActivateRequest(msg);
            break;
          case "close-request":
            this.notifyLayout(msg);
            this.onCloseRequest(msg);
            break;
          case "child-added":
            this.notifyLayout(msg);
            this.onChildAdded(msg);
            break;
          case "child-removed":
            this.notifyLayout(msg);
            this.onChildRemoved(msg);
            break;
          default:
            this.notifyLayout(msg);
            break;
        }
      }
      /**
       * Invoke the message processing routine of the widget's layout.
       *
       * @param msg - The message to dispatch to the layout.
       *
       * #### Notes
       * This is a no-op if the widget does not have a layout.
       *
       * This will not typically be called directly by user code.
       */
      notifyLayout(msg) {
        if (this._layout) {
          this._layout.processParentMessage(msg);
        }
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       *
       * #### Notes
       * The default implementation unparents or detaches the widget.
       */
      onCloseRequest(msg) {
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget3.detach(this);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onResize(msg) {
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onActivateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeShow(msg) {
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterShow(msg) {
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeHide(msg) {
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterHide(msg) {
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeAttach(msg) {
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterAttach(msg) {
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeDetach(msg) {
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterDetach(msg) {
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildAdded(msg) {
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildRemoved(msg) {
      }
      _toggleHidden(hidden) {
        if (hidden) {
          switch (this._hiddenMode) {
            case Widget3.HiddenMode.Display:
              this.addClass("lm-mod-hidden");
              break;
            case Widget3.HiddenMode.Scale:
              this.node.style.transform = "scale(0)";
              this.node.setAttribute("aria-hidden", "true");
              break;
            case Widget3.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "hidden";
              this.node.style.zIndex = "-1";
              break;
          }
        } else {
          switch (this._hiddenMode) {
            case Widget3.HiddenMode.Display:
              this.removeClass("lm-mod-hidden");
              break;
            case Widget3.HiddenMode.Scale:
              this.node.style.transform = "";
              this.node.removeAttribute("aria-hidden");
              break;
            case Widget3.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "";
              this.node.style.zIndex = "";
              break;
          }
        }
      }
    };
    (function(Widget6) {
      (function(HiddenMode) {
        HiddenMode[HiddenMode["Display"] = 0] = "Display";
        HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
        HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
      })(Widget6.HiddenMode || (Widget6.HiddenMode = {}));
      (function(Flag) {
        Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
        Flag[Flag["IsAttached"] = 2] = "IsAttached";
        Flag[Flag["IsHidden"] = 4] = "IsHidden";
        Flag[Flag["IsVisible"] = 8] = "IsVisible";
        Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
      })(Widget6.Flag || (Widget6.Flag = {}));
      (function(Msg) {
        Msg.BeforeShow = new Message2("before-show");
        Msg.AfterShow = new Message2("after-show");
        Msg.BeforeHide = new Message2("before-hide");
        Msg.AfterHide = new Message2("after-hide");
        Msg.BeforeAttach = new Message2("before-attach");
        Msg.AfterAttach = new Message2("after-attach");
        Msg.BeforeDetach = new Message2("before-detach");
        Msg.AfterDetach = new Message2("after-detach");
        Msg.ParentChanged = new Message2("parent-changed");
        Msg.UpdateRequest = new ConflatableMessage2("update-request");
        Msg.FitRequest = new ConflatableMessage2("fit-request");
        Msg.ActivateRequest = new ConflatableMessage2("activate-request");
        Msg.CloseRequest = new ConflatableMessage2("close-request");
      })(Widget6.Msg || (Widget6.Msg = {}));
      class ChildMessage extends Message2 {
        /**
         * Construct a new child message.
         *
         * @param type - The message type.
         *
         * @param child - The child widget for the message.
         */
        constructor(type, child) {
          super(type);
          this.child = child;
        }
      }
      Widget6.ChildMessage = ChildMessage;
      class ResizeMessage extends Message2 {
        /**
         * Construct a new resize message.
         *
         * @param width - The **offset width** of the widget, or `-1` if
         *   the width is not known.
         *
         * @param height - The **offset height** of the widget, or `-1` if
         *   the height is not known.
         */
        constructor(width, height) {
          super("resize");
          this.width = width;
          this.height = height;
        }
      }
      Widget6.ResizeMessage = ResizeMessage;
      (function(ResizeMessage2) {
        ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
      })(ResizeMessage = Widget6.ResizeMessage || (Widget6.ResizeMessage = {}));
      function attach(widget, host, ref = null) {
        if (widget.parent) {
          throw new Error("Cannot attach a child widget.");
        }
        if (widget.isAttached || widget.node.isConnected) {
          throw new Error("Widget is already attached.");
        }
        if (!host.isConnected) {
          throw new Error("Host is not attached.");
        }
        MessageLoop3.sendMessage(widget, Widget6.Msg.BeforeAttach);
        host.insertBefore(widget.node, ref);
        MessageLoop3.sendMessage(widget, Widget6.Msg.AfterAttach);
      }
      Widget6.attach = attach;
      function detach(widget) {
        if (widget.parent) {
          throw new Error("Cannot detach a child widget.");
        }
        if (!widget.isAttached || !widget.node.isConnected) {
          throw new Error("Widget is not attached.");
        }
        MessageLoop3.sendMessage(widget, Widget6.Msg.BeforeDetach);
        widget.node.parentNode.removeChild(widget.node);
        MessageLoop3.sendMessage(widget, Widget6.Msg.AfterDetach);
      }
      Widget6.detach = detach;
    })(Widget3 || (Widget3 = {}));
    (function(Private22) {
      Private22.titleProperty = new AttachedProperty({
        name: "title",
        create: (owner) => new Title3({ owner })
      });
      function createNode(options) {
        return options.node || document.createElement(options.tag || "div");
      }
      Private22.createNode = createNode;
    })(Private$j2 || (Private$j2 = {}));
    Layout2 = class {
      /**
       * Construct a new layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        this._disposed = false;
        this._parent = null;
        this._fitPolicy = options.fitPolicy || "set-min-size";
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This should be reimplemented to clear and dispose of the widgets.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        this._parent = null;
        this._disposed = true;
        Signal.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * Test whether the layout is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Get the parent widget of the layout.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent widget of the layout.
       *
       * #### Notes
       * This is set automatically when installing the layout on the parent
       * widget. The parent widget should not be set directly by user code.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (this._parent) {
          throw new Error("Cannot change parent widget.");
        }
        if (value.layout !== this) {
          throw new Error("Invalid parent widget.");
        }
        this._parent = value;
        this.init();
      }
      /**
       * Get the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       */
      get fitPolicy() {
        return this._fitPolicy;
      }
      /**
       * Set the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       *
       * Changing the fit policy will clear the current size constraint
       * for the parent widget and then re-fit the parent.
       */
      set fitPolicy(value) {
        if (this._fitPolicy === value) {
          return;
        }
        this._fitPolicy = value;
        if (this._parent) {
          let style = this._parent.node.style;
          style.minWidth = "";
          style.minHeight = "";
          style.maxWidth = "";
          style.maxHeight = "";
          this._parent.fit();
        }
      }
      /**
       * Process a message sent to the parent widget.
       *
       * @param msg - The message sent to the parent widget.
       *
       * #### Notes
       * This method is called by the parent widget to process a message.
       *
       * Subclasses may reimplement this method as needed.
       */
      processParentMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.onResize(msg);
            break;
          case "update-request":
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.onAfterDetach(msg);
            break;
          case "child-removed":
            this.onChildRemoved(msg);
            break;
          case "child-shown":
            this.onChildShown(msg);
            break;
          case "child-hidden":
            this.onChildHidden(msg);
            break;
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       *
       * #### Notes
       * This method is invoked immediately after the layout is installed
       * on the parent widget.
       *
       * The default implementation reparents all of the widgets to the
       * layout parent widget.
       *
       * Subclasses should reimplement this method and attach the child
       * widget nodes to the parent widget's node.
       */
      init() {
        for (const widget of this) {
          widget.parent = this.parent;
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the specified layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onResize(msg) {
        for (const widget of this) {
          MessageLoop3.sendMessage(widget, Widget3.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the available layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onUpdateRequest(msg) {
        for (const widget of this) {
          MessageLoop3.sendMessage(widget, Widget3.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeAttach(msg) {
        for (const widget of this) {
          MessageLoop3.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterAttach(msg) {
        for (const widget of this) {
          MessageLoop3.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeDetach(msg) {
        for (const widget of this) {
          MessageLoop3.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterDetach(msg) {
        for (const widget of this) {
          MessageLoop3.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop3.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop3.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop3.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop3.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * This will remove the child widget from the layout.
       *
       * Subclasses should **not** typically reimplement this method.
       */
      onChildRemoved(msg) {
        this.removeWidget(msg.child);
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildShown(msg) {
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildHidden(msg) {
      }
    };
    (function(Layout5) {
      function getHorizontalAlignment(widget) {
        return Private$i2.horizontalAlignmentProperty.get(widget);
      }
      Layout5.getHorizontalAlignment = getHorizontalAlignment;
      function setHorizontalAlignment(widget, value) {
        Private$i2.horizontalAlignmentProperty.set(widget, value);
      }
      Layout5.setHorizontalAlignment = setHorizontalAlignment;
      function getVerticalAlignment(widget) {
        return Private$i2.verticalAlignmentProperty.get(widget);
      }
      Layout5.getVerticalAlignment = getVerticalAlignment;
      function setVerticalAlignment(widget, value) {
        Private$i2.verticalAlignmentProperty.set(widget, value);
      }
      Layout5.setVerticalAlignment = setVerticalAlignment;
    })(Layout2 || (Layout2 = {}));
    LayoutItem2 = class {
      /**
       * Construct a new layout item.
       *
       * @param widget - The widget to be managed by the item.
       *
       * #### Notes
       * The widget will be set to absolute positioning.
       * The widget will use strict CSS containment.
       */
      constructor(widget) {
        this._top = NaN;
        this._left = NaN;
        this._width = NaN;
        this._height = NaN;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = Infinity;
        this._maxHeight = Infinity;
        this._disposed = false;
        this.widget = widget;
        this.widget.node.style.position = "absolute";
        this.widget.node.style.contain = "strict";
      }
      /**
       * Dispose of the the layout item.
       *
       * #### Notes
       * This will reset the positioning of the widget.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        let style = this.widget.node.style;
        style.position = "";
        style.top = "";
        style.left = "";
        style.width = "";
        style.height = "";
        style.contain = "";
      }
      /**
       * The computed minimum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minWidth() {
        return this._minWidth;
      }
      /**
       * The computed minimum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minHeight() {
        return this._minHeight;
      }
      /**
       * The computed maximum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxWidth() {
        return this._maxWidth;
      }
      /**
       * The computed maximum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxHeight() {
        return this._maxHeight;
      }
      /**
       * Whether the layout item is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Whether the managed widget is hidden.
       */
      get isHidden() {
        return this.widget.isHidden;
      }
      /**
       * Whether the managed widget is visible.
       */
      get isVisible() {
        return this.widget.isVisible;
      }
      /**
       * Whether the managed widget is attached.
       */
      get isAttached() {
        return this.widget.isAttached;
      }
      /**
       * Update the computed size limits of the managed widget.
       */
      fit() {
        let limits = ElementExt.sizeLimits(this.widget.node);
        this._minWidth = limits.minWidth;
        this._minHeight = limits.minHeight;
        this._maxWidth = limits.maxWidth;
        this._maxHeight = limits.maxHeight;
      }
      /**
       * Update the position and size of the managed widget.
       *
       * @param left - The left edge position of the layout box.
       *
       * @param top - The top edge position of the layout box.
       *
       * @param width - The width of the layout box.
       *
       * @param height - The height of the layout box.
       */
      update(left, top, width, height) {
        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
        if (clampW < width) {
          switch (Layout2.getHorizontalAlignment(this.widget)) {
            case "left":
              break;
            case "center":
              left += (width - clampW) / 2;
              break;
            case "right":
              left += width - clampW;
              break;
            default:
              throw "unreachable";
          }
        }
        if (clampH < height) {
          switch (Layout2.getVerticalAlignment(this.widget)) {
            case "top":
              break;
            case "center":
              top += (height - clampH) / 2;
              break;
            case "bottom":
              top += height - clampH;
              break;
            default:
              throw "unreachable";
          }
        }
        let resized = false;
        let style = this.widget.node.style;
        if (this._top !== top) {
          this._top = top;
          style.top = `${top}px`;
        }
        if (this._left !== left) {
          this._left = left;
          style.left = `${left}px`;
        }
        if (this._width !== clampW) {
          resized = true;
          this._width = clampW;
          style.width = `${clampW}px`;
        }
        if (this._height !== clampH) {
          resized = true;
          this._height = clampH;
          style.height = `${clampH}px`;
        }
        if (resized) {
          let msg = new Widget3.ResizeMessage(clampW, clampH);
          MessageLoop3.sendMessage(this.widget, msg);
        }
      }
    };
    (function(Private22) {
      Private22.horizontalAlignmentProperty = new AttachedProperty({
        name: "horizontalAlignment",
        create: () => "center",
        changed: onAlignmentChanged
      });
      Private22.verticalAlignmentProperty = new AttachedProperty({
        name: "verticalAlignment",
        create: () => "top",
        changed: onAlignmentChanged
      });
      function onAlignmentChanged(child) {
        if (child.parent && child.parent.layout) {
          child.parent.update();
        }
      }
    })(Private$i2 || (Private$i2 = {}));
    PanelLayout3 = class extends Layout2 {
      constructor() {
        super(...arguments);
        this._widgets = [];
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        while (this._widgets.length > 0) {
          this._widgets.pop().dispose();
        }
        super.dispose();
      }
      /**
       * A read-only array of the widgets in the layout.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        yield* this._widgets;
      }
      /**
       * Add a widget to the end of the layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, it will be moved.
       */
      addWidget(widget) {
        this.insertWidget(this._widgets.length, widget);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        widget.parent = this.parent;
        let i6 = this._widgets.indexOf(widget);
        let j2 = Math.max(0, Math.min(index2, this._widgets.length));
        if (i6 === -1) {
          ArrayExt.insert(this._widgets, j2, widget);
          if (this.parent) {
            this.attachWidget(j2, widget);
          }
          return;
        }
        if (j2 === this._widgets.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._widgets, i6, j2);
        if (this.parent) {
          this.moveWidget(i6, j2, widget);
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this.removeWidgetAt(this._widgets.indexOf(widget));
      }
      /**
       * Remove the widget at a given index from the layout.
       *
       * @param index - The index of the widget to remove.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      removeWidgetAt(index2) {
        let widget = ArrayExt.removeAt(this._widgets, index2);
        if (widget && this.parent) {
          this.detachWidget(index2, widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        let index2 = 0;
        for (const widget of this) {
          this.attachWidget(index2++, widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index2, widget) {
        let ref = this.parent.node.children[index2];
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
        let ref = this.parent.node.children[toIndex];
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index2, widget) {
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
      }
    };
    (function(Utils5) {
      function clampDimension(value) {
        return Math.max(0, Math.floor(value));
      }
      Utils5.clampDimension = clampDimension;
    })(Utils2 || (Utils2 = {}));
    Utils$12 = Utils2;
    SplitLayout2 = class extends PanelLayout3 {
      /**
       * Construct a new split layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this.widgetOffset = 0;
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._hasNormedSizes = false;
        this._sizers = [];
        this._items = [];
        this._handles = [];
        this._box = null;
        this._alignment = "start";
        this._orientation = "horizontal";
        this.renderer = options.renderer;
        if (options.orientation !== void 0) {
          this._orientation = options.orientation;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils2.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        this._handles.length = 0;
        super.dispose();
      }
      /**
       * Get the layout orientation for the split layout.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the layout orientation for the split layout.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._orientation = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["orientation"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the split layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the split layout.
       */
      set spacing(value) {
        value = Utils2.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the split handles in the layout.
       */
      get handles() {
        return this._handles;
      }
      /**
       * Get the absolute sizes of the widgets in the layout.
       *
       * @returns A new array of the absolute sizes of the widgets.
       *
       * This method **does not** measure the DOM nodes.
       */
      absoluteSizes() {
        return this._sizers.map((sizer) => sizer.size);
      }
      /**
       * Get the relative sizes of the widgets in the layout.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return Private$h2.normalize(this._sizers.map((sizer) => sizer.size));
      }
      /**
       * Set the relative sizes for the widgets in the layout.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        let n5 = this._sizers.length;
        let temp = sizes.slice(0, n5);
        while (temp.length < n5) {
          temp.push(0);
        }
        let normed = Private$h2.normalize(temp);
        for (let i6 = 0; i6 < n5; ++i6) {
          let sizer = this._sizers[i6];
          sizer.sizeHint = normed[i6];
          sizer.size = normed[i6];
        }
        this._hasNormedSizes = true;
        if (update && this.parent) {
          this.parent.update();
        }
      }
      /**
       * Move the offset position of a split handle.
       *
       * @param index - The index of the handle of the interest.
       *
       * @param position - The desired offset position of the handle.
       *
       * #### Notes
       * The position is relative to the offset parent.
       *
       * This will move the handle as close as possible to the desired
       * position. The sibling widgets will be adjusted as necessary.
       */
      moveHandle(index2, position) {
        let handle = this._handles[index2];
        if (!handle || handle.classList.contains("lm-mod-hidden")) {
          return;
        }
        let delta;
        if (this._orientation === "horizontal") {
          delta = position - handle.offsetLeft;
        } else {
          delta = position - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        for (let sizer of this._sizers) {
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
        }
        BoxEngine2.adjust(this._sizers, index2, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["orientation"] = this.orientation;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        let item = new LayoutItem2(widget);
        let handle = Private$h2.createHandle(this.renderer);
        let average = Private$h2.averageSize(this._sizers);
        let sizer = Private$h2.createSizer(average);
        ArrayExt.insert(this._items, index2, item);
        ArrayExt.insert(this._sizers, index2, sizer);
        ArrayExt.insert(this._handles, index2, handle);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        ArrayExt.move(this._handles, fromIndex, toIndex);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        let handle = ArrayExt.removeAt(this._handles, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        this.parent.node.removeChild(handle);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const item = this._items[i6];
        if (item.isHidden) {
          return;
        }
        let handleStyle = this._handles[i6].style;
        if (isHorizontal) {
          left += this.widgetOffset;
          item.update(left, top, size5, height);
          left += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${this._spacing}px`;
          handleStyle.height = `${height}px`;
        } else {
          top += this.widgetOffset;
          item.update(left, top, width, size5);
          top += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${this._spacing}px`;
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        let lastHandleIndex = -1;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          if (this._items[i6].isHidden) {
            this._handles[i6].classList.add("lm-mod-hidden");
          } else {
            this._handles[i6].classList.remove("lm-mod-hidden");
            lastHandleIndex = i6;
            nVisible++;
          }
        }
        if (lastHandleIndex !== -1) {
          this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
        let horz = this._orientation === "horizontal";
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.stretch = SplitLayout2.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop3.sendMessage(this.parent.parent, Widget3.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop3.sendMessage(this.parent, Widget3.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0 && this.widgetOffset === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let extra = 0;
        let offset4 = 0;
        let horz = this._orientation === "horizontal";
        if (nVisible > 0) {
          let space;
          if (horz) {
            space = Math.max(0, width - this._fixed);
          } else {
            space = Math.max(0, height - this._fixed);
          }
          if (this._hasNormedSizes) {
            for (let sizer of this._sizers) {
              sizer.sizeHint *= space;
            }
            this._hasNormedSizes = false;
          }
          let delta = BoxEngine2.calc(this._sizers, space);
          if (delta > 0) {
            switch (this._alignment) {
              case "start":
                break;
              case "center":
                extra = 0;
                offset4 = delta / 2;
                break;
              case "end":
                extra = 0;
                offset4 = delta;
                break;
              case "justify":
                extra = delta / nVisible;
                offset4 = 0;
                break;
              default:
                throw "unreachable";
            }
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          const item = this._items[i6];
          const size5 = item.isHidden ? 0 : this._sizers[i6].size + extra;
          this.updateItemPosition(i6, horz, horz ? left + offset4 : left, horz ? top : top + offset4, height, width, size5);
          const fullOffset = this.widgetOffset + (this._handles[i6].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
          if (horz) {
            left += size5 + fullOffset;
          } else {
            top += size5 + fullOffset;
          }
        }
      }
    };
    (function(SplitLayout5) {
      function getStretch(widget) {
        return Private$h2.stretchProperty.get(widget);
      }
      SplitLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$h2.stretchProperty.set(widget, value);
      }
      SplitLayout5.setStretch = setStretch;
    })(SplitLayout2 || (SplitLayout2 = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function createSizer(size5) {
        let sizer = new BoxSizer2();
        sizer.sizeHint = Math.floor(size5);
        return sizer;
      }
      Private22.createSizer = createSizer;
      function createHandle(renderer) {
        let handle = renderer.createHandle();
        handle.style.position = "absolute";
        handle.style.contain = "style";
        return handle;
      }
      Private22.createHandle = createHandle;
      function averageSize(sizers) {
        return sizers.reduce((v4, s8) => v4 + s8.size, 0) / sizers.length || 0;
      }
      Private22.averageSize = averageSize;
      function normalize2(values2) {
        let n5 = values2.length;
        if (n5 === 0) {
          return [];
        }
        let sum = values2.reduce((a3, b2) => a3 + Math.abs(b2), 0);
        return sum === 0 ? values2.map((v4) => 1 / n5) : values2.map((v4) => v4 / sum);
      }
      Private22.normalize = normalize2;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof SplitLayout2) {
          child.parent.fit();
        }
      }
    })(Private$h2 || (Private$h2 = {}));
    AccordionLayout2 = class extends SplitLayout2 {
      /**
       * Construct a new accordion layout.
       *
       * @param options - The options for initializing the layout.
       *
       * #### Notes
       * The default orientation will be vertical.
       *
       * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
       */
      constructor(options) {
        super({ ...options, orientation: options.orientation || "vertical" });
        this._titles = [];
        this.titleSpace = options.titleSpace || 22;
      }
      /**
       * The section title height or width depending on the orientation.
       */
      get titleSpace() {
        return this.widgetOffset;
      }
      set titleSpace(value) {
        value = Utils$12.clampDimension(value);
        if (this.widgetOffset === value) {
          return;
        }
        this.widgetOffset = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this._titles;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._titles.length = 0;
        super.dispose();
      }
      updateTitle(index2, widget) {
        const oldTitle = this._titles[index2];
        const expanded = oldTitle.classList.contains("lm-mod-expanded");
        const newTitle = Private$g2.createTitle(this.renderer, widget.title, expanded);
        this._titles[index2] = newTitle;
        this.parent.node.replaceChild(newTitle, oldTitle);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        if (!widget.id) {
          widget.id = `id-${import_coreutils3.UUID.uuid4()}`;
        }
        super.insertWidget(index2, widget);
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(index2, widget) {
        const title = Private$g2.createTitle(this.renderer, widget.title);
        ArrayExt.insert(this._titles, index2, title);
        this.parent.node.appendChild(title);
        widget.node.setAttribute("role", "region");
        widget.node.setAttribute("aria-labelledby", title.id);
        super.attachWidget(index2, widget);
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._titles, fromIndex, toIndex);
        super.moveWidget(fromIndex, toIndex, widget);
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        const title = ArrayExt.removeAt(this._titles, index2);
        this.parent.node.removeChild(title);
        super.detachWidget(index2, widget);
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const titleStyle = this._titles[i6].style;
        titleStyle.top = `${top}px`;
        titleStyle.left = `${left}px`;
        titleStyle.height = `${this.widgetOffset}px`;
        if (isHorizontal) {
          titleStyle.width = `${height}px`;
        } else {
          titleStyle.width = `${width}px`;
        }
        super.updateItemPosition(i6, isHorizontal, left, top, height, width, size5);
      }
    };
    (function(Private22) {
      function createTitle(renderer, data, expanded = true) {
        const title = renderer.createSectionTitle(data);
        title.style.position = "absolute";
        title.style.contain = "strict";
        title.setAttribute("aria-label", `${data.label} Section`);
        title.setAttribute("aria-expanded", expanded ? "true" : "false");
        title.setAttribute("aria-controls", data.owner.id);
        if (expanded) {
          title.classList.add("lm-mod-expanded");
        }
        return title;
      }
      Private22.createTitle = createTitle;
    })(Private$g2 || (Private$g2 = {}));
    Panel3 = class extends Widget3 {
      /**
       * Construct a new panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this.addClass("lm-Panel");
        this.layout = Private$f2.createLayout(options);
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        this.layout.addWidget(widget);
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        this.layout.insertWidget(index2, widget);
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new PanelLayout3();
      }
      Private22.createLayout = createLayout;
    })(Private$f2 || (Private$f2 = {}));
    SplitPanel2 = class extends Panel3 {
      /**
       * Construct a new split panel.
       *
       * @param options - The options for initializing the split panel.
       */
      constructor(options = {}) {
        super({ layout: Private$e2.createLayout(options) });
        this._handleMoved = new Signal(this);
        this._pressData = null;
        this.addClass("lm-SplitPanel");
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        super.dispose();
      }
      /**
       * Get the layout orientation for the split panel.
       */
      get orientation() {
        return this.layout.orientation;
      }
      /**
       * Set the layout orientation for the split panel.
       */
      set orientation(value) {
        this.layout.orientation = value;
      }
      /**
       * Get the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the split panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the split panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * The renderer used by the split panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * A signal emitted when a split handle has moved.
       */
      get handleMoved() {
        return this._handleMoved;
      }
      /**
       * A read-only array of the split handles in the panel.
       */
      get handles() {
        return this.layout.handles;
      }
      /**
       * Get the relative sizes of the widgets in the panel.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return this.layout.relativeSizes();
      }
      /**
       * Set the relative sizes for the widgets in the panel.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        this.layout.setRelativeSizes(sizes, update);
      }
      /**
       * Handle the DOM events for the split panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * Handle the `'keydown'` event for the split panel.
       */
      _evtKeyDown(event) {
        if (this._pressData) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (event.keyCode === 27) {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'pointerdown'` event for the split panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let index2 = ArrayExt.findFirstIndex(layout.handles, (handle2) => {
          return handle2.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("contextmenu", this, true);
        let delta;
        let handle = layout.handles[index2];
        let rect = handle.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          delta = event.clientX - rect.left;
        } else {
          delta = event.clientY - rect.top;
        }
        let style = window.getComputedStyle(handle);
        let override = Drag2.overrideCursor(style.cursor);
        this._pressData = { index: index2, delta, override };
      }
      /**
       * Handle the `'pointermove'` event for the split panel.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        let pos;
        let layout = this.layout;
        let rect = this.node.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          pos = event.clientX - rect.left - this._pressData.delta;
        } else {
          pos = event.clientY - rect.top - this._pressData.delta;
        }
        layout.moveHandle(this._pressData.index, pos);
      }
      /**
       * Handle the `'pointerup'` event for the split panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
      }
      /**
       * Release the mouse grab for the split panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._handleMoved.emit();
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
    };
    (function(SplitPanel5) {
      class Renderer {
        /**
         * Create a new handle for use with a split panel.
         *
         * @returns A new handle element for a split panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-SplitPanel-handle";
          return handle;
        }
      }
      SplitPanel5.Renderer = Renderer;
      SplitPanel5.defaultRenderer = new Renderer();
      function getStretch(widget) {
        return SplitLayout2.getStretch(widget);
      }
      SplitPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        SplitLayout2.setStretch(widget, value);
      }
      SplitPanel5.setStretch = setStretch;
    })(SplitPanel2 || (SplitPanel2 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new SplitLayout2({
          renderer: options.renderer || SplitPanel2.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing
        });
      }
      Private22.createLayout = createLayout;
    })(Private$e2 || (Private$e2 = {}));
    AccordionPanel2 = class extends SplitPanel2 {
      /**
       * Construct a new accordion panel.
       *
       * @param options - The options for initializing the accordion panel.
       *
       */
      constructor(options = {}) {
        super({ ...options, layout: Private$d2.createLayout(options) });
        this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
        this._expansionToggled = new Signal(this);
        this.addClass("lm-AccordionPanel");
      }
      /**
       * The renderer used by the accordion panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * The section title space.
       *
       * This is the height if the panel is vertical and the width if it is
       * horizontal.
       */
      get titleSpace() {
        return this.layout.titleSpace;
      }
      set titleSpace(value) {
        this.layout.titleSpace = value;
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this.layout.titles;
      }
      /**
       * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
       */
      get expansionToggled() {
        return this._expansionToggled;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        super.addWidget(widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Collapse the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      collapse(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && !widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Expand the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      expand(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        super.insertWidget(index2, widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Handle the DOM events for the accordion panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        super.handleEvent(event);
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._eventKeyDown(event);
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        super.onBeforeAttach(msg);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        super.onAfterDetach(msg);
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        const index2 = ArrayExt.findFirstIndex(this.widgets, (widget) => {
          return widget.contains(sender.owner);
        });
        if (index2 >= 0) {
          this.layout.updateTitle(index2, sender.owner);
          this.update();
        }
      }
      /**
       * Compute the size of widgets in this panel on the title click event.
       * On closing, the size of the widget is cached and we will try to expand
       * the last opened widget.
       * On opening, we will use the cached size if it is available to restore the
       * widget.
       * In both cases, if we can not compute the size of widgets, we will let
       * `SplitLayout` decide.
       *
       * @param index - The index of widget to be opened of closed
       *
       * @returns Relative size of widgets in this panel, if this size can
       * not be computed, return `undefined`
       */
      _computeWidgetSize(index2) {
        const layout = this.layout;
        const widget = layout.widgets[index2];
        if (!widget) {
          return void 0;
        }
        const isHidden2 = widget.isHidden;
        const widgetSizes = layout.absoluteSizes();
        const delta = (isHidden2 ? -1 : 1) * this.spacing;
        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
        let newSize = [...widgetSizes];
        if (!isHidden2) {
          const currentSize = widgetSizes[index2];
          this._widgetSizesCache.set(widget, currentSize);
          newSize[index2] = 0;
          const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            return void 0;
          }
          newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
        } else {
          const previousSize = this._widgetSizesCache.get(widget);
          if (!previousSize) {
            return void 0;
          }
          newSize[index2] += previousSize;
          const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            newSize.forEach((_4, idx) => {
              if (idx !== index2) {
                newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
              }
            });
          } else {
            newSize[widgetToCollapse] -= previousSize - delta;
          }
        }
        return newSize.map((sz) => sz / (totalSize + delta));
      }
      /**
       * Handle the `'click'` event for the accordion panel
       */
      _evtClick(event) {
        const target = event.target;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            event.preventDefault();
            event.stopPropagation();
            this._toggleExpansion(index2);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the accordion panel.
       */
      _eventKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const target = event.target;
        let handled = false;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            const keyCode = event.keyCode.toString();
            if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
              target.click();
              handled = true;
            } else if (this.orientation === "horizontal" ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
              const direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
              const length = this.titles.length;
              const newIndex = (index2 + length + direction) % length;
              this.titles[newIndex].focus();
              handled = true;
            } else if (event.key === "End" || keyCode === "35") {
              this.titles[this.titles.length - 1].focus();
              handled = true;
            } else if (event.key === "Home" || keyCode === "36") {
              this.titles[0].focus();
              handled = true;
            }
          }
          if (handled) {
            event.preventDefault();
          }
        }
      }
      _toggleExpansion(index2) {
        const title = this.titles[index2];
        const widget = this.layout.widgets[index2];
        const newSize = this._computeWidgetSize(index2);
        if (newSize) {
          this.setRelativeSizes(newSize, false);
        }
        if (widget.isHidden) {
          title.classList.add("lm-mod-expanded");
          title.setAttribute("aria-expanded", "true");
          widget.show();
        } else {
          title.classList.remove("lm-mod-expanded");
          title.setAttribute("aria-expanded", "false");
          widget.hide();
        }
        this._expansionToggled.emit(index2);
      }
    };
    (function(AccordionPanel5) {
      class Renderer extends SplitPanel2.Renderer {
        constructor() {
          super();
          this.titleClassName = "lm-AccordionPanel-title";
          this._titleID = 0;
          this._titleKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the collapse indicator for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the collapse indicator.
         */
        createCollapseIcon(data) {
          return document.createElement("span");
        }
        /**
         * Render the element for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the section title.
         */
        createSectionTitle(data) {
          const handle = document.createElement("h3");
          handle.setAttribute("tabindex", "0");
          handle.id = this.createTitleKey(data);
          handle.className = this.titleClassName;
          for (const aData in data.dataset) {
            handle.dataset[aData] = data.dataset[aData];
          }
          const collapser = handle.appendChild(this.createCollapseIcon(data));
          collapser.className = "lm-AccordionPanel-titleCollapser";
          const label = handle.appendChild(document.createElement("span"));
          label.className = "lm-AccordionPanel-titleLabel";
          label.textContent = data.label;
          label.title = data.caption || data.label;
          return handle;
        }
        /**
         * Create a unique render key for the title.
         *
         * @param data - The data to use for the title.
         *
         * @returns The unique render key for the title.
         *
         * #### Notes
         * This method caches the key against the section title the first time
         * the key is generated.
         */
        createTitleKey(data) {
          let key = this._titleKeys.get(data);
          if (key === void 0) {
            key = `title-key-${this._uuid}-${this._titleID++}`;
            this._titleKeys.set(data, key);
          }
          return key;
        }
      }
      Renderer._nInstance = 0;
      AccordionPanel5.Renderer = Renderer;
      AccordionPanel5.defaultRenderer = new Renderer();
    })(AccordionPanel2 || (AccordionPanel2 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new AccordionLayout2({
          renderer: options.renderer || AccordionPanel2.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing,
          titleSpace: options.titleSpace
        });
      }
      Private22.createLayout = createLayout;
    })(Private$d2 || (Private$d2 = {}));
    BoxLayout2 = class extends PanelLayout3 {
      /**
       * Construct a new box layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super();
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._sizers = [];
        this._items = [];
        this._box = null;
        this._alignment = "start";
        this._direction = "top-to-bottom";
        if (options.direction !== void 0) {
          this._direction = options.direction;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils$12.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        super.dispose();
      }
      /**
       * Get the layout direction for the box layout.
       */
      get direction() {
        return this._direction;
      }
      /**
       * Set the layout direction for the box layout.
       */
      set direction(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["direction"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the box layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the box layout.
       */
      set spacing(value) {
        value = Utils$12.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["direction"] = this.direction;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        ArrayExt.insert(this._items, index2, new LayoutItem2(widget));
        ArrayExt.insert(this._sizers, index2, new BoxSizer2());
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        let horz = Private$c2.isHorizontal(this._direction);
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.sizeHint = BoxLayout2.getSizeBasis(item.widget);
          sizer.stretch = BoxLayout2.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop3.sendMessage(this.parent.parent, Widget3.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop3.sendMessage(this.parent, Widget3.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let delta;
        switch (this._direction) {
          case "left-to-right":
            delta = BoxEngine2.calc(this._sizers, Math.max(0, width - this._fixed));
            break;
          case "top-to-bottom":
            delta = BoxEngine2.calc(this._sizers, Math.max(0, height - this._fixed));
            break;
          case "right-to-left":
            delta = BoxEngine2.calc(this._sizers, Math.max(0, width - this._fixed));
            left += width;
            break;
          case "bottom-to-top":
            delta = BoxEngine2.calc(this._sizers, Math.max(0, height - this._fixed));
            top += height;
            break;
          default:
            throw "unreachable";
        }
        let extra = 0;
        let offset4 = 0;
        if (delta > 0) {
          switch (this._alignment) {
            case "start":
              break;
            case "center":
              extra = 0;
              offset4 = delta / 2;
              break;
            case "end":
              extra = 0;
              offset4 = delta;
              break;
            case "justify":
              extra = delta / nVisible;
              offset4 = 0;
              break;
            default:
              throw "unreachable";
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let size5 = this._sizers[i6].size;
          switch (this._direction) {
            case "left-to-right":
              item.update(left + offset4, top, size5 + extra, height);
              left += size5 + extra + this._spacing;
              break;
            case "top-to-bottom":
              item.update(left, top + offset4, width, size5 + extra);
              top += size5 + extra + this._spacing;
              break;
            case "right-to-left":
              item.update(left - offset4 - size5 - extra, top, size5 + extra, height);
              left -= size5 + extra + this._spacing;
              break;
            case "bottom-to-top":
              item.update(left, top - offset4 - size5 - extra, width, size5 + extra);
              top -= size5 + extra + this._spacing;
              break;
            default:
              throw "unreachable";
          }
        }
      }
    };
    (function(BoxLayout5) {
      function getStretch(widget) {
        return Private$c2.stretchProperty.get(widget);
      }
      BoxLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$c2.stretchProperty.set(widget, value);
      }
      BoxLayout5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return Private$c2.sizeBasisProperty.get(widget);
      }
      BoxLayout5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        Private$c2.sizeBasisProperty.set(widget, value);
      }
      BoxLayout5.setSizeBasis = setSizeBasis;
    })(BoxLayout2 || (BoxLayout2 = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      Private22.sizeBasisProperty = new AttachedProperty({
        name: "sizeBasis",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function isHorizontal(dir) {
        return dir === "left-to-right" || dir === "right-to-left";
      }
      Private22.isHorizontal = isHorizontal;
      function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampSpacing = clampSpacing;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof BoxLayout2) {
          child.parent.fit();
        }
      }
    })(Private$c2 || (Private$c2 = {}));
    BoxPanel2 = class extends Panel3 {
      /**
       * Construct a new box panel.
       *
       * @param options - The options for initializing the box panel.
       */
      constructor(options = {}) {
        super({ layout: Private$b2.createLayout(options) });
        this.addClass("lm-BoxPanel");
      }
      /**
       * Get the layout direction for the box panel.
       */
      get direction() {
        return this.layout.direction;
      }
      /**
       * Set the layout direction for the box panel.
       */
      set direction(value) {
        this.layout.direction = value;
      }
      /**
       * Get the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the box panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the box panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-BoxPanel-child");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-BoxPanel-child");
      }
    };
    (function(BoxPanel5) {
      function getStretch(widget) {
        return BoxLayout2.getStretch(widget);
      }
      BoxPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        BoxLayout2.setStretch(widget, value);
      }
      BoxPanel5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return BoxLayout2.getSizeBasis(widget);
      }
      BoxPanel5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        BoxLayout2.setSizeBasis(widget, value);
      }
      BoxPanel5.setSizeBasis = setSizeBasis;
    })(BoxPanel2 || (BoxPanel2 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new BoxLayout2(options);
      }
      Private22.createLayout = createLayout;
    })(Private$b2 || (Private$b2 = {}));
    CommandPalette2 = class extends Widget3 {
      /**
       * Construct a new command palette.
       *
       * @param options - The options for initializing the palette.
       */
      constructor(options) {
        super({ node: Private$a2.createNode() });
        this._activeIndex = -1;
        this._items = [];
        this._results = null;
        this.addClass("lm-CommandPalette");
        this.setFlag(Widget3.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || CommandPalette2.defaultRenderer;
        this.commands.commandChanged.connect(this._onGenericChange, this);
        this.commands.keyBindingChanged.connect(this._onGenericChange, this);
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._items.length = 0;
        this._results = null;
        super.dispose();
      }
      /**
       * The command palette search node.
       *
       * #### Notes
       * This is the node which contains the search-related elements.
       */
      get searchNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
      }
      /**
       * The command palette input node.
       *
       * #### Notes
       * This is the actual input node for the search area.
       */
      get inputNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
      }
      /**
       * The command palette content node.
       *
       * #### Notes
       * This is the node which holds the command item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
      }
      /**
       * A read-only array of the command items in the palette.
       */
      get items() {
        return this._items;
      }
      /**
       * Add a command item to the command palette.
       *
       * @param options - The options for creating the command item.
       *
       * @returns The command item added to the palette.
       */
      addItem(options) {
        let item = Private$a2.createItem(this.commands, options);
        this._items.push(item);
        this.refresh();
        return item;
      }
      /**
       * Adds command items to the command palette.
       *
       * @param items - An array of options for creating each command item.
       *
       * @returns The command items added to the palette.
       */
      addItems(items) {
        const newItems = items.map((item) => Private$a2.createItem(this.commands, item));
        newItems.forEach((item) => this._items.push(item));
        this.refresh();
        return newItems;
      }
      /**
       * Remove an item from the command palette.
       *
       * @param item - The item to remove from the palette.
       *
       * #### Notes
       * This is a no-op if the item is not in the palette.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the command palette.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.refresh();
      }
      /**
       * Remove all items from the command palette.
       */
      clearItems() {
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.refresh();
      }
      /**
       * Clear the search results and schedule an update.
       *
       * #### Notes
       * This should be called whenever the search results of the palette
       * should be updated.
       *
       * This is typically called automatically by the palette as needed,
       * but can be called manually if the input text is programatically
       * changed.
       *
       * The rendered results are updated asynchronously.
       */
      refresh() {
        this._results = null;
        if (this.inputNode.value !== "") {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "inherit";
        } else {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "none";
        }
        this.update();
      }
      /**
       * Handle the DOM events for the command palette.
       *
       * @param event - The DOM event sent to the command palette.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the command palette's DOM node.
       * It should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "input":
            this.refresh();
            break;
          case "focus":
          case "blur":
            this._toggleFocused();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("input", this);
        this.node.addEventListener("focus", this, true);
        this.node.addEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("input", this);
        this.node.removeEventListener("focus", this, true);
        this.node.removeEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       */
      onAfterShow(msg) {
        this.update();
        super.onAfterShow(msg);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          let input = this.inputNode;
          input.focus();
          input.select();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (!this.isVisible) {
          VirtualDOM.render(null, this.contentNode);
          return;
        }
        let query = this.inputNode.value;
        let contentNode = this.contentNode;
        let results = this._results;
        if (!results) {
          results = this._results = Private$a2.search(this._items, query);
          this._activeIndex = query ? ArrayExt.findFirstIndex(results, Private$a2.canActivate) : -1;
        }
        if (!query && results.length === 0) {
          VirtualDOM.render(null, contentNode);
          return;
        }
        if (query && results.length === 0) {
          let content2 = this.renderer.renderEmptyMessage({ query });
          VirtualDOM.render(content2, contentNode);
          return;
        }
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let content = new Array(results.length);
        for (let i6 = 0, n5 = results.length; i6 < n5; ++i6) {
          let result2 = results[i6];
          if (result2.type === "header") {
            let indices = result2.indices;
            let category = result2.category;
            content[i6] = renderer.renderHeader({ category, indices });
          } else {
            let item = result2.item;
            let indices = result2.indices;
            let active = i6 === activeIndex;
            content[i6] = renderer.renderItem({ item, indices, active });
          }
        }
        VirtualDOM.render(content, contentNode);
        if (activeIndex < 0 || activeIndex >= results.length) {
          contentNode.scrollTop = 0;
        } else {
          let element2 = contentNode.children[activeIndex];
          ElementExt.scrollIntoViewIfNeeded(contentNode, element2);
        }
      }
      /**
       * Handle the `'click'` event for the command palette.
       */
      _evtClick(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.target.classList.contains("lm-close-icon")) {
          this.inputNode.value = "";
          this.refresh();
          return;
        }
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return node.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._execute(index2);
      }
      /**
       * Handle the `'keydown'` event for the command palette.
       */
      _evtKeyDown(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        switch (event.keyCode) {
          case 13:
            event.preventDefault();
            event.stopPropagation();
            this._execute(this._activeIndex);
            break;
          case 38:
            event.preventDefault();
            event.stopPropagation();
            this._activatePreviousItem();
            break;
          case 40:
            event.preventDefault();
            event.stopPropagation();
            this._activateNextItem();
            break;
        }
      }
      /**
       * Activate the next enabled command item.
       */
      _activateNextItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this._activeIndex = ArrayExt.findFirstIndex(this._results, Private$a2.canActivate, start, stop);
        this.update();
      }
      /**
       * Activate the previous enabled command item.
       */
      _activatePreviousItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this._activeIndex = ArrayExt.findLastIndex(this._results, Private$a2.canActivate, start, stop);
        this.update();
      }
      /**
       * Execute the command item at the given index, if possible.
       */
      _execute(index2) {
        if (!this._results) {
          return;
        }
        let part = this._results[index2];
        if (!part) {
          return;
        }
        if (part.type === "header") {
          let input = this.inputNode;
          input.value = `${part.category.toLowerCase()} `;
          input.focus();
          this.refresh();
          return;
        }
        if (!part.item.isEnabled) {
          return;
        }
        this.commands.execute(part.item.command, part.item.args);
        this.inputNode.value = "";
        this.refresh();
      }
      /**
       * Toggle the focused modifier based on the input node focus state.
       */
      _toggleFocused() {
        let focused = document.activeElement === this.inputNode;
        this.toggleClass("lm-mod-focused", focused);
      }
      /**
       * A signal handler for generic command changes.
       */
      _onGenericChange() {
        this.refresh();
      }
    };
    (function(CommandPalette5) {
      class Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          let content = this.formatHeader(data);
          return h.li({ className: "lm-CommandPalette-header" }, content);
        }
        /**
         * Render the virtual element for a command palette item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          if (data.item.isToggleable) {
            return h.li({
              className,
              dataset,
              role: "menuitemcheckbox",
              "aria-checked": `${data.item.isToggled}`
            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
          }
          return h.li({
            className,
            dataset,
            role: "menuitem"
          }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
        }
        /**
         * Render the empty results message for a command palette.
         *
         * @param data - The data to use for rendering the message.
         *
         * @returns A virtual element representing the message.
         */
        renderEmptyMessage(data) {
          let content = this.formatEmptyMessage(data);
          return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the content for a command palette item.
         *
         * @param data - The data to use for rendering the content.
         *
         * @returns A virtual element representing the content.
         */
        renderItemContent(data) {
          return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
        }
        /**
         * Render the label for a command palette item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the label.
         */
        renderItemLabel(data) {
          let content = this.formatItemLabel(data);
          return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
        }
        /**
         * Render the caption for a command palette item.
         *
         * @param data - The data to use for rendering the caption.
         *
         * @returns A virtual element representing the caption.
         */
        renderItemCaption(data) {
          let content = this.formatItemCaption(data);
          return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
        }
        /**
         * Render the shortcut for a command palette item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the shortcut.
         */
        renderItemShortcut(data) {
          let content = this.formatItemShortcut(data);
          return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
        }
        /**
         * Create the class name for the command palette item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the command palette item.
         */
        createItemClass(data) {
          let name = "lm-CommandPalette-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the command palette item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the command palette item.
         */
        createItemDataset(data) {
          return { ...data.item.dataset, command: data.item.command };
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-CommandPalette-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the header node.
         *
         * @param data - The data to use for the header content.
         *
         * @returns The content to add to the header node.
         */
        formatHeader(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.category;
          }
          return StringExt.highlight(data.category, data.indices, h.mark);
        }
        /**
         * Create the render content for the empty message node.
         *
         * @param data - The data to use for the empty message content.
         *
         * @returns The content to add to the empty message node.
         */
        formatEmptyMessage(data) {
          return `No commands found that match '${data.query}'`;
        }
        /**
         * Create the render content for the item shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatItemShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
        /**
         * Create the render content for the item label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatItemLabel(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.item.label;
          }
          return StringExt.highlight(data.item.label, data.indices, h.mark);
        }
        /**
         * Create the render content for the item caption node.
         *
         * @param data - The data to use for the caption content.
         *
         * @returns The content to add to the caption node.
         */
        formatItemCaption(data) {
          return data.item.caption;
        }
      }
      CommandPalette5.Renderer = Renderer;
      CommandPalette5.defaultRenderer = new Renderer();
    })(CommandPalette2 || (CommandPalette2 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let search2 = document.createElement("div");
        let wrapper = document.createElement("div");
        let input = document.createElement("input");
        let content = document.createElement("ul");
        let clear = document.createElement("button");
        search2.className = "lm-CommandPalette-search";
        wrapper.className = "lm-CommandPalette-wrapper";
        input.className = "lm-CommandPalette-input";
        clear.className = "lm-close-icon";
        content.className = "lm-CommandPalette-content";
        content.setAttribute("role", "menu");
        input.spellcheck = false;
        wrapper.appendChild(input);
        wrapper.appendChild(clear);
        search2.appendChild(wrapper);
        node.appendChild(search2);
        node.appendChild(content);
        return node;
      }
      Private22.createNode = createNode;
      function createItem(commands, options) {
        return new CommandItem(commands, options);
      }
      Private22.createItem = createItem;
      function search(items, query) {
        let scores = matchItems(items, query);
        scores.sort(scoreCmp);
        return createResults(scores);
      }
      Private22.search = search;
      function canActivate(result2) {
        return result2.type === "item" && result2.item.isEnabled;
      }
      Private22.canActivate = canActivate;
      function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, " ");
      }
      function normalizeQuery(text) {
        return text.replace(/\s+/g, "").toLowerCase();
      }
      function matchItems(items, query) {
        query = normalizeQuery(query);
        let scores = [];
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          if (!item.isVisible) {
            continue;
          }
          if (!query) {
            scores.push({
              matchType: 3,
              categoryIndices: null,
              labelIndices: null,
              score: 0,
              item
            });
            continue;
          }
          let score = fuzzySearch(item, query);
          if (!score) {
            continue;
          }
          if (!item.isEnabled) {
            score.score += 1e3;
          }
          scores.push(score);
        }
        return scores;
      }
      function fuzzySearch(item, query) {
        let category = item.category.toLowerCase();
        let label = item.label.toLowerCase();
        let source = `${category} ${label}`;
        let score = Infinity;
        let indices = null;
        let rgx = /\b\w/g;
        while (true) {
          let rgxMatch = rgx.exec(source);
          if (!rgxMatch) {
            break;
          }
          let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);
          if (!match) {
            break;
          }
          if (match.score <= score) {
            score = match.score;
            indices = match.indices;
          }
        }
        if (!indices || score === Infinity) {
          return null;
        }
        let pivot = category.length + 1;
        let j2 = ArrayExt.lowerBound(indices, pivot, (a3, b2) => a3 - b2);
        let categoryIndices = indices.slice(0, j2);
        let labelIndices = indices.slice(j2);
        for (let i6 = 0, n5 = labelIndices.length; i6 < n5; ++i6) {
          labelIndices[i6] -= pivot;
        }
        if (categoryIndices.length === 0) {
          return {
            matchType: 0,
            categoryIndices: null,
            labelIndices,
            score,
            item
          };
        }
        if (labelIndices.length === 0) {
          return {
            matchType: 1,
            categoryIndices,
            labelIndices: null,
            score,
            item
          };
        }
        return {
          matchType: 2,
          categoryIndices,
          labelIndices,
          score,
          item
        };
      }
      function scoreCmp(a3, b2) {
        let m1 = a3.matchType - b2.matchType;
        if (m1 !== 0) {
          return m1;
        }
        let d1 = a3.score - b2.score;
        if (d1 !== 0) {
          return d1;
        }
        let i1 = 0;
        let i22 = 0;
        switch (a3.matchType) {
          case 0:
            i1 = a3.labelIndices[0];
            i22 = b2.labelIndices[0];
            break;
          case 1:
          case 2:
            i1 = a3.categoryIndices[0];
            i22 = b2.categoryIndices[0];
            break;
        }
        if (i1 !== i22) {
          return i1 - i22;
        }
        let d22 = a3.item.category.localeCompare(b2.item.category);
        if (d22 !== 0) {
          return d22;
        }
        let r1 = a3.item.rank;
        let r22 = b2.item.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.item.label.localeCompare(b2.item.label);
      }
      function createResults(scores) {
        let results = [];
        for (let i6 = 0, n5 = scores.length; i6 < n5; ++i6) {
          let { item, categoryIndices, labelIndices } = scores[i6];
          let category = item.category;
          if (i6 === 0 || category !== scores[i6 - 1].item.category) {
            results.push({ type: "header", category, indices: categoryIndices });
          }
          results.push({ type: "item", item, indices: labelIndices });
        }
        return results;
      }
      class CommandItem {
        /**
         * Construct a new command item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.category = normalizeCategory(options.category);
          this.command = options.command;
          this.args = options.args || import_coreutils3.JSONExt.emptyObject;
          this.rank = options.rank !== void 0 ? options.rank : Infinity;
        }
        /**
         * The display label for the command item.
         */
        get label() {
          return this._commands.label(this.command, this.args);
        }
        /**
         * The icon renderer for the command item.
         */
        get icon() {
          return this._commands.icon(this.command, this.args);
        }
        /**
         * The icon class for the command item.
         */
        get iconClass() {
          return this._commands.iconClass(this.command, this.args);
        }
        /**
         * The icon label for the command item.
         */
        get iconLabel() {
          return this._commands.iconLabel(this.command, this.args);
        }
        /**
         * The display caption for the command item.
         */
        get caption() {
          return this._commands.caption(this.command, this.args);
        }
        /**
         * The extra class name for the command item.
         */
        get className() {
          return this._commands.className(this.command, this.args);
        }
        /**
         * The dataset for the command item.
         */
        get dataset() {
          return this._commands.dataset(this.command, this.args);
        }
        /**
         * Whether the command item is enabled.
         */
        get isEnabled() {
          return this._commands.isEnabled(this.command, this.args);
        }
        /**
         * Whether the command item is toggled.
         */
        get isToggled() {
          return this._commands.isToggled(this.command, this.args);
        }
        /**
         * Whether the command item is toggleable.
         */
        get isToggleable() {
          return this._commands.isToggleable(this.command, this.args);
        }
        /**
         * Whether the command item is visible.
         */
        get isVisible() {
          return this._commands.isVisible(this.command, this.args);
        }
        /**
         * The key binding for the command item.
         */
        get keyBinding() {
          let { command, args } = this;
          return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
            return kb.command === command && import_coreutils3.JSONExt.deepEqual(kb.args, args);
          }) || null;
        }
      }
    })(Private$a2 || (Private$a2 = {}));
    Menu2 = class extends Widget3 {
      /**
       * Construct a new menu.
       *
       * @param options - The options for initializing the menu.
       */
      constructor(options) {
        super({ node: Private$92.createNode() });
        this._childIndex = -1;
        this._activeIndex = -1;
        this._openTimerID = 0;
        this._closeTimerID = 0;
        this._items = [];
        this._childMenu = null;
        this._parentMenu = null;
        this._aboutToClose = new Signal(this);
        this._menuRequested = new Signal(this);
        this.addClass("lm-Menu");
        this.setFlag(Widget3.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || Menu2.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the menu.
       */
      dispose() {
        this.close();
        this._items.length = 0;
        super.dispose();
      }
      /**
       * A signal emitted just before the menu is closed.
       *
       * #### Notes
       * This signal is emitted when the menu receives a `'close-request'`
       * message, just before it removes itself from the DOM.
       *
       * This signal is not emitted if the menu is already detached from
       * the DOM when it receives the `'close-request'` message.
       */
      get aboutToClose() {
        return this._aboutToClose;
      }
      /**
       * A signal emitted when a new menu is requested by the user.
       *
       * #### Notes
       * This signal is emitted whenever the user presses the right or left
       * arrow keys, and a submenu cannot be opened or closed in response.
       *
       * This signal is useful when implementing menu bars in order to open
       * the next or previous menu in response to a user key press.
       *
       * This signal is only emitted for the root menu in a hierarchy.
       */
      get menuRequested() {
        return this._menuRequested;
      }
      /**
       * The parent menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu is an open submenu.
       */
      get parentMenu() {
        return this._parentMenu;
      }
      /**
       * The child menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu has an open submenu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The root menu of the menu hierarchy.
       */
      get rootMenu() {
        let menu = this;
        while (menu._parentMenu) {
          menu = menu._parentMenu;
        }
        return menu;
      }
      /**
       * The leaf menu of the menu hierarchy.
       */
      get leafMenu() {
        let menu = this;
        while (menu._childMenu) {
          menu = menu._childMenu;
        }
        return menu;
      }
      /**
       * The menu content node.
       *
       * #### Notes
       * This is the node which holds the menu item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-Menu-content")[0];
      }
      /**
       * Get the currently active menu item.
       */
      get activeItem() {
        return this._items[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the item will be set to `null`.
       */
      set activeItem(value) {
        this.activeIndex = value ? this._items.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu item.
       *
       * #### Notes
       * This will be `-1` if no menu item is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._items.length) {
          value = -1;
        }
        if (value !== -1 && !Private$92.canActivate(this._items[value])) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
          this.contentNode.childNodes[this._activeIndex].focus();
        }
        this.update();
      }
      /**
       * A read-only array of the menu items in the menu.
       */
      get items() {
        return this._items;
      }
      /**
       * Activate the next selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activateNextItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this.activeIndex = ArrayExt.findFirstIndex(this._items, Private$92.canActivate, start, stop);
      }
      /**
       * Activate the previous selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activatePreviousItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this.activeIndex = ArrayExt.findLastIndex(this._items, Private$92.canActivate, start, stop);
      }
      /**
       * Trigger the active menu item.
       *
       * #### Notes
       * If the active item is a submenu, it will be opened and the first
       * item will be activated.
       *
       * If the active item is a command, the command will be executed.
       *
       * If the menu is not attached, this is a no-op.
       *
       * If there is no active item, this is a no-op.
       */
      triggerActiveItem() {
        if (!this.isAttached) {
          return;
        }
        let item = this.activeItem;
        if (!item) {
          return;
        }
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        if (item.type === "submenu") {
          this._openChildMenu(true);
          return;
        }
        this.rootMenu.close();
        let { command, args } = item;
        if (this.commands.isEnabled(command, args)) {
          this.commands.execute(command, args);
        } else {
          console.log(`Command '${command}' is disabled.`);
        }
      }
      /**
       * Add a menu item to the end of the menu.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       */
      addItem(options) {
        return this.insertItem(this._items.length, options);
      }
      /**
       * Insert a menu item into the menu at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index2, options) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let i6 = Math.max(0, Math.min(index2, this._items.length));
        let item = Private$92.createItem(this, options);
        ArrayExt.insert(this._items, i6, item);
        this.update();
        return item;
      }
      /**
       * Remove an item from the menu.
       *
       * @param item - The item to remove from the menu.
       *
       * #### Notes
       * This is a no-op if the item is not in the menu.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the menu.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.update();
      }
      /**
       * Remove all menu items from the menu.
       */
      clearItems() {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.update();
      }
      /**
       * Open the menu at the specified location.
       *
       * @param x - The client X coordinate of the menu location.
       *
       * @param y - The client Y coordinate of the menu location.
       *
       * @param options - The additional options for opening the menu.
       *
       * #### Notes
       * The menu will be opened at the given location unless it will not
       * fully fit on the screen. If it will not fit, it will be adjusted
       * to fit naturally on the screen.
       *
       * The menu will be attached under the `host` element in the DOM
       * (or `document.body` if `host` is `null`) and before the `ref`
       * element (or as the last child of `host` if `ref` is `null`).
       * The menu may be displayed outside of the `host` element
       * following the rules of CSS absolute positioning.
       *
       * This is a no-op if the menu is already attached to the DOM.
       */
      open(x2, y4, options = {}) {
        var _a, _b, _c;
        if (this.isAttached) {
          return;
        }
        let forceX = options.forceX || false;
        let forceY = options.forceY || false;
        const host = (_a = options.host) !== null && _a !== void 0 ? _a : null;
        const ref = (_b = options.ref) !== null && _b !== void 0 ? _b : null;
        const horizontalAlignment = (_c = options.horizontalAlignment) !== null && _c !== void 0 ? _c : document.documentElement.dir === "rtl" ? "right" : "left";
        Private$92.openRootMenu(this, x2, y4, forceX, forceY, horizontalAlignment, host, ref);
        this.activate();
      }
      /**
       * Handle the DOM events for the menu.
       *
       * @param event - The DOM event sent to the menu.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu's DOM nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mouseup":
            this._evtMouseUp(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "mouseenter":
            this._evtMouseEnter(event);
            break;
          case "mouseleave":
            this._evtMouseLeave(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mouseup", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseenter", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("contextmenu", this);
        document.addEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mouseup", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseenter", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("contextmenu", this);
        document.removeEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this.node.focus();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        let items = this._items;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let collapsedFlags = Private$92.computeCollapsed(items);
        let content = new Array(items.length);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let active = i6 === activeIndex;
          let collapsed = collapsedFlags[i6];
          content[i6] = renderer.renderItem({
            item,
            active,
            collapsed,
            onfocus: () => {
              this.activeIndex = i6;
            }
          });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        this.activeIndex = -1;
        let childMenu = this._childMenu;
        if (childMenu) {
          this._childIndex = -1;
          this._childMenu = null;
          childMenu._parentMenu = null;
          childMenu.close();
        }
        let parentMenu = this._parentMenu;
        if (parentMenu) {
          this._parentMenu = null;
          parentMenu._childIndex = -1;
          parentMenu._childMenu = null;
          parentMenu.activate();
        }
        if (this.isAttached) {
          this._aboutToClose.emit(void 0);
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'keydown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        let kc = event.keyCode;
        if (kc === 13) {
          this.triggerActiveItem();
          return;
        }
        if (kc === 27) {
          this.close();
          return;
        }
        if (kc === 37) {
          if (this._parentMenu) {
            this.close();
          } else {
            this._menuRequested.emit("previous");
          }
          return;
        }
        if (kc === 38) {
          this.activatePreviousItem();
          return;
        }
        if (kc === 39) {
          let item = this.activeItem;
          if (item && item.type === "submenu") {
            this.triggerActiveItem();
          } else {
            this.rootMenu._menuRequested.emit("next");
          }
          return;
        }
        if (kc === 40) {
          this.activateNextItem();
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$92.findMnemonic(this._items, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.triggerActiveItem();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
        }
      }
      /**
       * Handle the `'mouseup'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
      }
      /**
       * Handle the `'mousemove'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        this.activeIndex = index2;
        index2 = this.activeIndex;
        if (index2 === this._childIndex) {
          this._cancelOpenTimer();
          this._cancelCloseTimer();
          return;
        }
        if (this._childIndex !== -1) {
          this._startCloseTimer();
        }
        this._cancelOpenTimer();
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          return;
        }
        this._startOpenTimer();
      }
      /**
       * Handle the `'mouseenter'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseEnter(event) {
        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
          menu._cancelOpenTimer();
          menu._cancelCloseTimer();
          menu.activeIndex = menu._childIndex;
        }
      }
      /**
       * Handle the `'mouseleave'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseLeave(event) {
        this._cancelOpenTimer();
        if (!this._childMenu) {
          this.activeIndex = -1;
          return;
        }
        let { clientX, clientY } = event;
        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
          this._cancelCloseTimer();
          return;
        }
        this.activeIndex = -1;
        this._startCloseTimer();
      }
      /**
       * Handle the `'mousedown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the document node.
       */
      _evtMouseDown(event) {
        if (this._parentMenu) {
          return;
        }
        if (Private$92.hitTestMenus(this, event.clientX, event.clientY)) {
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.close();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if the active item is not a valid submenu.
       */
      _openChildMenu(activateFirst = false) {
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          this._closeChildMenu();
          return;
        }
        let submenu = item.submenu;
        if (submenu === this._childMenu) {
          return;
        }
        Menu2.saveWindowData();
        this._closeChildMenu();
        this._childMenu = submenu;
        this._childIndex = this._activeIndex;
        submenu._parentMenu = this;
        MessageLoop3.sendMessage(this, Widget3.Msg.UpdateRequest);
        let itemNode = this.contentNode.children[this._activeIndex];
        Private$92.openSubmenu(submenu, itemNode);
        if (activateFirst) {
          submenu.activeIndex = -1;
          submenu.activateNextItem();
        }
        submenu.activate();
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (this._childMenu) {
          this._childMenu.close();
        }
      }
      /**
       * Start the open timer, unless it is already pending.
       */
      _startOpenTimer() {
        if (this._openTimerID === 0) {
          this._openTimerID = window.setTimeout(() => {
            this._openTimerID = 0;
            this._openChildMenu();
          }, Private$92.TIMER_DELAY);
        }
      }
      /**
       * Start the close timer, unless it is already pending.
       */
      _startCloseTimer() {
        if (this._closeTimerID === 0) {
          this._closeTimerID = window.setTimeout(() => {
            this._closeTimerID = 0;
            this._closeChildMenu();
          }, Private$92.TIMER_DELAY);
        }
      }
      /**
       * Cancel the open timer, if the timer is pending.
       */
      _cancelOpenTimer() {
        if (this._openTimerID !== 0) {
          clearTimeout(this._openTimerID);
          this._openTimerID = 0;
        }
      }
      /**
       * Cancel the close timer, if the timer is pending.
       */
      _cancelCloseTimer() {
        if (this._closeTimerID !== 0) {
          clearTimeout(this._closeTimerID);
          this._closeTimerID = 0;
        }
      }
      /**
       * Save window data used for menu positioning in transient cache.
       *
       * In order to avoid layout trashing it is recommended to invoke this
       * method immediately prior to opening the menu and any DOM modifications
       * (like closing previously visible menu, or adding a class to menu widget).
       *
       * The transient cache will be released upon `open()` call.
       */
      static saveWindowData() {
        Private$92.saveWindowData();
      }
    };
    (function(Menu5) {
      class Renderer {
        /**
         * Render the virtual element for a menu item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            tabindex: "0",
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
        }
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-Menu-itemLabel" }, content);
        }
        /**
         * Render the shortcut element for a menu item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the item shortcut.
         */
        renderShortcut(data) {
          let content = this.formatShortcut(data);
          return h.div({ className: "lm-Menu-itemShortcut" }, content);
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          return h.div({ className: "lm-Menu-itemSubmenuIcon" });
        }
        /**
         * Create the class name for the menu item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-Menu-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (!data.item.isVisible) {
            name += " lm-mod-hidden";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          if (data.collapsed) {
            name += " lm-mod-collapsed";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the menu item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the menu item.
         */
        createItemDataset(data) {
          let result2;
          let { type, command, dataset } = data.item;
          if (type === "command") {
            result2 = { ...dataset, type, command };
          } else {
            result2 = { ...dataset, type };
          }
          return result2;
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-Menu-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the aria attributes for menu item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          let aria = {};
          switch (data.item.type) {
            case "separator":
              aria.role = "presentation";
              break;
            case "submenu":
              aria["aria-haspopup"] = "true";
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              break;
            default:
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              if (data.item.isToggled) {
                aria.role = "menuitemcheckbox";
                aria["aria-checked"] = "true";
              } else {
                aria.role = "menuitem";
              }
          }
          return aria;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.item;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
        /**
         * Create the render content for the shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
      }
      Menu5.Renderer = Renderer;
      Menu5.defaultRenderer = new Renderer();
    })(Menu2 || (Menu2 = {}));
    (function(Private22) {
      Private22.TIMER_DELAY = 300;
      Private22.SUBMENU_OVERLAP = 3;
      let transientWindowDataCache = null;
      let transientCacheCounter = 0;
      function getWindowData() {
        if (transientCacheCounter > 0) {
          transientCacheCounter--;
          return transientWindowDataCache;
        }
        return _getWindowData();
      }
      function saveWindowData() {
        transientWindowDataCache = _getWindowData();
        transientCacheCounter++;
      }
      Private22.saveWindowData = saveWindowData;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-Menu-content";
        node.appendChild(content);
        content.setAttribute("role", "menu");
        node.tabIndex = 0;
        return node;
      }
      Private22.createNode = createNode;
      function canActivate(item) {
        return item.type !== "separator" && item.isEnabled && item.isVisible;
      }
      Private22.canActivate = canActivate;
      function createItem(owner, options) {
        return new MenuItem(owner.commands, options);
      }
      Private22.createItem = createItem;
      function hitTestMenus(menu, x2, y4) {
        for (let temp = menu; temp; temp = temp.childMenu) {
          if (ElementExt.hitTest(temp.node, x2, y4)) {
            return true;
          }
        }
        return false;
      }
      Private22.hitTestMenus = hitTestMenus;
      function computeCollapsed(items) {
        let result2 = new Array(items.length);
        ArrayExt.fill(result2, false);
        let k1 = 0;
        let n5 = items.length;
        for (; k1 < n5; ++k1) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k1] = true;
        }
        let k2 = n5 - 1;
        for (; k2 >= 0; --k2) {
          let item = items[k2];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k2] = true;
        }
        let hide4 = false;
        while (++k1 < k2) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            hide4 = false;
          } else if (hide4) {
            result2[k1] = true;
          } else {
            hide4 = true;
          }
        }
        return result2;
      }
      Private22.computeCollapsed = computeCollapsed;
      function _getWindowData() {
        return {
          pageXOffset: window.pageXOffset,
          pageYOffset: window.pageYOffset,
          clientWidth: document.documentElement.clientWidth,
          clientHeight: document.documentElement.clientHeight
        };
      }
      function openRootMenu(menu, x2, y4, forceX, forceY, horizontalAlignment, host, ref) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop3.sendMessage(menu, Widget3.Msg.UpdateRequest);
        let maxHeight = ch - (forceY ? y4 : 0);
        let node = menu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget3.attach(menu, host || document.body, ref);
        let { width, height } = node.getBoundingClientRect();
        if (horizontalAlignment === "right") {
          x2 -= width;
        }
        if (!forceX && x2 + width > px + cw) {
          x2 = px + cw - width;
        }
        if (!forceY && y4 + height > py + ch) {
          if (y4 > py + ch) {
            y4 = py + ch - height;
          } else {
            y4 = y4 - height;
          }
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openRootMenu = openRootMenu;
      function openSubmenu(submenu, itemNode) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop3.sendMessage(submenu, Widget3.Msg.UpdateRequest);
        let maxHeight = ch;
        let node = submenu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget3.attach(submenu, document.body);
        let { width, height } = node.getBoundingClientRect();
        let box = ElementExt.boxSizing(submenu.node);
        let itemRect = itemNode.getBoundingClientRect();
        let x2 = itemRect.right - Private22.SUBMENU_OVERLAP;
        if (x2 + width > px + cw) {
          x2 = itemRect.left + Private22.SUBMENU_OVERLAP - width;
        }
        let y4 = itemRect.top - box.borderTop - box.paddingTop;
        if (y4 + height > py + ch) {
          y4 = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openSubmenu = openSubmenu;
      function findMnemonic(items, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let item = items[k2];
          if (!canActivate(item)) {
            continue;
          }
          let label = item.label;
          if (label.length === 0) {
            continue;
          }
          let mn = item.mnemonic;
          if (mn >= 0 && mn < label.length) {
            if (label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
      class MenuItem {
        /**
         * Construct a new menu item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.type = options.type || "command";
          this.command = options.command || "";
          this.args = options.args || import_coreutils3.JSONExt.emptyObject;
          this.submenu = options.submenu || null;
        }
        /**
         * The display label for the menu item.
         */
        get label() {
          if (this.type === "command") {
            return this._commands.label(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.label;
          }
          return "";
        }
        /**
         * The mnemonic index for the menu item.
         */
        get mnemonic() {
          if (this.type === "command") {
            return this._commands.mnemonic(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.mnemonic;
          }
          return -1;
        }
        /**
         * The icon renderer for the menu item.
         */
        get icon() {
          if (this.type === "command") {
            return this._commands.icon(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.icon;
          }
          return void 0;
        }
        /**
         * The icon class for the menu item.
         */
        get iconClass() {
          if (this.type === "command") {
            return this._commands.iconClass(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconClass;
          }
          return "";
        }
        /**
         * The icon label for the menu item.
         */
        get iconLabel() {
          if (this.type === "command") {
            return this._commands.iconLabel(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconLabel;
          }
          return "";
        }
        /**
         * The display caption for the menu item.
         */
        get caption() {
          if (this.type === "command") {
            return this._commands.caption(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.caption;
          }
          return "";
        }
        /**
         * The extra class name for the menu item.
         */
        get className() {
          if (this.type === "command") {
            return this._commands.className(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.className;
          }
          return "";
        }
        /**
         * The dataset for the menu item.
         */
        get dataset() {
          if (this.type === "command") {
            return this._commands.dataset(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.dataset;
          }
          return {};
        }
        /**
         * Whether the menu item is enabled.
         */
        get isEnabled() {
          if (this.type === "command") {
            return this._commands.isEnabled(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * Whether the menu item is toggled.
         */
        get isToggled() {
          if (this.type === "command") {
            return this._commands.isToggled(this.command, this.args);
          }
          return false;
        }
        /**
         * Whether the menu item is visible.
         */
        get isVisible() {
          if (this.type === "command") {
            return this._commands.isVisible(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * The key binding for the menu item.
         */
        get keyBinding() {
          if (this.type === "command") {
            let { command, args } = this;
            return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
              return kb.command === command && import_coreutils3.JSONExt.deepEqual(kb.args, args);
            }) || null;
          }
          return null;
        }
      }
    })(Private$92 || (Private$92 = {}));
    (function(Private22) {
      function createItem(options, id) {
        let selector = validateSelector(options.selector);
        let rank = options.rank !== void 0 ? options.rank : Infinity;
        return { ...options, selector, rank, id };
      }
      Private22.createItem = createItem;
      function matchItems(items, event, groupByTarget, sortBySelector) {
        let target = event.target;
        if (!target) {
          return null;
        }
        let currentTarget = event.currentTarget;
        if (!currentTarget) {
          return null;
        }
        if (!currentTarget.contains(target)) {
          target = document.elementFromPoint(event.clientX, event.clientY);
          if (!target || !currentTarget.contains(target)) {
            return null;
          }
        }
        let result2 = [];
        let availableItems = items.slice();
        while (target !== null) {
          let matches2 = [];
          for (let i6 = 0, n5 = availableItems.length; i6 < n5; ++i6) {
            let item = availableItems[i6];
            if (!item) {
              continue;
            }
            if (!Selector.matches(target, item.selector)) {
              continue;
            }
            matches2.push(item);
            availableItems[i6] = null;
          }
          if (matches2.length !== 0) {
            if (groupByTarget) {
              matches2.sort(sortBySelector ? itemCmp : itemCmpRank);
            }
            result2.push(...matches2);
          }
          if (target === currentTarget) {
            break;
          }
          target = target.parentElement;
        }
        if (!groupByTarget) {
          result2.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        return result2;
      }
      Private22.matchItems = matchItems;
      function validateSelector(selector) {
        if (selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${selector}`);
        }
        if (!Selector.isValid(selector)) {
          throw new Error(`Invalid selector: ${selector}`);
        }
        return selector;
      }
      function itemCmpRank(a3, b2) {
        let r1 = a3.rank;
        let r22 = b2.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.id - b2.id;
      }
      function itemCmp(a3, b2) {
        let s1 = Selector.calculateSpecificity(a3.selector);
        let s22 = Selector.calculateSpecificity(b2.selector);
        if (s1 !== s22) {
          return s22 - s1;
        }
        return itemCmpRank(a3, b2);
      }
    })(Private$82 || (Private$82 = {}));
    ARROW_KEYS2 = [
      "ArrowLeft",
      "ArrowUp",
      "ArrowRight",
      "ArrowDown",
      "Home",
      "End"
    ];
    TabBar3 = class extends Widget3 {
      /**
       * Construct a new tab bar.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        super({ node: Private$72.createNode() });
        this._currentIndex = -1;
        this._titles = [];
        this._titlesEditable = false;
        this._previousTitle = null;
        this._dragData = null;
        this._addButtonEnabled = false;
        this._tabMoved = new Signal(this);
        this._currentChanged = new Signal(this);
        this._addRequested = new Signal(this);
        this._tabCloseRequested = new Signal(this);
        this._tabDetachRequested = new Signal(this);
        this._tabActivateRequested = new Signal(this);
        this.addClass("lm-TabBar");
        this.contentNode.setAttribute("role", "tablist");
        this.setFlag(Widget3.Flag.DisallowLayout);
        this._document = options.document || document;
        this.tabsMovable = options.tabsMovable || false;
        this.titlesEditable = options.titlesEditable || false;
        this.allowDeselect = options.allowDeselect || false;
        this.addButtonEnabled = options.addButtonEnabled || false;
        this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
        this.name = options.name || "";
        this.orientation = options.orientation || "horizontal";
        this.removeBehavior = options.removeBehavior || "select-tab-after";
        this.renderer = options.renderer || TabBar3.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._releaseMouse();
        this._titles.length = 0;
        this._previousTitle = null;
        super.dispose();
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when a tab is moved by the user.
       *
       * #### Notes
       * This signal is emitted when a tab is moved by user interaction.
       *
       * This signal is not emitted when a tab is moved programmatically.
       */
      get tabMoved() {
        return this._tabMoved;
      }
      /**
       * A signal emitted when a tab is clicked by the user.
       *
       * #### Notes
       * If the clicked tab is not the current tab, the clicked tab will be
       * made current and the `currentChanged` signal will be emitted first.
       *
       * This signal is emitted even if the clicked tab is the current tab.
       */
      get tabActivateRequested() {
        return this._tabActivateRequested;
      }
      /**
       * A signal emitted when the tab bar add button is clicked.
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * A signal emitted when a tab close icon is clicked.
       *
       * #### Notes
       * This signal is not emitted unless the tab title is `closable`.
       */
      get tabCloseRequested() {
        return this._tabCloseRequested;
      }
      /**
       * A signal emitted when a tab is dragged beyond the detach threshold.
       *
       * #### Notes
       * This signal is emitted when the user drags a tab with the mouse,
       * and mouse is dragged beyond the detach threshold.
       *
       * The consumer of the signal should call `releaseMouse` and remove
       * the tab in order to complete the detach.
       *
       * This signal is only emitted once per drag cycle.
       */
      get tabDetachRequested() {
        return this._tabDetachRequested;
      }
      /**
       * The document to use with the tab bar.
       *
       * The default is the global `document` instance.
       */
      get document() {
        return this._document;
      }
      /**
       * Whether the titles can be user-edited.
       *
       */
      get titlesEditable() {
        return this._titlesEditable;
      }
      /**
       * Set whether titles can be user edited.
       *
       */
      set titlesEditable(value) {
        this._titlesEditable = value;
      }
      /**
       * Get the currently selected title.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentTitle() {
        return this._titles[this._currentIndex] || null;
      }
      /**
       * Set the currently selected title.
       *
       * #### Notes
       * If the title does not exist, the title will be set to `null`.
       */
      set currentTitle(value) {
        this.currentIndex = value ? this._titles.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `-1` if no tab is selected.
       */
      get currentIndex() {
        return this._currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `-1`.
       */
      set currentIndex(value) {
        if (value < 0 || value >= this._titles.length) {
          value = -1;
        }
        if (this._currentIndex === value) {
          return;
        }
        let pi = this._currentIndex;
        let pt = this._titles[pi] || null;
        let ci = value;
        let ct = this._titles[ci] || null;
        this._currentIndex = ci;
        this._previousTitle = pt;
        this.update();
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: ci,
          currentTitle: ct
        });
      }
      /**
       * Get the name of the tab bar.
       */
      get name() {
        return this._name;
      }
      /**
       * Set the name of the tab bar.
       */
      set name(value) {
        this._name = value;
        if (value) {
          this.contentNode.setAttribute("aria-label", value);
        } else {
          this.contentNode.removeAttribute("aria-label");
        }
      }
      /**
       * Get the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._releaseMouse();
        this._orientation = value;
        this.dataset["orientation"] = value;
        this.contentNode.setAttribute("aria-orientation", value);
      }
      /**
       * Whether the add button is enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add button is enabled.
       */
      set addButtonEnabled(value) {
        if (this._addButtonEnabled === value) {
          return;
        }
        this._addButtonEnabled = value;
        if (value) {
          this.addButtonNode.classList.remove("lm-mod-hidden");
        } else {
          this.addButtonNode.classList.add("lm-mod-hidden");
        }
      }
      /**
       * A read-only array of the titles in the tab bar.
       */
      get titles() {
        return this._titles;
      }
      /**
       * The tab bar content node.
       *
       * #### Notes
       * This is the node which holds the tab nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-TabBar-content")[0];
      }
      /**
       * The tab bar add button node.
       *
       * #### Notes
       * This is the node which holds the add button.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get addButtonNode() {
        return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
      }
      /**
       * Add a tab to the end of the tab bar.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * If the title is already added to the tab bar, it will be moved.
       */
      addTab(value) {
        return this.insertTab(this._titles.length, value);
      }
      /**
       * Insert a tab into the tab bar at the specified index.
       *
       * @param index - The index at which to insert the tab.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the tabs.
       *
       * If the title is already added to the tab bar, it will be moved.
       */
      insertTab(index2, value) {
        this._releaseMouse();
        let title = Private$72.asTitle(value);
        let i6 = this._titles.indexOf(title);
        let j2 = Math.max(0, Math.min(index2, this._titles.length));
        if (i6 === -1) {
          ArrayExt.insert(this._titles, j2, title);
          title.changed.connect(this._onTitleChanged, this);
          this.update();
          this._adjustCurrentForInsert(j2, title);
          return title;
        }
        if (j2 === this._titles.length) {
          j2--;
        }
        if (i6 === j2) {
          return title;
        }
        ArrayExt.move(this._titles, i6, j2);
        this.update();
        this._adjustCurrentForMove(i6, j2);
        return title;
      }
      /**
       * Remove a tab from the tab bar.
       *
       * @param title - The title for the tab to remove.
       *
       * #### Notes
       * This is a no-op if the title is not in the tab bar.
       */
      removeTab(title) {
        this.removeTabAt(this._titles.indexOf(title));
      }
      /**
       * Remove the tab at a given index from the tab bar.
       *
       * @param index - The index of the tab to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeTabAt(index2) {
        this._releaseMouse();
        let title = ArrayExt.removeAt(this._titles, index2);
        if (!title) {
          return;
        }
        title.changed.disconnect(this._onTitleChanged, this);
        if (title === this._previousTitle) {
          this._previousTitle = null;
        }
        this.update();
        this._adjustCurrentForRemove(index2, title);
      }
      /**
       * Remove all tabs from the tab bar.
       */
      clearTabs() {
        if (this._titles.length === 0) {
          return;
        }
        this._releaseMouse();
        for (let title of this._titles) {
          title.changed.disconnect(this._onTitleChanged, this);
        }
        let pi = this.currentIndex;
        let pt = this.currentTitle;
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles.length = 0;
        this.update();
        if (pi === -1) {
          return;
        }
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       *
       * #### Notes
       * This will cause the tab bar to stop handling mouse events and to
       * restore the tabs to their non-dragged positions.
       */
      releaseMouse() {
        this._releaseMouse();
      }
      /**
       * Handle the DOM events for the tab bar.
       *
       * @param event - The DOM event sent to the tab bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tab bar's DOM node.
       *
       * This should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "dblclick":
            this._evtDblClick(event);
            break;
          case "keydown":
            event.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event) : this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
        this.node.addEventListener("dblclick", this);
        this.node.addEventListener("keydown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this.node.removeEventListener("dblclick", this);
        this.node.removeEventListener("keydown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let titles = this._titles;
        let renderer = this.renderer;
        let currentTitle = this.currentTitle;
        let content = new Array(titles.length);
        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
        for (let i6 = 0, n5 = titles.length; i6 < n5; ++i6) {
          let title = titles[i6];
          let current = title === currentTitle;
          let zIndex = current ? n5 : n5 - i6 - 1;
          let tabIndex = tabHandlingTabindex === i6 ? 0 : -1;
          content[i6] = renderer.renderTab({ title, current, zIndex, tabIndex });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * Get the index of the tab which handles tabindex="0".
       * If the add button handles tabindex="0", -1 is returned.
       * If none of the previous handles tabindex="0", null is returned.
       */
      _getCurrentTabindex() {
        let index2 = null;
        const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
        if (elemTabindex) {
          index2 = [...this.contentNode.children].indexOf(elemTabindex);
        } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
          index2 = -1;
        }
        return index2;
      }
      /**
       * Handle the `'dblclick'` event for the tab bar.
       */
      _evtDblClick(event) {
        if (!this.titlesEditable) {
          return;
        }
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          return;
        }
        let title = this.titles[index2];
        let label = tabs[index2].querySelector(".lm-TabBar-tabLabel");
        if (label && label.contains(event.target)) {
          let value = title.label || "";
          let oldValue = label.innerHTML;
          label.innerHTML = "";
          let input = document.createElement("input");
          input.classList.add("lm-TabBar-tabInput");
          input.value = value;
          label.appendChild(input);
          let onblur = () => {
            input.removeEventListener("blur", onblur);
            label.innerHTML = oldValue;
            this.node.addEventListener("keydown", this);
          };
          input.addEventListener("dblclick", (event2) => event2.stopPropagation());
          input.addEventListener("blur", onblur);
          input.addEventListener("keydown", (event2) => {
            if (event2.key === "Enter") {
              if (input.value !== "") {
                title.label = title.caption = input.value;
              }
              onblur();
            } else if (event2.key === "Escape") {
              onblur();
            }
          });
          this.node.removeEventListener("keydown", this);
          input.select();
          input.focus();
          if (label.children.length > 0) {
            label.children[0].focus();
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at capturing phase.
       */
      _evtKeyDownCapturing(event) {
        if (event.eventPhase !== Event.CAPTURING_PHASE) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "Escape") {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at target phase.
       */
      _evtKeyDown(event) {
        var _a, _b, _c;
        if (event.key === "Tab" || event.eventPhase === Event.CAPTURING_PHASE) {
          return;
        }
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
          const focusedElement = document.activeElement;
          if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
            event.preventDefault();
            event.stopPropagation();
            this._addRequested.emit();
          } else {
            const index2 = ArrayExt.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
            if (index2 >= 0) {
              event.preventDefault();
              event.stopPropagation();
              this.currentIndex = index2;
            }
          }
        } else if (ARROW_KEYS2.includes(event.key)) {
          const focusable = [...this.contentNode.children];
          if (this.addButtonEnabled) {
            focusable.push(this.addButtonNode);
          }
          if (focusable.length <= 1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          let focusedIndex = focusable.indexOf(document.activeElement);
          if (focusedIndex === -1) {
            focusedIndex = this._currentIndex;
          }
          let nextFocused;
          if (event.key === "ArrowRight" && this._orientation === "horizontal" || event.key === "ArrowDown" && this._orientation === "vertical") {
            nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
          } else if (event.key === "ArrowLeft" && this._orientation === "horizontal" || event.key === "ArrowUp" && this._orientation === "vertical") {
            nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
          } else if (event.key === "Home") {
            nextFocused = focusable[0];
          } else if (event.key === "End") {
            nextFocused = focusable[focusable.length - 1];
          }
          if (nextFocused) {
            (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
            nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
            nextFocused.focus();
          }
        }
      }
      /**
       * Handle the `'pointerdown'` event for the tab bar.
       */
      _evtPointerDown(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        if (this._dragData) {
          return;
        }
        if (event.target.classList.contains("lm-TabBar-tabInput")) {
          return;
        }
        let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1 && !addButtonClicked) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._dragData = {
          tab: tabs[index2],
          index: index2,
          pressX: event.clientX,
          pressY: event.clientY,
          tabPos: -1,
          tabSize: -1,
          tabPressPos: -1,
          targetIndex: -1,
          tabLayout: null,
          contentRect: null,
          override: null,
          dragActive: false,
          dragAborted: false,
          detachRequested: false
        };
        this.document.addEventListener("pointerup", this, true);
        if (event.button === 1 || addButtonClicked) {
          return;
        }
        let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
          return;
        }
        if (this.tabsMovable) {
          this.document.addEventListener("pointermove", this, true);
          this.document.addEventListener("keydown", this, true);
          this.document.addEventListener("contextmenu", this, true);
        }
        if (this.allowDeselect && this.currentIndex === index2) {
          this.currentIndex = -1;
        } else {
          this.currentIndex = index2;
        }
        if (this.currentIndex === -1) {
          return;
        }
        this._tabActivateRequested.emit({
          index: this.currentIndex,
          title: this.currentTitle
        });
      }
      /**
       * Handle the `'pointermove'` event for the tab bar.
       */
      _evtPointerMove(event) {
        let data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let tabs = this.contentNode.children;
        if (!data.dragActive && !Private$72.dragExceeded(data, event)) {
          return;
        }
        if (!data.dragActive) {
          let tabRect = data.tab.getBoundingClientRect();
          if (this._orientation === "horizontal") {
            data.tabPos = data.tab.offsetLeft;
            data.tabSize = tabRect.width;
            data.tabPressPos = data.pressX - tabRect.left;
          } else {
            data.tabPos = data.tab.offsetTop;
            data.tabSize = tabRect.height;
            data.tabPressPos = data.pressY - tabRect.top;
          }
          data.tabPressOffset = {
            x: data.pressX - tabRect.left,
            y: data.pressY - tabRect.top
          };
          data.tabLayout = Private$72.snapTabLayout(tabs, this._orientation);
          data.contentRect = this.contentNode.getBoundingClientRect();
          data.override = Drag2.overrideCursor("default");
          data.tab.classList.add("lm-mod-dragging");
          this.addClass("lm-mod-dragging");
          data.dragActive = true;
        }
        if (!data.detachRequested && Private$72.detachExceeded(data, event)) {
          data.detachRequested = true;
          let index2 = data.index;
          let clientX = event.clientX;
          let clientY = event.clientY;
          let tab = tabs[index2];
          let title = this._titles[index2];
          this._tabDetachRequested.emit({
            index: index2,
            title,
            tab,
            clientX,
            clientY,
            offset: data.tabPressOffset
          });
          if (data.dragAborted) {
            return;
          }
        }
        Private$72.layoutTabs(tabs, data, event, this._orientation);
      }
      /**
       * Handle the `'pointerup'` event for the document.
       */
      _evtPointerUp(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        const data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        if (!data.dragActive) {
          this._dragData = null;
          let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
          if (addButtonClicked) {
            this._addRequested.emit(void 0);
            return;
          }
          let tabs = this.contentNode.children;
          let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
            return ElementExt.hitTest(tab, event.clientX, event.clientY);
          });
          if (index2 !== data.index) {
            return;
          }
          let title = this._titles[index2];
          if (!title.closable) {
            return;
          }
          if (event.button === 1) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
          if (icon && icon.contains(event.target)) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          return;
        }
        if (event.button !== 0) {
          return;
        }
        Private$72.finalizeTabPosition(data, this._orientation);
        data.tab.classList.remove("lm-mod-dragging");
        let duration = Private$72.parseTransitionDuration(data.tab);
        setTimeout(() => {
          if (data.dragAborted) {
            return;
          }
          this._dragData = null;
          Private$72.resetTabPositions(this.contentNode.children, this._orientation);
          data.override.dispose();
          this.removeClass("lm-mod-dragging");
          let i6 = data.index;
          let j2 = data.targetIndex;
          if (j2 === -1 || i6 === j2) {
            return;
          }
          ArrayExt.move(this._titles, i6, j2);
          this._adjustCurrentForMove(i6, j2);
          this._tabMoved.emit({
            fromIndex: i6,
            toIndex: j2,
            title: this._titles[j2]
          });
          MessageLoop3.sendMessage(this, Widget3.Msg.UpdateRequest);
        }, duration);
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       */
      _releaseMouse() {
        let data = this._dragData;
        if (!data) {
          return;
        }
        this._dragData = null;
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        data.dragAborted = true;
        if (!data.dragActive) {
          return;
        }
        Private$72.resetTabPositions(this.contentNode.children, this._orientation);
        data.override.dispose();
        data.tab.classList.remove("lm-mod-dragging");
        this.removeClass("lm-mod-dragging");
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * This method accounts for the tab bar's insertion behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForInsert(i6, title) {
        let ct = this.currentTitle;
        let ci = this._currentIndex;
        let bh = this.insertBehavior;
        if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
          this._currentIndex = i6;
          this._previousTitle = ct;
          this._currentChanged.emit({
            previousIndex: ci,
            previousTitle: ct,
            currentIndex: i6,
            currentTitle: title
          });
          return;
        }
        if (ci >= i6) {
          this._currentIndex++;
        }
      }
      /**
       * Adjust the current index for a tab move operation.
       *
       * This method will not cause the actual current tab to change.
       * It silently adjusts the index to account for the given move.
       */
      _adjustCurrentForMove(i6, j2) {
        if (this._currentIndex === i6) {
          this._currentIndex = j2;
        } else if (this._currentIndex < i6 && this._currentIndex >= j2) {
          this._currentIndex++;
        } else if (this._currentIndex > i6 && this._currentIndex <= j2) {
          this._currentIndex--;
        }
      }
      /**
       * Adjust the current index for a tab remove operation.
       *
       * This method accounts for the tab bar's remove behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForRemove(i6, title) {
        let ci = this._currentIndex;
        let bh = this.removeBehavior;
        if (ci !== i6) {
          if (ci > i6) {
            this._currentIndex--;
          }
          return;
        }
        if (this._titles.length === 0) {
          this._currentIndex = -1;
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: -1,
            currentTitle: null
          });
          return;
        }
        if (bh === "select-tab-after") {
          this._currentIndex = Math.min(i6, this._titles.length - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-tab-before") {
          this._currentIndex = Math.max(0, i6 - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-previous-tab") {
          if (this._previousTitle) {
            this._currentIndex = this._titles.indexOf(this._previousTitle);
            this._previousTitle = null;
          } else {
            this._currentIndex = Math.min(i6, this._titles.length - 1);
          }
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        this._currentIndex = -1;
        this._currentChanged.emit({
          previousIndex: i6,
          previousTitle: title,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this.update();
      }
    };
    (function(TabBar6) {
      class Renderer {
        constructor() {
          this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
          this._tabID = 0;
          this._tabKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the virtual element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab.
         */
        renderTab(data) {
          let title = data.title.caption;
          let key = this.createTabKey(data);
          let id = key;
          let style = this.createTabStyle(data);
          let className = this.createTabClass(data);
          let dataset = this.createTabDataset(data);
          let aria = this.createTabARIA(data);
          if (data.title.closable) {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
          } else {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
          }
        }
        /**
         * Render the icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab icon.
         */
        renderIcon(data) {
          const { title } = data;
          let className = this.createIconClass(data);
          return h.div({ className }, title.icon, title.iconLabel);
        }
        /**
         * Render the label element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab label.
         */
        renderLabel(data) {
          return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
        }
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          return h.div({ className: "lm-TabBar-tabCloseIcon" });
        }
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        createTabKey(data) {
          let key = this._tabKeys.get(data.title);
          if (key === void 0) {
            key = `tab-key-${this._uuid}-${this._tabID++}`;
            this._tabKeys.set(data.title, key);
          }
          return key;
        }
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        createTabStyle(data) {
          return { zIndex: `${data.zIndex}` };
        }
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        createTabClass(data) {
          let name = "lm-TabBar-tab";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.title.closable) {
            name += " lm-mod-closable";
          }
          if (data.current) {
            name += " lm-mod-current";
          }
          return name;
        }
        /**
         * Create the dataset for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The dataset for the tab.
         */
        createTabDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the ARIA attributes for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The ARIA attributes for the tab.
         */
        createTabARIA(data) {
          var _a;
          return {
            role: "tab",
            "aria-selected": data.current.toString(),
            tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
          };
        }
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        createIconClass(data) {
          let name = "lm-TabBar-tabIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
      }
      Renderer._nInstance = 0;
      TabBar6.Renderer = Renderer;
      TabBar6.defaultRenderer = new Renderer();
      TabBar6.addButtonSelector = ".lm-TabBar-addButton";
    })(TabBar3 || (TabBar3 = {}));
    (function(Private22) {
      Private22.DRAG_THRESHOLD = 5;
      Private22.DETACH_THRESHOLD = 20;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.setAttribute("role", "tablist");
        content.className = "lm-TabBar-content";
        node.appendChild(content);
        let add = document.createElement("div");
        add.className = "lm-TabBar-addButton lm-mod-hidden";
        add.setAttribute("tabindex", "-1");
        add.setAttribute("role", "button");
        node.appendChild(add);
        return node;
      }
      Private22.createNode = createNode;
      function asTitle(value) {
        return value instanceof Title3 ? value : new Title3(value);
      }
      Private22.asTitle = asTitle;
      function parseTransitionDuration(tab) {
        let style = window.getComputedStyle(tab);
        return 1e3 * (parseFloat(style.transitionDuration) || 0);
      }
      Private22.parseTransitionDuration = parseTransitionDuration;
      function snapTabLayout(tabs, orientation) {
        let layout = new Array(tabs.length);
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let node = tabs[i6];
          let style = window.getComputedStyle(node);
          if (orientation === "horizontal") {
            layout[i6] = {
              pos: node.offsetLeft,
              size: node.offsetWidth,
              margin: parseFloat(style.marginLeft) || 0
            };
          } else {
            layout[i6] = {
              pos: node.offsetTop,
              size: node.offsetHeight,
              margin: parseFloat(style.marginTop) || 0
            };
          }
        }
        return layout;
      }
      Private22.snapTabLayout = snapTabLayout;
      function dragExceeded(data, event) {
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        return dx >= Private22.DRAG_THRESHOLD || dy >= Private22.DRAG_THRESHOLD;
      }
      Private22.dragExceeded = dragExceeded;
      function detachExceeded(data, event) {
        let rect = data.contentRect;
        return event.clientX < rect.left - Private22.DETACH_THRESHOLD || event.clientX >= rect.right + Private22.DETACH_THRESHOLD || event.clientY < rect.top - Private22.DETACH_THRESHOLD || event.clientY >= rect.bottom + Private22.DETACH_THRESHOLD;
      }
      Private22.detachExceeded = detachExceeded;
      function layoutTabs(tabs, data, event, orientation) {
        let pressPos;
        let localPos;
        let clientPos;
        let clientSize;
        if (orientation === "horizontal") {
          pressPos = data.pressX;
          localPos = event.clientX - data.contentRect.left;
          clientPos = event.clientX;
          clientSize = data.contentRect.width;
        } else {
          pressPos = data.pressY;
          localPos = event.clientY - data.contentRect.top;
          clientPos = event.clientY;
          clientSize = data.contentRect.height;
        }
        let targetIndex = data.index;
        let targetPos = localPos - data.tabPressPos;
        let targetEnd = targetPos + data.tabSize;
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let pxPos;
          let layout = data.tabLayout[i6];
          let threshold = layout.pos + (layout.size >> 1);
          if (i6 < data.index && targetPos < threshold) {
            pxPos = `${data.tabSize + data.tabLayout[i6 + 1].margin}px`;
            targetIndex = Math.min(targetIndex, i6);
          } else if (i6 > data.index && targetEnd > threshold) {
            pxPos = `${-data.tabSize - layout.margin}px`;
            targetIndex = Math.max(targetIndex, i6);
          } else if (i6 === data.index) {
            let ideal = clientPos - pressPos;
            let limit = clientSize - (data.tabPos + data.tabSize);
            pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;
          } else {
            pxPos = "";
          }
          if (orientation === "horizontal") {
            tabs[i6].style.left = pxPos;
          } else {
            tabs[i6].style.top = pxPos;
          }
        }
        data.targetIndex = targetIndex;
      }
      Private22.layoutTabs = layoutTabs;
      function finalizeTabPosition(data, orientation) {
        let clientSize;
        if (orientation === "horizontal") {
          clientSize = data.contentRect.width;
        } else {
          clientSize = data.contentRect.height;
        }
        let ideal;
        if (data.targetIndex === data.index) {
          ideal = 0;
        } else if (data.targetIndex > data.index) {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        } else {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos - data.tabPos;
        }
        let limit = clientSize - (data.tabPos + data.tabSize);
        let final = Math.max(-data.tabPos, Math.min(ideal, limit));
        if (orientation === "horizontal") {
          data.tab.style.left = `${final}px`;
        } else {
          data.tab.style.top = `${final}px`;
        }
      }
      Private22.finalizeTabPosition = finalizeTabPosition;
      function resetTabPositions(tabs, orientation) {
        for (const tab of tabs) {
          if (orientation === "horizontal") {
            tab.style.left = "";
          } else {
            tab.style.top = "";
          }
        }
      }
      Private22.resetTabPositions = resetTabPositions;
    })(Private$72 || (Private$72 = {}));
    DockLayout2 = class extends Layout2 {
      /**
       * Construct a new dock layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this._spacing = 4;
        this._dirty = false;
        this._root = null;
        this._box = null;
        this._items = /* @__PURE__ */ new Map();
        this.renderer = options.renderer;
        if (options.spacing !== void 0) {
          this._spacing = Utils$12.clampDimension(options.spacing);
        }
        this._document = options.document || document;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget3.HiddenMode.Display;
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       */
      dispose() {
        let widgets = this[Symbol.iterator]();
        this._items.forEach((item) => {
          item.dispose();
        });
        this._box = null;
        this._root = null;
        this._items.clear();
        for (const widget of widgets) {
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding child widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        for (const bar of this.tabBars()) {
          if (bar.titles.length > 1) {
            for (const title of bar.titles) {
              title.owner.hiddenMode = this._hiddenMode;
            }
          }
        }
      }
      /**
       * Get the inter-element spacing for the dock layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the dock layout.
       */
      set spacing(value) {
        value = Utils$12.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Whether the dock layout is empty.
       */
      get isEmpty() {
        return this._root === null;
      }
      /**
       * Create an iterator over all widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       *
       * #### Notes
       * This iterator includes the generated tab bars.
       */
      [Symbol.iterator]() {
        return this._root ? this._root.iterAllWidgets() : empty();
      }
      /**
       * Create an iterator over the user widgets in the layout.
       *
       * @returns A new iterator over the user widgets in the layout.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      widgets() {
        return this._root ? this._root.iterUserWidgets() : empty();
      }
      /**
       * Create an iterator over the selected widgets in the layout.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the layout.
       */
      selectedWidgets() {
        return this._root ? this._root.iterSelectedWidgets() : empty();
      }
      /**
       * Create an iterator over the tab bars in the layout.
       *
       * @returns A new iterator over the tab bars in the layout.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      tabBars() {
        return this._root ? this._root.iterTabBars() : empty();
      }
      /**
       * Create an iterator over the handles in the layout.
       *
       * @returns A new iterator over the handles in the layout.
       */
      handles() {
        return this._root ? this._root.iterHandles() : empty();
      }
      /**
       * Move a handle to the given offset position.
       *
       * @param handle - The handle to move.
       *
       * @param offsetX - The desired offset X position of the handle.
       *
       * @param offsetY - The desired offset Y position of the handle.
       *
       * #### Notes
       * If the given handle is not contained in the layout, this is no-op.
       *
       * The handle will be moved as close as possible to the desired
       * position without violating any of the layout constraints.
       *
       * Only one of the coordinates is used depending on the orientation
       * of the handle. This method accepts both coordinates to make it
       * easy to invoke from a mouse move event without needing to know
       * the handle orientation.
       */
      moveHandle(handle, offsetX, offsetY) {
        let hidden = handle.classList.contains("lm-mod-hidden");
        if (!this._root || hidden) {
          return;
        }
        let data = this._root.findSplitNode(handle);
        if (!data) {
          return;
        }
        let delta;
        if (data.node.orientation === "horizontal") {
          delta = offsetX - handle.offsetLeft;
        } else {
          delta = offsetY - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        data.node.holdSizes();
        BoxEngine2.adjust(data.node.sizers, data.index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Save the current configuration of the dock layout.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        if (!this._root) {
          return { main: null };
        }
        this._root.holdAllSizes();
        return { main: this._root.createConfig() };
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       */
      restoreLayout(config) {
        let widgetSet = /* @__PURE__ */ new Set();
        let mainConfig;
        if (config.main) {
          mainConfig = Private$62.normalizeAreaConfig(config.main, widgetSet);
        } else {
          mainConfig = null;
        }
        let oldWidgets = this.widgets();
        let oldTabBars = this.tabBars();
        let oldHandles = this.handles();
        this._root = null;
        for (const widget of oldWidgets) {
          if (!widgetSet.has(widget)) {
            widget.parent = null;
          }
        }
        for (const tabBar of oldTabBars) {
          tabBar.dispose();
        }
        for (const handle of oldHandles) {
          if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
          }
        }
        for (const widget of widgetSet) {
          widget.parent = this.parent;
        }
        if (mainConfig) {
          this._root = Private$62.realizeAreaConfig(mainConfig, {
            // Ignoring optional `document` argument as we must reuse `this._document`
            createTabBar: (document2) => this._createTabBar(),
            createHandle: () => this._createHandle()
          }, this._document);
        } else {
          this._root = null;
        }
        if (!this.parent) {
          return;
        }
        widgetSet.forEach((widget) => {
          this.attachWidget(widget);
        });
        this.parent.fit();
      }
      /**
       * Add a widget to the dock layout.
       *
       * @param widget - The widget to add to the dock layout.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * The widget will be moved if it is already contained in the layout.
       *
       * An error will be thrown if the reference widget is invalid.
       */
      addWidget(widget, options = {}) {
        let ref = options.ref || null;
        let mode = options.mode || "tab-after";
        let refNode = null;
        if (this._root && ref) {
          refNode = this._root.findTabNode(ref);
        }
        if (ref && !refNode) {
          throw new Error("Reference widget is not in the layout.");
        }
        widget.parent = this.parent;
        switch (mode) {
          case "tab-after":
            this._insertTab(widget, ref, refNode, true);
            break;
          case "tab-before":
            this._insertTab(widget, ref, refNode, false);
            break;
          case "split-top":
            this._insertSplit(widget, ref, refNode, "vertical", false);
            break;
          case "split-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false);
            break;
          case "split-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true);
            break;
          case "split-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true);
            break;
          case "merge-top":
            this._insertSplit(widget, ref, refNode, "vertical", false, true);
            break;
          case "merge-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false, true);
            break;
          case "merge-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true, true);
            break;
          case "merge-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true, true);
            break;
        }
        if (!this.parent) {
          return;
        }
        this.attachWidget(widget);
        this.parent.fit();
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this._removeWidget(widget);
        if (!this.parent) {
          return;
        }
        this.detachWidget(widget);
        this.parent.fit();
      }
      /**
       * Find the tab area which contains the given client position.
       *
       * @param clientX - The client X position of interest.
       *
       * @param clientY - The client Y position of interest.
       *
       * @returns The geometry of the tab area at the given position, or
       *   `null` if there is no tab area at the given position.
       */
      hitTestTabAreas(clientX, clientY) {
        if (!this._root || !this.parent || !this.parent.isVisible) {
          return null;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let rect = this.parent.node.getBoundingClientRect();
        let x2 = clientX - rect.left - this._box.borderLeft;
        let y4 = clientY - rect.top - this._box.borderTop;
        let tabNode = this._root.hitTestTabNodes(x2, y4);
        if (!tabNode) {
          return null;
        }
        let { tabBar, top, left, width, height } = tabNode;
        let borderWidth = this._box.borderLeft + this._box.borderRight;
        let borderHeight = this._box.borderTop + this._box.borderBottom;
        let right = rect.width - borderWidth - (left + width);
        let bottom = rect.height - borderHeight - (top + height);
        return { tabBar, x: x2, y: y4, top, left, right, bottom, width, height };
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
        for (const handle of this.handles()) {
          this.parent.node.appendChild(handle);
        }
        this.parent.fit();
      }
      /**
       * Attach the widget to the layout parent widget.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a no-op if the widget is already attached.
       */
      attachWidget(widget) {
        if (this.parent.node === widget.node.parentNode) {
          return;
        }
        this._items.set(widget, new LayoutItem2(widget));
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
      }
      /**
       * Detach the widget from the layout parent widget.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a no-op if the widget is not attached.
       */
      detachWidget(widget) {
        if (this.parent.node !== widget.node.parentNode) {
          return;
        }
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
        let item = this._items.get(widget);
        if (item) {
          this._items.delete(widget);
          item.dispose();
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Remove the specified widget from the layout structure.
       *
       * #### Notes
       * This is a no-op if the widget is not in the layout tree.
       *
       * This does not detach the widget from the parent node.
       */
      _removeWidget(widget) {
        if (!this._root) {
          return;
        }
        let tabNode = this._root.findTabNode(widget);
        if (!tabNode) {
          return;
        }
        Private$62.removeAria(widget);
        if (tabNode.tabBar.titles.length > 1) {
          tabNode.tabBar.removeTab(widget.title);
          if (this._hiddenMode === Widget3.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
            const existingWidget = tabNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget3.HiddenMode.Display;
          }
          return;
        }
        tabNode.tabBar.dispose();
        if (this._root === tabNode) {
          this._root = null;
          return;
        }
        this._root.holdAllSizes();
        let splitNode = tabNode.parent;
        tabNode.parent = null;
        let i6 = ArrayExt.removeFirstOf(splitNode.children, tabNode);
        let handle = ArrayExt.removeAt(splitNode.handles, i6);
        ArrayExt.removeAt(splitNode.sizers, i6);
        if (handle.parentNode) {
          handle.parentNode.removeChild(handle);
        }
        if (splitNode.children.length > 1) {
          splitNode.syncHandles();
          return;
        }
        let maybeParent = splitNode.parent;
        splitNode.parent = null;
        let childNode = splitNode.children[0];
        let childHandle = splitNode.handles[0];
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        if (childHandle.parentNode) {
          childHandle.parentNode.removeChild(childHandle);
        }
        if (this._root === splitNode) {
          childNode.parent = null;
          this._root = childNode;
          return;
        }
        let parentNode = maybeParent;
        let j2 = parentNode.children.indexOf(splitNode);
        if (childNode instanceof Private$62.TabLayoutNode) {
          childNode.parent = parentNode;
          parentNode.children[j2] = childNode;
          return;
        }
        let splitHandle = ArrayExt.removeAt(parentNode.handles, j2);
        ArrayExt.removeAt(parentNode.children, j2);
        ArrayExt.removeAt(parentNode.sizers, j2);
        if (splitHandle.parentNode) {
          splitHandle.parentNode.removeChild(splitHandle);
        }
        for (let i7 = 0, n5 = childNode.children.length; i7 < n5; ++i7) {
          let gChild = childNode.children[i7];
          let gHandle = childNode.handles[i7];
          let gSizer = childNode.sizers[i7];
          ArrayExt.insert(parentNode.children, j2 + i7, gChild);
          ArrayExt.insert(parentNode.handles, j2 + i7, gHandle);
          ArrayExt.insert(parentNode.sizers, j2 + i7, gSizer);
          gChild.parent = parentNode;
        }
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        parentNode.syncHandles();
      }
      /**
       * Create the tab layout node to hold the widget.
       */
      _createTabNode(widget) {
        let tabNode = new Private$62.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        Private$62.addAria(widget, tabNode.tabBar);
        return tabNode;
      }
      /**
       * Insert a widget next to an existing tab.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertTab(widget, ref, refNode, after2) {
        if (widget === ref) {
          return;
        }
        if (!this._root) {
          let tabNode = new Private$62.TabLayoutNode(this._createTabBar());
          tabNode.tabBar.addTab(widget.title);
          this._root = tabNode;
          Private$62.addAria(widget, tabNode.tabBar);
          return;
        }
        if (!refNode) {
          refNode = this._root.findFirstTabNode();
        }
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
          this._removeWidget(widget);
          widget.hide();
        }
        let index2;
        if (ref) {
          index2 = refNode.tabBar.titles.indexOf(ref.title);
        } else {
          index2 = refNode.tabBar.currentIndex;
        }
        if (this._hiddenMode === Widget3.HiddenMode.Scale) {
          if (refNode.tabBar.titles.length === 0) {
            widget.hiddenMode = Widget3.HiddenMode.Display;
          } else if (refNode.tabBar.titles.length == 1) {
            const existingWidget = refNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget3.HiddenMode.Scale;
          } else {
            widget.hiddenMode = Widget3.HiddenMode.Scale;
          }
        } else {
          widget.hiddenMode = this._hiddenMode;
        }
        refNode.tabBar.insertTab(index2 + (after2 ? 1 : 0), widget.title);
        Private$62.addAria(widget, refNode.tabBar);
      }
      /**
       * Insert a widget as a new split area.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertSplit(widget, ref, refNode, orientation, after2, merge = false) {
        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {
          return;
        }
        this._removeWidget(widget);
        if (!this._root) {
          this._root = this._createTabNode(widget);
          return;
        }
        if (!refNode || !refNode.parent) {
          let root2 = this._splitRoot(orientation);
          let i7 = after2 ? root2.children.length : 0;
          root2.normalizeSizes();
          let sizer = Private$62.createSizer(refNode ? 1 : Private$62.GOLDEN_RATIO);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(root2.children, i7, tabNode2);
          ArrayExt.insert(root2.sizers, i7, sizer);
          ArrayExt.insert(root2.handles, i7, this._createHandle());
          tabNode2.parent = root2;
          root2.normalizeSizes();
          root2.syncHandles();
          return;
        }
        let splitNode = refNode.parent;
        if (splitNode.orientation === orientation) {
          let i7 = splitNode.children.indexOf(refNode);
          if (merge) {
            let j4 = i7 + (after2 ? 1 : -1);
            let sibling = splitNode.children[j4];
            if (sibling instanceof Private$62.TabLayoutNode) {
              this._insertTab(widget, null, sibling, true);
              ++sibling.tabBar.currentIndex;
              return;
            }
          }
          splitNode.normalizeSizes();
          let s8 = splitNode.sizers[i7].sizeHint /= 2;
          let j3 = i7 + (after2 ? 1 : 0);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(splitNode.children, j3, tabNode2);
          ArrayExt.insert(splitNode.sizers, j3, Private$62.createSizer(s8));
          ArrayExt.insert(splitNode.handles, j3, this._createHandle());
          tabNode2.parent = splitNode;
          splitNode.syncHandles();
          return;
        }
        let i6 = ArrayExt.removeFirstOf(splitNode.children, refNode);
        let childNode = new Private$62.SplitLayoutNode(orientation);
        childNode.normalized = true;
        childNode.children.push(refNode);
        childNode.sizers.push(Private$62.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        let j2 = after2 ? 1 : 0;
        let tabNode = this._createTabNode(widget);
        ArrayExt.insert(childNode.children, j2, tabNode);
        ArrayExt.insert(childNode.sizers, j2, Private$62.createSizer(0.5));
        ArrayExt.insert(childNode.handles, j2, this._createHandle());
        tabNode.parent = childNode;
        childNode.syncHandles();
        ArrayExt.insert(splitNode.children, i6, childNode);
        childNode.parent = splitNode;
      }
      /**
       * Ensure the root is a split node with the given orientation.
       */
      _splitRoot(orientation) {
        let oldRoot = this._root;
        if (oldRoot instanceof Private$62.SplitLayoutNode) {
          if (oldRoot.orientation === orientation) {
            return oldRoot;
          }
        }
        let newRoot = this._root = new Private$62.SplitLayoutNode(orientation);
        if (oldRoot) {
          newRoot.children.push(oldRoot);
          newRoot.sizers.push(Private$62.createSizer(0));
          newRoot.handles.push(this._createHandle());
          oldRoot.parent = newRoot;
        }
        return newRoot;
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        if (this._root) {
          let limits = this._root.fit(this._spacing, this._items);
          minW = limits.minWidth;
          minH = limits.minHeight;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop3.sendMessage(this.parent.parent, Widget3.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop3.sendMessage(this.parent, Widget3.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (!this._root) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let x2 = this._box.paddingTop;
        let y4 = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        this._root.update(x2, y4, width, height, this._spacing, this._items);
      }
      /**
       * Create a new tab bar for use by the dock layout.
       *
       * #### Notes
       * The tab bar will be attached to the parent if it exists.
       */
      _createTabBar() {
        let tabBar = this.renderer.createTabBar(this._document);
        tabBar.orientation = "horizontal";
        if (this.parent) {
          this.attachWidget(tabBar);
        }
        return tabBar;
      }
      /**
       * Create a new handle for the dock layout.
       *
       * #### Notes
       * The handle will be attached to the parent if it exists.
       */
      _createHandle() {
        let handle = this.renderer.createHandle();
        let style = handle.style;
        style.position = "absolute";
        style.contain = "strict";
        style.top = "0";
        style.left = "0";
        style.width = "0";
        style.height = "0";
        if (this.parent) {
          this.parent.node.appendChild(handle);
        }
        return handle;
      }
    };
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      function createSizer(hint) {
        let sizer = new BoxSizer2();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
      }
      Private22.createSizer = createSizer;
      function normalizeAreaConfig(config, widgetSet) {
        let result2;
        if (config.type === "tab-area") {
          result2 = normalizeTabAreaConfig(config, widgetSet);
        } else {
          result2 = normalizeSplitAreaConfig(config, widgetSet);
        }
        return result2;
      }
      Private22.normalizeAreaConfig = normalizeAreaConfig;
      function realizeAreaConfig(config, renderer, document2) {
        let node;
        if (config.type === "tab-area") {
          node = realizeTabAreaConfig(config, renderer, document2);
        } else {
          node = realizeSplitAreaConfig(config, renderer, document2);
        }
        return node;
      }
      Private22.realizeAreaConfig = realizeAreaConfig;
      class TabLayoutNode {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        constructor(tabBar) {
          this.parent = null;
          this._top = 0;
          this._left = 0;
          this._width = 0;
          this._height = 0;
          let tabSizer = new BoxSizer2();
          let widgetSizer = new BoxSizer2();
          tabSizer.stretch = 0;
          widgetSizer.stretch = 1;
          this.tabBar = tabBar;
          this.sizers = [tabSizer, widgetSizer];
        }
        /**
         * The most recent value for the `top` edge of the layout box.
         */
        get top() {
          return this._top;
        }
        /**
         * The most recent value for the `left` edge of the layout box.
         */
        get left() {
          return this._left;
        }
        /**
         * The most recent value for the `width` of the layout box.
         */
        get width() {
          return this._width;
        }
        /**
         * The most recent value for the `height` of the layout box.
         */
        get height() {
          return this._height;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          yield this.tabBar;
          yield* this.iterUserWidgets();
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const title of this.tabBar.titles) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          let title = this.tabBar.currentTitle;
          if (title) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          yield this.tabBar;
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        // eslint-disable-next-line require-yield
        *iterHandles() {
          return;
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          return this;
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          if (x2 < this._left || x2 >= this._left + this._width) {
            return null;
          }
          if (y4 < this._top || y4 >= this._top + this._height) {
            return null;
          }
          return this;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let widgets = this.tabBar.titles.map((title) => title.owner);
          let currentIndex = this.tabBar.currentIndex;
          return { type: "tab-area", widgets, currentIndex };
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          return;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let minWidth = 0;
          let minHeight = 0;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          let [tabBarSizer, widgetSizer] = this.sizers;
          if (tabBarItem) {
            tabBarItem.fit();
          }
          if (widgetItem) {
            widgetItem.fit();
          }
          if (tabBarItem && !tabBarItem.isHidden) {
            minWidth = Math.max(minWidth, tabBarItem.minWidth);
            minHeight += tabBarItem.minHeight;
            tabBarSizer.minSize = tabBarItem.minHeight;
            tabBarSizer.maxSize = tabBarItem.maxHeight;
          } else {
            tabBarSizer.minSize = 0;
            tabBarSizer.maxSize = 0;
          }
          if (widgetItem && !widgetItem.isHidden) {
            minWidth = Math.max(minWidth, widgetItem.minWidth);
            minHeight += widgetItem.minHeight;
            widgetSizer.minSize = widgetItem.minHeight;
            widgetSizer.maxSize = Infinity;
          } else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = Infinity;
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          this._top = top;
          this._left = left;
          this._width = width;
          this._height = height;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          BoxEngine2.calc(this.sizers, height);
          if (tabBarItem && !tabBarItem.isHidden) {
            let size5 = this.sizers[0].size;
            tabBarItem.update(left, top, width, size5);
            top += size5;
          }
          if (widgetItem && !widgetItem.isHidden) {
            let size5 = this.sizers[1].size;
            widgetItem.update(left, top, width, size5);
          }
        }
      }
      Private22.TabLayoutNode = TabLayoutNode;
      class SplitLayoutNode {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        constructor(orientation) {
          this.parent = null;
          this.normalized = false;
          this.children = [];
          this.sizers = [];
          this.handles = [];
          this.orientation = orientation;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          for (const child of this.children) {
            yield* child.iterAllWidgets();
          }
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const child of this.children) {
            yield* child.iterUserWidgets();
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          for (const child of this.children) {
            yield* child.iterSelectedWidgets();
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          for (const child of this.children) {
            yield* child.iterTabBars();
          }
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        *iterHandles() {
          yield* this.handles;
          for (const child of this.children) {
            yield* child.iterHandles();
          }
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findTabNode(widget);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          let index2 = this.handles.indexOf(handle);
          if (index2 !== -1) {
            return { index: index2, node: this };
          }
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findSplitNode(handle);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          if (this.children.length === 0) {
            return null;
          }
          return this.children[0].findFirstTabNode();
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].hitTestTabNodes(x2, y4);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let orientation = this.orientation;
          let sizes = this.createNormalizedSizes();
          let children = this.children.map((child) => child.createConfig());
          return { type: "split-area", orientation, children, sizes };
        }
        /**
         * Sync the visibility and orientation of the handles.
         */
        syncHandles() {
          this.handles.forEach((handle, i6) => {
            handle.setAttribute("data-orientation", this.orientation);
            if (i6 === this.handles.length - 1) {
              handle.classList.add("lm-mod-hidden");
            } else {
              handle.classList.remove("lm-mod-hidden");
            }
          });
        }
        /**
         * Hold the current sizes of the box sizers.
         *
         * This sets the size hint of each sizer to its current size.
         */
        holdSizes() {
          for (const sizer of this.sizers) {
            sizer.sizeHint = sizer.size;
          }
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          for (const child of this.children) {
            child.holdAllSizes();
          }
          this.holdSizes();
        }
        /**
         * Normalize the sizes of the split layout node.
         */
        normalizeSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return;
          }
          this.holdSizes();
          let sum = this.sizers.reduce((v4, sizer) => v4 + sizer.sizeHint, 0);
          if (sum === 0) {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint = 1 / n5;
            }
          } else {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint /= sum;
            }
          }
          this.normalized = true;
        }
        /**
         * Snap the normalized sizes of the split layout node.
         */
        createNormalizedSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return [];
          }
          let sizes = this.sizers.map((sizer) => sizer.size);
          let sum = sizes.reduce((v4, size5) => v4 + size5, 0);
          if (sum === 0) {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] = 1 / n5;
            }
          } else {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] /= sum;
            }
          }
          return sizes;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let minWidth = horizontal ? fixed : 0;
          let minHeight = horizontal ? 0 : fixed;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let limits = this.children[i6].fit(spacing, items);
            if (horizontal) {
              minHeight = Math.max(minHeight, limits.minHeight);
              minWidth += limits.minWidth;
              this.sizers[i6].minSize = limits.minWidth;
            } else {
              minWidth = Math.max(minWidth, limits.minWidth);
              minHeight += limits.minHeight;
              this.sizers[i6].minSize = limits.minHeight;
            }
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let space = Math.max(0, (horizontal ? width : height) - fixed);
          if (this.normalized) {
            for (const sizer of this.sizers) {
              sizer.sizeHint *= space;
            }
            this.normalized = false;
          }
          BoxEngine2.calc(this.sizers, space);
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let child = this.children[i6];
            let size5 = this.sizers[i6].size;
            let handleStyle = this.handles[i6].style;
            if (horizontal) {
              child.update(left, top, size5, height, spacing, items);
              left += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${spacing}px`;
              handleStyle.height = `${height}px`;
              left += spacing;
            } else {
              child.update(left, top, width, size5, spacing, items);
              top += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${width}px`;
              handleStyle.height = `${spacing}px`;
              top += spacing;
            }
          }
        }
      }
      Private22.SplitLayoutNode = SplitLayoutNode;
      function addAria(widget, tabBar) {
        widget.node.setAttribute("role", "tabpanel");
        let renderer = tabBar.renderer;
        if (renderer instanceof TabBar3.Renderer) {
          let tabId = renderer.createTabKey({
            title: widget.title,
            current: false,
            zIndex: 0
          });
          widget.node.setAttribute("aria-labelledby", tabId);
        }
      }
      Private22.addAria = addAria;
      function removeAria(widget) {
        widget.node.removeAttribute("role");
        widget.node.removeAttribute("aria-labelledby");
      }
      Private22.removeAria = removeAria;
      function normalizeTabAreaConfig(config, widgetSet) {
        if (config.widgets.length === 0) {
          return null;
        }
        let widgets = [];
        for (const widget of config.widgets) {
          if (!widgetSet.has(widget)) {
            widgetSet.add(widget);
            widgets.push(widget);
          }
        }
        if (widgets.length === 0) {
          return null;
        }
        let index2 = config.currentIndex;
        if (index2 !== -1 && (index2 < 0 || index2 >= widgets.length)) {
          index2 = 0;
        }
        return { type: "tab-area", widgets, currentIndex: index2 };
      }
      function normalizeSplitAreaConfig(config, widgetSet) {
        let orientation = config.orientation;
        let children = [];
        let sizes = [];
        for (let i6 = 0, n5 = config.children.length; i6 < n5; ++i6) {
          let child = normalizeAreaConfig(config.children[i6], widgetSet);
          if (!child) {
            continue;
          }
          if (child.type === "tab-area" || child.orientation !== orientation) {
            children.push(child);
            sizes.push(Math.abs(config.sizes[i6] || 0));
          } else {
            children.push(...child.children);
            sizes.push(...child.sizes);
          }
        }
        if (children.length === 0) {
          return null;
        }
        if (children.length === 1) {
          return children[0];
        }
        return { type: "split-area", orientation, children, sizes };
      }
      function realizeTabAreaConfig(config, renderer, document2) {
        let tabBar = renderer.createTabBar(document2);
        for (const widget of config.widgets) {
          widget.hide();
          tabBar.addTab(widget.title);
          Private22.addAria(widget, tabBar);
        }
        tabBar.currentIndex = config.currentIndex;
        return new TabLayoutNode(tabBar);
      }
      function realizeSplitAreaConfig(config, renderer, document2) {
        let node = new SplitLayoutNode(config.orientation);
        config.children.forEach((child, i6) => {
          let childNode = realizeAreaConfig(child, renderer, document2);
          let sizer = createSizer(config.sizes[i6]);
          let handle = renderer.createHandle();
          node.children.push(childNode);
          node.handles.push(handle);
          node.sizers.push(sizer);
          childNode.parent = node;
        });
        node.syncHandles();
        node.normalizeSizes();
        return node;
      }
    })(Private$62 || (Private$62 = {}));
    DockPanel2 = class extends Widget3 {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this._drag = null;
        this._tabsMovable = true;
        this._tabsConstrained = false;
        this._addButtonEnabled = false;
        this._pressData = null;
        this._layoutModified = new Signal(this);
        this._addRequested = new Signal(this);
        this.addClass("lm-DockPanel");
        this._document = options.document || document;
        this._mode = options.mode || "multiple-document";
        this._renderer = options.renderer || DockPanel2.defaultRenderer;
        this._edges = options.edges || Private$52.DEFAULT_EDGES;
        if (options.tabsMovable !== void 0) {
          this._tabsMovable = options.tabsMovable;
        }
        if (options.tabsConstrained !== void 0) {
          this._tabsConstrained = options.tabsConstrained;
        }
        if (options.addButtonEnabled !== void 0) {
          this._addButtonEnabled = options.addButtonEnabled;
        }
        this.dataset["mode"] = this._mode;
        let renderer = {
          createTabBar: () => this._createTabBar(),
          createHandle: () => this._createHandle()
        };
        this.layout = new DockLayout2({
          document: this._document,
          renderer,
          spacing: options.spacing,
          hiddenMode: options.hiddenMode
        });
        this.overlay = options.overlay || new DockPanel2.Overlay();
        this.node.appendChild(this.overlay.node);
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        this.overlay.hide(0);
        if (this._drag) {
          this._drag.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding widgets.
       */
      get hiddenMode() {
        return this.layout.hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       */
      set hiddenMode(v4) {
        this.layout.hiddenMode = v4;
      }
      /**
       * A signal emitted when the layout configuration is modified.
       *
       * #### Notes
       * This signal is emitted whenever the current layout configuration
       * may have changed.
       *
       * This signal is emitted asynchronously in a collapsed fashion, so
       * that multiple synchronous modifications results in only a single
       * emit of the signal.
       */
      get layoutModified() {
        return this._layoutModified;
      }
      /**
       * A signal emitted when the add button on a tab bar is clicked.
       *
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * The renderer used by the dock panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * Get the spacing between the widgets.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the spacing between the widgets.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * Get the mode for the dock panel.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Set the mode for the dock panel.
       *
       * #### Notes
       * Changing the mode is a destructive operation with respect to the
       * panel's layout configuration. If layout state must be preserved,
       * save the current layout config before changing the mode.
       */
      set mode(value) {
        if (this._mode === value) {
          return;
        }
        this._mode = value;
        this.dataset["mode"] = value;
        let layout = this.layout;
        switch (value) {
          case "multiple-document":
            for (const tabBar of layout.tabBars()) {
              tabBar.show();
            }
            break;
          case "single-document":
            layout.restoreLayout(Private$52.createSingleDocumentConfig(this));
            break;
          default:
            throw "unreachable";
        }
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Whether the tabs can be dragged / moved at runtime.
       */
      get tabsMovable() {
        return this._tabsMovable;
      }
      /**
       * Enable / Disable draggable / movable tabs.
       */
      set tabsMovable(value) {
        this._tabsMovable = value;
        for (const tabBar of this.tabBars()) {
          tabBar.tabsMovable = value;
        }
      }
      /**
       * Whether the tabs are constrained to their source dock panel
       */
      get tabsConstrained() {
        return this._tabsConstrained;
      }
      /**
       * Constrain/Allow tabs to be dragged outside of this dock panel
       */
      set tabsConstrained(value) {
        this._tabsConstrained = value;
      }
      /**
       * Whether the add buttons for each tab bar are enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add buttons for each tab bar are enabled.
       */
      set addButtonEnabled(value) {
        this._addButtonEnabled = value;
        for (const tabBar of this.tabBars()) {
          tabBar.addButtonEnabled = value;
        }
      }
      /**
       * Whether the dock panel is empty.
       */
      get isEmpty() {
        return this.layout.isEmpty;
      }
      /**
       * Create an iterator over the user widgets in the panel.
       *
       * @returns A new iterator over the user widgets in the panel.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      *widgets() {
        yield* this.layout.widgets();
      }
      /**
       * Create an iterator over the selected widgets in the panel.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the panel.
       */
      *selectedWidgets() {
        yield* this.layout.selectedWidgets();
      }
      /**
       * Create an iterator over the tab bars in the panel.
       *
       * @returns A new iterator over the tab bars in the panel.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      *tabBars() {
        yield* this.layout.tabBars();
      }
      /**
       * Create an iterator over the handles in the panel.
       *
       * @returns A new iterator over the handles in the panel.
       */
      *handles() {
        yield* this.layout.handles();
      }
      /**
       * Select a specific widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will make the widget the current widget in its tab area.
       */
      selectWidget(widget) {
        let tabBar = find(this.tabBars(), (bar) => {
          return bar.titles.indexOf(widget.title) !== -1;
        });
        if (!tabBar) {
          throw new Error("Widget is not contained in the dock panel.");
        }
        tabBar.currentTitle = widget.title;
      }
      /**
       * Activate a specified widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will select and activate the given widget.
       */
      activateWidget(widget) {
        this.selectWidget(widget);
        widget.activate();
      }
      /**
       * Save the current layout configuration of the dock panel.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        return this.layout.saveLayout();
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       *
       * The dock panel automatically reverts to `'multiple-document'`
       * mode when a layout config is restored.
       */
      restoreLayout(config) {
        this._mode = "multiple-document";
        this.layout.restoreLayout(config);
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop3.flush();
        }
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Add a widget to the dock panel.
       *
       * @param widget - The widget to add to the dock panel.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * If the panel is in single document mode, the options are ignored
       * and the widget is always added as tab in the hidden tab bar.
       */
      addWidget(widget, options = {}) {
        if (this._mode === "single-document") {
          this.layout.addWidget(widget);
        } else {
          this.layout.addWidget(widget, options);
        }
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       */
      processMessage(msg) {
        if (msg.type === "layout-modified") {
          this._layoutModified.emit(void 0);
        } else {
          super.processMessage(msg);
        }
      }
      /**
       * Handle the DOM events for the dock panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "lm-dragenter":
            this._evtDragEnter(event);
            break;
          case "lm-dragleave":
            this._evtDragLeave(event);
            break;
          case "lm-dragover":
            this._evtDragOver(event);
            break;
          case "lm-drop":
            this._evtDrop(event);
            break;
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("lm-dragenter", this);
        this.node.addEventListener("lm-dragleave", this);
        this.node.addEventListener("lm-dragover", this);
        this.node.addEventListener("lm-drop", this);
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("lm-dragenter", this);
        this.node.removeEventListener("lm-dragleave", this);
        this.node.removeEventListener("lm-dragover", this);
        this.node.removeEventListener("lm-drop", this);
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        if (Private$52.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.addClass("lm-DockPanel-widget");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        if (Private$52.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.removeClass("lm-DockPanel-widget");
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Handle the `'lm-dragenter'` event for the dock panel.
       */
      _evtDragEnter(event) {
        if (event.mimeData.hasData("application/vnd.lumino.widget-factory")) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /**
       * Handle the `'lm-dragleave'` event for the dock panel.
       */
      _evtDragLeave(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this)
          return;
        event.stopPropagation();
        this.overlay.hide(1);
      }
      /**
       * Handle the `'lm-dragover'` event for the dock panel.
       */
      _evtDragOver(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this || this._showOverlay(event.clientX, event.clientY) === "invalid") {
          event.dropAction = "none";
        } else {
          event.stopPropagation();
          event.dropAction = event.proposedAction;
        }
      }
      /**
       * Handle the `'lm-drop'` event for the dock panel.
       */
      _evtDrop(event) {
        event.preventDefault();
        this.overlay.hide(0);
        if (event.proposedAction === "none") {
          event.dropAction = "none";
          return;
        }
        let { clientX, clientY } = event;
        let { zone, target } = Private$52.findDropTarget(this, clientX, clientY, this._edges);
        if (this._tabsConstrained && event.source !== this || zone === "invalid") {
          event.dropAction = "none";
          return;
        }
        let mimeData = event.mimeData;
        let factory = mimeData.getData("application/vnd.lumino.widget-factory");
        if (typeof factory !== "function") {
          event.dropAction = "none";
          return;
        }
        let widget = factory();
        if (!(widget instanceof Widget3)) {
          event.dropAction = "none";
          return;
        }
        if (widget.contains(this)) {
          event.dropAction = "none";
          return;
        }
        let ref = target ? Private$52.getDropRef(target.tabBar) : null;
        switch (zone) {
          case "root-all":
            this.addWidget(widget);
            break;
          case "root-top":
            this.addWidget(widget, { mode: "split-top" });
            break;
          case "root-left":
            this.addWidget(widget, { mode: "split-left" });
            break;
          case "root-right":
            this.addWidget(widget, { mode: "split-right" });
            break;
          case "root-bottom":
            this.addWidget(widget, { mode: "split-bottom" });
            break;
          case "widget-all":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          case "widget-top":
            this.addWidget(widget, { mode: "split-top", ref });
            break;
          case "widget-left":
            this.addWidget(widget, { mode: "split-left", ref });
            break;
          case "widget-right":
            this.addWidget(widget, { mode: "split-right", ref });
            break;
          case "widget-bottom":
            this.addWidget(widget, { mode: "split-bottom", ref });
            break;
          case "widget-tab":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          default:
            throw "unreachable";
        }
        event.dropAction = event.proposedAction;
        event.stopPropagation();
        this.activateWidget(widget);
      }
      /**
       * Handle the `'keydown'` event for the dock panel.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this._releaseMouse();
          MessageLoop3.postMessage(this, Private$52.LayoutModified);
        }
      }
      /**
       * Handle the `'pointerdown'` event for the dock panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let target = event.target;
        let handle = find(layout.handles(), (handle2) => handle2.contains(target));
        if (!handle) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._document.addEventListener("keydown", this, true);
        this._document.addEventListener("pointerup", this, true);
        this._document.addEventListener("pointermove", this, true);
        this._document.addEventListener("contextmenu", this, true);
        let rect = handle.getBoundingClientRect();
        let deltaX = event.clientX - rect.left;
        let deltaY = event.clientY - rect.top;
        let style = window.getComputedStyle(handle);
        let override = Drag2.overrideCursor(style.cursor, this._document);
        this._pressData = { handle, deltaX, deltaY, override };
      }
      /**
       * Handle the `'pointermove'` event for the dock panel.
       */
      _evtPointerMove(event) {
        if (!this._pressData) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let rect = this.node.getBoundingClientRect();
        let xPos = event.clientX - rect.left - this._pressData.deltaX;
        let yPos = event.clientY - rect.top - this._pressData.deltaY;
        let layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
      }
      /**
       * Handle the `'pointerup'` event for the dock panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Release the mouse grab for the dock panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._document.removeEventListener("keydown", this, true);
        this._document.removeEventListener("pointerup", this, true);
        this._document.removeEventListener("pointermove", this, true);
        this._document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Show the overlay indicator at the given client position.
       *
       * Returns the drop zone at the specified client position.
       *
       * #### Notes
       * If the position is not over a valid zone, the overlay is hidden.
       */
      _showOverlay(clientX, clientY) {
        let { zone, target } = Private$52.findDropTarget(this, clientX, clientY, this._edges);
        if (zone === "invalid") {
          this.overlay.hide(100);
          return zone;
        }
        let top;
        let left;
        let right;
        let bottom;
        let box = ElementExt.boxSizing(this.node);
        let rect = this.node.getBoundingClientRect();
        switch (zone) {
          case "root-all":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-top":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = rect.height * Private$52.GOLDEN_RATIO;
            break;
          case "root-left":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = rect.width * Private$52.GOLDEN_RATIO;
            bottom = box.paddingBottom;
            break;
          case "root-right":
            top = box.paddingTop;
            left = rect.width * Private$52.GOLDEN_RATIO;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-bottom":
            top = rect.height * Private$52.GOLDEN_RATIO;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "widget-all":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-top":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height / 2;
            break;
          case "widget-left":
            top = target.top;
            left = target.left;
            right = target.right + target.width / 2;
            bottom = target.bottom;
            break;
          case "widget-right":
            top = target.top;
            left = target.left + target.width / 2;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-bottom":
            top = target.top + target.height / 2;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-tab": {
            const tabHeight = target.tabBar.node.getBoundingClientRect().height;
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height - tabHeight;
            break;
          }
          default:
            throw "unreachable";
        }
        this.overlay.show({ top, left, right, bottom });
        return zone;
      }
      /**
       * Create a new tab bar for use by the panel.
       */
      _createTabBar() {
        let tabBar = this._renderer.createTabBar(this._document);
        Private$52.isGeneratedTabBarProperty.set(tabBar, true);
        if (this._mode === "single-document") {
          tabBar.hide();
        }
        tabBar.tabsMovable = this._tabsMovable;
        tabBar.allowDeselect = false;
        tabBar.addButtonEnabled = this._addButtonEnabled;
        tabBar.removeBehavior = "select-previous-tab";
        tabBar.insertBehavior = "select-tab-if-needed";
        tabBar.tabMoved.connect(this._onTabMoved, this);
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        tabBar.addRequested.connect(this._onTabAddRequested, this);
        return tabBar;
      }
      /**
       * Create a new handle for use by the panel.
       */
      _createHandle() {
        return this._renderer.createHandle();
      }
      /**
       * Handle the `tabMoved` signal from a tab bar.
       */
      _onTabMoved() {
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Handle the `currentChanged` signal from a tab bar.
       */
      _onCurrentChanged(sender, args) {
        let { previousTitle, currentTitle } = args;
        if (previousTitle) {
          previousTitle.owner.hide();
        }
        if (currentTitle) {
          currentTitle.owner.show();
        }
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop3.flush();
        }
        MessageLoop3.postMessage(this, Private$52.LayoutModified);
      }
      /**
       * Handle the `addRequested` signal from a tab bar.
       */
      _onTabAddRequested(sender) {
        this._addRequested.emit(sender);
      }
      /**
       * Handle the `tabActivateRequested` signal from a tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from a tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabDetachRequested` signal from a tab bar.
       */
      _onTabDetachRequested(sender, args) {
        if (this._drag) {
          return;
        }
        sender.releaseMouse();
        let { title, tab, clientX, clientY, offset: offset4 } = args;
        let mimeData = new import_coreutils3.MimeData();
        let factory = () => title.owner;
        mimeData.setData("application/vnd.lumino.widget-factory", factory);
        let dragImage = tab.cloneNode(true);
        if (offset4) {
          dragImage.style.top = `-${offset4.y}px`;
          dragImage.style.left = `-${offset4.x}px`;
        }
        this._drag = new Drag2({
          document: this._document,
          mimeData,
          dragImage,
          proposedAction: "move",
          supportedActions: "move",
          source: this
        });
        tab.classList.add("lm-mod-hidden");
        let cleanup = () => {
          this._drag = null;
          tab.classList.remove("lm-mod-hidden");
        };
        this._drag.start(clientX, clientY).then(cleanup);
      }
    };
    (function(DockPanel5) {
      class Overlay2 {
        /**
         * Construct a new overlay.
         */
        constructor() {
          this._timer = -1;
          this._hidden = true;
          this.node = document.createElement("div");
          this.node.classList.add("lm-DockPanel-overlay");
          this.node.classList.add("lm-mod-hidden");
          this.node.style.position = "absolute";
          this.node.style.contain = "strict";
        }
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo) {
          let style = this.node.style;
          style.top = `${geo.top}px`;
          style.left = `${geo.left}px`;
          style.right = `${geo.right}px`;
          style.bottom = `${geo.bottom}px`;
          clearTimeout(this._timer);
          this._timer = -1;
          if (!this._hidden) {
            return;
          }
          this._hidden = false;
          this.node.classList.remove("lm-mod-hidden");
        }
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay) {
          if (this._hidden) {
            return;
          }
          if (delay <= 0) {
            clearTimeout(this._timer);
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
            return;
          }
          if (this._timer !== -1) {
            return;
          }
          this._timer = window.setTimeout(() => {
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
          }, delay);
        }
      }
      DockPanel5.Overlay = Overlay2;
      class Renderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(document2) {
          let bar = new TabBar3({ document: document2 });
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-DockPanel-handle";
          return handle;
        }
      }
      DockPanel5.Renderer = Renderer;
      DockPanel5.defaultRenderer = new Renderer();
    })(DockPanel2 || (DockPanel2 = {}));
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      Private22.DEFAULT_EDGES = {
        /**
         * The size of the top edge dock zone for the root panel, in pixels.
         * This is different from the others to distinguish between the top
         * tab bar and the top root zone.
         */
        top: 12,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        right: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        bottom: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        left: 40
      };
      Private22.LayoutModified = new ConflatableMessage2("layout-modified");
      Private22.isGeneratedTabBarProperty = new AttachedProperty({
        name: "isGeneratedTabBar",
        create: () => false
      });
      function createSingleDocumentConfig(panel) {
        if (panel.isEmpty) {
          return { main: null };
        }
        let widgets = Array.from(panel.widgets());
        let selected = panel.selectedWidgets().next().value;
        let currentIndex = selected ? widgets.indexOf(selected) : -1;
        return { main: { type: "tab-area", widgets, currentIndex } };
      }
      Private22.createSingleDocumentConfig = createSingleDocumentConfig;
      function findDropTarget(panel, clientX, clientY, edges) {
        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
          return { zone: "invalid", target: null };
        }
        let layout = panel.layout;
        if (layout.isEmpty) {
          return { zone: "root-all", target: null };
        }
        if (panel.mode === "multiple-document") {
          let panelRect = panel.node.getBoundingClientRect();
          let pl = clientX - panelRect.left + 1;
          let pt = clientY - panelRect.top + 1;
          let pr = panelRect.right - clientX;
          let pb = panelRect.bottom - clientY;
          let pd = Math.min(pt, pr, pb, pl);
          switch (pd) {
            case pt:
              if (pt < edges.top) {
                return { zone: "root-top", target: null };
              }
              break;
            case pr:
              if (pr < edges.right) {
                return { zone: "root-right", target: null };
              }
              break;
            case pb:
              if (pb < edges.bottom) {
                return { zone: "root-bottom", target: null };
              }
              break;
            case pl:
              if (pl < edges.left) {
                return { zone: "root-left", target: null };
              }
              break;
            default:
              throw "unreachable";
          }
        }
        let target = layout.hitTestTabAreas(clientX, clientY);
        if (!target) {
          return { zone: "invalid", target: null };
        }
        if (panel.mode === "single-document") {
          return { zone: "widget-all", target };
        }
        let al = target.x - target.left + 1;
        let at = target.y - target.top + 1;
        let ar = target.left + target.width - target.x;
        let ab = target.top + target.height - target.y;
        const tabHeight = target.tabBar.node.getBoundingClientRect().height;
        if (at < tabHeight) {
          return { zone: "widget-tab", target };
        }
        let rx = Math.round(target.width / 3);
        let ry = Math.round(target.height / 3);
        if (al > rx && ar > rx && at > ry && ab > ry) {
          return { zone: "widget-all", target };
        }
        al /= rx;
        at /= ry;
        ar /= rx;
        ab /= ry;
        let ad = Math.min(al, at, ar, ab);
        let zone;
        switch (ad) {
          case al:
            zone = "widget-left";
            break;
          case at:
            zone = "widget-top";
            break;
          case ar:
            zone = "widget-right";
            break;
          case ab:
            zone = "widget-bottom";
            break;
          default:
            throw "unreachable";
        }
        return { zone, target };
      }
      Private22.findDropTarget = findDropTarget;
      function getDropRef(tabBar) {
        if (tabBar.titles.length === 0) {
          return null;
        }
        if (tabBar.currentTitle) {
          return tabBar.currentTitle.owner;
        }
        return tabBar.titles[tabBar.titles.length - 1].owner;
      }
      Private22.getDropRef = getDropRef;
    })(Private$52 || (Private$52 = {}));
    GridLayout2 = class extends Layout2 {
      /**
       * Construct a new grid layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._rowSpacing = 4;
        this._columnSpacing = 4;
        this._items = [];
        this._rowStarts = [];
        this._columnStarts = [];
        this._rowSizers = [new BoxSizer2()];
        this._columnSizers = [new BoxSizer2()];
        this._box = null;
        if (options.rowCount !== void 0) {
          Private$42.reallocSizers(this._rowSizers, options.rowCount);
        }
        if (options.columnCount !== void 0) {
          Private$42.reallocSizers(this._columnSizers, options.columnCount);
        }
        if (options.rowSpacing !== void 0) {
          this._rowSpacing = Private$42.clampValue(options.rowSpacing);
        }
        if (options.columnSpacing !== void 0) {
          this._columnSpacing = Private$42.clampValue(options.columnSpacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          let widget = item.widget;
          item.dispose();
          widget.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._rowStarts.length = 0;
        this._rowSizers.length = 0;
        this._columnStarts.length = 0;
        this._columnSizers.length = 0;
        super.dispose();
      }
      /**
       * Get the number of rows in the layout.
       */
      get rowCount() {
        return this._rowSizers.length;
      }
      /**
       * Set the number of rows in the layout.
       *
       * #### Notes
       * The minimum row count is `1`.
       */
      set rowCount(value) {
        if (value === this.rowCount) {
          return;
        }
        Private$42.reallocSizers(this._rowSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the number of columns in the layout.
       */
      get columnCount() {
        return this._columnSizers.length;
      }
      /**
       * Set the number of columns in the layout.
       *
       * #### Notes
       * The minimum column count is `1`.
       */
      set columnCount(value) {
        if (value === this.columnCount) {
          return;
        }
        Private$42.reallocSizers(this._columnSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the row spacing for the layout.
       */
      get rowSpacing() {
        return this._rowSpacing;
      }
      /**
       * Set the row spacing for the layout.
       */
      set rowSpacing(value) {
        value = Private$42.clampValue(value);
        if (this._rowSpacing === value) {
          return;
        }
        this._rowSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the column spacing for the layout.
       */
      get columnSpacing() {
        return this._columnSpacing;
      }
      /**
       * Set the col spacing for the layout.
       */
      set columnSpacing(value) {
        value = Private$42.clampValue(value);
        if (this._columnSpacing === value) {
          return;
        }
        this._columnSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @returns The stretch factor for the row.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      rowStretch(index2) {
        let sizer = this._rowSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @param value - The stretch factor for the row.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setRowStretch(index2, value) {
        let sizer = this._rowSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$42.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Get the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @returns The stretch factor for the column.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      columnStretch(index2) {
        let sizer = this._columnSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @param value - The stretch factor for the column.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setColumnStretch(index2, value) {
        let sizer = this._columnSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$42.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        for (const item of this._items) {
          yield item.widget;
        }
      }
      /**
       * Add a widget to the grid layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, this is no-op.
       */
      addWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 !== -1) {
          return;
        }
        this._items.push(new LayoutItem2(widget));
        if (this.parent) {
          this.attachWidget(widget);
        }
      }
      /**
       * Remove a widget from the grid layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 === -1) {
          return;
        }
        let item = ArrayExt.removeAt(this._items, i6);
        if (this.parent) {
          this.detachWidget(widget);
        }
        item.dispose();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowSizers[i6].minSize = 0;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnSizers[i6].minSize = 0;
        }
        let items = this._items.filter((it) => !it.isHidden);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          items[i6].fit();
        }
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        items.sort(Private$42.rowSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout2.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          Private$42.distributeMin(this._rowSizers, r1, r22, item.minHeight);
        }
        items.sort(Private$42.columnSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout2.getCellConfig(item.widget);
          let c1 = Math.min(config.column, maxCol);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          Private$42.distributeMin(this._columnSizers, c1, c22, item.minWidth);
        }
        if (this.fitPolicy === "set-no-constraint") {
          MessageLoop3.sendMessage(this.parent, Widget3.Msg.UpdateRequest);
          return;
        }
        let minH = maxRow * this._rowSpacing;
        let minW = maxCol * this._columnSpacing;
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          minH += this._rowSizers[i6].minSize;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          minW += this._columnSizers[i6].minSize;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop3.sendMessage(this.parent.parent, Widget3.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop3.sendMessage(this.parent, Widget3.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        let fixedRowSpace = maxRow * this._rowSpacing;
        let fixedColSpace = maxCol * this._columnSpacing;
        BoxEngine2.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
        BoxEngine2.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
        for (let i6 = 0, pos = top, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowStarts[i6] = pos;
          pos += this._rowSizers[i6].size + this._rowSpacing;
        }
        for (let i6 = 0, pos = left, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnStarts[i6] = pos;
          pos += this._columnSizers[i6].size + this._columnSpacing;
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let config = GridLayout2.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let c1 = Math.min(config.column, maxCol);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          let x2 = this._columnStarts[c1];
          let y4 = this._rowStarts[r1];
          let w3 = this._columnStarts[c22] + this._columnSizers[c22].size - x2;
          let h4 = this._rowStarts[r22] + this._rowSizers[r22].size - y4;
          item.update(x2, y4, w3, h4);
        }
      }
    };
    (function(GridLayout5) {
      function getCellConfig(widget) {
        return Private$42.cellConfigProperty.get(widget);
      }
      GridLayout5.getCellConfig = getCellConfig;
      function setCellConfig(widget, value) {
        Private$42.cellConfigProperty.set(widget, Private$42.normalizeConfig(value));
      }
      GridLayout5.setCellConfig = setCellConfig;
    })(GridLayout2 || (GridLayout2 = {}));
    (function(Private22) {
      Private22.cellConfigProperty = new AttachedProperty({
        name: "cellConfig",
        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
        changed: onChildCellConfigChanged
      });
      function normalizeConfig(config) {
        let row = Math.max(0, Math.floor(config.row || 0));
        let column = Math.max(0, Math.floor(config.column || 0));
        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));
        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));
        return { row, column, rowSpan, columnSpan };
      }
      Private22.normalizeConfig = normalizeConfig;
      function clampValue(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampValue = clampValue;
      function rowSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.rowSpan - c22.rowSpan;
      }
      Private22.rowSpanCmp = rowSpanCmp;
      function columnSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.columnSpan - c22.columnSpan;
      }
      Private22.columnSpanCmp = columnSpanCmp;
      function reallocSizers(sizers, count3) {
        count3 = Math.max(1, Math.floor(count3));
        while (sizers.length < count3) {
          sizers.push(new BoxSizer2());
        }
        if (sizers.length > count3) {
          sizers.length = count3;
        }
      }
      Private22.reallocSizers = reallocSizers;
      function distributeMin(sizers, i1, i22, minSize) {
        if (i22 < i1) {
          return;
        }
        if (i1 === i22) {
          let sizer = sizers[i1];
          sizer.minSize = Math.max(sizer.minSize, minSize);
          return;
        }
        let totalMin = 0;
        for (let i6 = i1; i6 <= i22; ++i6) {
          totalMin += sizers[i6].minSize;
        }
        if (totalMin >= minSize) {
          return;
        }
        let portion = (minSize - totalMin) / (i22 - i1 + 1);
        for (let i6 = i1; i6 <= i22; ++i6) {
          sizers[i6].minSize += portion;
        }
      }
      Private22.distributeMin = distributeMin;
      function onChildCellConfigChanged(child) {
        if (child.parent && child.parent.layout instanceof GridLayout2) {
          child.parent.fit();
        }
      }
    })(Private$42 || (Private$42 = {}));
    MenuBar2 = class extends Widget3 {
      /**
       * Construct a new menu bar.
       *
       * @param options - The options for initializing the menu bar.
       */
      constructor(options = {}) {
        super({ node: Private$32.createNode() });
        this._activeIndex = -1;
        this._tabFocusIndex = 0;
        this._menus = [];
        this._childMenu = null;
        this._overflowMenu = null;
        this._menuItemSizes = [];
        this._overflowIndex = -1;
        this.addClass("lm-MenuBar");
        this.setFlag(Widget3.Flag.DisallowLayout);
        this.renderer = options.renderer || MenuBar2.defaultRenderer;
        this._forceItemsPosition = options.forceItemsPosition || {
          forceX: true,
          forceY: true
        };
        this._overflowMenuOptions = options.overflowMenuOptions || {
          isVisible: true
        };
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._closeChildMenu();
        this._menus.length = 0;
        super.dispose();
      }
      /**
       * The child menu of the menu bar.
       *
       * #### Notes
       * This will be `null` if the menu bar does not have an open menu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The overflow index of the menu bar.
       */
      get overflowIndex() {
        return this._overflowIndex;
      }
      /**
       * The overflow menu of the menu bar.
       */
      get overflowMenu() {
        return this._overflowMenu;
      }
      /**
       * Get the menu bar content node.
       *
       * #### Notes
       * This is the node which holds the menu title nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-MenuBar-content")[0];
      }
      /**
       * Get the currently active menu.
       */
      get activeMenu() {
        return this._menus[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu.
       *
       * #### Notes
       * If the menu does not exist, the menu will be set to `null`.
       */
      set activeMenu(value) {
        this.activeIndex = value ? this._menus.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu.
       *
       * #### Notes
       * This will be `-1` if no menu is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu.
       *
       * #### Notes
       * If the menu cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._menus.length) {
          value = -1;
        }
        if (value > -1 && this._menus[value].items.length === 0) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        this.update();
      }
      /**
       * A read-only array of the menus in the menu bar.
       */
      get menus() {
        return this._menus;
      }
      /**
       * Open the active menu and activate its first menu item.
       *
       * #### Notes
       * If there is no active menu, this is a no-op.
       */
      openActiveMenu() {
        if (this._activeIndex === -1) {
          return;
        }
        this._openChildMenu();
        if (this._childMenu) {
          this._childMenu.activeIndex = -1;
          this._childMenu.activateNextItem();
        }
      }
      /**
       * Add a menu to the end of the menu bar.
       *
       * @param menu - The menu to add to the menu bar.
       *
       * #### Notes
       * If the menu is already added to the menu bar, it will be moved.
       */
      addMenu(menu, update = true) {
        this.insertMenu(this._menus.length, menu, update);
      }
      /**
       * Insert a menu into the menu bar at the specified index.
       *
       * @param index - The index at which to insert the menu.
       *
       * @param menu - The menu to insert into the menu bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the menus.
       *
       * If the menu is already added to the menu bar, it will be moved.
       */
      insertMenu(index2, menu, update = true) {
        this._closeChildMenu();
        let i6 = this._menus.indexOf(menu);
        let j2 = Math.max(0, Math.min(index2, this._menus.length));
        if (i6 === -1) {
          ArrayExt.insert(this._menus, j2, menu);
          menu.addClass("lm-MenuBar-menu");
          menu.aboutToClose.connect(this._onMenuAboutToClose, this);
          menu.menuRequested.connect(this._onMenuMenuRequested, this);
          menu.title.changed.connect(this._onTitleChanged, this);
          if (update) {
            this.update();
          }
          return;
        }
        if (j2 === this._menus.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._menus, i6, j2);
        if (update) {
          this.update();
        }
      }
      /**
       * Remove a menu from the menu bar.
       *
       * @param menu - The menu to remove from the menu bar.
       *
       * #### Notes
       * This is a no-op if the menu is not in the menu bar.
       */
      removeMenu(menu, update = true) {
        this.removeMenuAt(this._menus.indexOf(menu), update);
      }
      /**
       * Remove the menu at a given index from the menu bar.
       *
       * @param index - The index of the menu to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeMenuAt(index2, update = true) {
        this._closeChildMenu();
        let menu = ArrayExt.removeAt(this._menus, index2);
        if (!menu) {
          return;
        }
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        menu.removeClass("lm-MenuBar-menu");
        if (update) {
          this.update();
        }
      }
      /**
       * Remove all menus from the menu bar.
       */
      clearMenus() {
        if (this._menus.length === 0) {
          return;
        }
        this._closeChildMenu();
        for (let menu of this._menus) {
          menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
          menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
          menu.title.changed.disconnect(this._onTitleChanged, this);
          menu.removeClass("lm-MenuBar-menu");
        }
        this._menus.length = 0;
        this.update();
      }
      /**
       * Handle the DOM events for the menu bar.
       *
       * @param event - The DOM event sent to the menu bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu bar's DOM nodes. It
       * should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "mousemove":
          case "mouseleave":
            this._evtMouseMove(event);
            break;
          case "focusout":
            this._evtFocusOut(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mousedown", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("focusout", this);
        this.node.addEventListener("contextmenu", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mousedown", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("focusout", this);
        this.node.removeEventListener("contextmenu", this);
        this._closeChildMenu();
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this._focusItemAt(0);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        this.update();
        super.onResize(msg);
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let menus = this._menus;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
        let totalMenuSize = 0;
        let isVisible2 = false;
        length = this._overflowMenu !== null ? length - 1 : length;
        let content = new Array(length);
        for (let i6 = 0; i6 < length; ++i6) {
          content[i6] = renderer.renderItem({
            title: menus[i6].title,
            active: i6 === activeIndex,
            tabbable: i6 === tabFocusIndex,
            disabled: menus[i6].items.length === 0,
            onfocus: () => {
              this._tabFocusIndex = i6;
              this.activeIndex = i6;
            }
          });
          totalMenuSize += this._menuItemSizes[i6];
          if (menus[i6].title.label === this._overflowMenuOptions.title) {
            isVisible2 = true;
            length--;
          }
        }
        if (this._overflowMenuOptions.isVisible) {
          if (this._overflowIndex > -1 && !isVisible2) {
            if (this._overflowMenu === null) {
              const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
              this._overflowMenu = new Menu2({ commands: new CommandRegistry() });
              this._overflowMenu.title.label = overflowMenuTitle;
              this._overflowMenu.title.mnemonic = 0;
              this.addMenu(this._overflowMenu, false);
            }
            for (let i6 = menus.length - 2; i6 >= length; i6--) {
              const submenu = this.menus[i6];
              submenu.title.mnemonic = 0;
              this._overflowMenu.insertItem(0, {
                type: "submenu",
                submenu
              });
              this.removeMenu(submenu, false);
            }
            content[length] = renderer.renderItem({
              title: this._overflowMenu.title,
              active: length === activeIndex && menus[length].items.length !== 0,
              tabbable: length === tabFocusIndex,
              disabled: menus[length].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length;
                this.activeIndex = length;
              }
            });
            length++;
          } else if (this._overflowMenu !== null) {
            let overflowMenuItems = this._overflowMenu.items;
            let screenSize = this.node.offsetWidth;
            let n5 = this._overflowMenu.items.length;
            for (let i6 = 0; i6 < n5; ++i6) {
              let index2 = menus.length - 1 - i6;
              if (screenSize - totalMenuSize > this._menuItemSizes[index2]) {
                let menu = overflowMenuItems[0].submenu;
                this._overflowMenu.removeItemAt(0);
                this.insertMenu(length, menu, false);
                content[length] = renderer.renderItem({
                  title: menu.title,
                  active: false,
                  tabbable: length === tabFocusIndex,
                  disabled: menus[length].items.length === 0,
                  onfocus: () => {
                    this._tabFocusIndex = length;
                    this.activeIndex = length;
                  }
                });
                length++;
              }
            }
            if (this._overflowMenu.items.length === 0) {
              this.removeMenu(this._overflowMenu, false);
              content.pop();
              this._overflowMenu = null;
              this._overflowIndex = -1;
            }
          }
        }
        VirtualDOM.render(content, this.contentNode);
        this._updateOverflowIndex();
      }
      /**
       * Calculate and update the current overflow index.
       */
      _updateOverflowIndex() {
        if (!this._overflowMenuOptions.isVisible) {
          return;
        }
        const itemMenus = this.contentNode.childNodes;
        let screenSize = this.node.offsetWidth;
        let totalMenuSize = 0;
        let index2 = -1;
        let n5 = itemMenus.length;
        if (this._menuItemSizes.length == 0) {
          for (let i6 = 0; i6 < n5; i6++) {
            let item = itemMenus[i6];
            totalMenuSize += item.offsetWidth;
            this._menuItemSizes.push(item.offsetWidth);
            if (totalMenuSize > screenSize && index2 === -1) {
              index2 = i6;
            }
          }
        } else {
          for (let i6 = 0; i6 < this._menuItemSizes.length; i6++) {
            totalMenuSize += this._menuItemSizes[i6];
            if (totalMenuSize > screenSize) {
              index2 = i6;
              break;
            }
          }
        }
        this._overflowIndex = index2;
      }
      /**
       * Handle the `'keydown'` event for the menu bar.
       *
       * #### Notes
       * All keys are trapped except the tab key that is ignored.
       */
      _evtKeyDown(event) {
        let kc = event.keyCode;
        if (kc === 9) {
          this.activeIndex = -1;
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
          this.activeIndex = this._tabFocusIndex;
          if (this.activeIndex !== this._tabFocusIndex) {
            return;
          }
          this.openActiveMenu();
          return;
        }
        if (kc === 27) {
          this._closeChildMenu();
          this._focusItemAt(this.activeIndex);
          return;
        }
        if (kc === 37 || kc === 39) {
          let direction = kc === 37 ? -1 : 1;
          let start2 = this._tabFocusIndex + direction;
          let n5 = this._menus.length;
          for (let i6 = 0; i6 < n5; i6++) {
            let index2 = (n5 + start2 + direction * i6) % n5;
            if (this._menus[index2].items.length) {
              this._focusItemAt(index2);
              return;
            }
          }
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$32.findMnemonic(this._menus, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.openActiveMenu();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
          this._focusItemAt(this.activeIndex);
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
          this._focusItemAt(this.activeIndex);
        }
      }
      /**
       * Handle the `'mousedown'` event for the menu bar.
       */
      _evtMouseDown(event) {
        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {
          return;
        }
        event.stopPropagation();
        event.stopImmediatePropagation();
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          this._closeChildMenu();
          return;
        }
        if (event.button !== 0) {
          return;
        }
        if (this._childMenu) {
          this._closeChildMenu();
          this.activeIndex = index2;
        } else {
          event.preventDefault();
          const position = this._positionForMenu(index2);
          Menu2.saveWindowData();
          this.activeIndex = index2;
          this._openChildMenu(position);
        }
      }
      /**
       * Handle the `'mousemove'` event for the menu bar.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        if (index2 === -1 && this._childMenu) {
          return;
        }
        const position = index2 >= 0 && this._childMenu ? this._positionForMenu(index2) : null;
        Menu2.saveWindowData();
        this.activeIndex = index2;
        if (position) {
          this._openChildMenu(position);
        }
      }
      /**
       * Find initial position for the menu based on menubar item position.
       *
       * NOTE: this should be called before updating active index to avoid
       * an additional layout and style invalidation as changing active
       * index modifies DOM.
       */
      _positionForMenu(index2) {
        let itemNode = this.contentNode.children[index2];
        let { left, bottom } = itemNode.getBoundingClientRect();
        return {
          top: bottom,
          left
        };
      }
      /**
       * Handle the `'focusout'` event for the menu bar.
       */
      _evtFocusOut(event) {
        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {
          this.activeIndex = -1;
        }
      }
      /**
       * Focus an item in the menu bar.
       *
       * #### Notes
       * Does not open the associated menu.
       */
      _focusItemAt(index2) {
        const itemNode = this.contentNode.childNodes[index2];
        if (itemNode) {
          itemNode.focus();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if there is no active menu.
       */
      _openChildMenu(options = {}) {
        let newMenu = this.activeMenu;
        if (!newMenu) {
          this._closeChildMenu();
          return;
        }
        let oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
          return;
        }
        this._childMenu = newMenu;
        if (oldMenu) {
          oldMenu.close();
        } else {
          document.addEventListener("mousedown", this, true);
        }
        this._tabFocusIndex = this.activeIndex;
        MessageLoop3.sendMessage(this, Widget3.Msg.UpdateRequest);
        let { left, top } = options;
        if (typeof left === "undefined" || typeof top === "undefined") {
          ({ left, top } = this._positionForMenu(this._activeIndex));
        }
        if (!oldMenu) {
          this.addClass("lm-mod-active");
        }
        if (newMenu.items.length > 0) {
          newMenu.open(left, top, this._forceItemsPosition);
        }
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (!this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        let menu = this._childMenu;
        this._childMenu = null;
        menu.close();
        this.activeIndex = -1;
      }
      /**
       * Handle the `aboutToClose` signal of a menu.
       */
      _onMenuAboutToClose(sender) {
        if (sender !== this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        this._childMenu = null;
        this.activeIndex = -1;
      }
      /**
       * Handle the `menuRequested` signal of a child menu.
       */
      _onMenuMenuRequested(sender, args) {
        if (sender !== this._childMenu) {
          return;
        }
        let i6 = this._activeIndex;
        let n5 = this._menus.length;
        switch (args) {
          case "next":
            this.activeIndex = i6 === n5 - 1 ? 0 : i6 + 1;
            break;
          case "previous":
            this.activeIndex = i6 === 0 ? n5 - 1 : i6 - 1;
            break;
        }
        this.openActiveMenu();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged() {
        this.update();
      }
    };
    (function(MenuBar5) {
      class Renderer {
        /**
         * Render the virtual element for a menu bar item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data));
        }
        /**
         * Render the icon element for a menu bar item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.title.icon, data.title.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-MenuBar-itemLabel" }, content);
        }
        /**
         * Create the class name for the menu bar item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-MenuBar-item";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.active && !data.disabled) {
            name += " lm-mod-active";
          }
          return name;
        }
        /**
         * Create the dataset for a menu bar item.
         *
         * @param data - The data to use for the item.
         *
         * @returns The dataset for the menu bar item.
         */
        createItemDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the aria attributes for menu bar item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          return {
            role: "menuitem",
            "aria-haspopup": "true",
            "aria-disabled": data.disabled ? "true" : "false"
          };
        }
        /**
         * Create the class name for the menu bar item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-MenuBar-itemIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.title;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
      }
      MenuBar5.Renderer = Renderer;
      MenuBar5.defaultRenderer = new Renderer();
    })(MenuBar2 || (MenuBar2 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-MenuBar-content";
        node.appendChild(content);
        content.setAttribute("role", "menubar");
        return node;
      }
      Private22.createNode = createNode;
      function findMnemonic(menus, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = menus.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let title = menus[k2].title;
          if (title.label.length === 0) {
            continue;
          }
          let mn = title.mnemonic;
          if (mn >= 0 && mn < title.label.length) {
            if (title.label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
    })(Private$32 || (Private$32 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let decrement = document.createElement("div");
        let increment = document.createElement("div");
        let track = document.createElement("div");
        let thumb = document.createElement("div");
        decrement.className = "lm-ScrollBar-button";
        increment.className = "lm-ScrollBar-button";
        decrement.dataset["action"] = "decrement";
        increment.dataset["action"] = "increment";
        track.className = "lm-ScrollBar-track";
        thumb.className = "lm-ScrollBar-thumb";
        track.appendChild(thumb);
        node.appendChild(decrement);
        node.appendChild(track);
        node.appendChild(increment);
        return node;
      }
      Private22.createNode = createNode;
      function findPart(scrollBar, target) {
        if (scrollBar.thumbNode.contains(target)) {
          return "thumb";
        }
        if (scrollBar.trackNode.contains(target)) {
          return "track";
        }
        if (scrollBar.decrementNode.contains(target)) {
          return "decrement";
        }
        if (scrollBar.incrementNode.contains(target)) {
          return "increment";
        }
        return null;
      }
      Private22.findPart = findPart;
    })(Private$22 || (Private$22 = {}));
    SingletonLayout2 = class extends Layout2 {
      constructor() {
        super(...arguments);
        this._widget = null;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this._widget) {
          let widget = this._widget;
          this._widget = null;
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * Get the child widget for the layout.
       */
      get widget() {
        return this._widget;
      }
      /**
       * Set the child widget for the layout.
       *
       * #### Notes
       * Setting the child widget will cause the old child widget to be
       * automatically disposed. If that is not desired, set the parent
       * of the old child to `null` before assigning a new child.
       */
      set widget(widget) {
        if (widget) {
          widget.parent = this.parent;
        }
        if (this._widget === widget) {
          return;
        }
        if (this._widget) {
          this._widget.dispose();
        }
        this._widget = widget;
        if (this.parent && widget) {
          this.attachWidget(widget);
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        if (this._widget) {
          yield this._widget;
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        if (this._widget !== widget) {
          return;
        }
        this._widget = null;
        if (this.parent) {
          this.detachWidget(widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
      }
    };
    StackedLayout2 = class extends PanelLayout3 {
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._items = [];
        this._box = null;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget3.HiddenMode.Display;
      }
      /**
       * The method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        if (this.widgets.length > 1) {
          this.widgets.forEach((w3) => {
            w3.hiddenMode = this._hiddenMode;
          });
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        super.dispose();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        if (this._hiddenMode === Widget3.HiddenMode.Scale && this._items.length > 0) {
          if (this._items.length === 1) {
            this.widgets[0].hiddenMode = Widget3.HiddenMode.Scale;
          }
          widget.hiddenMode = Widget3.HiddenMode.Scale;
        } else {
          widget.hiddenMode = Widget3.HiddenMode.Display;
        }
        ArrayExt.insert(this._items, index2, new LayoutItem2(widget));
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop3.sendMessage(widget, Widget3.Msg.AfterDetach);
        }
        item.widget.node.style.zIndex = "";
        if (this._hiddenMode === Widget3.HiddenMode.Scale) {
          widget.hiddenMode = Widget3.HiddenMode.Display;
          if (this._items.length === 1) {
            this._items[0].widget.hiddenMode = Widget3.HiddenMode.Display;
          }
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.fit();
          minW = Math.max(minW, item.minWidth);
          minH = Math.max(minH, item.minHeight);
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop3.sendMessage(this.parent.parent, Widget3.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop3.sendMessage(this.parent, Widget3.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.widget.node.style.zIndex = `${i6}`;
          item.update(left, top, width, height);
        }
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new StackedLayout2();
      }
      Private22.createLayout = createLayout;
    })(Private$12 || (Private$12 = {}));
    (function(Private22) {
      function orientationFromPlacement(plc) {
        return placementToOrientationMap[plc];
      }
      Private22.orientationFromPlacement = orientationFromPlacement;
      function directionFromPlacement(plc) {
        return placementToDirectionMap[plc];
      }
      Private22.directionFromPlacement = directionFromPlacement;
      const placementToOrientationMap = {
        top: "horizontal",
        left: "vertical",
        right: "vertical",
        bottom: "horizontal"
      };
      const placementToDirectionMap = {
        top: "top-to-bottom",
        left: "left-to-right",
        right: "right-to-left",
        bottom: "bottom-to-top"
      };
    })(Private7 || (Private7 = {}));
  }
});

// ../../node_modules/lodash.escape/index.js
var require_lodash2 = __commonJS({
  "../../node_modules/lodash.escape/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reUnescapedHtml = /[&<>"'`]/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#96;"
    };
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    function escape2(string) {
      string = toString2(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape2;
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/latex.js
function removeMath(text) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = text.includes("`") || text.includes("~~~");
  if (hasCodeSpans) {
    text = text.replace(/~/g, "~T").replace(/^(?<fence>`{3,}|(~T){3,})[^`\n]*\n([\s\S]*?)^\k<fence>`*$/gm, (wholematch) => wholematch.replace(/\$/g, "~D")).replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text2) => {
      return text2.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline3);
    };
  } else {
    deTilde = (text2) => {
      return text2;
    };
  }
  let blocks = text.replace(/\r\n?/g, "\n").split(MATHSPLIT);
  for (let i6 = 1, m5 = blocks.length; i6 < m5; i6 += 2) {
    const block = blocks[i6];
    if (block.charAt(0) === "@") {
      blocks[i6] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i6;
        } else {
          blocks = processMath(start, i6, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i6 = last2;
          blocks = processMath(start, i6, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline3 || block === "$$") {
        start = i6;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i6;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i6;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath(text, math) {
  const process2 = (match, n5) => {
    let group2 = math[n5];
    if (group2.substr(0, 3) === "\\\\(" && group2.substr(group2.length - 3) === "\\\\)") {
      group2 = "\\(" + group2.substring(3, group2.length - 3) + "\\)";
    } else if (group2.substr(0, 3) === "\\\\[" && group2.substr(group2.length - 3) === "\\\\]") {
      group2 = "\\[" + group2.substring(3, group2.length - 3) + "\\]";
    }
    return group2;
  };
  return text.replace(/@@(\d+)@@/g, process2);
}
function processMath(i6, j2, preProcess, math, blocks) {
  let block = blocks.slice(i6, j2 + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j2 > i6) {
    blocks[j2] = "";
    j2--;
  }
  blocks[i6] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
var inline3, MATHSPLIT;
var init_latex = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/latex.js"() {
    inline3 = "$";
    MATHSPLIT = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/renderers.js
async function renderHTML(options) {
  let { host, source, trusted, sanitizer, resolver, linkHandler, shouldTypeset, latexTypesetter, translator } = options;
  translator = translator || nullTranslator;
  const trans = translator === null || translator === void 0 ? void 0 : translator.load("jupyterlab");
  let originalSource = source;
  if (!source) {
    host.textContent = "";
    return;
  }
  if (!trusted) {
    originalSource = `${source}`;
    source = sanitizer.sanitize(source);
  }
  host.innerHTML = source;
  if (host.getElementsByTagName("script").length > 0) {
    if (trusted) {
      Private8.evalInnerHTMLScriptTags(host);
    } else {
      const container = document.createElement("div");
      const warning = document.createElement("pre");
      warning.textContent = trans.__("This HTML output contains inline scripts. Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
      const runButton = document.createElement("button");
      runButton.textContent = trans.__("Run");
      runButton.onclick = (event) => {
        host.innerHTML = originalSource;
        Private8.evalInnerHTMLScriptTags(host);
        if (host.firstChild) {
          host.removeChild(host.firstChild);
        }
      };
      container.appendChild(warning);
      container.appendChild(runButton);
      host.insertBefore(container, host.firstChild);
    }
  }
  Private8.handleDefaults(host);
  if (shouldTypeset && latexTypesetter) {
    const maybePromise = latexTypesetter.typeset(host);
    if (maybePromise instanceof Promise) {
      maybePromise.then(() => hardenAnchorLinks(host, resolver)).catch(console.warn);
    } else {
      hardenAnchorLinks(host, resolver);
    }
  } else {
    hardenAnchorLinks(host, resolver);
  }
  if (resolver) {
    await Private8.handleUrls(host, resolver, linkHandler);
  }
}
async function renderImage(options) {
  const { host, mimeType, source, width, height, needsBackground, unconfined } = options;
  host.textContent = "";
  const img = document.createElement("img");
  img.src = `data:${mimeType};base64,${source}`;
  if (typeof height === "number") {
    img.height = height;
  }
  if (typeof width === "number") {
    img.width = width;
  }
  if (needsBackground === "light") {
    img.classList.add("jp-needs-light-background");
  } else if (needsBackground === "dark") {
    img.classList.add("jp-needs-dark-background");
  }
  if (unconfined === true) {
    img.classList.add("jp-mod-unconfined");
  }
  host.appendChild(img);
}
async function renderLatex(options) {
  const { host, source, shouldTypeset, latexTypesetter, resolver } = options;
  host.textContent = source;
  if (shouldTypeset && latexTypesetter) {
    const maybePromise = latexTypesetter.typeset(host);
    if (maybePromise instanceof Promise) {
      maybePromise.then(() => hardenAnchorLinks(host, resolver)).catch(console.warn);
    } else {
      hardenAnchorLinks(host, resolver);
    }
  }
}
async function renderMarkdown(options) {
  var _a;
  const { host, source, markdownParser, ...others } = options;
  if (!source) {
    host.textContent = "";
    return;
  }
  let html = "";
  if (markdownParser) {
    const parts = removeMath(source);
    html = await markdownParser.render(parts["text"]);
    html = replaceMath(html, parts["math"]);
  } else {
    html = `<pre>${source}</pre>`;
  }
  await renderHTML({
    host,
    source: html,
    ...others
  });
  Private8.headerAnchors(host, (_a = options.sanitizer.allowNamedProperties) !== null && _a !== void 0 ? _a : false);
}
async function renderSVG(options) {
  let { host, source, trusted, unconfined } = options;
  if (!source) {
    host.textContent = "";
    return;
  }
  if (!trusted) {
    host.textContent = "Cannot display an untrusted SVG. Maybe you need to run the cell?";
    return;
  }
  const patt = "<svg[^>]+xmlns=[^>]+svg";
  if (source.search(patt) < 0) {
    source = source.replace("<svg", '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  const img = new Image();
  img.src = `data:image/svg+xml,${encodeURIComponent(source)}`;
  host.appendChild(img);
  if (unconfined === true) {
    host.classList.add("jp-mod-unconfined");
  }
}
function autolink(content, options) {
  const linkers = [];
  if (options.checkWeb) {
    linkers.push(new WebLinker());
  }
  if (options.checkPaths) {
    linkers.push(new PathLinker());
  }
  const nodes = [];
  const linkify = (content2, regexIndex) => {
    if (regexIndex >= linkers.length) {
      nodes.push(document.createTextNode(content2));
      return;
    }
    const linker = linkers[regexIndex];
    let match;
    let currentIndex = 0;
    const regex = linker.regex;
    regex.lastIndex = 0;
    while (null != (match = regex.exec(content2))) {
      const stringBeforeMatch = content2.substring(currentIndex, match.index);
      if (stringBeforeMatch) {
        linkify(stringBeforeMatch, regexIndex + 1);
      }
      const { path, ...locators } = match.groups;
      const value = linker.processPath ? linker.processPath(path) : path;
      const label = linker.processLabel ? linker.processLabel(match[0]) : match[0];
      nodes.push(linker.createAnchor(value, label, locators));
      currentIndex = match.index + label.length;
    }
    const stringAfterMatches = content2.substring(currentIndex);
    if (stringAfterMatches) {
      linkify(stringAfterMatches, regexIndex + 1);
    }
  };
  linkify(content, 0);
  return nodes;
}
function splitShallowNode(node, at) {
  var _a, _b;
  const pre = node.cloneNode();
  pre.textContent = (_a = node.textContent) === null || _a === void 0 ? void 0 : _a.slice(0, at);
  const post = node.cloneNode();
  post.textContent = (_b = node.textContent) === null || _b === void 0 ? void 0 : _b.slice(at);
  return {
    pre,
    post
  };
}
function* nodeIter(nodes) {
  var _a;
  let start = 0;
  let end;
  for (let node of nodes) {
    end = start + (((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
    yield {
      node,
      start,
      end,
      isText: node.nodeType === Node.TEXT_NODE
    };
    start = end;
  }
}
function* alignedNodes(a3, b2) {
  var _a, _b;
  let iterA = nodeIter(a3);
  let iterB = nodeIter(b2);
  let nA = iterA.next();
  let nB = iterB.next();
  while (!nA.done && !nB.done) {
    let A = nA.value;
    let B = nB.value;
    if (A.isText && A.start <= B.start && A.end >= B.end) {
      yield [null, B.node];
      nB = iterB.next();
    } else if (B.isText && B.start <= A.start && B.end >= A.end) {
      yield [A.node, null];
      nA = iterA.next();
    } else {
      if (A.end === B.end && A.start === B.start) {
        yield [A.node, B.node];
        nA = iterA.next();
        nB = iterB.next();
      } else if (A.end > B.end) {
        let { pre, post } = splitShallowNode(A.node, B.end - A.start);
        if (B.start < A.start) {
          B.node.textContent = (_a = B.node.textContent) === null || _a === void 0 ? void 0 : _a.slice(A.start - B.start);
        }
        yield [pre, B.node];
        A.node = post;
        A.start = B.end;
        nB = iterB.next();
      } else if (B.end > A.end) {
        let { pre, post } = splitShallowNode(B.node, A.end - B.start);
        if (A.start < B.start) {
          A.node.textContent = (_b = A.node.textContent) === null || _b === void 0 ? void 0 : _b.slice(B.start - A.start);
        }
        yield [A.node, pre];
        B.node = post;
        B.start = A.end;
        nA = iterA.next();
      } else {
        throw new Error(`Unexpected intersection: ${JSON.stringify(A)} ${JSON.stringify(B)}`);
      }
    }
  }
}
async function renderText(options) {
  renderTextual(options, {
    checkWeb: true,
    checkPaths: false
  });
}
function nativeSanitize(source) {
  const el = document.createElement("span");
  el.textContent = source;
  return el.innerHTML;
}
function renderTextual(options, autoLinkOptions) {
  var _a, _b;
  const { host, sanitizer, source } = options;
  const hasAnsiPrefix = source.includes(ansiPrefix);
  const content = hasAnsiPrefix ? sanitizer.sanitize(Private8.ansiSpan(source), {
    allowedTags: ["span"]
  }) : nativeSanitize(source);
  const pre = document.createElement("pre");
  pre.innerHTML = content;
  const preTextContent = pre.textContent;
  const cacheStoreOptions = [];
  if (autoLinkOptions.checkWeb) {
    cacheStoreOptions.push("web");
  }
  if (autoLinkOptions.checkPaths) {
    cacheStoreOptions.push("paths");
  }
  const cacheStoreKey = cacheStoreOptions.join("-");
  let cacheStore = Private8.autoLinkCache.get(cacheStoreKey);
  if (!cacheStore) {
    cacheStore = /* @__PURE__ */ new WeakMap();
    Private8.autoLinkCache.set(cacheStoreKey, cacheStore);
  }
  let ret;
  if (preTextContent) {
    let linkedNodes;
    if ((_b = (_a = sanitizer.getAutolink) === null || _a === void 0 ? void 0 : _a.call(sanitizer)) !== null && _b !== void 0 ? _b : true) {
      const cache2 = getApplicableLinkCache(cacheStore.get(host), preTextContent);
      if (cache2) {
        const { cachedNodes: fromCache, addedText } = cache2;
        const newAdditions = autolink(addedText, autoLinkOptions);
        const lastInCache = fromCache[fromCache.length - 1];
        const firstNewNode = newAdditions[0];
        if (lastInCache instanceof Text && firstNewNode instanceof Text) {
          const joiningNode = lastInCache;
          joiningNode.data += firstNewNode.data;
          linkedNodes = [
            ...fromCache.slice(0, -1),
            joiningNode,
            ...newAdditions.slice(1)
          ];
        } else {
          linkedNodes = [...fromCache, ...newAdditions];
        }
      } else {
        linkedNodes = autolink(preTextContent, autoLinkOptions);
      }
      cacheStore.set(host, {
        preTextContent,
        // Clone the nodes before storing them in the cache in case if another component
        // attempts to modify (e.g. dispose of) them - which is the case for search highlights!
        linkedNodes: linkedNodes.map((node) => node.cloneNode(true))
      });
    } else {
      linkedNodes = [document.createTextNode(content)];
    }
    const preNodes = Array.from(pre.childNodes);
    ret = mergeNodes(preNodes, linkedNodes);
  } else {
    ret = document.createElement("pre");
  }
  host.appendChild(ret);
}
function getApplicableLinkCache(cachedResult, preTextContent) {
  if (!cachedResult) {
    return null;
  }
  if (preTextContent.length < cachedResult.preTextContent.length) {
    return null;
  }
  let addedText = preTextContent.substring(cachedResult.preTextContent.length);
  let cachedNodes = cachedResult.linkedNodes;
  const lastCachedNode = cachedResult.linkedNodes[cachedResult.linkedNodes.length - 1];
  if (cachedResult.preTextContent.endsWith("\n") || addedText.startsWith("\n")) {
  } else if (lastCachedNode instanceof Text) {
    cachedNodes = cachedNodes.slice(0, -1);
    addedText = lastCachedNode.textContent + addedText;
  } else {
    return null;
  }
  if (!preTextContent.startsWith(cachedResult.preTextContent)) {
    return null;
  }
  return {
    cachedNodes,
    addedText
  };
}
async function renderError(options) {
  const { host, linkHandler, resolver } = options;
  renderTextual(options, {
    checkWeb: true,
    checkPaths: true
  });
  if (resolver) {
    await Private8.handlePaths(host, resolver, linkHandler);
  }
}
function mergeNodes(preNodes, linkedNodes) {
  const ret = document.createElement("pre");
  let inAnchorElement = false;
  const combinedNodes = [];
  for (let nodes of alignedNodes(preNodes, linkedNodes)) {
    if (!nodes[0]) {
      combinedNodes.push(nodes[1]);
      inAnchorElement = nodes[1].nodeType !== Node.TEXT_NODE;
      continue;
    } else if (!nodes[1]) {
      combinedNodes.push(nodes[0]);
      inAnchorElement = false;
      continue;
    }
    let [preNode, linkNode] = nodes;
    const lastCombined = combinedNodes[combinedNodes.length - 1];
    if (inAnchorElement && linkNode.href === lastCombined.href) {
      lastCombined.appendChild(preNode);
    } else {
      const isAnchor = linkNode.nodeType !== Node.TEXT_NODE;
      if (!isAnchor) {
        combinedNodes.push(preNode);
        inAnchorElement = false;
      } else {
        linkNode.textContent = "";
        linkNode.appendChild(preNode);
        combinedNodes.push(linkNode);
        inAnchorElement = true;
      }
    }
  }
  for (const child of combinedNodes) {
    ret.appendChild(child);
  }
  return ret;
}
function hardenAnchorLinks(node, resolver) {
  const anchors = node.getElementsByTagName("a");
  for (let i6 = 0; i6 < anchors.length; i6++) {
    const el = anchors[i6];
    if (!(el instanceof HTMLAnchorElement)) {
      continue;
    }
    const path = el.href;
    const isLocal = resolver && resolver.isLocal ? resolver.isLocal(path) : import_coreutils4.URLExt.isLocal(path);
    if (!el.target) {
      el.target = isLocal ? "_self" : "_blank";
    }
    if (!isLocal) {
      el.rel = "noopener";
    }
  }
}
var import_coreutils4, import_lodash2, ILinker, WebLinker, PathLinker, ansiPrefix, Private8;
var init_renderers = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/renderers.js"() {
    import_coreutils4 = __toESM(require_lib());
    init_lib();
    import_lodash2 = __toESM(require_lodash2());
    init_latex();
    (function(renderMarkdown2) {
      function createHeaderId(header) {
        var _a;
        return ((_a = header.textContent) !== null && _a !== void 0 ? _a : "").replace(/ /g, "-");
      }
      renderMarkdown2.createHeaderId = createHeaderId;
    })(renderMarkdown || (renderMarkdown = {}));
    (function(ILinker2) {
      const maxAcceptedProtocolLength = 40;
      const controlCodes = "\\u0000-\\u0020\\u007f-\\u009f";
      ILinker2.webLinkRegex = new RegExp("(?<path>(?:[a-zA-Z][a-zA-Z0-9+.-]{2," + maxAcceptedProtocolLength + "}:\\/\\/|data:|www\\.)[^\\s" + controlCodes + '"]{2,}[^\\s' + controlCodes + `"'(){}\\[\\],:;.!?])`, "ug");
      const winAbsPathRegex = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/;
      const winRelPathRegex = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/;
      const winPathRegex = new RegExp(`(${winAbsPathRegex.source}|${winRelPathRegex.source})`);
      const posixPathRegex = /((?:\~|\.)?(?:\/[\w\.-]*)+)/;
      const lineColumnRegex = /(?:(?:\:|", line )(?<line>[\d]+))?(?:\:(?<column>[\d]+))?/;
      const isWindows = navigator.userAgent.indexOf("Windows") >= 0;
      ILinker2.pathLinkRegex = new RegExp(`(?<path>${isWindows ? winPathRegex.source : posixPathRegex.source})${lineColumnRegex.source}`, "g");
    })(ILinker || (ILinker = {}));
    WebLinker = class {
      constructor() {
        this.regex = ILinker.webLinkRegex;
      }
      createAnchor(url, label) {
        const anchor = document.createElement("a");
        anchor.href = url.startsWith("www.") ? "https://" + url : url;
        anchor.rel = "noopener";
        anchor.target = "_blank";
        anchor.appendChild(document.createTextNode(label));
        return anchor;
      }
      processPath(url) {
        const lastChars = url.slice(-1);
        const endsWithGtLt = [">", "<"].indexOf(lastChars) !== -1;
        const len = endsWithGtLt ? url.length - 1 : url.length;
        url = url.slice(0, len);
        return url;
      }
      processLabel(url) {
        return this.processPath(url);
      }
    };
    PathLinker = class {
      constructor() {
        this.regex = ILinker.pathLinkRegex;
      }
      createAnchor(path, label, locators) {
        const anchor = document.createElement("a");
        anchor.dataset.path = path;
        const line = parseInt(locators["line"], 10);
        let locator = !isNaN(line) ? `line=${line - 1}` : "";
        anchor.dataset.locator = locator;
        anchor.appendChild(document.createTextNode(label));
        return anchor;
      }
    };
    ansiPrefix = "\x1B";
    (function(Private22) {
      Private22.autoLinkCache = /* @__PURE__ */ new Map();
      function evalInnerHTMLScriptTags(host) {
        const scripts = Array.from(host.getElementsByTagName("script"));
        for (const script of scripts) {
          if (!script.parentNode) {
            continue;
          }
          const clone2 = document.createElement("script");
          const attrs = script.attributes;
          for (let i6 = 0, n5 = attrs.length; i6 < n5; ++i6) {
            const { name, value } = attrs[i6];
            clone2.setAttribute(name, value);
          }
          clone2.textContent = script.textContent;
          script.parentNode.replaceChild(clone2, script);
        }
      }
      Private22.evalInnerHTMLScriptTags = evalInnerHTMLScriptTags;
      function handleDefaults(node) {
        const imgs = node.getElementsByTagName("img");
        for (let i6 = 0; i6 < imgs.length; i6++) {
          if (!imgs[i6].alt) {
            imgs[i6].alt = "Image";
          }
        }
      }
      Private22.handleDefaults = handleDefaults;
      async function handleUrls(node, resolver, linkHandler) {
        const promises = [];
        const nodes = node.querySelectorAll("*[src]");
        for (let i6 = 0; i6 < nodes.length; i6++) {
          promises.push(handleAttr(nodes[i6], "src", resolver));
        }
        const anchors = node.getElementsByTagName("a");
        for (let i6 = 0; i6 < anchors.length; i6++) {
          promises.push(handleAnchor(anchors[i6], resolver, linkHandler));
        }
        const links = node.getElementsByTagName("link");
        for (let i6 = 0; i6 < links.length; i6++) {
          promises.push(handleAttr(links[i6], "href", resolver));
        }
        return Promise.all(promises);
      }
      Private22.handleUrls = handleUrls;
      async function handlePaths(node, resolver, linkHandler) {
        const anchors = Array.from(node.querySelectorAll("a[data-path]"));
        return Promise.all(anchors.map((anchor) => handlePathAnchor(anchor, resolver, linkHandler)));
      }
      Private22.handlePaths = handlePaths;
      function headerAnchors(node, allowNamedProperties) {
        const headerNames = ["h1", "h2", "h3", "h4", "h5", "h6"];
        for (const headerType of headerNames) {
          const headers = node.getElementsByTagName(headerType);
          for (let i6 = 0; i6 < headers.length; i6++) {
            const header = headers[i6];
            const headerId = renderMarkdown.createHeaderId(header);
            if (allowNamedProperties) {
              header.id = headerId;
            } else {
              header.setAttribute("data-jupyter-id", headerId);
            }
            const anchor = document.createElement("a");
            anchor.target = "_self";
            anchor.textContent = "\xB6";
            anchor.href = "#" + headerId;
            anchor.classList.add("jp-InternalAnchorLink");
            header.appendChild(anchor);
          }
        }
      }
      Private22.headerAnchors = headerAnchors;
      async function handleAttr(node, name, resolver) {
        const source = node.getAttribute(name) || "";
        const isLocal = resolver.isLocal ? resolver.isLocal(source) : import_coreutils4.URLExt.isLocal(source);
        if (!source || !isLocal) {
          return;
        }
        try {
          const urlPath = await resolver.resolveUrl(source, {
            attribute: name,
            tag: node.localName
          });
          let url = await resolver.getDownloadUrl(urlPath);
          if (import_coreutils4.URLExt.parse(url).protocol !== "data:") {
            url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
          }
          node.setAttribute(name, url);
        } catch (err) {
          node.setAttribute(name, "");
          throw err;
        }
      }
      async function handleAnchor(anchor, resolver, linkHandler) {
        let href = anchor.getAttribute("href") || "";
        const isLocal = resolver.isLocal ? resolver.isLocal(href) : import_coreutils4.URLExt.isLocal(href);
        if (!href || !isLocal) {
          return;
        }
        const hash = anchor.hash;
        if (hash) {
          if (hash === href) {
            anchor.target = "_self";
            return;
          }
          href = href.replace(hash, "");
        }
        return resolver.resolveUrl(href, { attribute: "href", tag: "a" }).then((urlPath) => {
          const path = decodeURIComponent(urlPath);
          if (linkHandler) {
            linkHandler.handleLink(anchor, path, hash);
          }
          return resolver.getDownloadUrl(urlPath);
        }).then((url) => {
          anchor.href = url + hash;
        }).catch((err) => {
          anchor.href = "";
        });
      }
      async function handlePathAnchor(anchor, resolver, linkHandler) {
        let path = anchor.dataset.path || "";
        let locator = anchor.dataset.locator ? "#" + anchor.dataset.locator : "";
        delete anchor.dataset.path;
        delete anchor.dataset.locator;
        const allowRoot = true;
        const isLocal = resolver.isLocal ? resolver.isLocal(path, allowRoot) : import_coreutils4.URLExt.isLocal(path, allowRoot);
        if (!path || !isLocal || !resolver.resolvePath || !linkHandler || !linkHandler.handlePath) {
          anchor.replaceWith(...anchor.childNodes);
          return;
        }
        try {
          const resolution = await resolver.resolvePath(path);
          if (!resolution) {
            console.log("Path resolution bailing: does not exist");
            return;
          }
          linkHandler.handlePath(anchor, resolution.path, resolution.scope, locator);
          anchor.href = resolution.path + locator;
        } catch (err) {
          console.warn("Path anchor error:", err);
          anchor.href = "#linking-failed-see-console";
        }
      }
      const ANSI_COLORS = [
        "ansi-black",
        "ansi-red",
        "ansi-green",
        "ansi-yellow",
        "ansi-blue",
        "ansi-magenta",
        "ansi-cyan",
        "ansi-white",
        "ansi-black-intense",
        "ansi-red-intense",
        "ansi-green-intense",
        "ansi-yellow-intense",
        "ansi-blue-intense",
        "ansi-magenta-intense",
        "ansi-cyan-intense",
        "ansi-white-intense"
      ];
      function pushColoredChunk(chunk2, fg, bg, bold, underline, inverse, out) {
        if (chunk2) {
          const classes = [];
          const styles = [];
          if (bold && typeof fg === "number" && 0 <= fg && fg < 8) {
            fg += 8;
          }
          if (inverse) {
            [fg, bg] = [bg, fg];
          }
          if (typeof fg === "number") {
            classes.push(ANSI_COLORS[fg] + "-fg");
          } else if (fg.length) {
            styles.push(`color: rgb(${fg})`);
          } else if (inverse) {
            classes.push("ansi-default-inverse-fg");
          }
          if (typeof bg === "number") {
            classes.push(ANSI_COLORS[bg] + "-bg");
          } else if (bg.length) {
            styles.push(`background-color: rgb(${bg})`);
          } else if (inverse) {
            classes.push("ansi-default-inverse-bg");
          }
          if (bold) {
            classes.push("ansi-bold");
          }
          if (underline) {
            classes.push("ansi-underline");
          }
          if (classes.length || styles.length) {
            out.push("<span");
            if (classes.length) {
              out.push(` class="${classes.join(" ")}"`);
            }
            if (styles.length) {
              out.push(` style="${styles.join("; ")}"`);
            }
            out.push(">");
            out.push(chunk2);
            out.push("</span>");
          } else {
            out.push(chunk2);
          }
        }
      }
      function getExtendedColors(numbers) {
        let r4;
        let g4;
        let b2;
        const n5 = numbers.shift();
        if (n5 === 2 && numbers.length >= 3) {
          r4 = numbers.shift();
          g4 = numbers.shift();
          b2 = numbers.shift();
          if ([r4, g4, b2].some((c6) => c6 < 0 || 255 < c6)) {
            throw new RangeError("Invalid range for RGB colors");
          }
        } else if (n5 === 5 && numbers.length >= 1) {
          const idx = numbers.shift();
          if (idx < 0) {
            throw new RangeError("Color index must be >= 0");
          } else if (idx < 16) {
            return idx;
          } else if (idx < 232) {
            r4 = Math.floor((idx - 16) / 36);
            r4 = r4 > 0 ? 55 + r4 * 40 : 0;
            g4 = Math.floor((idx - 16) % 36 / 6);
            g4 = g4 > 0 ? 55 + g4 * 40 : 0;
            b2 = (idx - 16) % 6;
            b2 = b2 > 0 ? 55 + b2 * 40 : 0;
          } else if (idx < 256) {
            r4 = g4 = b2 = (idx - 232) * 10 + 8;
          } else {
            throw new RangeError("Color index must be < 256");
          }
        } else {
          throw new RangeError("Invalid extended color specification");
        }
        return [r4, g4, b2];
      }
      function ansiSpan(str) {
        const ansiRe = /\x1b\[(.*?)([@-~])/g;
        let fg = [];
        let bg = [];
        let bold = false;
        let underline = false;
        let inverse = false;
        let match;
        const out = [];
        const numbers = [];
        let start = 0;
        str = (0, import_lodash2.default)(str);
        str += "\x1B[m";
        while (match = ansiRe.exec(str)) {
          if (match[2] === "m") {
            const items = match[1].split(";");
            for (let i6 = 0; i6 < items.length; i6++) {
              const item = items[i6];
              if (item === "") {
                numbers.push(0);
              } else if (item.search(/^\d+$/) !== -1) {
                numbers.push(parseInt(item, 10));
              } else {
                numbers.length = 0;
                break;
              }
            }
          } else {
          }
          const chunk2 = str.substring(start, match.index);
          pushColoredChunk(chunk2, fg, bg, bold, underline, inverse, out);
          start = ansiRe.lastIndex;
          while (numbers.length) {
            const n5 = numbers.shift();
            switch (n5) {
              case 0:
                fg = bg = [];
                bold = false;
                underline = false;
                inverse = false;
                break;
              case 1:
              case 5:
                bold = true;
                break;
              case 4:
                underline = true;
                break;
              case 7:
                inverse = true;
                break;
              case 21:
              case 22:
                bold = false;
                break;
              case 24:
                underline = false;
                break;
              case 27:
                inverse = false;
                break;
              case 30:
              case 31:
              case 32:
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
                fg = n5 - 30;
                break;
              case 38:
                try {
                  fg = getExtendedColors(numbers);
                } catch (e3) {
                  numbers.length = 0;
                }
                break;
              case 39:
                fg = [];
                break;
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
              case 46:
              case 47:
                bg = n5 - 40;
                break;
              case 48:
                try {
                  bg = getExtendedColors(numbers);
                } catch (e3) {
                  numbers.length = 0;
                }
                break;
              case 49:
                bg = [];
                break;
              case 90:
              case 91:
              case 92:
              case 93:
              case 94:
              case 95:
              case 96:
              case 97:
                fg = n5 - 90 + 8;
                break;
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
              case 106:
              case 107:
                bg = n5 - 100 + 8;
                break;
              default:
            }
          }
        }
        return out.join("");
      }
      Private22.ansiSpan = ansiSpan;
    })(Private8 || (Private8 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/widgets.js
var RenderedCommon, RenderedHTMLCommon, RenderedHTML, RenderedLatex, RenderedImage, RenderedMarkdown, RenderedSVG, RenderedText, RenderedError, RenderedJavaScript, Private9;
var init_widgets = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/widgets.js"() {
    init_lib();
    init_index_es618();
    init_renderers();
    RenderedCommon = class extends Widget3 {
      /**
       * Construct a new rendered common widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        var _a, _b;
        super();
        this.mimeType = options.mimeType;
        this.sanitizer = options.sanitizer;
        this.resolver = options.resolver;
        this.linkHandler = options.linkHandler;
        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
        this.latexTypesetter = options.latexTypesetter;
        this.markdownParser = (_b = options.markdownParser) !== null && _b !== void 0 ? _b : null;
        this.node.dataset["mimeType"] = this.mimeType;
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @param keepExisting - Whether to keep the existing rendering.
       *
       * @returns A promise which resolves when rendering is complete.
       *
       * #### Notes
       * By default, if the DOM node for this widget already has content, it
       * is emptied before rendering. Subclasses that do not want this behavior
       * (if, for instance, they are using DOM diffing), should override this
       * method or call `super.renderModel(model, true)`.
       */
      async renderModel(model, keepExisting) {
        if (!keepExisting) {
          while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
          }
        }
        this.toggleClass("jp-mod-trusted", model.trusted);
        await this.render(model);
        const { fragment } = model.metadata;
        if (fragment) {
          this.setFragment(fragment);
        }
      }
      /**
       * Set the URI fragment identifier.
       *
       * @param fragment - The URI fragment identifier.
       */
      setFragment(fragment) {
      }
    };
    RenderedHTMLCommon = class extends RenderedCommon {
      /**
       * Construct a new rendered HTML common widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedHTMLCommon");
      }
      setFragment(fragment) {
        let el;
        try {
          el = this.node.querySelector(fragment.startsWith("#") ? `#${CSS.escape(fragment.slice(1))}` : fragment);
        } catch (error) {
          console.warn("Unable to set URI fragment identifier.", error);
        }
        if (el) {
          el.scrollIntoView();
        }
      }
    };
    RenderedHTML = class extends RenderedHTMLCommon {
      /**
       * Construct a new rendered HTML widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedHTML");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return this._rendered = renderHTML({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          translator: this.translator
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            Private9.typeset(this.node, this.latexTypesetter, this.resolver);
          }
        }).catch(console.warn);
      }
    };
    RenderedLatex = class extends RenderedCommon {
      /**
       * Construct a new rendered LaTeX widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedLatex");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return this._rendered = renderLatex({
          host: this.node,
          source: String(model.data[this.mimeType]),
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          resolver: this.resolver
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            Private9.typeset(this.node, this.latexTypesetter, this.resolver);
          }
        }).catch(console.warn);
      }
    };
    RenderedImage = class extends RenderedCommon {
      /**
       * Construct a new rendered image widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedImage");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const metadata = model.metadata[this.mimeType];
        return renderImage({
          host: this.node,
          mimeType: this.mimeType,
          source: String(model.data[this.mimeType]),
          width: metadata && metadata.width,
          height: metadata && metadata.height,
          needsBackground: model.metadata["needs_background"],
          unconfined: metadata && metadata.unconfined
        });
      }
    };
    RenderedMarkdown = class extends RenderedHTMLCommon {
      /**
       * Construct a new rendered markdown widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedMarkdown");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return this._rendered = renderMarkdown({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          shouldTypeset: this.isAttached,
          latexTypesetter: this.latexTypesetter,
          markdownParser: this.markdownParser,
          translator: this.translator
        });
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      async renderModel(model) {
        await super.renderModel(model, true);
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            Private9.typeset(this.node, this.latexTypesetter, this.resolver);
          }
        }).catch(console.warn);
      }
    };
    RenderedSVG = class extends RenderedCommon {
      /**
       * Construct a new rendered SVG widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this._rendered = Promise.resolve();
        this.addClass("jp-RenderedSVG");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const metadata = model.metadata[this.mimeType];
        return this._rendered = renderSVG({
          host: this.node,
          source: String(model.data[this.mimeType]),
          trusted: model.trusted,
          unconfined: metadata && metadata.unconfined,
          translator: this.translator
        });
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       */
      onAfterAttach(msg) {
        this._rendered.then(() => {
          if (this.latexTypesetter) {
            Private9.typeset(this.node, this.latexTypesetter, this.resolver);
          }
        }).catch(console.warn);
      }
    };
    RenderedText = class extends RenderedCommon {
      /**
       * Construct a new rendered text widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedText");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        return renderText({
          host: this.node,
          sanitizer: this.sanitizer,
          source: String(model.data[this.mimeType]),
          translator: this.translator
        });
      }
    };
    RenderedError = class extends RenderedCommon {
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedText");
      }
      render(model) {
        return renderError({
          host: this.node,
          sanitizer: this.sanitizer,
          source: String(model.data[this.mimeType]),
          linkHandler: this.linkHandler,
          resolver: this.resolver,
          translator: this.translator
        });
      }
    };
    RenderedJavaScript = class extends RenderedCommon {
      /**
       * Construct a new rendered text widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options) {
        super(options);
        this.addClass("jp-RenderedJavaScript");
      }
      /**
       * Render a mime model.
       *
       * @param model - The mime model to render.
       *
       * @returns A promise which resolves when rendering is complete.
       */
      render(model) {
        const trans = this.translator.load("jupyterlab");
        return renderText({
          host: this.node,
          sanitizer: this.sanitizer,
          source: trans.__("JavaScript output is disabled in JupyterLab"),
          translator: this.translator
        });
      }
    };
    (function(Private22) {
      function typeset2(host, latexTypesetter, resolver) {
        const result2 = latexTypesetter.typeset(host);
        if (result2 instanceof Promise) {
          result2.then(() => hardenAnchorLinks(host, resolver)).catch(console.warn);
        } else {
          hardenAnchorLinks(host, resolver);
        }
      }
      Private22.typeset = typeset2;
    })(Private9 || (Private9 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/factories.js
var htmlRendererFactory, imageRendererFactory, latexRendererFactory, markdownRendererFactory, svgRendererFactory, errorRendererFactory, textRendererFactory;
var init_factories = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/factories.js"() {
    init_widgets();
    htmlRendererFactory = {
      safe: true,
      mimeTypes: ["text/html"],
      defaultRank: 50,
      createRenderer: (options) => new RenderedHTML(options)
    };
    imageRendererFactory = {
      safe: true,
      mimeTypes: [
        "image/bmp",
        "image/png",
        "image/jpeg",
        "image/gif",
        "image/webp"
      ],
      defaultRank: 90,
      createRenderer: (options) => new RenderedImage(options)
    };
    latexRendererFactory = {
      safe: true,
      mimeTypes: ["text/latex"],
      defaultRank: 70,
      createRenderer: (options) => new RenderedLatex(options)
    };
    markdownRendererFactory = {
      safe: true,
      mimeTypes: ["text/markdown"],
      defaultRank: 60,
      createRenderer: (options) => new RenderedMarkdown(options)
    };
    svgRendererFactory = {
      safe: false,
      mimeTypes: ["image/svg+xml"],
      defaultRank: 80,
      createRenderer: (options) => new RenderedSVG(options)
    };
    errorRendererFactory = {
      safe: true,
      mimeTypes: ["application/vnd.jupyter.stderr"],
      defaultRank: 110,
      createRenderer: (options) => new RenderedError(options)
    };
    textRendererFactory = {
      safe: true,
      mimeTypes: ["text/plain", "application/vnd.jupyter.stdout"],
      defaultRank: 120,
      createRenderer: (options) => new RenderedText(options)
    };
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/mimemodel.js
var MimeModel, Private10;
var init_mimemodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/mimemodel.js"() {
    MimeModel = class {
      /**
       * Construct a new mime model.
       */
      constructor(options = {}) {
        this.trusted = !!options.trusted;
        this._data = options.data || {};
        this._metadata = options.metadata || {};
        this._callback = options.callback || Private10.noOp;
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return this._data;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return this._metadata;
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        this._data = options.data || this._data;
        this._metadata = options.metadata || this._metadata;
        this._callback(options);
      }
    };
    (function(Private22) {
      function noOp() {
      }
      Private22.noOp = noOp;
    })(Private10 || (Private10 = {}));
  }
});

// ../../node_modules/@jupyterlab/nbformat/lib/index.js
function isExecuteResult(output) {
  return output.output_type === "execute_result";
}
function isDisplayData(output) {
  return output.output_type === "display_data";
}
function isDisplayUpdate(output) {
  return output.output_type === "update_display_data";
}
function isStream(output) {
  return output.output_type === "stream";
}
function isError(output) {
  return output.output_type === "error";
}
var import_coreutils5;
var init_lib5 = __esm({
  "../../node_modules/@jupyterlab/nbformat/lib/index.js"() {
    import_coreutils5 = __toESM(require_dist());
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/outputmodel.js
var import_coreutils6, OutputModel, Private11;
var init_outputmodel = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/outputmodel.js"() {
    init_lib5();
    init_lib2();
    import_coreutils6 = __toESM(require_dist());
    init_index_es62();
    OutputModel = class {
      /**
       * Construct a new output model.
       */
      constructor(options) {
        this._changed = new Signal(this);
        this._raw = {};
        this._text = void 0;
        const { data, metadata, trusted } = Private11.getBundleOptions(options);
        this._rawData = data;
        if (options.value !== void 0 && isStream(options.value)) {
          this._text = new ObservableString(typeof options.value.text === "string" ? options.value.text : options.value.text.join(""));
        }
        this._metadata = new ObservableJSON({ values: metadata });
        this._rawMetadata = metadata;
        this.trusted = trusted;
        const value = options.value;
        for (const key in value) {
          switch (key) {
            case "data":
            case "metadata":
              break;
            default:
              this._raw[key] = Private11.extract(value, key);
          }
        }
        this.type = value.output_type;
        if (isExecuteResult(value)) {
          this.executionCount = value.execution_count;
        } else {
          this.executionCount = null;
        }
      }
      /**
       * A signal emitted when the output model changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Dispose of the resources used by the output model.
       */
      dispose() {
        var _a;
        (_a = this._text) === null || _a === void 0 ? void 0 : _a.dispose();
        this._metadata.dispose();
        Signal.clearData(this);
      }
      /**
       * The data associated with the model.
       */
      get data() {
        return Private11.getData(this.toJSON());
      }
      get streamText() {
        return this._text;
      }
      /**
       * The metadata associated with the model.
       */
      get metadata() {
        return this._rawMetadata;
      }
      /**
       * Set the data associated with the model.
       *
       * #### Notes
       * Depending on the implementation of the mime model,
       * this call may or may not have deferred effects,
       */
      setData(options) {
        if (options.data) {
          this._rawData = options.data;
        }
        if (options.metadata) {
          this._updateObservable(this._metadata, options.metadata);
          this._rawMetadata = options.metadata;
        }
        this._changed.emit();
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        const output = {};
        for (const key in this._raw) {
          output[key] = Private11.extract(this._raw, key);
        }
        if (this._text !== void 0) {
          output["text"] = this._text.text;
        }
        switch (this.type) {
          case "display_data":
          case "execute_result":
          case "update_display_data":
            output["data"] = this._rawData;
            output["metadata"] = this.metadata;
            break;
          default:
            break;
        }
        delete output["transient"];
        return output;
      }
      /**
       * Update an observable JSON object using a readonly JSON object.
       */
      _updateObservable(observable, data) {
        const oldKeys = observable.keys();
        const newKeys = Object.keys(data);
        for (const key of oldKeys) {
          if (newKeys.indexOf(key) === -1) {
            observable.delete(key);
          }
        }
        for (const key of newKeys) {
          const oldValue = observable.get(key);
          const newValue = data[key];
          if (oldValue !== newValue) {
            observable.set(key, newValue);
          }
        }
      }
    };
    (function(OutputModel4) {
      function getData(output) {
        return Private11.getData(output);
      }
      OutputModel4.getData = getData;
      function getMetadata(output) {
        return Private11.getMetadata(output);
      }
      OutputModel4.getMetadata = getMetadata;
    })(OutputModel || (OutputModel = {}));
    (function(Private22) {
      function getData(output) {
        let bundle = {};
        if (isExecuteResult(output) || isDisplayData(output) || isDisplayUpdate(output)) {
          bundle = output.data;
        } else if (isStream(output)) {
          if (output.name === "stderr") {
            bundle["application/vnd.jupyter.stderr"] = output.text;
          } else {
            bundle["application/vnd.jupyter.stdout"] = output.text;
          }
        } else if (isError(output)) {
          bundle["application/vnd.jupyter.error"] = output;
          const traceback = output.traceback.join("\n");
          bundle["application/vnd.jupyter.stderr"] = traceback || `${output.ename}: ${output.evalue}`;
        }
        return convertBundle(bundle);
      }
      Private22.getData = getData;
      function getMetadata(output) {
        const value = /* @__PURE__ */ Object.create(null);
        if (isExecuteResult(output) || isDisplayData(output)) {
          for (const key in output.metadata) {
            value[key] = extract(output.metadata, key);
          }
        }
        return value;
      }
      Private22.getMetadata = getMetadata;
      function getBundleOptions(options) {
        const data = getData(options.value);
        const metadata = getMetadata(options.value);
        const trusted = !!options.trusted;
        return { data, metadata, trusted };
      }
      Private22.getBundleOptions = getBundleOptions;
      function extract(value, key) {
        const item = value[key];
        if (item === void 0 || import_coreutils6.JSONExt.isPrimitive(item)) {
          return item;
        }
        return JSON.parse(JSON.stringify(item));
      }
      Private22.extract = extract;
      function convertBundle(bundle) {
        const map4 = /* @__PURE__ */ Object.create(null);
        for (const mimeType in bundle) {
          map4[mimeType] = extract(bundle, mimeType);
        }
        return map4;
      }
    })(Private11 || (Private11 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/registry.js
var import_coreutils7, RenderMimeRegistry, Private12;
var init_registry = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/registry.js"() {
    init_lib3();
    import_coreutils7 = __toESM(require_lib());
    init_lib();
    init_mimemodel();
    RenderMimeRegistry = class {
      /**
       * Construct a new rendermime.
       *
       * @param options - The options for initializing the instance.
       */
      constructor(options = {}) {
        var _a, _b, _c, _d, _e2, _f;
        this._id = 0;
        this._ranks = {};
        this._types = null;
        this._factories = {};
        this.translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;
        this.resolver = (_b = options.resolver) !== null && _b !== void 0 ? _b : null;
        this.linkHandler = (_c = options.linkHandler) !== null && _c !== void 0 ? _c : null;
        this.latexTypesetter = (_d = options.latexTypesetter) !== null && _d !== void 0 ? _d : null;
        this.markdownParser = (_e2 = options.markdownParser) !== null && _e2 !== void 0 ? _e2 : null;
        this.sanitizer = (_f = options.sanitizer) !== null && _f !== void 0 ? _f : new Sanitizer();
        if (options.initialFactories) {
          for (const factory of options.initialFactories) {
            this.addFactory(factory);
          }
        }
      }
      /**
       * The ordered list of mimeTypes.
       */
      get mimeTypes() {
        return this._types || (this._types = Private12.sortedTypes(this._ranks));
      }
      /**
       * Find the preferred mime type for a mime bundle.
       *
       * @param bundle - The bundle of mime data.
       *
       * @param safe - How to consider safe/unsafe factories. If 'ensure',
       *   it will only consider safe factories. If 'any', any factory will be
       *   considered. If 'prefer', unsafe factories will be considered, but
       *   only after the safe options have been exhausted.
       *
       * @returns The preferred mime type from the available factories,
       *   or `undefined` if the mime type cannot be rendered.
       */
      preferredMimeType(bundle, safe = "ensure") {
        if (safe === "ensure" || safe === "prefer") {
          for (const mt of this.mimeTypes) {
            if (mt in bundle && this._factories[mt].safe) {
              return mt;
            }
          }
        }
        if (safe !== "ensure") {
          for (const mt of this.mimeTypes) {
            if (mt in bundle) {
              return mt;
            }
          }
        }
        return void 0;
      }
      /**
       * Create a renderer for a mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns A new renderer for the given mime type.
       *
       * @throws An error if no factory exists for the mime type.
       */
      createRenderer(mimeType) {
        if (!(mimeType in this._factories)) {
          throw new Error(`No factory for mime type: '${mimeType}'`);
        }
        return this._factories[mimeType].createRenderer({
          mimeType,
          resolver: this.resolver,
          sanitizer: this.sanitizer,
          linkHandler: this.linkHandler,
          latexTypesetter: this.latexTypesetter,
          markdownParser: this.markdownParser,
          translator: this.translator
        });
      }
      /**
       * Create a new mime model.  This is a convenience method.
       *
       * @options - The options used to create the model.
       *
       * @returns A new mime model.
       */
      createModel(options = {}) {
        return new MimeModel(options);
      }
      /**
       * Create a clone of this rendermime instance.
       *
       * @param options - The options for configuring the clone.
       *
       * @returns A new independent clone of the rendermime.
       */
      clone(options = {}) {
        var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k;
        const clone2 = new RenderMimeRegistry({
          resolver: (_b = (_a = options.resolver) !== null && _a !== void 0 ? _a : this.resolver) !== null && _b !== void 0 ? _b : void 0,
          sanitizer: (_d = (_c = options.sanitizer) !== null && _c !== void 0 ? _c : this.sanitizer) !== null && _d !== void 0 ? _d : void 0,
          linkHandler: (_f = (_e2 = options.linkHandler) !== null && _e2 !== void 0 ? _e2 : this.linkHandler) !== null && _f !== void 0 ? _f : void 0,
          latexTypesetter: (_h = (_g = options.latexTypesetter) !== null && _g !== void 0 ? _g : this.latexTypesetter) !== null && _h !== void 0 ? _h : void 0,
          markdownParser: (_k = (_j = options.markdownParser) !== null && _j !== void 0 ? _j : this.markdownParser) !== null && _k !== void 0 ? _k : void 0,
          translator: this.translator
        });
        clone2._factories = { ...this._factories };
        clone2._ranks = { ...this._ranks };
        clone2._id = this._id;
        return clone2;
      }
      /**
       * Get the renderer factory registered for a mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns The factory for the mime type, or `undefined`.
       */
      getFactory(mimeType) {
        return this._factories[mimeType];
      }
      /**
       * Add a renderer factory to the rendermime.
       *
       * @param factory - The renderer factory of interest.
       *
       * @param rank - The rank of the renderer. A lower rank indicates
       *   a higher priority for rendering. If not given, the rank will
       *   defer to the `defaultRank` of the factory.  If no `defaultRank`
       *   is given, it will default to 100.
       *
       * #### Notes
       * The renderer will replace an existing renderer for the given
       * mimeType.
       */
      addFactory(factory, rank) {
        if (rank === void 0) {
          rank = factory.defaultRank;
          if (rank === void 0) {
            rank = 100;
          }
        }
        for (const mt of factory.mimeTypes) {
          this._factories[mt] = factory;
          this._ranks[mt] = { rank, id: this._id++ };
        }
        this._types = null;
      }
      /**
       * Remove a mime type.
       *
       * @param mimeType - The mime type of interest.
       */
      removeMimeType(mimeType) {
        delete this._factories[mimeType];
        delete this._ranks[mimeType];
        this._types = null;
      }
      /**
       * Get the rank for a given mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @returns The rank of the mime type or undefined.
       */
      getRank(mimeType) {
        const rank = this._ranks[mimeType];
        return rank && rank.rank;
      }
      /**
       * Set the rank of a given mime type.
       *
       * @param mimeType - The mime type of interest.
       *
       * @param rank - The new rank to assign.
       *
       * #### Notes
       * This is a no-op if the mime type is not registered.
       */
      setRank(mimeType, rank) {
        if (!this._ranks[mimeType]) {
          return;
        }
        const id = this._id++;
        this._ranks[mimeType] = { rank, id };
        this._types = null;
      }
    };
    (function(RenderMimeRegistry2) {
      class UrlResolver {
        /**
         * Create a new url resolver.
         */
        constructor(options) {
          this._path = options.path;
          this._contents = options.contents;
        }
        /**
         * The path of the object, from which local urls can be derived.
         */
        get path() {
          return this._path;
        }
        set path(value) {
          this._path = value;
        }
        /**
         * Resolve a relative url to an absolute url path.
         */
        async resolveUrl(url) {
          if (this.isLocal(url)) {
            const cwd = encodeURI(import_coreutils7.PathExt.dirname(this.path));
            url = import_coreutils7.PathExt.resolve(cwd, url);
          }
          return url;
        }
        /**
         * Get the download url of a given absolute url path.
         *
         * #### Notes
         * The returned URL may include a query parameter.
         */
        async getDownloadUrl(urlPath) {
          if (this.isLocal(urlPath)) {
            return this._contents.getDownloadUrl(decodeURIComponent(urlPath));
          }
          return urlPath;
        }
        /**
         * Whether the URL should be handled by the resolver
         * or not.
         *
         * @param allowRoot - Whether the paths starting at Unix-style filesystem root (`/`) are permitted.
         *
         * #### Notes
         * This is similar to the `isLocal` check in `URLExt`,
         * but it also checks whether the path points to any
         * of the `IDrive`s that may be registered with the contents
         * manager.
         */
        isLocal(url, allowRoot = false) {
          if (this.isMalformed(url)) {
            return false;
          }
          return import_coreutils7.URLExt.isLocal(url, allowRoot) || !!this._contents.driveName(decodeURI(url));
        }
        /**
         * Resolve a path from Jupyter kernel to a path:
         * - relative to `root_dir` (preferably) this is in jupyter-server scope,
         * - path understood and known by kernel (if such a path exists).
         * Returns `null` if there is no file matching provided path in neither
         * kernel nor jupyter-server contents manager.
         */
        async resolvePath(path) {
          const rootDir = import_coreutils7.PageConfig.getOption("rootUri").replace("file://", "");
          if (path.startsWith("~/") && rootDir.startsWith("/home/")) {
            path = rootDir.split("/").slice(0, 3).join("/") + path.substring(1);
          }
          if (path.startsWith(rootDir) || path.startsWith("./")) {
            try {
              const relativePath = path.replace(rootDir, "");
              const response = await this._contents.get(relativePath, {
                content: false
              });
              return {
                path: response.path,
                scope: "server"
              };
            } catch (error) {
              console.warn(`Could not resolve location of ${path} on server`);
              return null;
            }
          }
          return {
            path,
            scope: "kernel"
          };
        }
        /**
         * Whether the URL can be decoded using `decodeURI`.
         */
        isMalformed(url) {
          try {
            decodeURI(url);
            return false;
          } catch (error) {
            if (error instanceof URIError) {
              return true;
            }
            throw error;
          }
        }
      }
      RenderMimeRegistry2.UrlResolver = UrlResolver;
    })(RenderMimeRegistry || (RenderMimeRegistry = {}));
    (function(Private22) {
      function sortedTypes(map4) {
        return Object.keys(map4).sort((a3, b2) => {
          const p1 = map4[a3];
          const p22 = map4[b2];
          if (p1.rank !== p22.rank) {
            return p1.rank - p22.rank;
          }
          return p1.id - p22.id;
        });
      }
      Private22.sortedTypes = sortedTypes;
    })(Private12 || (Private12 = {}));
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/tokens.js
var import_coreutils8, IRenderMimeRegistry, ILatexTypesetter, IMarkdownParser, IUrlResolverFactory;
var init_tokens = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/tokens.js"() {
    import_coreutils8 = __toESM(require_dist());
    IRenderMimeRegistry = new import_coreutils8.Token("@jupyterlab/rendermime:IRenderMimeRegistry", 'A service for the rendermime registry for the application. Use this to create renderers for various mime-types in your extension. Many times it will be easier to create a "mime renderer extension" rather than using this service directly.');
    ILatexTypesetter = new import_coreutils8.Token("@jupyterlab/rendermime:ILatexTypesetter", "A service for the LaTeX typesetter for the application. Use this if you want to typeset math in your extension.");
    IMarkdownParser = new import_coreutils8.Token("@jupyterlab/rendermime:IMarkdownParser", "A service for rendering markdown syntax as HTML content.");
    IUrlResolverFactory = new import_coreutils8.Token("@jupyterlab/rendermime:IUrlResolverFactory", "A factory for resolver of asset URLs.");
  }
});

// ../../node_modules/@jupyterlab/rendermime/lib/index.js
var init_lib6 = __esm({
  "../../node_modules/@jupyterlab/rendermime/lib/index.js"() {
    init_lib4();
    init_attachmentmodel();
    init_factories();
    init_latex();
    init_mimemodel();
    init_outputmodel();
    init_registry();
    init_renderers();
    init_tokens();
    init_widgets();
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/model.js
var import_coreutils9, OutputAreaModel, Private13;
var init_model = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/model.js"() {
    init_lib5();
    init_lib2();
    init_lib6();
    init_index_es6();
    import_coreutils9 = __toESM(require_dist());
    init_index_es62();
    OutputAreaModel = class {
      /**
       * Construct a new observable outputs instance.
       */
      constructor(options = {}) {
        this.clearNext = false;
        this._lastStreamName = "";
        this._trusted = false;
        this._isDisposed = false;
        this._stateChanged = new Signal(this);
        this._changed = new Signal(this);
        this._streamIndex = 0;
        this._trusted = !!options.trusted;
        this.contentFactory = options.contentFactory || OutputAreaModel.defaultContentFactory;
        this.list = new ObservableList();
        if (options.values) {
          for (const value of options.values) {
            const index2 = this._add(value) - 1;
            const item = this.list.get(index2);
            item.changed.connect(this._onGenericChange, this);
          }
        }
        this.list.changed.connect(this._onListChanged, this);
      }
      /**
       * A signal emitted when an item changes.
       */
      get stateChanged() {
        return this._stateChanged;
      }
      /**
       * A signal emitted when the list of items changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the length of the items in the model.
       */
      get length() {
        return this.list ? this.list.length : 0;
      }
      /**
       * Get whether the model is trusted.
       */
      get trusted() {
        return this._trusted;
      }
      /**
       * Set whether the model is trusted.
       *
       * #### Notes
       * Changing the value will cause all of the models to re-set.
       */
      set trusted(value) {
        if (value === this._trusted) {
          return;
        }
        const trusted = this._trusted = value;
        for (let i6 = 0; i6 < this.list.length; i6++) {
          const oldItem = this.list.get(i6);
          const value2 = oldItem.toJSON();
          const item = this._createItem({ value: value2, trusted });
          this.list.set(i6, item);
          oldItem.dispose();
        }
      }
      /**
       * Test whether the model is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the model.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this.list.dispose();
        Signal.clearData(this);
      }
      /**
       * Get an item at the specified index.
       */
      get(index2) {
        return this.list.get(index2);
      }
      /**
       * Set the value at the specified index.
       */
      set(index2, value) {
        value = import_coreutils9.JSONExt.deepCopy(value);
        Private13.normalize(value);
        const item = this._createItem({ value, trusted: this._trusted });
        this.list.set(index2, item);
      }
      removeStreamOutput(number) {
        const prev = this.list.get(this.length - 1);
        const curText = prev.streamText;
        const length = curText.text.length;
        const options = { silent: true };
        curText.remove(length - number, length, options);
      }
      appendStreamOutput(text) {
        const prev = this.list.get(this.length - 1);
        const curText = prev.streamText;
        const length = curText.text.length;
        const options = { silent: true };
        curText.insert(length, text, options);
      }
      /**
       * Add an output, which may be combined with previous output.
       *
       * @returns The total number of outputs.
       *
       * #### Notes
       * The output bundle is copied.
       * Contiguous stream outputs of the same `name` are combined.
       */
      add(output) {
        if (this.clearNext) {
          this.clear();
          this.clearNext = false;
        }
        return this._add(output);
      }
      /**
       * Remove an output at a given index.
       */
      remove(index2) {
        var _a;
        (_a = this.list.remove(index2)) === null || _a === void 0 ? void 0 : _a.dispose();
      }
      /**
       * Clear all of the output.
       *
       * @param wait Delay clearing the output until the next message is added.
       */
      clear(wait = false) {
        this._lastStreamName = "";
        if (wait) {
          this.clearNext = true;
          return;
        }
        for (const item of this.list) {
          item.dispose();
        }
        this.list.clear();
      }
      /**
       * Deserialize the model from JSON.
       *
       * #### Notes
       * This will clear any existing data.
       */
      fromJSON(values2) {
        this.clear();
        for (const value of values2) {
          this._add(value);
        }
      }
      /**
       * Serialize the model to JSON.
       */
      toJSON() {
        return Array.from(map(this.list, (output) => output.toJSON()));
      }
      /**
       * Add a copy of the item to the list.
       *
       * @returns The list length
       */
      _add(value) {
        const trusted = this._trusted;
        value = import_coreutils9.JSONExt.deepCopy(value);
        Private13.normalize(value);
        if (isStream(value) && value.name === this._lastStreamName && this.length > 0 && this.shouldCombine({
          value,
          lastModel: this.list.get(this.length - 1)
        })) {
          const prev = this.list.get(this.length - 1);
          const curText = prev.streamText;
          const newText = typeof value.text === "string" ? value.text : value.text.join("");
          this._streamIndex = Private13.addText(this._streamIndex, curText, newText);
          return this.length;
        }
        if (isStream(value)) {
          if (typeof value.text !== "string") {
            value.text = value.text.join("");
          }
          const { text, index: index2 } = Private13.processText(0, value.text);
          this._streamIndex = index2;
          value.text = text;
        }
        const item = this._createItem({ value, trusted });
        const length = this.list.push(item);
        if (isStream(value)) {
          this._lastStreamName = value.name;
        } else {
          this._lastStreamName = "";
        }
        return length;
      }
      /**
       * Whether a new value should be consolidated with the previous output.
       *
       * This will only be called if the minimal criteria of both being stream
       * messages of the same type.
       */
      shouldCombine(options) {
        return true;
      }
      /**
       * Create an output item and hook up its signals.
       */
      _createItem(options) {
        const factory = this.contentFactory;
        const item = factory.createOutputModel(options);
        return item;
      }
      /**
       * Handle a change to the list.
       */
      _onListChanged(sender, args) {
        switch (args.type) {
          case "add":
            args.newValues.forEach((item) => {
              item.changed.connect(this._onGenericChange, this);
            });
            break;
          case "remove":
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
          case "set":
            args.newValues.forEach((item) => {
              item.changed.connect(this._onGenericChange, this);
            });
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
          case "move":
            break;
          case "clear":
            args.oldValues.forEach((item) => {
              item.changed.disconnect(this._onGenericChange, this);
            });
            break;
        }
        this._changed.emit(args);
      }
      /**
       * Handle a change to an item.
       */
      _onGenericChange(itemModel) {
        let idx;
        let item = null;
        for (idx = 0; idx < this.list.length; idx++) {
          item = this.list.get(idx);
          if (item === itemModel) {
            break;
          }
        }
        if (item != null) {
          this._stateChanged.emit(idx);
          this._changed.emit({
            type: "set",
            newIndex: idx,
            oldIndex: idx,
            oldValues: [item],
            newValues: [item]
          });
        }
      }
    };
    (function(OutputAreaModel2) {
      class ContentFactory {
        /**
         * Create an output model.
         */
        createOutputModel(options) {
          return new OutputModel(options);
        }
      }
      OutputAreaModel2.ContentFactory = ContentFactory;
      OutputAreaModel2.defaultContentFactory = new ContentFactory();
    })(OutputAreaModel || (OutputAreaModel = {}));
    (function(Private22) {
      function normalize2(value) {
        if (isStream(value)) {
          if (Array.isArray(value.text)) {
            value.text = value.text.join("\n");
          }
        }
      }
      Private22.normalize = normalize2;
      function indexOfAny(text, re2, i6) {
        const index2 = text.slice(i6).search(re2);
        return index2 >= 0 ? index2 + i6 : index2;
      }
      function processText(index2, newText, text) {
        if (text === void 0) {
          text = "";
        }
        if (!(newText.includes("\b") || newText.includes("\r") || newText.includes("\n"))) {
          text = text.slice(0, index2) + newText + text.slice(index2 + newText.length);
          return { text, index: index2 + newText.length };
        }
        let idx0 = index2;
        let idx1 = -1;
        let lastEnd = 0;
        const regex = /[\n\b\r]/;
        while (true) {
          idx1 = indexOfAny(newText, regex, lastEnd);
          const prefix = newText.slice(lastEnd, idx1 === -1 ? newText.length : idx1);
          text = text.slice(0, idx0) + prefix + text.slice(idx0 + prefix.length);
          lastEnd = idx1 + 1;
          idx0 += prefix.length;
          if (idx1 === -1) {
            break;
          }
          const newChar = newText[idx1];
          if (newChar === "\b") {
            if (idx0 > 0 && text[idx0 - 1] !== "\n") {
              text = text.slice(0, idx0 - 1) + text.slice(idx0 + 1);
              idx0--;
            }
          } else if (newChar === "\r") {
            let done = false;
            while (!done) {
              if (idx0 === 0) {
                done = true;
              } else if (text[idx0 - 1] === "\n") {
                done = true;
              } else {
                idx0--;
              }
            }
          } else if (newChar === "\n") {
            text = text + "\n";
            idx0 = text.length;
          } else {
            throw Error(`This should not happen`);
          }
        }
        return { text, index: idx0 };
      }
      Private22.processText = processText;
      function unleakString(s8) {
        return JSON.parse(JSON.stringify(s8));
      }
      function addText(prevIndex, curText, newText) {
        const { text, index: index2 } = processText(prevIndex, newText, curText.text);
        let done = false;
        let idx = 0;
        while (!done) {
          if (idx === text.length) {
            if (idx === curText.text.length) {
              done = true;
            } else {
              curText.remove(idx, curText.text.length);
              done = true;
            }
          } else if (idx === curText.text.length) {
            if (idx !== text.length) {
              curText.insert(curText.text.length, unleakString(text.slice(idx)));
              done = true;
            }
          } else if (text[idx] !== curText.text[idx]) {
            curText.remove(idx, curText.text.length);
            curText.insert(idx, unleakString(text.slice(idx)));
            done = true;
          } else {
            idx++;
          }
        }
        return index2;
      }
      Private22.addText = addText;
    })(Private13 || (Private13 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList3, Private14;
var init_index_es619 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList3 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private14.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private14.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private14.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private14.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private14.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private14.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private14.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList5) {
      function from(values2) {
        let list = new LinkedList5();
        list.assign(values2);
        return list;
      }
      LinkedList5.from = from;
    })(LinkedList3 || (LinkedList3 = {}));
    (function(Private22) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private22.LinkedListNode = LinkedListNode;
    })(Private14 || (Private14 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/messaging/dist/index.es6.js
var Message3, ConflatableMessage3, MessageLoop4;
var init_index_es620 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es6();
    init_index_es619();
    Message3 = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    ConflatableMessage3 = class extends Message3 {
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * This property is always `true`.
       */
      get isConflatable() {
        return true;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * #### Notes
       * This method always returns `true`.
       */
      conflate(other) {
        return true;
      }
    };
    (function(MessageLoop6) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop6.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop6.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop6.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i6 = hooks.indexOf(hook);
        if (i6 === -1) {
          return;
        }
        hooks[i6] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop6.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop6.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop6.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop6.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop6.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList3();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt.removeAllWhere(hooks, isNull2);
      }
      function isNull2(value) {
        return value === null;
      }
    })(MessageLoop4 || (MessageLoop4 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/dragdrop/dist/index.es6.js
var Drag3, Private15;
var init_index_es621 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/dragdrop/dist/index.es6.js"() {
    init_index_es63();
    Drag3 = class {
      /**
       * Construct a new drag object.
       *
       * @param options - The options for initializing the drag.
       */
      constructor(options) {
        this._onScrollFrame = () => {
          if (!this._scrollTarget) {
            return;
          }
          let { element: element2, edge, distance } = this._scrollTarget;
          let d6 = Private15.SCROLL_EDGE_SIZE - distance;
          let f6 = Math.pow(d6 / Private15.SCROLL_EDGE_SIZE, 2);
          let s8 = Math.max(1, Math.round(f6 * Private15.SCROLL_EDGE_SIZE));
          switch (edge) {
            case "top":
              element2.scrollTop -= s8;
              break;
            case "left":
              element2.scrollLeft -= s8;
              break;
            case "right":
              element2.scrollLeft += s8;
              break;
            case "bottom":
              element2.scrollTop += s8;
              break;
          }
          requestAnimationFrame(this._onScrollFrame);
        };
        this._disposed = false;
        this._dropAction = "none";
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._scrollTarget = null;
        this._resolve = null;
        this.document = options.document || document;
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || "copy";
        this.supportedActions = options.supportedActions || "all";
        this.source = options.source || null;
      }
      /**
       * Dispose of the resources held by the drag object.
       *
       * #### Notes
       * This will cancel the drag operation if it is active.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        if (this._currentTarget) {
          let event = new PointerEvent("pointerup", {
            bubbles: true,
            cancelable: true,
            clientX: -1,
            clientY: -1
          });
          Private15.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        this._finalize("none");
      }
      /**
       * Test whether the drag object is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Start the drag operation at the specified client position.
       *
       * @param clientX - The client X position for the drag start.
       *
       * @param clientY - The client Y position for the drag start.
       *
       * @returns A promise which resolves to the result of the drag.
       *
       * #### Notes
       * If the drag has already been started, the promise created by the
       * first call to `start` is returned.
       *
       * If the drag operation has ended, or if the drag object has been
       * disposed, the returned promise will resolve to `'none'`.
       *
       * The drag object will be automatically disposed when drag operation
       * completes. This means `Drag` objects are for single-use only.
       *
       * This method assumes the left mouse button is already held down.
       */
      start(clientX, clientY) {
        if (this._disposed) {
          return Promise.resolve("none");
        }
        if (this._promise) {
          return this._promise;
        }
        this._addListeners();
        this._attachDragImage(clientX, clientY);
        this._promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
        let event = new PointerEvent("pointermove", {
          bubbles: true,
          cancelable: true,
          clientX,
          clientY
        });
        document.dispatchEvent(event);
        return this._promise;
      }
      /**
       * Handle the DOM events for the drag operation.
       *
       * @param event - The DOM event sent to the drag object.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the document. It should not be
       * called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          default:
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * Move the drag image element to the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        let style = this.dragImage.style;
        style.transform = `translate(${clientX}px, ${clientY}px)`;
      }
      /**
       * Handle the `'pointermove'` event for the drag object.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        this._updateCurrentTarget(event);
        this._updateDragScroll(event);
        this.moveDragImage(event.clientX, event.clientY);
      }
      /**
       * Handle the `'pointerup'` event for the drag object.
       */
      _evtPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
          return;
        }
        this._updateCurrentTarget(event);
        if (!this._currentTarget) {
          this._finalize("none");
          return;
        }
        if (this._dropAction === "none") {
          Private15.dispatchDragLeave(this, this._currentTarget, null, event);
          this._finalize("none");
          return;
        }
        let action = Private15.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
      }
      /**
       * Handle the `'keydown'` event for the drag object.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this.dispose();
        }
      }
      /**
       * Add the document event listeners for the drag object.
       */
      _addListeners() {
        document.addEventListener("pointerdown", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointerenter", this, true);
        document.addEventListener("pointerleave", this, true);
        document.addEventListener("pointerover", this, true);
        document.addEventListener("pointerout", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("keyup", this, true);
        document.addEventListener("keypress", this, true);
        document.addEventListener("contextmenu", this, true);
      }
      /**
       * Remove the document event listeners for the drag object.
       */
      _removeListeners() {
        document.removeEventListener("pointerdown", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointerenter", this, true);
        document.removeEventListener("pointerleave", this, true);
        document.removeEventListener("pointerover", this, true);
        document.removeEventListener("pointerout", this, true);
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("keyup", this, true);
        document.removeEventListener("keypress", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Update the drag scroll element under the mouse.
       */
      _updateDragScroll(event) {
        let target = Private15.findScrollTarget(event);
        if (!this._scrollTarget && !target) {
          return;
        }
        if (!this._scrollTarget) {
          setTimeout(this._onScrollFrame, 500);
        }
        this._scrollTarget = target;
      }
      /**
       * Update the current target node using the given mouse event.
       */
      _updateCurrentTarget(event) {
        let prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        let prevElem = this._currentElement;
        let currElem = Private15.findElementBehindBackdrop(event, this.document);
        this._currentElement = currElem;
        if (currElem !== prevElem && currElem !== currTarget) {
          Private15.dispatchDragExit(this, currTarget, currElem, event);
        }
        if (currElem !== prevElem && currElem !== currTarget) {
          currTarget = Private15.dispatchDragEnter(this, currElem, currTarget, event);
        }
        if (currTarget !== prevTarget) {
          this._currentTarget = currTarget;
          Private15.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        let action = Private15.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
      }
      /**
       * Attach the drag image element at the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        this.dragImage.classList.add("lm-mod-drag-image");
        let style = this.dragImage.style;
        style.pointerEvents = "none";
        style.position = "fixed";
        style.transform = `translate(${clientX}px, ${clientY}px)`;
        const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
        body.appendChild(this.dragImage);
      }
      /**
       * Detach the drag image element from the DOM.
       *
       * This is a no-op if there is no drag image element.
       */
      _detachDragImage() {
        if (!this.dragImage) {
          return;
        }
        let parent = this.dragImage.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(this.dragImage);
      }
      /**
       * Set the internal drop action state and update the drag cursor.
       */
      _setDropAction(action) {
        action = Private15.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
          return;
        }
        switch (action) {
          case "none":
            this._dropAction = action;
            this._override = Drag3.overrideCursor("no-drop", this.document);
            break;
          case "copy":
            this._dropAction = action;
            this._override = Drag3.overrideCursor("copy", this.document);
            break;
          case "link":
            this._dropAction = action;
            this._override = Drag3.overrideCursor("alias", this.document);
            break;
          case "move":
            this._dropAction = action;
            this._override = Drag3.overrideCursor("move", this.document);
            break;
        }
      }
      /**
       * Finalize the drag operation and resolve the drag promise.
       */
      _finalize(action) {
        let resolve = this._resolve;
        this._removeListeners();
        this._detachDragImage();
        if (this._override) {
          this._override.dispose();
          this._override = null;
        }
        this.mimeData.clear();
        this._disposed = true;
        this._dropAction = "none";
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        if (resolve) {
          resolve(action);
        }
      }
    };
    (function(Drag5) {
      class Event2 extends DragEvent {
        constructor(event, options) {
          super(options.type, {
            bubbles: true,
            cancelable: true,
            altKey: event.altKey,
            button: event.button,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            detail: 0,
            metaKey: event.metaKey,
            relatedTarget: options.related,
            screenX: event.screenX,
            screenY: event.screenY,
            shiftKey: event.shiftKey,
            view: window
          });
          const { drag } = options;
          this.dropAction = "none";
          this.mimeData = drag.mimeData;
          this.proposedAction = drag.proposedAction;
          this.supportedActions = drag.supportedActions;
          this.source = drag.source;
        }
      }
      Drag5.Event = Event2;
      function overrideCursor(cursor, doc = document) {
        return Private15.overrideCursor(cursor, doc);
      }
      Drag5.overrideCursor = overrideCursor;
    })(Drag3 || (Drag3 = {}));
    (function(Private22) {
      Private22.SCROLL_EDGE_SIZE = 20;
      function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : "none";
      }
      Private22.validateAction = validateAction;
      function findElementBehindBackdrop(event, root2 = document) {
        if (event) {
          if (lastElementEventSearch && event == lastElementEventSearch.event) {
            return lastElementEventSearch.element;
          }
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(event.clientX, event.clientY);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementEventSearch = { event, element: element2 };
          return element2;
        } else {
          const transform = Private22.cursorBackdrop.style.transform;
          if (lastElementSearch && transform === lastElementSearch.transform) {
            return lastElementSearch.element;
          }
          const bbox = Private22.cursorBackdrop.getBoundingClientRect();
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementSearch = { transform, element: element2 };
          return element2;
        }
      }
      Private22.findElementBehindBackdrop = findElementBehindBackdrop;
      let lastElementEventSearch = null;
      let lastElementSearch = null;
      function findScrollTarget(event) {
        let x2 = event.clientX;
        let y4 = event.clientY;
        let element2 = findElementBehindBackdrop(event);
        for (; element2; element2 = element2.parentElement) {
          if (!element2.hasAttribute("data-lm-dragscroll")) {
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (element2 === document.body) {
            offsetX = window.pageXOffset;
            offsetY = window.pageYOffset;
          }
          let r4 = element2.getBoundingClientRect();
          let top = r4.top + offsetY;
          let left = r4.left + offsetX;
          let right = left + r4.width;
          let bottom = top + r4.height;
          if (x2 < left || x2 >= right || y4 < top || y4 >= bottom) {
            continue;
          }
          let dl = x2 - left + 1;
          let dt = y4 - top + 1;
          let dr = right - x2;
          let db = bottom - y4;
          let distance = Math.min(dl, dt, dr, db);
          if (distance > Private22.SCROLL_EDGE_SIZE) {
            continue;
          }
          let edge;
          switch (distance) {
            case db:
              edge = "bottom";
              break;
            case dt:
              edge = "top";
              break;
            case dr:
              edge = "right";
              break;
            case dl:
              edge = "left";
              break;
            default:
              throw "unreachable";
          }
          let dsw = element2.scrollWidth - element2.clientWidth;
          let dsh = element2.scrollHeight - element2.clientHeight;
          let shouldScroll;
          switch (edge) {
            case "top":
              shouldScroll = dsh > 0 && element2.scrollTop > 0;
              break;
            case "left":
              shouldScroll = dsw > 0 && element2.scrollLeft > 0;
              break;
            case "right":
              shouldScroll = dsw > 0 && element2.scrollLeft < dsw;
              break;
            case "bottom":
              shouldScroll = dsh > 0 && element2.scrollTop < dsh;
              break;
            default:
              throw "unreachable";
          }
          if (!shouldScroll) {
            continue;
          }
          return { element: element2, edge, distance };
        }
        return null;
      }
      Private22.findScrollTarget = findScrollTarget;
      function dispatchDragEnter(drag, currElem, currTarget, event) {
        if (!currElem) {
          return null;
        }
        let dragEvent = new Drag3.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        let canceled = !currElem.dispatchEvent(dragEvent);
        if (canceled) {
          return currElem;
        }
        const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
        if (currElem === body) {
          return currTarget;
        }
        dragEvent = new Drag3.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        body.dispatchEvent(dragEvent);
        return body;
      }
      Private22.dispatchDragEnter = dispatchDragEnter;
      function dispatchDragExit(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag3.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragexit"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragExit = dispatchDragExit;
      function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag3.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragleave"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragLeave = dispatchDragLeave;
      function dispatchDragOver(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag3.Event(event, {
          drag,
          related: null,
          type: "lm-dragover"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDragOver = dispatchDragOver;
      function dispatchDrop(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag3.Event(event, {
          drag,
          related: null,
          type: "lm-drop"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDrop = dispatchDrop;
      const actionTable = {
        none: 0,
        copy: 1,
        link: 2,
        move: 4
      };
      const supportedTable = {
        none: actionTable["none"],
        copy: actionTable["copy"],
        link: actionTable["link"],
        move: actionTable["move"],
        "copy-link": actionTable["copy"] | actionTable["link"],
        "copy-move": actionTable["copy"] | actionTable["move"],
        "link-move": actionTable["link"] | actionTable["move"],
        all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
      };
      function overrideCursor(cursor, doc = document) {
        let id = ++overrideCursorID;
        const body = doc instanceof Document ? doc.body : doc.firstElementChild;
        if (!Private22.cursorBackdrop.isConnected) {
          Private22.cursorBackdrop.style.transform = "scale(0)";
          body.appendChild(Private22.cursorBackdrop);
          resetBackdropScroll();
          document.addEventListener("pointermove", alignBackdrop, {
            capture: true,
            passive: true
          });
          Private22.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
            capture: true,
            passive: true
          });
        }
        Private22.cursorBackdrop.style.cursor = cursor;
        return new DisposableDelegate(() => {
          if (id === overrideCursorID && Private22.cursorBackdrop.isConnected) {
            document.removeEventListener("pointermove", alignBackdrop, true);
            Private22.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
            body.removeChild(Private22.cursorBackdrop);
          }
        });
      }
      Private22.overrideCursor = overrideCursor;
      function alignBackdrop(event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        Private22.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
      }
      function propagateBackdropScroll(_event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        let element2 = findElementBehindBackdrop();
        if (!element2) {
          return;
        }
        const scrollTarget = element2.closest("[data-lm-dragscroll]");
        if (!scrollTarget) {
          return;
        }
        scrollTarget.scrollTop += Private22.cursorBackdrop.scrollTop - backdropScrollOrigin;
        scrollTarget.scrollLeft += Private22.cursorBackdrop.scrollLeft - backdropScrollOrigin;
        resetBackdropScroll();
      }
      function resetBackdropScroll() {
        Private22.cursorBackdrop.scrollTop = backdropScrollOrigin;
        Private22.cursorBackdrop.scrollLeft = backdropScrollOrigin;
      }
      const backdropScrollOrigin = 500;
      function createCursorBackdrop() {
        const backdrop = document.createElement("div");
        backdrop.classList.add("lm-cursor-backdrop");
        return backdrop;
      }
      let overrideCursorID = 0;
      Private22.cursorBackdrop = createCursorBackdrop();
    })(Private15 || (Private15 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/widgets/dist/index.es6.js
var import_coreutils10, BoxSizer3, BoxEngine3, Title4, Widget4, Private$j3, Layout3, LayoutItem3, Private$i3, PanelLayout4, Utils3, Utils$13, SplitLayout3, Private$h3, AccordionLayout3, Private$g3, Panel4, Private$f3, SplitPanel3, Private$e3, AccordionPanel3, Private$d3, BoxLayout3, Private$c3, BoxPanel3, Private$b3, CommandPalette3, Private$a3, Menu3, Private$93, Private$83, ARROW_KEYS3, TabBar4, Private$73, DockLayout3, Private$63, DockPanel3, Private$53, GridLayout3, Private$43, MenuBar3, Private$33, Private$23, SingletonLayout3, StackedLayout3, Private$13, Private16;
var init_index_es622 = __esm({
  "../../node_modules/@jupyterlab/outputarea/node_modules/@lumino/widgets/dist/index.es6.js"() {
    init_index_es6();
    import_coreutils10 = __toESM(require_dist());
    init_index_es65();
    init_index_es620();
    init_index_es64();
    init_index_es62();
    init_index_es621();
    init_index_es67();
    init_index_es68();
    init_index_es63();
    init_index_es66();
    BoxSizer3 = class {
      constructor() {
        this.sizeHint = 0;
        this.minSize = 0;
        this.maxSize = Infinity;
        this.stretch = 1;
        this.size = 0;
        this.done = false;
      }
    };
    (function(BoxEngine5) {
      function calc(sizers, space) {
        let count3 = sizers.length;
        if (count3 === 0) {
          return space;
        }
        let totalMin = 0;
        let totalMax = 0;
        let totalSize = 0;
        let totalStretch = 0;
        let stretchCount = 0;
        for (let i6 = 0; i6 < count3; ++i6) {
          let sizer = sizers[i6];
          let min3 = sizer.minSize;
          let max4 = sizer.maxSize;
          let hint = sizer.sizeHint;
          sizer.done = false;
          sizer.size = Math.max(min3, Math.min(hint, max4));
          totalSize += sizer.size;
          totalMin += min3;
          totalMax += max4;
          if (sizer.stretch > 0) {
            totalStretch += sizer.stretch;
            stretchCount++;
          }
        }
        if (space === totalSize) {
          return 0;
        }
        if (space <= totalMin) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.minSize;
          }
          return space - totalMin;
        }
        if (space >= totalMax) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.maxSize;
          }
          return space - totalMax;
        }
        let nearZero = 0.01;
        let notDoneCount = count3;
        if (space < totalSize) {
          let freeSpace = totalSize - space;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
        } else {
          let freeSpace = space - totalSize;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
        }
        return 0;
      }
      BoxEngine5.calc = calc;
      function adjust(sizers, index2, delta) {
        if (sizers.length === 0 || delta === 0) {
          return;
        }
        if (delta > 0) {
          growSizer(sizers, index2, delta);
        } else {
          shrinkSizer(sizers, index2, -delta);
        }
      }
      BoxEngine5.adjust = adjust;
      function growSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2; i6 >= 0 && grow > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && shrink > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
      function shrinkSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && grow > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2; i6 >= 0 && shrink > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
    })(BoxEngine3 || (BoxEngine3 = {}));
    Title4 = class {
      /**
       * Construct a new title.
       *
       * @param options - The options for initializing the title.
       */
      constructor(options) {
        this._label = "";
        this._caption = "";
        this._mnemonic = -1;
        this._icon = void 0;
        this._iconClass = "";
        this._iconLabel = "";
        this._className = "";
        this._closable = false;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this.owner = options.owner;
        if (options.label !== void 0) {
          this._label = options.label;
        }
        if (options.mnemonic !== void 0) {
          this._mnemonic = options.mnemonic;
        }
        if (options.icon !== void 0) {
          this._icon = options.icon;
        }
        if (options.iconClass !== void 0) {
          this._iconClass = options.iconClass;
        }
        if (options.iconLabel !== void 0) {
          this._iconLabel = options.iconLabel;
        }
        if (options.caption !== void 0) {
          this._caption = options.caption;
        }
        if (options.className !== void 0) {
          this._className = options.className;
        }
        if (options.closable !== void 0) {
          this._closable = options.closable;
        }
        this._dataset = options.dataset || {};
      }
      /**
       * A signal emitted when the state of the title changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get label() {
        return this._label;
      }
      /**
       * Set the label for the title.
       */
      set label(value) {
        if (this._label === value) {
          return;
        }
        this._label = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the mnemonic index for the title.
       *
       * #### Notes
       * The default value is `-1`.
       */
      get mnemonic() {
        return this._mnemonic;
      }
      /**
       * Set the mnemonic index for the title.
       */
      set mnemonic(value) {
        if (this._mnemonic === value) {
          return;
        }
        this._mnemonic = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon renderer for the title.
       *
       * #### Notes
       * The default value is undefined.
       */
      get icon() {
        return this._icon;
      }
      /**
       * Set the icon renderer for the title.
       *
       * #### Notes
       * A renderer is an object that supplies a render and unrender function.
       */
      set icon(value) {
        if (this._icon === value) {
          return;
        }
        this._icon = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconClass() {
        return this._iconClass;
      }
      /**
       * Set the icon class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconClass(value) {
        if (this._iconClass === value) {
          return;
        }
        this._iconClass = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconLabel() {
        return this._iconLabel;
      }
      /**
       * Set the icon label for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconLabel(value) {
        if (this._iconLabel === value) {
          return;
        }
        this._iconLabel = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the caption for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get caption() {
        return this._caption;
      }
      /**
       * Set the caption for the title.
       */
      set caption(value) {
        if (this._caption === value) {
          return;
        }
        this._caption = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the extra class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get className() {
        return this._className;
      }
      /**
       * Set the extra class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set className(value) {
        if (this._className === value) {
          return;
        }
        this._className = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the closable state for the title.
       *
       * #### Notes
       * The default value is `false`.
       */
      get closable() {
        return this._closable;
      }
      /**
       * Set the closable state for the title.
       *
       * #### Notes
       * This controls the presence of a close icon when applicable.
       */
      set closable(value) {
        if (this._closable === value) {
          return;
        }
        this._closable = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the dataset for the title.
       *
       * #### Notes
       * The default value is an empty dataset.
       */
      get dataset() {
        return this._dataset;
      }
      /**
       * Set the dataset for the title.
       *
       * #### Notes
       * This controls the data attributes when applicable.
       */
      set dataset(value) {
        if (this._dataset === value) {
          return;
        }
        this._dataset = value;
        this._changed.emit(void 0);
      }
      /**
       * Test whether the title has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the title.
       *
       * #### Notes
       * It is the responsibility of the owner to call the title disposal.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
    Widget4 = class {
      /**
       * Construct a new widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options = {}) {
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this._disposed = new Signal(this);
        this._hiddenMode = Widget4.HiddenMode.Display;
        this.node = Private$j3.createNode(options);
        this.addClass("lm-Widget");
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.setFlag(Widget4.Flag.IsDisposed);
        this._disposed.emit(void 0);
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget4.detach(this);
        }
        if (this._layout) {
          this._layout.dispose();
          this._layout = null;
        }
        this.title.dispose();
        Signal.clearData(this);
        MessageLoop4.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * A signal emitted when the widget is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the widget has been disposed.
       */
      get isDisposed() {
        return this.testFlag(Widget4.Flag.IsDisposed);
      }
      /**
       * Test whether the widget's node is attached to the DOM.
       */
      get isAttached() {
        return this.testFlag(Widget4.Flag.IsAttached);
      }
      /**
       * Test whether the widget is explicitly hidden.
       *
       * #### Notes
       * You should prefer `!{@link isVisible}` over `{@link isHidden}` if you want to know if the
       * widget is hidden as this does not test if the widget is hidden because one of its ancestors is hidden.
       */
      get isHidden() {
        return this.testFlag(Widget4.Flag.IsHidden);
      }
      /**
       * Test whether the widget is visible.
       *
       * #### Notes
       * A widget is visible when it is attached to the DOM, is not
       * explicitly hidden, and has no explicitly hidden ancestors.
       *
       * Since 2.7.0, this does not rely on the {@link Widget.Flag.IsVisible} flag.
       * It recursively checks the visibility of all parent widgets.
       */
      get isVisible() {
        let parent = this;
        do {
          if (parent.isHidden || !parent.isAttached) {
            return false;
          }
          parent = parent.parent;
        } while (parent != null);
        return true;
      }
      /**
       * The title object for the widget.
       *
       * #### Notes
       * The title object is used by some container widgets when displaying
       * the widget alongside some title, such as a tab panel or side bar.
       *
       * Since not all widgets will use the title, it is created on demand.
       *
       * The `owner` property of the title is set to this widget.
       */
      get title() {
        return Private$j3.titleProperty.get(this);
      }
      /**
       * Get the id of the widget's DOM node.
       */
      get id() {
        return this.node.id;
      }
      /**
       * Set the id of the widget's DOM node.
       */
      set id(value) {
        this.node.id = value;
      }
      /**
       * The dataset for the widget's DOM node.
       */
      get dataset() {
        return this.node.dataset;
      }
      /**
       * Get the method for hiding the widget.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding the widget.
       */
      set hiddenMode(value) {
        if (this._hiddenMode === value) {
          return;
        }
        if (this.isHidden) {
          this._toggleHidden(false);
        }
        if (value == Widget4.HiddenMode.Scale) {
          this.node.style.willChange = "transform";
        } else {
          this.node.style.willChange = "auto";
        }
        this._hiddenMode = value;
        if (this.isHidden) {
          this._toggleHidden(true);
        }
      }
      /**
       * Get the parent of the widget.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the widget.
       *
       * #### Notes
       * Children are typically added to a widget by using a layout, which
       * means user code will not normally set the parent widget directly.
       *
       * The widget will be automatically removed from its old parent.
       *
       * This is a no-op if there is no effective parent change.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (value && this.contains(value)) {
          throw new Error("Invalid parent widget.");
        }
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget4.ChildMessage("child-removed", this);
          MessageLoop4.sendMessage(this._parent, msg);
        }
        this._parent = value;
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget4.ChildMessage("child-added", this);
          MessageLoop4.sendMessage(this._parent, msg);
        }
        if (!this.isDisposed) {
          MessageLoop4.sendMessage(this, Widget4.Msg.ParentChanged);
        }
      }
      /**
       * Get the layout for the widget.
       */
      get layout() {
        return this._layout;
      }
      /**
       * Set the layout for the widget.
       *
       * #### Notes
       * The layout is single-use only. It cannot be changed after the
       * first assignment.
       *
       * The layout is disposed automatically when the widget is disposed.
       */
      set layout(value) {
        if (this._layout === value) {
          return;
        }
        if (this.testFlag(Widget4.Flag.DisallowLayout)) {
          throw new Error("Cannot set widget layout.");
        }
        if (this._layout) {
          throw new Error("Cannot change widget layout.");
        }
        if (value.parent) {
          throw new Error("Cannot change layout parent.");
        }
        this._layout = value;
        value.parent = this;
      }
      /**
       * Create an iterator over the widget's children.
       *
       * @returns A new iterator over the children of the widget.
       *
       * #### Notes
       * The widget must have a populated layout in order to have children.
       *
       * If a layout is not installed, the returned iterator will be empty.
       */
      *children() {
        if (this._layout) {
          yield* this._layout;
        }
      }
      /**
       * Test whether a widget is a descendant of this widget.
       *
       * @param widget - The descendant widget of interest.
       *
       * @returns `true` if the widget is a descendant, `false` otherwise.
       */
      contains(widget) {
        for (let value = widget; value; value = value._parent) {
          if (value === this) {
            return true;
          }
        }
        return false;
      }
      /**
       * Test whether the widget's DOM node has the given class name.
       *
       * @param name - The class name of interest.
       *
       * @returns `true` if the node has the class, `false` otherwise.
       */
      hasClass(name) {
        return this.node.classList.contains(name);
      }
      /**
       * Add a class name to the widget's DOM node.
       *
       * @param name - The class name to add to the node.
       *
       * #### Notes
       * If the class name is already added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      addClass(name) {
        this.node.classList.add(name);
      }
      /**
       * Remove a class name from the widget's DOM node.
       *
       * @param name - The class name to remove from the node.
       *
       * #### Notes
       * If the class name is not yet added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      removeClass(name) {
        this.node.classList.remove(name);
      }
      /**
       * Toggle a class name on the widget's DOM node.
       *
       * @param name - The class name to toggle on the node.
       *
       * @param force - Whether to force add the class (`true`) or force
       *   remove the class (`false`). If not provided, the presence of
       *   the class will be toggled from its current state.
       *
       * @returns `true` if the class is now present, `false` otherwise.
       *
       * #### Notes
       * The class name must not contain whitespace.
       */
      toggleClass(name, force) {
        if (force === true) {
          this.node.classList.add(name);
          return true;
        }
        if (force === false) {
          this.node.classList.remove(name);
          return false;
        }
        return this.node.classList.toggle(name);
      }
      /**
       * Post an `'update-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      update() {
        MessageLoop4.postMessage(this, Widget4.Msg.UpdateRequest);
      }
      /**
       * Post a `'fit-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      fit() {
        MessageLoop4.postMessage(this, Widget4.Msg.FitRequest);
      }
      /**
       * Post an `'activate-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      activate() {
        MessageLoop4.postMessage(this, Widget4.Msg.ActivateRequest);
      }
      /**
       * Send a `'close-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for sending the message.
       */
      close() {
        MessageLoop4.sendMessage(this, Widget4.Msg.CloseRequest);
      }
      /**
       * Show the widget and make it visible to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `false`.
       *
       * If the widget is not explicitly hidden, this is a no-op.
       */
      show() {
        if (!this.testFlag(Widget4.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop4.sendMessage(this, Widget4.Msg.BeforeShow);
        }
        this.clearFlag(Widget4.Flag.IsHidden);
        this._toggleHidden(false);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop4.sendMessage(this, Widget4.Msg.AfterShow);
        }
        if (this.parent) {
          let msg = new Widget4.ChildMessage("child-shown", this);
          MessageLoop4.sendMessage(this.parent, msg);
        }
      }
      /**
       * Hide the widget and make it hidden to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `true`.
       *
       * If the widget is explicitly hidden, this is a no-op.
       */
      hide() {
        if (this.testFlag(Widget4.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop4.sendMessage(this, Widget4.Msg.BeforeHide);
        }
        this.setFlag(Widget4.Flag.IsHidden);
        this._toggleHidden(true);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop4.sendMessage(this, Widget4.Msg.AfterHide);
        }
        if (this.parent) {
          let msg = new Widget4.ChildMessage("child-hidden", this);
          MessageLoop4.sendMessage(this.parent, msg);
        }
      }
      /**
       * Show or hide the widget according to a boolean value.
       *
       * @param hidden - `true` to hide the widget, or `false` to show it.
       *
       * #### Notes
       * This is a convenience method for `hide()` and `show()`.
       */
      setHidden(hidden) {
        if (hidden) {
          this.hide();
        } else {
          this.show();
        }
      }
      /**
       * Test whether the given widget flag is set.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      testFlag(flag) {
        return (this._flags & flag) !== 0;
      }
      /**
       * Set the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      setFlag(flag) {
        this._flags |= flag;
      }
      /**
       * Clear the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      clearFlag(flag) {
        this._flags &= ~flag;
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       *
       * #### Notes
       * Subclasses may reimplement this method as needed.
       */
      processMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.notifyLayout(msg);
            this.onResize(msg);
            break;
          case "update-request":
            this.notifyLayout(msg);
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.notifyLayout(msg);
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.notifyLayout(msg);
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.setFlag(Widget4.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.notifyLayout(msg);
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.clearFlag(Widget4.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.notifyLayout(msg);
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
              this.setFlag(Widget4.Flag.IsVisible);
            }
            this.setFlag(Widget4.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.notifyLayout(msg);
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.clearFlag(Widget4.Flag.IsVisible);
            this.clearFlag(Widget4.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterDetach(msg);
            break;
          case "activate-request":
            this.notifyLayout(msg);
            this.onActivateRequest(msg);
            break;
          case "close-request":
            this.notifyLayout(msg);
            this.onCloseRequest(msg);
            break;
          case "child-added":
            this.notifyLayout(msg);
            this.onChildAdded(msg);
            break;
          case "child-removed":
            this.notifyLayout(msg);
            this.onChildRemoved(msg);
            break;
          default:
            this.notifyLayout(msg);
            break;
        }
      }
      /**
       * Invoke the message processing routine of the widget's layout.
       *
       * @param msg - The message to dispatch to the layout.
       *
       * #### Notes
       * This is a no-op if the widget does not have a layout.
       *
       * This will not typically be called directly by user code.
       */
      notifyLayout(msg) {
        if (this._layout) {
          this._layout.processParentMessage(msg);
        }
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       *
       * #### Notes
       * The default implementation unparents or detaches the widget.
       */
      onCloseRequest(msg) {
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget4.detach(this);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onResize(msg) {
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onActivateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeShow(msg) {
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterShow(msg) {
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeHide(msg) {
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterHide(msg) {
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeAttach(msg) {
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterAttach(msg) {
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeDetach(msg) {
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterDetach(msg) {
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildAdded(msg) {
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildRemoved(msg) {
      }
      _toggleHidden(hidden) {
        if (hidden) {
          switch (this._hiddenMode) {
            case Widget4.HiddenMode.Display:
              this.addClass("lm-mod-hidden");
              break;
            case Widget4.HiddenMode.Scale:
              this.node.style.transform = "scale(0)";
              this.node.setAttribute("aria-hidden", "true");
              break;
            case Widget4.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "hidden";
              this.node.style.zIndex = "-1";
              break;
          }
        } else {
          switch (this._hiddenMode) {
            case Widget4.HiddenMode.Display:
              this.removeClass("lm-mod-hidden");
              break;
            case Widget4.HiddenMode.Scale:
              this.node.style.transform = "";
              this.node.removeAttribute("aria-hidden");
              break;
            case Widget4.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "";
              this.node.style.zIndex = "";
              break;
          }
        }
      }
    };
    (function(Widget6) {
      (function(HiddenMode) {
        HiddenMode[HiddenMode["Display"] = 0] = "Display";
        HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
        HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
      })(Widget6.HiddenMode || (Widget6.HiddenMode = {}));
      (function(Flag) {
        Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
        Flag[Flag["IsAttached"] = 2] = "IsAttached";
        Flag[Flag["IsHidden"] = 4] = "IsHidden";
        Flag[Flag["IsVisible"] = 8] = "IsVisible";
        Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
      })(Widget6.Flag || (Widget6.Flag = {}));
      (function(Msg) {
        Msg.BeforeShow = new Message3("before-show");
        Msg.AfterShow = new Message3("after-show");
        Msg.BeforeHide = new Message3("before-hide");
        Msg.AfterHide = new Message3("after-hide");
        Msg.BeforeAttach = new Message3("before-attach");
        Msg.AfterAttach = new Message3("after-attach");
        Msg.BeforeDetach = new Message3("before-detach");
        Msg.AfterDetach = new Message3("after-detach");
        Msg.ParentChanged = new Message3("parent-changed");
        Msg.UpdateRequest = new ConflatableMessage3("update-request");
        Msg.FitRequest = new ConflatableMessage3("fit-request");
        Msg.ActivateRequest = new ConflatableMessage3("activate-request");
        Msg.CloseRequest = new ConflatableMessage3("close-request");
      })(Widget6.Msg || (Widget6.Msg = {}));
      class ChildMessage extends Message3 {
        /**
         * Construct a new child message.
         *
         * @param type - The message type.
         *
         * @param child - The child widget for the message.
         */
        constructor(type, child) {
          super(type);
          this.child = child;
        }
      }
      Widget6.ChildMessage = ChildMessage;
      class ResizeMessage extends Message3 {
        /**
         * Construct a new resize message.
         *
         * @param width - The **offset width** of the widget, or `-1` if
         *   the width is not known.
         *
         * @param height - The **offset height** of the widget, or `-1` if
         *   the height is not known.
         */
        constructor(width, height) {
          super("resize");
          this.width = width;
          this.height = height;
        }
      }
      Widget6.ResizeMessage = ResizeMessage;
      (function(ResizeMessage2) {
        ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
      })(ResizeMessage = Widget6.ResizeMessage || (Widget6.ResizeMessage = {}));
      function attach(widget, host, ref = null) {
        if (widget.parent) {
          throw new Error("Cannot attach a child widget.");
        }
        if (widget.isAttached || widget.node.isConnected) {
          throw new Error("Widget is already attached.");
        }
        if (!host.isConnected) {
          throw new Error("Host is not attached.");
        }
        MessageLoop4.sendMessage(widget, Widget6.Msg.BeforeAttach);
        host.insertBefore(widget.node, ref);
        MessageLoop4.sendMessage(widget, Widget6.Msg.AfterAttach);
      }
      Widget6.attach = attach;
      function detach(widget) {
        if (widget.parent) {
          throw new Error("Cannot detach a child widget.");
        }
        if (!widget.isAttached || !widget.node.isConnected) {
          throw new Error("Widget is not attached.");
        }
        MessageLoop4.sendMessage(widget, Widget6.Msg.BeforeDetach);
        widget.node.parentNode.removeChild(widget.node);
        MessageLoop4.sendMessage(widget, Widget6.Msg.AfterDetach);
      }
      Widget6.detach = detach;
    })(Widget4 || (Widget4 = {}));
    (function(Private22) {
      Private22.titleProperty = new AttachedProperty({
        name: "title",
        create: (owner) => new Title4({ owner })
      });
      function createNode(options) {
        return options.node || document.createElement(options.tag || "div");
      }
      Private22.createNode = createNode;
    })(Private$j3 || (Private$j3 = {}));
    Layout3 = class {
      /**
       * Construct a new layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        this._disposed = false;
        this._parent = null;
        this._fitPolicy = options.fitPolicy || "set-min-size";
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This should be reimplemented to clear and dispose of the widgets.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        this._parent = null;
        this._disposed = true;
        Signal.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * Test whether the layout is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Get the parent widget of the layout.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent widget of the layout.
       *
       * #### Notes
       * This is set automatically when installing the layout on the parent
       * widget. The parent widget should not be set directly by user code.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (this._parent) {
          throw new Error("Cannot change parent widget.");
        }
        if (value.layout !== this) {
          throw new Error("Invalid parent widget.");
        }
        this._parent = value;
        this.init();
      }
      /**
       * Get the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       */
      get fitPolicy() {
        return this._fitPolicy;
      }
      /**
       * Set the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       *
       * Changing the fit policy will clear the current size constraint
       * for the parent widget and then re-fit the parent.
       */
      set fitPolicy(value) {
        if (this._fitPolicy === value) {
          return;
        }
        this._fitPolicy = value;
        if (this._parent) {
          let style = this._parent.node.style;
          style.minWidth = "";
          style.minHeight = "";
          style.maxWidth = "";
          style.maxHeight = "";
          this._parent.fit();
        }
      }
      /**
       * Process a message sent to the parent widget.
       *
       * @param msg - The message sent to the parent widget.
       *
       * #### Notes
       * This method is called by the parent widget to process a message.
       *
       * Subclasses may reimplement this method as needed.
       */
      processParentMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.onResize(msg);
            break;
          case "update-request":
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.onAfterDetach(msg);
            break;
          case "child-removed":
            this.onChildRemoved(msg);
            break;
          case "child-shown":
            this.onChildShown(msg);
            break;
          case "child-hidden":
            this.onChildHidden(msg);
            break;
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       *
       * #### Notes
       * This method is invoked immediately after the layout is installed
       * on the parent widget.
       *
       * The default implementation reparents all of the widgets to the
       * layout parent widget.
       *
       * Subclasses should reimplement this method and attach the child
       * widget nodes to the parent widget's node.
       */
      init() {
        for (const widget of this) {
          widget.parent = this.parent;
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the specified layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onResize(msg) {
        for (const widget of this) {
          MessageLoop4.sendMessage(widget, Widget4.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the available layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onUpdateRequest(msg) {
        for (const widget of this) {
          MessageLoop4.sendMessage(widget, Widget4.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeAttach(msg) {
        for (const widget of this) {
          MessageLoop4.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterAttach(msg) {
        for (const widget of this) {
          MessageLoop4.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeDetach(msg) {
        for (const widget of this) {
          MessageLoop4.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterDetach(msg) {
        for (const widget of this) {
          MessageLoop4.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop4.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop4.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop4.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop4.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * This will remove the child widget from the layout.
       *
       * Subclasses should **not** typically reimplement this method.
       */
      onChildRemoved(msg) {
        this.removeWidget(msg.child);
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildShown(msg) {
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildHidden(msg) {
      }
    };
    (function(Layout5) {
      function getHorizontalAlignment(widget) {
        return Private$i3.horizontalAlignmentProperty.get(widget);
      }
      Layout5.getHorizontalAlignment = getHorizontalAlignment;
      function setHorizontalAlignment(widget, value) {
        Private$i3.horizontalAlignmentProperty.set(widget, value);
      }
      Layout5.setHorizontalAlignment = setHorizontalAlignment;
      function getVerticalAlignment(widget) {
        return Private$i3.verticalAlignmentProperty.get(widget);
      }
      Layout5.getVerticalAlignment = getVerticalAlignment;
      function setVerticalAlignment(widget, value) {
        Private$i3.verticalAlignmentProperty.set(widget, value);
      }
      Layout5.setVerticalAlignment = setVerticalAlignment;
    })(Layout3 || (Layout3 = {}));
    LayoutItem3 = class {
      /**
       * Construct a new layout item.
       *
       * @param widget - The widget to be managed by the item.
       *
       * #### Notes
       * The widget will be set to absolute positioning.
       * The widget will use strict CSS containment.
       */
      constructor(widget) {
        this._top = NaN;
        this._left = NaN;
        this._width = NaN;
        this._height = NaN;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = Infinity;
        this._maxHeight = Infinity;
        this._disposed = false;
        this.widget = widget;
        this.widget.node.style.position = "absolute";
        this.widget.node.style.contain = "strict";
      }
      /**
       * Dispose of the the layout item.
       *
       * #### Notes
       * This will reset the positioning of the widget.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        let style = this.widget.node.style;
        style.position = "";
        style.top = "";
        style.left = "";
        style.width = "";
        style.height = "";
        style.contain = "";
      }
      /**
       * The computed minimum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minWidth() {
        return this._minWidth;
      }
      /**
       * The computed minimum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minHeight() {
        return this._minHeight;
      }
      /**
       * The computed maximum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxWidth() {
        return this._maxWidth;
      }
      /**
       * The computed maximum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxHeight() {
        return this._maxHeight;
      }
      /**
       * Whether the layout item is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Whether the managed widget is hidden.
       */
      get isHidden() {
        return this.widget.isHidden;
      }
      /**
       * Whether the managed widget is visible.
       */
      get isVisible() {
        return this.widget.isVisible;
      }
      /**
       * Whether the managed widget is attached.
       */
      get isAttached() {
        return this.widget.isAttached;
      }
      /**
       * Update the computed size limits of the managed widget.
       */
      fit() {
        let limits = ElementExt.sizeLimits(this.widget.node);
        this._minWidth = limits.minWidth;
        this._minHeight = limits.minHeight;
        this._maxWidth = limits.maxWidth;
        this._maxHeight = limits.maxHeight;
      }
      /**
       * Update the position and size of the managed widget.
       *
       * @param left - The left edge position of the layout box.
       *
       * @param top - The top edge position of the layout box.
       *
       * @param width - The width of the layout box.
       *
       * @param height - The height of the layout box.
       */
      update(left, top, width, height) {
        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
        if (clampW < width) {
          switch (Layout3.getHorizontalAlignment(this.widget)) {
            case "left":
              break;
            case "center":
              left += (width - clampW) / 2;
              break;
            case "right":
              left += width - clampW;
              break;
            default:
              throw "unreachable";
          }
        }
        if (clampH < height) {
          switch (Layout3.getVerticalAlignment(this.widget)) {
            case "top":
              break;
            case "center":
              top += (height - clampH) / 2;
              break;
            case "bottom":
              top += height - clampH;
              break;
            default:
              throw "unreachable";
          }
        }
        let resized = false;
        let style = this.widget.node.style;
        if (this._top !== top) {
          this._top = top;
          style.top = `${top}px`;
        }
        if (this._left !== left) {
          this._left = left;
          style.left = `${left}px`;
        }
        if (this._width !== clampW) {
          resized = true;
          this._width = clampW;
          style.width = `${clampW}px`;
        }
        if (this._height !== clampH) {
          resized = true;
          this._height = clampH;
          style.height = `${clampH}px`;
        }
        if (resized) {
          let msg = new Widget4.ResizeMessage(clampW, clampH);
          MessageLoop4.sendMessage(this.widget, msg);
        }
      }
    };
    (function(Private22) {
      Private22.horizontalAlignmentProperty = new AttachedProperty({
        name: "horizontalAlignment",
        create: () => "center",
        changed: onAlignmentChanged
      });
      Private22.verticalAlignmentProperty = new AttachedProperty({
        name: "verticalAlignment",
        create: () => "top",
        changed: onAlignmentChanged
      });
      function onAlignmentChanged(child) {
        if (child.parent && child.parent.layout) {
          child.parent.update();
        }
      }
    })(Private$i3 || (Private$i3 = {}));
    PanelLayout4 = class extends Layout3 {
      constructor() {
        super(...arguments);
        this._widgets = [];
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        while (this._widgets.length > 0) {
          this._widgets.pop().dispose();
        }
        super.dispose();
      }
      /**
       * A read-only array of the widgets in the layout.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        yield* this._widgets;
      }
      /**
       * Add a widget to the end of the layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, it will be moved.
       */
      addWidget(widget) {
        this.insertWidget(this._widgets.length, widget);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        widget.parent = this.parent;
        let i6 = this._widgets.indexOf(widget);
        let j2 = Math.max(0, Math.min(index2, this._widgets.length));
        if (i6 === -1) {
          ArrayExt.insert(this._widgets, j2, widget);
          if (this.parent) {
            this.attachWidget(j2, widget);
          }
          return;
        }
        if (j2 === this._widgets.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._widgets, i6, j2);
        if (this.parent) {
          this.moveWidget(i6, j2, widget);
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this.removeWidgetAt(this._widgets.indexOf(widget));
      }
      /**
       * Remove the widget at a given index from the layout.
       *
       * @param index - The index of the widget to remove.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      removeWidgetAt(index2) {
        let widget = ArrayExt.removeAt(this._widgets, index2);
        if (widget && this.parent) {
          this.detachWidget(index2, widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        let index2 = 0;
        for (const widget of this) {
          this.attachWidget(index2++, widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index2, widget) {
        let ref = this.parent.node.children[index2];
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
        let ref = this.parent.node.children[toIndex];
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index2, widget) {
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
      }
    };
    (function(Utils5) {
      function clampDimension(value) {
        return Math.max(0, Math.floor(value));
      }
      Utils5.clampDimension = clampDimension;
    })(Utils3 || (Utils3 = {}));
    Utils$13 = Utils3;
    SplitLayout3 = class extends PanelLayout4 {
      /**
       * Construct a new split layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this.widgetOffset = 0;
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._hasNormedSizes = false;
        this._sizers = [];
        this._items = [];
        this._handles = [];
        this._box = null;
        this._alignment = "start";
        this._orientation = "horizontal";
        this.renderer = options.renderer;
        if (options.orientation !== void 0) {
          this._orientation = options.orientation;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils3.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        this._handles.length = 0;
        super.dispose();
      }
      /**
       * Get the layout orientation for the split layout.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the layout orientation for the split layout.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._orientation = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["orientation"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the split layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the split layout.
       */
      set spacing(value) {
        value = Utils3.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the split handles in the layout.
       */
      get handles() {
        return this._handles;
      }
      /**
       * Get the absolute sizes of the widgets in the layout.
       *
       * @returns A new array of the absolute sizes of the widgets.
       *
       * This method **does not** measure the DOM nodes.
       */
      absoluteSizes() {
        return this._sizers.map((sizer) => sizer.size);
      }
      /**
       * Get the relative sizes of the widgets in the layout.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return Private$h3.normalize(this._sizers.map((sizer) => sizer.size));
      }
      /**
       * Set the relative sizes for the widgets in the layout.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        let n5 = this._sizers.length;
        let temp = sizes.slice(0, n5);
        while (temp.length < n5) {
          temp.push(0);
        }
        let normed = Private$h3.normalize(temp);
        for (let i6 = 0; i6 < n5; ++i6) {
          let sizer = this._sizers[i6];
          sizer.sizeHint = normed[i6];
          sizer.size = normed[i6];
        }
        this._hasNormedSizes = true;
        if (update && this.parent) {
          this.parent.update();
        }
      }
      /**
       * Move the offset position of a split handle.
       *
       * @param index - The index of the handle of the interest.
       *
       * @param position - The desired offset position of the handle.
       *
       * #### Notes
       * The position is relative to the offset parent.
       *
       * This will move the handle as close as possible to the desired
       * position. The sibling widgets will be adjusted as necessary.
       */
      moveHandle(index2, position) {
        let handle = this._handles[index2];
        if (!handle || handle.classList.contains("lm-mod-hidden")) {
          return;
        }
        let delta;
        if (this._orientation === "horizontal") {
          delta = position - handle.offsetLeft;
        } else {
          delta = position - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        for (let sizer of this._sizers) {
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
        }
        BoxEngine3.adjust(this._sizers, index2, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["orientation"] = this.orientation;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        let item = new LayoutItem3(widget);
        let handle = Private$h3.createHandle(this.renderer);
        let average = Private$h3.averageSize(this._sizers);
        let sizer = Private$h3.createSizer(average);
        ArrayExt.insert(this._items, index2, item);
        ArrayExt.insert(this._sizers, index2, sizer);
        ArrayExt.insert(this._handles, index2, handle);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        ArrayExt.move(this._handles, fromIndex, toIndex);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        let handle = ArrayExt.removeAt(this._handles, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        this.parent.node.removeChild(handle);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const item = this._items[i6];
        if (item.isHidden) {
          return;
        }
        let handleStyle = this._handles[i6].style;
        if (isHorizontal) {
          left += this.widgetOffset;
          item.update(left, top, size5, height);
          left += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${this._spacing}px`;
          handleStyle.height = `${height}px`;
        } else {
          top += this.widgetOffset;
          item.update(left, top, width, size5);
          top += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${this._spacing}px`;
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        let lastHandleIndex = -1;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          if (this._items[i6].isHidden) {
            this._handles[i6].classList.add("lm-mod-hidden");
          } else {
            this._handles[i6].classList.remove("lm-mod-hidden");
            lastHandleIndex = i6;
            nVisible++;
          }
        }
        if (lastHandleIndex !== -1) {
          this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
        let horz = this._orientation === "horizontal";
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.stretch = SplitLayout3.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop4.sendMessage(this.parent.parent, Widget4.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop4.sendMessage(this.parent, Widget4.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0 && this.widgetOffset === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let extra = 0;
        let offset4 = 0;
        let horz = this._orientation === "horizontal";
        if (nVisible > 0) {
          let space;
          if (horz) {
            space = Math.max(0, width - this._fixed);
          } else {
            space = Math.max(0, height - this._fixed);
          }
          if (this._hasNormedSizes) {
            for (let sizer of this._sizers) {
              sizer.sizeHint *= space;
            }
            this._hasNormedSizes = false;
          }
          let delta = BoxEngine3.calc(this._sizers, space);
          if (delta > 0) {
            switch (this._alignment) {
              case "start":
                break;
              case "center":
                extra = 0;
                offset4 = delta / 2;
                break;
              case "end":
                extra = 0;
                offset4 = delta;
                break;
              case "justify":
                extra = delta / nVisible;
                offset4 = 0;
                break;
              default:
                throw "unreachable";
            }
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          const item = this._items[i6];
          const size5 = item.isHidden ? 0 : this._sizers[i6].size + extra;
          this.updateItemPosition(i6, horz, horz ? left + offset4 : left, horz ? top : top + offset4, height, width, size5);
          const fullOffset = this.widgetOffset + (this._handles[i6].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
          if (horz) {
            left += size5 + fullOffset;
          } else {
            top += size5 + fullOffset;
          }
        }
      }
    };
    (function(SplitLayout5) {
      function getStretch(widget) {
        return Private$h3.stretchProperty.get(widget);
      }
      SplitLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$h3.stretchProperty.set(widget, value);
      }
      SplitLayout5.setStretch = setStretch;
    })(SplitLayout3 || (SplitLayout3 = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function createSizer(size5) {
        let sizer = new BoxSizer3();
        sizer.sizeHint = Math.floor(size5);
        return sizer;
      }
      Private22.createSizer = createSizer;
      function createHandle(renderer) {
        let handle = renderer.createHandle();
        handle.style.position = "absolute";
        handle.style.contain = "style";
        return handle;
      }
      Private22.createHandle = createHandle;
      function averageSize(sizers) {
        return sizers.reduce((v4, s8) => v4 + s8.size, 0) / sizers.length || 0;
      }
      Private22.averageSize = averageSize;
      function normalize2(values2) {
        let n5 = values2.length;
        if (n5 === 0) {
          return [];
        }
        let sum = values2.reduce((a3, b2) => a3 + Math.abs(b2), 0);
        return sum === 0 ? values2.map((v4) => 1 / n5) : values2.map((v4) => v4 / sum);
      }
      Private22.normalize = normalize2;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof SplitLayout3) {
          child.parent.fit();
        }
      }
    })(Private$h3 || (Private$h3 = {}));
    AccordionLayout3 = class extends SplitLayout3 {
      /**
       * Construct a new accordion layout.
       *
       * @param options - The options for initializing the layout.
       *
       * #### Notes
       * The default orientation will be vertical.
       *
       * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
       */
      constructor(options) {
        super({ ...options, orientation: options.orientation || "vertical" });
        this._titles = [];
        this.titleSpace = options.titleSpace || 22;
      }
      /**
       * The section title height or width depending on the orientation.
       */
      get titleSpace() {
        return this.widgetOffset;
      }
      set titleSpace(value) {
        value = Utils$13.clampDimension(value);
        if (this.widgetOffset === value) {
          return;
        }
        this.widgetOffset = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this._titles;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._titles.length = 0;
        super.dispose();
      }
      updateTitle(index2, widget) {
        const oldTitle = this._titles[index2];
        const expanded = oldTitle.classList.contains("lm-mod-expanded");
        const newTitle = Private$g3.createTitle(this.renderer, widget.title, expanded);
        this._titles[index2] = newTitle;
        this.parent.node.replaceChild(newTitle, oldTitle);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        if (!widget.id) {
          widget.id = `id-${import_coreutils10.UUID.uuid4()}`;
        }
        super.insertWidget(index2, widget);
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(index2, widget) {
        const title = Private$g3.createTitle(this.renderer, widget.title);
        ArrayExt.insert(this._titles, index2, title);
        this.parent.node.appendChild(title);
        widget.node.setAttribute("role", "region");
        widget.node.setAttribute("aria-labelledby", title.id);
        super.attachWidget(index2, widget);
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._titles, fromIndex, toIndex);
        super.moveWidget(fromIndex, toIndex, widget);
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        const title = ArrayExt.removeAt(this._titles, index2);
        this.parent.node.removeChild(title);
        super.detachWidget(index2, widget);
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const titleStyle = this._titles[i6].style;
        titleStyle.top = `${top}px`;
        titleStyle.left = `${left}px`;
        titleStyle.height = `${this.widgetOffset}px`;
        if (isHorizontal) {
          titleStyle.width = `${height}px`;
        } else {
          titleStyle.width = `${width}px`;
        }
        super.updateItemPosition(i6, isHorizontal, left, top, height, width, size5);
      }
    };
    (function(Private22) {
      function createTitle(renderer, data, expanded = true) {
        const title = renderer.createSectionTitle(data);
        title.style.position = "absolute";
        title.style.contain = "strict";
        title.setAttribute("aria-label", `${data.label} Section`);
        title.setAttribute("aria-expanded", expanded ? "true" : "false");
        title.setAttribute("aria-controls", data.owner.id);
        if (expanded) {
          title.classList.add("lm-mod-expanded");
        }
        return title;
      }
      Private22.createTitle = createTitle;
    })(Private$g3 || (Private$g3 = {}));
    Panel4 = class extends Widget4 {
      /**
       * Construct a new panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this.addClass("lm-Panel");
        this.layout = Private$f3.createLayout(options);
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        this.layout.addWidget(widget);
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        this.layout.insertWidget(index2, widget);
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new PanelLayout4();
      }
      Private22.createLayout = createLayout;
    })(Private$f3 || (Private$f3 = {}));
    SplitPanel3 = class extends Panel4 {
      /**
       * Construct a new split panel.
       *
       * @param options - The options for initializing the split panel.
       */
      constructor(options = {}) {
        super({ layout: Private$e3.createLayout(options) });
        this._handleMoved = new Signal(this);
        this._pressData = null;
        this.addClass("lm-SplitPanel");
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        super.dispose();
      }
      /**
       * Get the layout orientation for the split panel.
       */
      get orientation() {
        return this.layout.orientation;
      }
      /**
       * Set the layout orientation for the split panel.
       */
      set orientation(value) {
        this.layout.orientation = value;
      }
      /**
       * Get the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the split panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the split panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * The renderer used by the split panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * A signal emitted when a split handle has moved.
       */
      get handleMoved() {
        return this._handleMoved;
      }
      /**
       * A read-only array of the split handles in the panel.
       */
      get handles() {
        return this.layout.handles;
      }
      /**
       * Get the relative sizes of the widgets in the panel.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return this.layout.relativeSizes();
      }
      /**
       * Set the relative sizes for the widgets in the panel.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        this.layout.setRelativeSizes(sizes, update);
      }
      /**
       * Handle the DOM events for the split panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * Handle the `'keydown'` event for the split panel.
       */
      _evtKeyDown(event) {
        if (this._pressData) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (event.keyCode === 27) {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'pointerdown'` event for the split panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let index2 = ArrayExt.findFirstIndex(layout.handles, (handle2) => {
          return handle2.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("contextmenu", this, true);
        let delta;
        let handle = layout.handles[index2];
        let rect = handle.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          delta = event.clientX - rect.left;
        } else {
          delta = event.clientY - rect.top;
        }
        let style = window.getComputedStyle(handle);
        let override = Drag3.overrideCursor(style.cursor);
        this._pressData = { index: index2, delta, override };
      }
      /**
       * Handle the `'pointermove'` event for the split panel.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        let pos;
        let layout = this.layout;
        let rect = this.node.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          pos = event.clientX - rect.left - this._pressData.delta;
        } else {
          pos = event.clientY - rect.top - this._pressData.delta;
        }
        layout.moveHandle(this._pressData.index, pos);
      }
      /**
       * Handle the `'pointerup'` event for the split panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
      }
      /**
       * Release the mouse grab for the split panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._handleMoved.emit();
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
    };
    (function(SplitPanel5) {
      class Renderer {
        /**
         * Create a new handle for use with a split panel.
         *
         * @returns A new handle element for a split panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-SplitPanel-handle";
          return handle;
        }
      }
      SplitPanel5.Renderer = Renderer;
      SplitPanel5.defaultRenderer = new Renderer();
      function getStretch(widget) {
        return SplitLayout3.getStretch(widget);
      }
      SplitPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        SplitLayout3.setStretch(widget, value);
      }
      SplitPanel5.setStretch = setStretch;
    })(SplitPanel3 || (SplitPanel3 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new SplitLayout3({
          renderer: options.renderer || SplitPanel3.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing
        });
      }
      Private22.createLayout = createLayout;
    })(Private$e3 || (Private$e3 = {}));
    AccordionPanel3 = class extends SplitPanel3 {
      /**
       * Construct a new accordion panel.
       *
       * @param options - The options for initializing the accordion panel.
       *
       */
      constructor(options = {}) {
        super({ ...options, layout: Private$d3.createLayout(options) });
        this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
        this._expansionToggled = new Signal(this);
        this.addClass("lm-AccordionPanel");
      }
      /**
       * The renderer used by the accordion panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * The section title space.
       *
       * This is the height if the panel is vertical and the width if it is
       * horizontal.
       */
      get titleSpace() {
        return this.layout.titleSpace;
      }
      set titleSpace(value) {
        this.layout.titleSpace = value;
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this.layout.titles;
      }
      /**
       * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
       */
      get expansionToggled() {
        return this._expansionToggled;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        super.addWidget(widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Collapse the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      collapse(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && !widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Expand the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      expand(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        super.insertWidget(index2, widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Handle the DOM events for the accordion panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        super.handleEvent(event);
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._eventKeyDown(event);
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        super.onBeforeAttach(msg);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        super.onAfterDetach(msg);
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        const index2 = ArrayExt.findFirstIndex(this.widgets, (widget) => {
          return widget.contains(sender.owner);
        });
        if (index2 >= 0) {
          this.layout.updateTitle(index2, sender.owner);
          this.update();
        }
      }
      /**
       * Compute the size of widgets in this panel on the title click event.
       * On closing, the size of the widget is cached and we will try to expand
       * the last opened widget.
       * On opening, we will use the cached size if it is available to restore the
       * widget.
       * In both cases, if we can not compute the size of widgets, we will let
       * `SplitLayout` decide.
       *
       * @param index - The index of widget to be opened of closed
       *
       * @returns Relative size of widgets in this panel, if this size can
       * not be computed, return `undefined`
       */
      _computeWidgetSize(index2) {
        const layout = this.layout;
        const widget = layout.widgets[index2];
        if (!widget) {
          return void 0;
        }
        const isHidden2 = widget.isHidden;
        const widgetSizes = layout.absoluteSizes();
        const delta = (isHidden2 ? -1 : 1) * this.spacing;
        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
        let newSize = [...widgetSizes];
        if (!isHidden2) {
          const currentSize = widgetSizes[index2];
          this._widgetSizesCache.set(widget, currentSize);
          newSize[index2] = 0;
          const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            return void 0;
          }
          newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
        } else {
          const previousSize = this._widgetSizesCache.get(widget);
          if (!previousSize) {
            return void 0;
          }
          newSize[index2] += previousSize;
          const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            newSize.forEach((_4, idx) => {
              if (idx !== index2) {
                newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
              }
            });
          } else {
            newSize[widgetToCollapse] -= previousSize - delta;
          }
        }
        return newSize.map((sz) => sz / (totalSize + delta));
      }
      /**
       * Handle the `'click'` event for the accordion panel
       */
      _evtClick(event) {
        const target = event.target;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            event.preventDefault();
            event.stopPropagation();
            this._toggleExpansion(index2);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the accordion panel.
       */
      _eventKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const target = event.target;
        let handled = false;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            const keyCode = event.keyCode.toString();
            if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
              target.click();
              handled = true;
            } else if (this.orientation === "horizontal" ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
              const direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
              const length = this.titles.length;
              const newIndex = (index2 + length + direction) % length;
              this.titles[newIndex].focus();
              handled = true;
            } else if (event.key === "End" || keyCode === "35") {
              this.titles[this.titles.length - 1].focus();
              handled = true;
            } else if (event.key === "Home" || keyCode === "36") {
              this.titles[0].focus();
              handled = true;
            }
          }
          if (handled) {
            event.preventDefault();
          }
        }
      }
      _toggleExpansion(index2) {
        const title = this.titles[index2];
        const widget = this.layout.widgets[index2];
        const newSize = this._computeWidgetSize(index2);
        if (newSize) {
          this.setRelativeSizes(newSize, false);
        }
        if (widget.isHidden) {
          title.classList.add("lm-mod-expanded");
          title.setAttribute("aria-expanded", "true");
          widget.show();
        } else {
          title.classList.remove("lm-mod-expanded");
          title.setAttribute("aria-expanded", "false");
          widget.hide();
        }
        this._expansionToggled.emit(index2);
      }
    };
    (function(AccordionPanel5) {
      class Renderer extends SplitPanel3.Renderer {
        constructor() {
          super();
          this.titleClassName = "lm-AccordionPanel-title";
          this._titleID = 0;
          this._titleKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the collapse indicator for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the collapse indicator.
         */
        createCollapseIcon(data) {
          return document.createElement("span");
        }
        /**
         * Render the element for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the section title.
         */
        createSectionTitle(data) {
          const handle = document.createElement("h3");
          handle.setAttribute("tabindex", "0");
          handle.id = this.createTitleKey(data);
          handle.className = this.titleClassName;
          for (const aData in data.dataset) {
            handle.dataset[aData] = data.dataset[aData];
          }
          const collapser = handle.appendChild(this.createCollapseIcon(data));
          collapser.className = "lm-AccordionPanel-titleCollapser";
          const label = handle.appendChild(document.createElement("span"));
          label.className = "lm-AccordionPanel-titleLabel";
          label.textContent = data.label;
          label.title = data.caption || data.label;
          return handle;
        }
        /**
         * Create a unique render key for the title.
         *
         * @param data - The data to use for the title.
         *
         * @returns The unique render key for the title.
         *
         * #### Notes
         * This method caches the key against the section title the first time
         * the key is generated.
         */
        createTitleKey(data) {
          let key = this._titleKeys.get(data);
          if (key === void 0) {
            key = `title-key-${this._uuid}-${this._titleID++}`;
            this._titleKeys.set(data, key);
          }
          return key;
        }
      }
      Renderer._nInstance = 0;
      AccordionPanel5.Renderer = Renderer;
      AccordionPanel5.defaultRenderer = new Renderer();
    })(AccordionPanel3 || (AccordionPanel3 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new AccordionLayout3({
          renderer: options.renderer || AccordionPanel3.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing,
          titleSpace: options.titleSpace
        });
      }
      Private22.createLayout = createLayout;
    })(Private$d3 || (Private$d3 = {}));
    BoxLayout3 = class extends PanelLayout4 {
      /**
       * Construct a new box layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super();
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._sizers = [];
        this._items = [];
        this._box = null;
        this._alignment = "start";
        this._direction = "top-to-bottom";
        if (options.direction !== void 0) {
          this._direction = options.direction;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils$13.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        super.dispose();
      }
      /**
       * Get the layout direction for the box layout.
       */
      get direction() {
        return this._direction;
      }
      /**
       * Set the layout direction for the box layout.
       */
      set direction(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["direction"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the box layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the box layout.
       */
      set spacing(value) {
        value = Utils$13.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["direction"] = this.direction;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        ArrayExt.insert(this._items, index2, new LayoutItem3(widget));
        ArrayExt.insert(this._sizers, index2, new BoxSizer3());
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        let horz = Private$c3.isHorizontal(this._direction);
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.sizeHint = BoxLayout3.getSizeBasis(item.widget);
          sizer.stretch = BoxLayout3.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop4.sendMessage(this.parent.parent, Widget4.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop4.sendMessage(this.parent, Widget4.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let delta;
        switch (this._direction) {
          case "left-to-right":
            delta = BoxEngine3.calc(this._sizers, Math.max(0, width - this._fixed));
            break;
          case "top-to-bottom":
            delta = BoxEngine3.calc(this._sizers, Math.max(0, height - this._fixed));
            break;
          case "right-to-left":
            delta = BoxEngine3.calc(this._sizers, Math.max(0, width - this._fixed));
            left += width;
            break;
          case "bottom-to-top":
            delta = BoxEngine3.calc(this._sizers, Math.max(0, height - this._fixed));
            top += height;
            break;
          default:
            throw "unreachable";
        }
        let extra = 0;
        let offset4 = 0;
        if (delta > 0) {
          switch (this._alignment) {
            case "start":
              break;
            case "center":
              extra = 0;
              offset4 = delta / 2;
              break;
            case "end":
              extra = 0;
              offset4 = delta;
              break;
            case "justify":
              extra = delta / nVisible;
              offset4 = 0;
              break;
            default:
              throw "unreachable";
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let size5 = this._sizers[i6].size;
          switch (this._direction) {
            case "left-to-right":
              item.update(left + offset4, top, size5 + extra, height);
              left += size5 + extra + this._spacing;
              break;
            case "top-to-bottom":
              item.update(left, top + offset4, width, size5 + extra);
              top += size5 + extra + this._spacing;
              break;
            case "right-to-left":
              item.update(left - offset4 - size5 - extra, top, size5 + extra, height);
              left -= size5 + extra + this._spacing;
              break;
            case "bottom-to-top":
              item.update(left, top - offset4 - size5 - extra, width, size5 + extra);
              top -= size5 + extra + this._spacing;
              break;
            default:
              throw "unreachable";
          }
        }
      }
    };
    (function(BoxLayout5) {
      function getStretch(widget) {
        return Private$c3.stretchProperty.get(widget);
      }
      BoxLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$c3.stretchProperty.set(widget, value);
      }
      BoxLayout5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return Private$c3.sizeBasisProperty.get(widget);
      }
      BoxLayout5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        Private$c3.sizeBasisProperty.set(widget, value);
      }
      BoxLayout5.setSizeBasis = setSizeBasis;
    })(BoxLayout3 || (BoxLayout3 = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      Private22.sizeBasisProperty = new AttachedProperty({
        name: "sizeBasis",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function isHorizontal(dir) {
        return dir === "left-to-right" || dir === "right-to-left";
      }
      Private22.isHorizontal = isHorizontal;
      function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampSpacing = clampSpacing;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof BoxLayout3) {
          child.parent.fit();
        }
      }
    })(Private$c3 || (Private$c3 = {}));
    BoxPanel3 = class extends Panel4 {
      /**
       * Construct a new box panel.
       *
       * @param options - The options for initializing the box panel.
       */
      constructor(options = {}) {
        super({ layout: Private$b3.createLayout(options) });
        this.addClass("lm-BoxPanel");
      }
      /**
       * Get the layout direction for the box panel.
       */
      get direction() {
        return this.layout.direction;
      }
      /**
       * Set the layout direction for the box panel.
       */
      set direction(value) {
        this.layout.direction = value;
      }
      /**
       * Get the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the box panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the box panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-BoxPanel-child");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-BoxPanel-child");
      }
    };
    (function(BoxPanel5) {
      function getStretch(widget) {
        return BoxLayout3.getStretch(widget);
      }
      BoxPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        BoxLayout3.setStretch(widget, value);
      }
      BoxPanel5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return BoxLayout3.getSizeBasis(widget);
      }
      BoxPanel5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        BoxLayout3.setSizeBasis(widget, value);
      }
      BoxPanel5.setSizeBasis = setSizeBasis;
    })(BoxPanel3 || (BoxPanel3 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new BoxLayout3(options);
      }
      Private22.createLayout = createLayout;
    })(Private$b3 || (Private$b3 = {}));
    CommandPalette3 = class extends Widget4 {
      /**
       * Construct a new command palette.
       *
       * @param options - The options for initializing the palette.
       */
      constructor(options) {
        super({ node: Private$a3.createNode() });
        this._activeIndex = -1;
        this._items = [];
        this._results = null;
        this.addClass("lm-CommandPalette");
        this.setFlag(Widget4.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || CommandPalette3.defaultRenderer;
        this.commands.commandChanged.connect(this._onGenericChange, this);
        this.commands.keyBindingChanged.connect(this._onGenericChange, this);
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._items.length = 0;
        this._results = null;
        super.dispose();
      }
      /**
       * The command palette search node.
       *
       * #### Notes
       * This is the node which contains the search-related elements.
       */
      get searchNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
      }
      /**
       * The command palette input node.
       *
       * #### Notes
       * This is the actual input node for the search area.
       */
      get inputNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
      }
      /**
       * The command palette content node.
       *
       * #### Notes
       * This is the node which holds the command item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
      }
      /**
       * A read-only array of the command items in the palette.
       */
      get items() {
        return this._items;
      }
      /**
       * Add a command item to the command palette.
       *
       * @param options - The options for creating the command item.
       *
       * @returns The command item added to the palette.
       */
      addItem(options) {
        let item = Private$a3.createItem(this.commands, options);
        this._items.push(item);
        this.refresh();
        return item;
      }
      /**
       * Adds command items to the command palette.
       *
       * @param items - An array of options for creating each command item.
       *
       * @returns The command items added to the palette.
       */
      addItems(items) {
        const newItems = items.map((item) => Private$a3.createItem(this.commands, item));
        newItems.forEach((item) => this._items.push(item));
        this.refresh();
        return newItems;
      }
      /**
       * Remove an item from the command palette.
       *
       * @param item - The item to remove from the palette.
       *
       * #### Notes
       * This is a no-op if the item is not in the palette.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the command palette.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.refresh();
      }
      /**
       * Remove all items from the command palette.
       */
      clearItems() {
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.refresh();
      }
      /**
       * Clear the search results and schedule an update.
       *
       * #### Notes
       * This should be called whenever the search results of the palette
       * should be updated.
       *
       * This is typically called automatically by the palette as needed,
       * but can be called manually if the input text is programatically
       * changed.
       *
       * The rendered results are updated asynchronously.
       */
      refresh() {
        this._results = null;
        if (this.inputNode.value !== "") {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "inherit";
        } else {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "none";
        }
        this.update();
      }
      /**
       * Handle the DOM events for the command palette.
       *
       * @param event - The DOM event sent to the command palette.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the command palette's DOM node.
       * It should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "input":
            this.refresh();
            break;
          case "focus":
          case "blur":
            this._toggleFocused();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("input", this);
        this.node.addEventListener("focus", this, true);
        this.node.addEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("input", this);
        this.node.removeEventListener("focus", this, true);
        this.node.removeEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       */
      onAfterShow(msg) {
        this.update();
        super.onAfterShow(msg);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          let input = this.inputNode;
          input.focus();
          input.select();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (!this.isVisible) {
          VirtualDOM.render(null, this.contentNode);
          return;
        }
        let query = this.inputNode.value;
        let contentNode = this.contentNode;
        let results = this._results;
        if (!results) {
          results = this._results = Private$a3.search(this._items, query);
          this._activeIndex = query ? ArrayExt.findFirstIndex(results, Private$a3.canActivate) : -1;
        }
        if (!query && results.length === 0) {
          VirtualDOM.render(null, contentNode);
          return;
        }
        if (query && results.length === 0) {
          let content2 = this.renderer.renderEmptyMessage({ query });
          VirtualDOM.render(content2, contentNode);
          return;
        }
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let content = new Array(results.length);
        for (let i6 = 0, n5 = results.length; i6 < n5; ++i6) {
          let result2 = results[i6];
          if (result2.type === "header") {
            let indices = result2.indices;
            let category = result2.category;
            content[i6] = renderer.renderHeader({ category, indices });
          } else {
            let item = result2.item;
            let indices = result2.indices;
            let active = i6 === activeIndex;
            content[i6] = renderer.renderItem({ item, indices, active });
          }
        }
        VirtualDOM.render(content, contentNode);
        if (activeIndex < 0 || activeIndex >= results.length) {
          contentNode.scrollTop = 0;
        } else {
          let element2 = contentNode.children[activeIndex];
          ElementExt.scrollIntoViewIfNeeded(contentNode, element2);
        }
      }
      /**
       * Handle the `'click'` event for the command palette.
       */
      _evtClick(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.target.classList.contains("lm-close-icon")) {
          this.inputNode.value = "";
          this.refresh();
          return;
        }
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return node.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._execute(index2);
      }
      /**
       * Handle the `'keydown'` event for the command palette.
       */
      _evtKeyDown(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        switch (event.keyCode) {
          case 13:
            event.preventDefault();
            event.stopPropagation();
            this._execute(this._activeIndex);
            break;
          case 38:
            event.preventDefault();
            event.stopPropagation();
            this._activatePreviousItem();
            break;
          case 40:
            event.preventDefault();
            event.stopPropagation();
            this._activateNextItem();
            break;
        }
      }
      /**
       * Activate the next enabled command item.
       */
      _activateNextItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this._activeIndex = ArrayExt.findFirstIndex(this._results, Private$a3.canActivate, start, stop);
        this.update();
      }
      /**
       * Activate the previous enabled command item.
       */
      _activatePreviousItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this._activeIndex = ArrayExt.findLastIndex(this._results, Private$a3.canActivate, start, stop);
        this.update();
      }
      /**
       * Execute the command item at the given index, if possible.
       */
      _execute(index2) {
        if (!this._results) {
          return;
        }
        let part = this._results[index2];
        if (!part) {
          return;
        }
        if (part.type === "header") {
          let input = this.inputNode;
          input.value = `${part.category.toLowerCase()} `;
          input.focus();
          this.refresh();
          return;
        }
        if (!part.item.isEnabled) {
          return;
        }
        this.commands.execute(part.item.command, part.item.args);
        this.inputNode.value = "";
        this.refresh();
      }
      /**
       * Toggle the focused modifier based on the input node focus state.
       */
      _toggleFocused() {
        let focused = document.activeElement === this.inputNode;
        this.toggleClass("lm-mod-focused", focused);
      }
      /**
       * A signal handler for generic command changes.
       */
      _onGenericChange() {
        this.refresh();
      }
    };
    (function(CommandPalette5) {
      class Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          let content = this.formatHeader(data);
          return h.li({ className: "lm-CommandPalette-header" }, content);
        }
        /**
         * Render the virtual element for a command palette item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          if (data.item.isToggleable) {
            return h.li({
              className,
              dataset,
              role: "menuitemcheckbox",
              "aria-checked": `${data.item.isToggled}`
            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
          }
          return h.li({
            className,
            dataset,
            role: "menuitem"
          }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
        }
        /**
         * Render the empty results message for a command palette.
         *
         * @param data - The data to use for rendering the message.
         *
         * @returns A virtual element representing the message.
         */
        renderEmptyMessage(data) {
          let content = this.formatEmptyMessage(data);
          return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the content for a command palette item.
         *
         * @param data - The data to use for rendering the content.
         *
         * @returns A virtual element representing the content.
         */
        renderItemContent(data) {
          return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
        }
        /**
         * Render the label for a command palette item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the label.
         */
        renderItemLabel(data) {
          let content = this.formatItemLabel(data);
          return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
        }
        /**
         * Render the caption for a command palette item.
         *
         * @param data - The data to use for rendering the caption.
         *
         * @returns A virtual element representing the caption.
         */
        renderItemCaption(data) {
          let content = this.formatItemCaption(data);
          return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
        }
        /**
         * Render the shortcut for a command palette item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the shortcut.
         */
        renderItemShortcut(data) {
          let content = this.formatItemShortcut(data);
          return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
        }
        /**
         * Create the class name for the command palette item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the command palette item.
         */
        createItemClass(data) {
          let name = "lm-CommandPalette-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the command palette item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the command palette item.
         */
        createItemDataset(data) {
          return { ...data.item.dataset, command: data.item.command };
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-CommandPalette-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the header node.
         *
         * @param data - The data to use for the header content.
         *
         * @returns The content to add to the header node.
         */
        formatHeader(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.category;
          }
          return StringExt.highlight(data.category, data.indices, h.mark);
        }
        /**
         * Create the render content for the empty message node.
         *
         * @param data - The data to use for the empty message content.
         *
         * @returns The content to add to the empty message node.
         */
        formatEmptyMessage(data) {
          return `No commands found that match '${data.query}'`;
        }
        /**
         * Create the render content for the item shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatItemShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
        /**
         * Create the render content for the item label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatItemLabel(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.item.label;
          }
          return StringExt.highlight(data.item.label, data.indices, h.mark);
        }
        /**
         * Create the render content for the item caption node.
         *
         * @param data - The data to use for the caption content.
         *
         * @returns The content to add to the caption node.
         */
        formatItemCaption(data) {
          return data.item.caption;
        }
      }
      CommandPalette5.Renderer = Renderer;
      CommandPalette5.defaultRenderer = new Renderer();
    })(CommandPalette3 || (CommandPalette3 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let search2 = document.createElement("div");
        let wrapper = document.createElement("div");
        let input = document.createElement("input");
        let content = document.createElement("ul");
        let clear = document.createElement("button");
        search2.className = "lm-CommandPalette-search";
        wrapper.className = "lm-CommandPalette-wrapper";
        input.className = "lm-CommandPalette-input";
        clear.className = "lm-close-icon";
        content.className = "lm-CommandPalette-content";
        content.setAttribute("role", "menu");
        input.spellcheck = false;
        wrapper.appendChild(input);
        wrapper.appendChild(clear);
        search2.appendChild(wrapper);
        node.appendChild(search2);
        node.appendChild(content);
        return node;
      }
      Private22.createNode = createNode;
      function createItem(commands, options) {
        return new CommandItem(commands, options);
      }
      Private22.createItem = createItem;
      function search(items, query) {
        let scores = matchItems(items, query);
        scores.sort(scoreCmp);
        return createResults(scores);
      }
      Private22.search = search;
      function canActivate(result2) {
        return result2.type === "item" && result2.item.isEnabled;
      }
      Private22.canActivate = canActivate;
      function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, " ");
      }
      function normalizeQuery(text) {
        return text.replace(/\s+/g, "").toLowerCase();
      }
      function matchItems(items, query) {
        query = normalizeQuery(query);
        let scores = [];
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          if (!item.isVisible) {
            continue;
          }
          if (!query) {
            scores.push({
              matchType: 3,
              categoryIndices: null,
              labelIndices: null,
              score: 0,
              item
            });
            continue;
          }
          let score = fuzzySearch(item, query);
          if (!score) {
            continue;
          }
          if (!item.isEnabled) {
            score.score += 1e3;
          }
          scores.push(score);
        }
        return scores;
      }
      function fuzzySearch(item, query) {
        let category = item.category.toLowerCase();
        let label = item.label.toLowerCase();
        let source = `${category} ${label}`;
        let score = Infinity;
        let indices = null;
        let rgx = /\b\w/g;
        while (true) {
          let rgxMatch = rgx.exec(source);
          if (!rgxMatch) {
            break;
          }
          let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);
          if (!match) {
            break;
          }
          if (match.score <= score) {
            score = match.score;
            indices = match.indices;
          }
        }
        if (!indices || score === Infinity) {
          return null;
        }
        let pivot = category.length + 1;
        let j2 = ArrayExt.lowerBound(indices, pivot, (a3, b2) => a3 - b2);
        let categoryIndices = indices.slice(0, j2);
        let labelIndices = indices.slice(j2);
        for (let i6 = 0, n5 = labelIndices.length; i6 < n5; ++i6) {
          labelIndices[i6] -= pivot;
        }
        if (categoryIndices.length === 0) {
          return {
            matchType: 0,
            categoryIndices: null,
            labelIndices,
            score,
            item
          };
        }
        if (labelIndices.length === 0) {
          return {
            matchType: 1,
            categoryIndices,
            labelIndices: null,
            score,
            item
          };
        }
        return {
          matchType: 2,
          categoryIndices,
          labelIndices,
          score,
          item
        };
      }
      function scoreCmp(a3, b2) {
        let m1 = a3.matchType - b2.matchType;
        if (m1 !== 0) {
          return m1;
        }
        let d1 = a3.score - b2.score;
        if (d1 !== 0) {
          return d1;
        }
        let i1 = 0;
        let i22 = 0;
        switch (a3.matchType) {
          case 0:
            i1 = a3.labelIndices[0];
            i22 = b2.labelIndices[0];
            break;
          case 1:
          case 2:
            i1 = a3.categoryIndices[0];
            i22 = b2.categoryIndices[0];
            break;
        }
        if (i1 !== i22) {
          return i1 - i22;
        }
        let d22 = a3.item.category.localeCompare(b2.item.category);
        if (d22 !== 0) {
          return d22;
        }
        let r1 = a3.item.rank;
        let r22 = b2.item.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.item.label.localeCompare(b2.item.label);
      }
      function createResults(scores) {
        let results = [];
        for (let i6 = 0, n5 = scores.length; i6 < n5; ++i6) {
          let { item, categoryIndices, labelIndices } = scores[i6];
          let category = item.category;
          if (i6 === 0 || category !== scores[i6 - 1].item.category) {
            results.push({ type: "header", category, indices: categoryIndices });
          }
          results.push({ type: "item", item, indices: labelIndices });
        }
        return results;
      }
      class CommandItem {
        /**
         * Construct a new command item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.category = normalizeCategory(options.category);
          this.command = options.command;
          this.args = options.args || import_coreutils10.JSONExt.emptyObject;
          this.rank = options.rank !== void 0 ? options.rank : Infinity;
        }
        /**
         * The display label for the command item.
         */
        get label() {
          return this._commands.label(this.command, this.args);
        }
        /**
         * The icon renderer for the command item.
         */
        get icon() {
          return this._commands.icon(this.command, this.args);
        }
        /**
         * The icon class for the command item.
         */
        get iconClass() {
          return this._commands.iconClass(this.command, this.args);
        }
        /**
         * The icon label for the command item.
         */
        get iconLabel() {
          return this._commands.iconLabel(this.command, this.args);
        }
        /**
         * The display caption for the command item.
         */
        get caption() {
          return this._commands.caption(this.command, this.args);
        }
        /**
         * The extra class name for the command item.
         */
        get className() {
          return this._commands.className(this.command, this.args);
        }
        /**
         * The dataset for the command item.
         */
        get dataset() {
          return this._commands.dataset(this.command, this.args);
        }
        /**
         * Whether the command item is enabled.
         */
        get isEnabled() {
          return this._commands.isEnabled(this.command, this.args);
        }
        /**
         * Whether the command item is toggled.
         */
        get isToggled() {
          return this._commands.isToggled(this.command, this.args);
        }
        /**
         * Whether the command item is toggleable.
         */
        get isToggleable() {
          return this._commands.isToggleable(this.command, this.args);
        }
        /**
         * Whether the command item is visible.
         */
        get isVisible() {
          return this._commands.isVisible(this.command, this.args);
        }
        /**
         * The key binding for the command item.
         */
        get keyBinding() {
          let { command, args } = this;
          return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
            return kb.command === command && import_coreutils10.JSONExt.deepEqual(kb.args, args);
          }) || null;
        }
      }
    })(Private$a3 || (Private$a3 = {}));
    Menu3 = class extends Widget4 {
      /**
       * Construct a new menu.
       *
       * @param options - The options for initializing the menu.
       */
      constructor(options) {
        super({ node: Private$93.createNode() });
        this._childIndex = -1;
        this._activeIndex = -1;
        this._openTimerID = 0;
        this._closeTimerID = 0;
        this._items = [];
        this._childMenu = null;
        this._parentMenu = null;
        this._aboutToClose = new Signal(this);
        this._menuRequested = new Signal(this);
        this.addClass("lm-Menu");
        this.setFlag(Widget4.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || Menu3.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the menu.
       */
      dispose() {
        this.close();
        this._items.length = 0;
        super.dispose();
      }
      /**
       * A signal emitted just before the menu is closed.
       *
       * #### Notes
       * This signal is emitted when the menu receives a `'close-request'`
       * message, just before it removes itself from the DOM.
       *
       * This signal is not emitted if the menu is already detached from
       * the DOM when it receives the `'close-request'` message.
       */
      get aboutToClose() {
        return this._aboutToClose;
      }
      /**
       * A signal emitted when a new menu is requested by the user.
       *
       * #### Notes
       * This signal is emitted whenever the user presses the right or left
       * arrow keys, and a submenu cannot be opened or closed in response.
       *
       * This signal is useful when implementing menu bars in order to open
       * the next or previous menu in response to a user key press.
       *
       * This signal is only emitted for the root menu in a hierarchy.
       */
      get menuRequested() {
        return this._menuRequested;
      }
      /**
       * The parent menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu is an open submenu.
       */
      get parentMenu() {
        return this._parentMenu;
      }
      /**
       * The child menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu has an open submenu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The root menu of the menu hierarchy.
       */
      get rootMenu() {
        let menu = this;
        while (menu._parentMenu) {
          menu = menu._parentMenu;
        }
        return menu;
      }
      /**
       * The leaf menu of the menu hierarchy.
       */
      get leafMenu() {
        let menu = this;
        while (menu._childMenu) {
          menu = menu._childMenu;
        }
        return menu;
      }
      /**
       * The menu content node.
       *
       * #### Notes
       * This is the node which holds the menu item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-Menu-content")[0];
      }
      /**
       * Get the currently active menu item.
       */
      get activeItem() {
        return this._items[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the item will be set to `null`.
       */
      set activeItem(value) {
        this.activeIndex = value ? this._items.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu item.
       *
       * #### Notes
       * This will be `-1` if no menu item is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._items.length) {
          value = -1;
        }
        if (value !== -1 && !Private$93.canActivate(this._items[value])) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
          this.contentNode.childNodes[this._activeIndex].focus();
        }
        this.update();
      }
      /**
       * A read-only array of the menu items in the menu.
       */
      get items() {
        return this._items;
      }
      /**
       * Activate the next selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activateNextItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this.activeIndex = ArrayExt.findFirstIndex(this._items, Private$93.canActivate, start, stop);
      }
      /**
       * Activate the previous selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activatePreviousItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this.activeIndex = ArrayExt.findLastIndex(this._items, Private$93.canActivate, start, stop);
      }
      /**
       * Trigger the active menu item.
       *
       * #### Notes
       * If the active item is a submenu, it will be opened and the first
       * item will be activated.
       *
       * If the active item is a command, the command will be executed.
       *
       * If the menu is not attached, this is a no-op.
       *
       * If there is no active item, this is a no-op.
       */
      triggerActiveItem() {
        if (!this.isAttached) {
          return;
        }
        let item = this.activeItem;
        if (!item) {
          return;
        }
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        if (item.type === "submenu") {
          this._openChildMenu(true);
          return;
        }
        this.rootMenu.close();
        let { command, args } = item;
        if (this.commands.isEnabled(command, args)) {
          this.commands.execute(command, args);
        } else {
          console.log(`Command '${command}' is disabled.`);
        }
      }
      /**
       * Add a menu item to the end of the menu.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       */
      addItem(options) {
        return this.insertItem(this._items.length, options);
      }
      /**
       * Insert a menu item into the menu at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index2, options) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let i6 = Math.max(0, Math.min(index2, this._items.length));
        let item = Private$93.createItem(this, options);
        ArrayExt.insert(this._items, i6, item);
        this.update();
        return item;
      }
      /**
       * Remove an item from the menu.
       *
       * @param item - The item to remove from the menu.
       *
       * #### Notes
       * This is a no-op if the item is not in the menu.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the menu.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.update();
      }
      /**
       * Remove all menu items from the menu.
       */
      clearItems() {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.update();
      }
      /**
       * Open the menu at the specified location.
       *
       * @param x - The client X coordinate of the menu location.
       *
       * @param y - The client Y coordinate of the menu location.
       *
       * @param options - The additional options for opening the menu.
       *
       * #### Notes
       * The menu will be opened at the given location unless it will not
       * fully fit on the screen. If it will not fit, it will be adjusted
       * to fit naturally on the screen.
       *
       * The menu will be attached under the `host` element in the DOM
       * (or `document.body` if `host` is `null`) and before the `ref`
       * element (or as the last child of `host` if `ref` is `null`).
       * The menu may be displayed outside of the `host` element
       * following the rules of CSS absolute positioning.
       *
       * This is a no-op if the menu is already attached to the DOM.
       */
      open(x2, y4, options = {}) {
        var _a, _b, _c;
        if (this.isAttached) {
          return;
        }
        let forceX = options.forceX || false;
        let forceY = options.forceY || false;
        const host = (_a = options.host) !== null && _a !== void 0 ? _a : null;
        const ref = (_b = options.ref) !== null && _b !== void 0 ? _b : null;
        const horizontalAlignment = (_c = options.horizontalAlignment) !== null && _c !== void 0 ? _c : document.documentElement.dir === "rtl" ? "right" : "left";
        Private$93.openRootMenu(this, x2, y4, forceX, forceY, horizontalAlignment, host, ref);
        this.activate();
      }
      /**
       * Handle the DOM events for the menu.
       *
       * @param event - The DOM event sent to the menu.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu's DOM nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mouseup":
            this._evtMouseUp(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "mouseenter":
            this._evtMouseEnter(event);
            break;
          case "mouseleave":
            this._evtMouseLeave(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mouseup", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseenter", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("contextmenu", this);
        document.addEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mouseup", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseenter", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("contextmenu", this);
        document.removeEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this.node.focus();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        let items = this._items;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let collapsedFlags = Private$93.computeCollapsed(items);
        let content = new Array(items.length);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let active = i6 === activeIndex;
          let collapsed = collapsedFlags[i6];
          content[i6] = renderer.renderItem({
            item,
            active,
            collapsed,
            onfocus: () => {
              this.activeIndex = i6;
            }
          });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        this.activeIndex = -1;
        let childMenu = this._childMenu;
        if (childMenu) {
          this._childIndex = -1;
          this._childMenu = null;
          childMenu._parentMenu = null;
          childMenu.close();
        }
        let parentMenu = this._parentMenu;
        if (parentMenu) {
          this._parentMenu = null;
          parentMenu._childIndex = -1;
          parentMenu._childMenu = null;
          parentMenu.activate();
        }
        if (this.isAttached) {
          this._aboutToClose.emit(void 0);
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'keydown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        let kc = event.keyCode;
        if (kc === 13) {
          this.triggerActiveItem();
          return;
        }
        if (kc === 27) {
          this.close();
          return;
        }
        if (kc === 37) {
          if (this._parentMenu) {
            this.close();
          } else {
            this._menuRequested.emit("previous");
          }
          return;
        }
        if (kc === 38) {
          this.activatePreviousItem();
          return;
        }
        if (kc === 39) {
          let item = this.activeItem;
          if (item && item.type === "submenu") {
            this.triggerActiveItem();
          } else {
            this.rootMenu._menuRequested.emit("next");
          }
          return;
        }
        if (kc === 40) {
          this.activateNextItem();
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$93.findMnemonic(this._items, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.triggerActiveItem();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
        }
      }
      /**
       * Handle the `'mouseup'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
      }
      /**
       * Handle the `'mousemove'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        this.activeIndex = index2;
        index2 = this.activeIndex;
        if (index2 === this._childIndex) {
          this._cancelOpenTimer();
          this._cancelCloseTimer();
          return;
        }
        if (this._childIndex !== -1) {
          this._startCloseTimer();
        }
        this._cancelOpenTimer();
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          return;
        }
        this._startOpenTimer();
      }
      /**
       * Handle the `'mouseenter'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseEnter(event) {
        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
          menu._cancelOpenTimer();
          menu._cancelCloseTimer();
          menu.activeIndex = menu._childIndex;
        }
      }
      /**
       * Handle the `'mouseleave'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseLeave(event) {
        this._cancelOpenTimer();
        if (!this._childMenu) {
          this.activeIndex = -1;
          return;
        }
        let { clientX, clientY } = event;
        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
          this._cancelCloseTimer();
          return;
        }
        this.activeIndex = -1;
        this._startCloseTimer();
      }
      /**
       * Handle the `'mousedown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the document node.
       */
      _evtMouseDown(event) {
        if (this._parentMenu) {
          return;
        }
        if (Private$93.hitTestMenus(this, event.clientX, event.clientY)) {
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.close();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if the active item is not a valid submenu.
       */
      _openChildMenu(activateFirst = false) {
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          this._closeChildMenu();
          return;
        }
        let submenu = item.submenu;
        if (submenu === this._childMenu) {
          return;
        }
        Menu3.saveWindowData();
        this._closeChildMenu();
        this._childMenu = submenu;
        this._childIndex = this._activeIndex;
        submenu._parentMenu = this;
        MessageLoop4.sendMessage(this, Widget4.Msg.UpdateRequest);
        let itemNode = this.contentNode.children[this._activeIndex];
        Private$93.openSubmenu(submenu, itemNode);
        if (activateFirst) {
          submenu.activeIndex = -1;
          submenu.activateNextItem();
        }
        submenu.activate();
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (this._childMenu) {
          this._childMenu.close();
        }
      }
      /**
       * Start the open timer, unless it is already pending.
       */
      _startOpenTimer() {
        if (this._openTimerID === 0) {
          this._openTimerID = window.setTimeout(() => {
            this._openTimerID = 0;
            this._openChildMenu();
          }, Private$93.TIMER_DELAY);
        }
      }
      /**
       * Start the close timer, unless it is already pending.
       */
      _startCloseTimer() {
        if (this._closeTimerID === 0) {
          this._closeTimerID = window.setTimeout(() => {
            this._closeTimerID = 0;
            this._closeChildMenu();
          }, Private$93.TIMER_DELAY);
        }
      }
      /**
       * Cancel the open timer, if the timer is pending.
       */
      _cancelOpenTimer() {
        if (this._openTimerID !== 0) {
          clearTimeout(this._openTimerID);
          this._openTimerID = 0;
        }
      }
      /**
       * Cancel the close timer, if the timer is pending.
       */
      _cancelCloseTimer() {
        if (this._closeTimerID !== 0) {
          clearTimeout(this._closeTimerID);
          this._closeTimerID = 0;
        }
      }
      /**
       * Save window data used for menu positioning in transient cache.
       *
       * In order to avoid layout trashing it is recommended to invoke this
       * method immediately prior to opening the menu and any DOM modifications
       * (like closing previously visible menu, or adding a class to menu widget).
       *
       * The transient cache will be released upon `open()` call.
       */
      static saveWindowData() {
        Private$93.saveWindowData();
      }
    };
    (function(Menu5) {
      class Renderer {
        /**
         * Render the virtual element for a menu item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            tabindex: "0",
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
        }
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-Menu-itemLabel" }, content);
        }
        /**
         * Render the shortcut element for a menu item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the item shortcut.
         */
        renderShortcut(data) {
          let content = this.formatShortcut(data);
          return h.div({ className: "lm-Menu-itemShortcut" }, content);
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          return h.div({ className: "lm-Menu-itemSubmenuIcon" });
        }
        /**
         * Create the class name for the menu item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-Menu-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (!data.item.isVisible) {
            name += " lm-mod-hidden";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          if (data.collapsed) {
            name += " lm-mod-collapsed";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the menu item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the menu item.
         */
        createItemDataset(data) {
          let result2;
          let { type, command, dataset } = data.item;
          if (type === "command") {
            result2 = { ...dataset, type, command };
          } else {
            result2 = { ...dataset, type };
          }
          return result2;
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-Menu-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the aria attributes for menu item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          let aria = {};
          switch (data.item.type) {
            case "separator":
              aria.role = "presentation";
              break;
            case "submenu":
              aria["aria-haspopup"] = "true";
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              break;
            default:
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              if (data.item.isToggled) {
                aria.role = "menuitemcheckbox";
                aria["aria-checked"] = "true";
              } else {
                aria.role = "menuitem";
              }
          }
          return aria;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.item;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
        /**
         * Create the render content for the shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
      }
      Menu5.Renderer = Renderer;
      Menu5.defaultRenderer = new Renderer();
    })(Menu3 || (Menu3 = {}));
    (function(Private22) {
      Private22.TIMER_DELAY = 300;
      Private22.SUBMENU_OVERLAP = 3;
      let transientWindowDataCache = null;
      let transientCacheCounter = 0;
      function getWindowData() {
        if (transientCacheCounter > 0) {
          transientCacheCounter--;
          return transientWindowDataCache;
        }
        return _getWindowData();
      }
      function saveWindowData() {
        transientWindowDataCache = _getWindowData();
        transientCacheCounter++;
      }
      Private22.saveWindowData = saveWindowData;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-Menu-content";
        node.appendChild(content);
        content.setAttribute("role", "menu");
        node.tabIndex = 0;
        return node;
      }
      Private22.createNode = createNode;
      function canActivate(item) {
        return item.type !== "separator" && item.isEnabled && item.isVisible;
      }
      Private22.canActivate = canActivate;
      function createItem(owner, options) {
        return new MenuItem(owner.commands, options);
      }
      Private22.createItem = createItem;
      function hitTestMenus(menu, x2, y4) {
        for (let temp = menu; temp; temp = temp.childMenu) {
          if (ElementExt.hitTest(temp.node, x2, y4)) {
            return true;
          }
        }
        return false;
      }
      Private22.hitTestMenus = hitTestMenus;
      function computeCollapsed(items) {
        let result2 = new Array(items.length);
        ArrayExt.fill(result2, false);
        let k1 = 0;
        let n5 = items.length;
        for (; k1 < n5; ++k1) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k1] = true;
        }
        let k2 = n5 - 1;
        for (; k2 >= 0; --k2) {
          let item = items[k2];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k2] = true;
        }
        let hide4 = false;
        while (++k1 < k2) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            hide4 = false;
          } else if (hide4) {
            result2[k1] = true;
          } else {
            hide4 = true;
          }
        }
        return result2;
      }
      Private22.computeCollapsed = computeCollapsed;
      function _getWindowData() {
        return {
          pageXOffset: window.pageXOffset,
          pageYOffset: window.pageYOffset,
          clientWidth: document.documentElement.clientWidth,
          clientHeight: document.documentElement.clientHeight
        };
      }
      function openRootMenu(menu, x2, y4, forceX, forceY, horizontalAlignment, host, ref) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop4.sendMessage(menu, Widget4.Msg.UpdateRequest);
        let maxHeight = ch - (forceY ? y4 : 0);
        let node = menu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget4.attach(menu, host || document.body, ref);
        let { width, height } = node.getBoundingClientRect();
        if (horizontalAlignment === "right") {
          x2 -= width;
        }
        if (!forceX && x2 + width > px + cw) {
          x2 = px + cw - width;
        }
        if (!forceY && y4 + height > py + ch) {
          if (y4 > py + ch) {
            y4 = py + ch - height;
          } else {
            y4 = y4 - height;
          }
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openRootMenu = openRootMenu;
      function openSubmenu(submenu, itemNode) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop4.sendMessage(submenu, Widget4.Msg.UpdateRequest);
        let maxHeight = ch;
        let node = submenu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget4.attach(submenu, document.body);
        let { width, height } = node.getBoundingClientRect();
        let box = ElementExt.boxSizing(submenu.node);
        let itemRect = itemNode.getBoundingClientRect();
        let x2 = itemRect.right - Private22.SUBMENU_OVERLAP;
        if (x2 + width > px + cw) {
          x2 = itemRect.left + Private22.SUBMENU_OVERLAP - width;
        }
        let y4 = itemRect.top - box.borderTop - box.paddingTop;
        if (y4 + height > py + ch) {
          y4 = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openSubmenu = openSubmenu;
      function findMnemonic(items, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let item = items[k2];
          if (!canActivate(item)) {
            continue;
          }
          let label = item.label;
          if (label.length === 0) {
            continue;
          }
          let mn = item.mnemonic;
          if (mn >= 0 && mn < label.length) {
            if (label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
      class MenuItem {
        /**
         * Construct a new menu item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.type = options.type || "command";
          this.command = options.command || "";
          this.args = options.args || import_coreutils10.JSONExt.emptyObject;
          this.submenu = options.submenu || null;
        }
        /**
         * The display label for the menu item.
         */
        get label() {
          if (this.type === "command") {
            return this._commands.label(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.label;
          }
          return "";
        }
        /**
         * The mnemonic index for the menu item.
         */
        get mnemonic() {
          if (this.type === "command") {
            return this._commands.mnemonic(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.mnemonic;
          }
          return -1;
        }
        /**
         * The icon renderer for the menu item.
         */
        get icon() {
          if (this.type === "command") {
            return this._commands.icon(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.icon;
          }
          return void 0;
        }
        /**
         * The icon class for the menu item.
         */
        get iconClass() {
          if (this.type === "command") {
            return this._commands.iconClass(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconClass;
          }
          return "";
        }
        /**
         * The icon label for the menu item.
         */
        get iconLabel() {
          if (this.type === "command") {
            return this._commands.iconLabel(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconLabel;
          }
          return "";
        }
        /**
         * The display caption for the menu item.
         */
        get caption() {
          if (this.type === "command") {
            return this._commands.caption(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.caption;
          }
          return "";
        }
        /**
         * The extra class name for the menu item.
         */
        get className() {
          if (this.type === "command") {
            return this._commands.className(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.className;
          }
          return "";
        }
        /**
         * The dataset for the menu item.
         */
        get dataset() {
          if (this.type === "command") {
            return this._commands.dataset(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.dataset;
          }
          return {};
        }
        /**
         * Whether the menu item is enabled.
         */
        get isEnabled() {
          if (this.type === "command") {
            return this._commands.isEnabled(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * Whether the menu item is toggled.
         */
        get isToggled() {
          if (this.type === "command") {
            return this._commands.isToggled(this.command, this.args);
          }
          return false;
        }
        /**
         * Whether the menu item is visible.
         */
        get isVisible() {
          if (this.type === "command") {
            return this._commands.isVisible(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * The key binding for the menu item.
         */
        get keyBinding() {
          if (this.type === "command") {
            let { command, args } = this;
            return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
              return kb.command === command && import_coreutils10.JSONExt.deepEqual(kb.args, args);
            }) || null;
          }
          return null;
        }
      }
    })(Private$93 || (Private$93 = {}));
    (function(Private22) {
      function createItem(options, id) {
        let selector = validateSelector(options.selector);
        let rank = options.rank !== void 0 ? options.rank : Infinity;
        return { ...options, selector, rank, id };
      }
      Private22.createItem = createItem;
      function matchItems(items, event, groupByTarget, sortBySelector) {
        let target = event.target;
        if (!target) {
          return null;
        }
        let currentTarget = event.currentTarget;
        if (!currentTarget) {
          return null;
        }
        if (!currentTarget.contains(target)) {
          target = document.elementFromPoint(event.clientX, event.clientY);
          if (!target || !currentTarget.contains(target)) {
            return null;
          }
        }
        let result2 = [];
        let availableItems = items.slice();
        while (target !== null) {
          let matches2 = [];
          for (let i6 = 0, n5 = availableItems.length; i6 < n5; ++i6) {
            let item = availableItems[i6];
            if (!item) {
              continue;
            }
            if (!Selector.matches(target, item.selector)) {
              continue;
            }
            matches2.push(item);
            availableItems[i6] = null;
          }
          if (matches2.length !== 0) {
            if (groupByTarget) {
              matches2.sort(sortBySelector ? itemCmp : itemCmpRank);
            }
            result2.push(...matches2);
          }
          if (target === currentTarget) {
            break;
          }
          target = target.parentElement;
        }
        if (!groupByTarget) {
          result2.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        return result2;
      }
      Private22.matchItems = matchItems;
      function validateSelector(selector) {
        if (selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${selector}`);
        }
        if (!Selector.isValid(selector)) {
          throw new Error(`Invalid selector: ${selector}`);
        }
        return selector;
      }
      function itemCmpRank(a3, b2) {
        let r1 = a3.rank;
        let r22 = b2.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.id - b2.id;
      }
      function itemCmp(a3, b2) {
        let s1 = Selector.calculateSpecificity(a3.selector);
        let s22 = Selector.calculateSpecificity(b2.selector);
        if (s1 !== s22) {
          return s22 - s1;
        }
        return itemCmpRank(a3, b2);
      }
    })(Private$83 || (Private$83 = {}));
    ARROW_KEYS3 = [
      "ArrowLeft",
      "ArrowUp",
      "ArrowRight",
      "ArrowDown",
      "Home",
      "End"
    ];
    TabBar4 = class extends Widget4 {
      /**
       * Construct a new tab bar.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        super({ node: Private$73.createNode() });
        this._currentIndex = -1;
        this._titles = [];
        this._titlesEditable = false;
        this._previousTitle = null;
        this._dragData = null;
        this._addButtonEnabled = false;
        this._tabMoved = new Signal(this);
        this._currentChanged = new Signal(this);
        this._addRequested = new Signal(this);
        this._tabCloseRequested = new Signal(this);
        this._tabDetachRequested = new Signal(this);
        this._tabActivateRequested = new Signal(this);
        this.addClass("lm-TabBar");
        this.contentNode.setAttribute("role", "tablist");
        this.setFlag(Widget4.Flag.DisallowLayout);
        this._document = options.document || document;
        this.tabsMovable = options.tabsMovable || false;
        this.titlesEditable = options.titlesEditable || false;
        this.allowDeselect = options.allowDeselect || false;
        this.addButtonEnabled = options.addButtonEnabled || false;
        this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
        this.name = options.name || "";
        this.orientation = options.orientation || "horizontal";
        this.removeBehavior = options.removeBehavior || "select-tab-after";
        this.renderer = options.renderer || TabBar4.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._releaseMouse();
        this._titles.length = 0;
        this._previousTitle = null;
        super.dispose();
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when a tab is moved by the user.
       *
       * #### Notes
       * This signal is emitted when a tab is moved by user interaction.
       *
       * This signal is not emitted when a tab is moved programmatically.
       */
      get tabMoved() {
        return this._tabMoved;
      }
      /**
       * A signal emitted when a tab is clicked by the user.
       *
       * #### Notes
       * If the clicked tab is not the current tab, the clicked tab will be
       * made current and the `currentChanged` signal will be emitted first.
       *
       * This signal is emitted even if the clicked tab is the current tab.
       */
      get tabActivateRequested() {
        return this._tabActivateRequested;
      }
      /**
       * A signal emitted when the tab bar add button is clicked.
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * A signal emitted when a tab close icon is clicked.
       *
       * #### Notes
       * This signal is not emitted unless the tab title is `closable`.
       */
      get tabCloseRequested() {
        return this._tabCloseRequested;
      }
      /**
       * A signal emitted when a tab is dragged beyond the detach threshold.
       *
       * #### Notes
       * This signal is emitted when the user drags a tab with the mouse,
       * and mouse is dragged beyond the detach threshold.
       *
       * The consumer of the signal should call `releaseMouse` and remove
       * the tab in order to complete the detach.
       *
       * This signal is only emitted once per drag cycle.
       */
      get tabDetachRequested() {
        return this._tabDetachRequested;
      }
      /**
       * The document to use with the tab bar.
       *
       * The default is the global `document` instance.
       */
      get document() {
        return this._document;
      }
      /**
       * Whether the titles can be user-edited.
       *
       */
      get titlesEditable() {
        return this._titlesEditable;
      }
      /**
       * Set whether titles can be user edited.
       *
       */
      set titlesEditable(value) {
        this._titlesEditable = value;
      }
      /**
       * Get the currently selected title.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentTitle() {
        return this._titles[this._currentIndex] || null;
      }
      /**
       * Set the currently selected title.
       *
       * #### Notes
       * If the title does not exist, the title will be set to `null`.
       */
      set currentTitle(value) {
        this.currentIndex = value ? this._titles.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `-1` if no tab is selected.
       */
      get currentIndex() {
        return this._currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `-1`.
       */
      set currentIndex(value) {
        if (value < 0 || value >= this._titles.length) {
          value = -1;
        }
        if (this._currentIndex === value) {
          return;
        }
        let pi = this._currentIndex;
        let pt = this._titles[pi] || null;
        let ci = value;
        let ct = this._titles[ci] || null;
        this._currentIndex = ci;
        this._previousTitle = pt;
        this.update();
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: ci,
          currentTitle: ct
        });
      }
      /**
       * Get the name of the tab bar.
       */
      get name() {
        return this._name;
      }
      /**
       * Set the name of the tab bar.
       */
      set name(value) {
        this._name = value;
        if (value) {
          this.contentNode.setAttribute("aria-label", value);
        } else {
          this.contentNode.removeAttribute("aria-label");
        }
      }
      /**
       * Get the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._releaseMouse();
        this._orientation = value;
        this.dataset["orientation"] = value;
        this.contentNode.setAttribute("aria-orientation", value);
      }
      /**
       * Whether the add button is enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add button is enabled.
       */
      set addButtonEnabled(value) {
        if (this._addButtonEnabled === value) {
          return;
        }
        this._addButtonEnabled = value;
        if (value) {
          this.addButtonNode.classList.remove("lm-mod-hidden");
        } else {
          this.addButtonNode.classList.add("lm-mod-hidden");
        }
      }
      /**
       * A read-only array of the titles in the tab bar.
       */
      get titles() {
        return this._titles;
      }
      /**
       * The tab bar content node.
       *
       * #### Notes
       * This is the node which holds the tab nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-TabBar-content")[0];
      }
      /**
       * The tab bar add button node.
       *
       * #### Notes
       * This is the node which holds the add button.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get addButtonNode() {
        return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
      }
      /**
       * Add a tab to the end of the tab bar.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * If the title is already added to the tab bar, it will be moved.
       */
      addTab(value) {
        return this.insertTab(this._titles.length, value);
      }
      /**
       * Insert a tab into the tab bar at the specified index.
       *
       * @param index - The index at which to insert the tab.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the tabs.
       *
       * If the title is already added to the tab bar, it will be moved.
       */
      insertTab(index2, value) {
        this._releaseMouse();
        let title = Private$73.asTitle(value);
        let i6 = this._titles.indexOf(title);
        let j2 = Math.max(0, Math.min(index2, this._titles.length));
        if (i6 === -1) {
          ArrayExt.insert(this._titles, j2, title);
          title.changed.connect(this._onTitleChanged, this);
          this.update();
          this._adjustCurrentForInsert(j2, title);
          return title;
        }
        if (j2 === this._titles.length) {
          j2--;
        }
        if (i6 === j2) {
          return title;
        }
        ArrayExt.move(this._titles, i6, j2);
        this.update();
        this._adjustCurrentForMove(i6, j2);
        return title;
      }
      /**
       * Remove a tab from the tab bar.
       *
       * @param title - The title for the tab to remove.
       *
       * #### Notes
       * This is a no-op if the title is not in the tab bar.
       */
      removeTab(title) {
        this.removeTabAt(this._titles.indexOf(title));
      }
      /**
       * Remove the tab at a given index from the tab bar.
       *
       * @param index - The index of the tab to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeTabAt(index2) {
        this._releaseMouse();
        let title = ArrayExt.removeAt(this._titles, index2);
        if (!title) {
          return;
        }
        title.changed.disconnect(this._onTitleChanged, this);
        if (title === this._previousTitle) {
          this._previousTitle = null;
        }
        this.update();
        this._adjustCurrentForRemove(index2, title);
      }
      /**
       * Remove all tabs from the tab bar.
       */
      clearTabs() {
        if (this._titles.length === 0) {
          return;
        }
        this._releaseMouse();
        for (let title of this._titles) {
          title.changed.disconnect(this._onTitleChanged, this);
        }
        let pi = this.currentIndex;
        let pt = this.currentTitle;
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles.length = 0;
        this.update();
        if (pi === -1) {
          return;
        }
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       *
       * #### Notes
       * This will cause the tab bar to stop handling mouse events and to
       * restore the tabs to their non-dragged positions.
       */
      releaseMouse() {
        this._releaseMouse();
      }
      /**
       * Handle the DOM events for the tab bar.
       *
       * @param event - The DOM event sent to the tab bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tab bar's DOM node.
       *
       * This should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "dblclick":
            this._evtDblClick(event);
            break;
          case "keydown":
            event.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event) : this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
        this.node.addEventListener("dblclick", this);
        this.node.addEventListener("keydown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this.node.removeEventListener("dblclick", this);
        this.node.removeEventListener("keydown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let titles = this._titles;
        let renderer = this.renderer;
        let currentTitle = this.currentTitle;
        let content = new Array(titles.length);
        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
        for (let i6 = 0, n5 = titles.length; i6 < n5; ++i6) {
          let title = titles[i6];
          let current = title === currentTitle;
          let zIndex = current ? n5 : n5 - i6 - 1;
          let tabIndex = tabHandlingTabindex === i6 ? 0 : -1;
          content[i6] = renderer.renderTab({ title, current, zIndex, tabIndex });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * Get the index of the tab which handles tabindex="0".
       * If the add button handles tabindex="0", -1 is returned.
       * If none of the previous handles tabindex="0", null is returned.
       */
      _getCurrentTabindex() {
        let index2 = null;
        const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
        if (elemTabindex) {
          index2 = [...this.contentNode.children].indexOf(elemTabindex);
        } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
          index2 = -1;
        }
        return index2;
      }
      /**
       * Handle the `'dblclick'` event for the tab bar.
       */
      _evtDblClick(event) {
        if (!this.titlesEditable) {
          return;
        }
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          return;
        }
        let title = this.titles[index2];
        let label = tabs[index2].querySelector(".lm-TabBar-tabLabel");
        if (label && label.contains(event.target)) {
          let value = title.label || "";
          let oldValue = label.innerHTML;
          label.innerHTML = "";
          let input = document.createElement("input");
          input.classList.add("lm-TabBar-tabInput");
          input.value = value;
          label.appendChild(input);
          let onblur = () => {
            input.removeEventListener("blur", onblur);
            label.innerHTML = oldValue;
            this.node.addEventListener("keydown", this);
          };
          input.addEventListener("dblclick", (event2) => event2.stopPropagation());
          input.addEventListener("blur", onblur);
          input.addEventListener("keydown", (event2) => {
            if (event2.key === "Enter") {
              if (input.value !== "") {
                title.label = title.caption = input.value;
              }
              onblur();
            } else if (event2.key === "Escape") {
              onblur();
            }
          });
          this.node.removeEventListener("keydown", this);
          input.select();
          input.focus();
          if (label.children.length > 0) {
            label.children[0].focus();
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at capturing phase.
       */
      _evtKeyDownCapturing(event) {
        if (event.eventPhase !== Event.CAPTURING_PHASE) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "Escape") {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at target phase.
       */
      _evtKeyDown(event) {
        var _a, _b, _c;
        if (event.key === "Tab" || event.eventPhase === Event.CAPTURING_PHASE) {
          return;
        }
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
          const focusedElement = document.activeElement;
          if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
            event.preventDefault();
            event.stopPropagation();
            this._addRequested.emit();
          } else {
            const index2 = ArrayExt.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
            if (index2 >= 0) {
              event.preventDefault();
              event.stopPropagation();
              this.currentIndex = index2;
            }
          }
        } else if (ARROW_KEYS3.includes(event.key)) {
          const focusable = [...this.contentNode.children];
          if (this.addButtonEnabled) {
            focusable.push(this.addButtonNode);
          }
          if (focusable.length <= 1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          let focusedIndex = focusable.indexOf(document.activeElement);
          if (focusedIndex === -1) {
            focusedIndex = this._currentIndex;
          }
          let nextFocused;
          if (event.key === "ArrowRight" && this._orientation === "horizontal" || event.key === "ArrowDown" && this._orientation === "vertical") {
            nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
          } else if (event.key === "ArrowLeft" && this._orientation === "horizontal" || event.key === "ArrowUp" && this._orientation === "vertical") {
            nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
          } else if (event.key === "Home") {
            nextFocused = focusable[0];
          } else if (event.key === "End") {
            nextFocused = focusable[focusable.length - 1];
          }
          if (nextFocused) {
            (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
            nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
            nextFocused.focus();
          }
        }
      }
      /**
       * Handle the `'pointerdown'` event for the tab bar.
       */
      _evtPointerDown(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        if (this._dragData) {
          return;
        }
        if (event.target.classList.contains("lm-TabBar-tabInput")) {
          return;
        }
        let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1 && !addButtonClicked) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._dragData = {
          tab: tabs[index2],
          index: index2,
          pressX: event.clientX,
          pressY: event.clientY,
          tabPos: -1,
          tabSize: -1,
          tabPressPos: -1,
          targetIndex: -1,
          tabLayout: null,
          contentRect: null,
          override: null,
          dragActive: false,
          dragAborted: false,
          detachRequested: false
        };
        this.document.addEventListener("pointerup", this, true);
        if (event.button === 1 || addButtonClicked) {
          return;
        }
        let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
          return;
        }
        if (this.tabsMovable) {
          this.document.addEventListener("pointermove", this, true);
          this.document.addEventListener("keydown", this, true);
          this.document.addEventListener("contextmenu", this, true);
        }
        if (this.allowDeselect && this.currentIndex === index2) {
          this.currentIndex = -1;
        } else {
          this.currentIndex = index2;
        }
        if (this.currentIndex === -1) {
          return;
        }
        this._tabActivateRequested.emit({
          index: this.currentIndex,
          title: this.currentTitle
        });
      }
      /**
       * Handle the `'pointermove'` event for the tab bar.
       */
      _evtPointerMove(event) {
        let data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let tabs = this.contentNode.children;
        if (!data.dragActive && !Private$73.dragExceeded(data, event)) {
          return;
        }
        if (!data.dragActive) {
          let tabRect = data.tab.getBoundingClientRect();
          if (this._orientation === "horizontal") {
            data.tabPos = data.tab.offsetLeft;
            data.tabSize = tabRect.width;
            data.tabPressPos = data.pressX - tabRect.left;
          } else {
            data.tabPos = data.tab.offsetTop;
            data.tabSize = tabRect.height;
            data.tabPressPos = data.pressY - tabRect.top;
          }
          data.tabPressOffset = {
            x: data.pressX - tabRect.left,
            y: data.pressY - tabRect.top
          };
          data.tabLayout = Private$73.snapTabLayout(tabs, this._orientation);
          data.contentRect = this.contentNode.getBoundingClientRect();
          data.override = Drag3.overrideCursor("default");
          data.tab.classList.add("lm-mod-dragging");
          this.addClass("lm-mod-dragging");
          data.dragActive = true;
        }
        if (!data.detachRequested && Private$73.detachExceeded(data, event)) {
          data.detachRequested = true;
          let index2 = data.index;
          let clientX = event.clientX;
          let clientY = event.clientY;
          let tab = tabs[index2];
          let title = this._titles[index2];
          this._tabDetachRequested.emit({
            index: index2,
            title,
            tab,
            clientX,
            clientY,
            offset: data.tabPressOffset
          });
          if (data.dragAborted) {
            return;
          }
        }
        Private$73.layoutTabs(tabs, data, event, this._orientation);
      }
      /**
       * Handle the `'pointerup'` event for the document.
       */
      _evtPointerUp(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        const data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        if (!data.dragActive) {
          this._dragData = null;
          let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
          if (addButtonClicked) {
            this._addRequested.emit(void 0);
            return;
          }
          let tabs = this.contentNode.children;
          let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
            return ElementExt.hitTest(tab, event.clientX, event.clientY);
          });
          if (index2 !== data.index) {
            return;
          }
          let title = this._titles[index2];
          if (!title.closable) {
            return;
          }
          if (event.button === 1) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
          if (icon && icon.contains(event.target)) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          return;
        }
        if (event.button !== 0) {
          return;
        }
        Private$73.finalizeTabPosition(data, this._orientation);
        data.tab.classList.remove("lm-mod-dragging");
        let duration = Private$73.parseTransitionDuration(data.tab);
        setTimeout(() => {
          if (data.dragAborted) {
            return;
          }
          this._dragData = null;
          Private$73.resetTabPositions(this.contentNode.children, this._orientation);
          data.override.dispose();
          this.removeClass("lm-mod-dragging");
          let i6 = data.index;
          let j2 = data.targetIndex;
          if (j2 === -1 || i6 === j2) {
            return;
          }
          ArrayExt.move(this._titles, i6, j2);
          this._adjustCurrentForMove(i6, j2);
          this._tabMoved.emit({
            fromIndex: i6,
            toIndex: j2,
            title: this._titles[j2]
          });
          MessageLoop4.sendMessage(this, Widget4.Msg.UpdateRequest);
        }, duration);
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       */
      _releaseMouse() {
        let data = this._dragData;
        if (!data) {
          return;
        }
        this._dragData = null;
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        data.dragAborted = true;
        if (!data.dragActive) {
          return;
        }
        Private$73.resetTabPositions(this.contentNode.children, this._orientation);
        data.override.dispose();
        data.tab.classList.remove("lm-mod-dragging");
        this.removeClass("lm-mod-dragging");
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * This method accounts for the tab bar's insertion behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForInsert(i6, title) {
        let ct = this.currentTitle;
        let ci = this._currentIndex;
        let bh = this.insertBehavior;
        if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
          this._currentIndex = i6;
          this._previousTitle = ct;
          this._currentChanged.emit({
            previousIndex: ci,
            previousTitle: ct,
            currentIndex: i6,
            currentTitle: title
          });
          return;
        }
        if (ci >= i6) {
          this._currentIndex++;
        }
      }
      /**
       * Adjust the current index for a tab move operation.
       *
       * This method will not cause the actual current tab to change.
       * It silently adjusts the index to account for the given move.
       */
      _adjustCurrentForMove(i6, j2) {
        if (this._currentIndex === i6) {
          this._currentIndex = j2;
        } else if (this._currentIndex < i6 && this._currentIndex >= j2) {
          this._currentIndex++;
        } else if (this._currentIndex > i6 && this._currentIndex <= j2) {
          this._currentIndex--;
        }
      }
      /**
       * Adjust the current index for a tab remove operation.
       *
       * This method accounts for the tab bar's remove behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForRemove(i6, title) {
        let ci = this._currentIndex;
        let bh = this.removeBehavior;
        if (ci !== i6) {
          if (ci > i6) {
            this._currentIndex--;
          }
          return;
        }
        if (this._titles.length === 0) {
          this._currentIndex = -1;
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: -1,
            currentTitle: null
          });
          return;
        }
        if (bh === "select-tab-after") {
          this._currentIndex = Math.min(i6, this._titles.length - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-tab-before") {
          this._currentIndex = Math.max(0, i6 - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-previous-tab") {
          if (this._previousTitle) {
            this._currentIndex = this._titles.indexOf(this._previousTitle);
            this._previousTitle = null;
          } else {
            this._currentIndex = Math.min(i6, this._titles.length - 1);
          }
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        this._currentIndex = -1;
        this._currentChanged.emit({
          previousIndex: i6,
          previousTitle: title,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this.update();
      }
    };
    (function(TabBar6) {
      class Renderer {
        constructor() {
          this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
          this._tabID = 0;
          this._tabKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the virtual element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab.
         */
        renderTab(data) {
          let title = data.title.caption;
          let key = this.createTabKey(data);
          let id = key;
          let style = this.createTabStyle(data);
          let className = this.createTabClass(data);
          let dataset = this.createTabDataset(data);
          let aria = this.createTabARIA(data);
          if (data.title.closable) {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
          } else {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
          }
        }
        /**
         * Render the icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab icon.
         */
        renderIcon(data) {
          const { title } = data;
          let className = this.createIconClass(data);
          return h.div({ className }, title.icon, title.iconLabel);
        }
        /**
         * Render the label element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab label.
         */
        renderLabel(data) {
          return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
        }
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          return h.div({ className: "lm-TabBar-tabCloseIcon" });
        }
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        createTabKey(data) {
          let key = this._tabKeys.get(data.title);
          if (key === void 0) {
            key = `tab-key-${this._uuid}-${this._tabID++}`;
            this._tabKeys.set(data.title, key);
          }
          return key;
        }
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        createTabStyle(data) {
          return { zIndex: `${data.zIndex}` };
        }
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        createTabClass(data) {
          let name = "lm-TabBar-tab";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.title.closable) {
            name += " lm-mod-closable";
          }
          if (data.current) {
            name += " lm-mod-current";
          }
          return name;
        }
        /**
         * Create the dataset for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The dataset for the tab.
         */
        createTabDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the ARIA attributes for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The ARIA attributes for the tab.
         */
        createTabARIA(data) {
          var _a;
          return {
            role: "tab",
            "aria-selected": data.current.toString(),
            tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
          };
        }
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        createIconClass(data) {
          let name = "lm-TabBar-tabIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
      }
      Renderer._nInstance = 0;
      TabBar6.Renderer = Renderer;
      TabBar6.defaultRenderer = new Renderer();
      TabBar6.addButtonSelector = ".lm-TabBar-addButton";
    })(TabBar4 || (TabBar4 = {}));
    (function(Private22) {
      Private22.DRAG_THRESHOLD = 5;
      Private22.DETACH_THRESHOLD = 20;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.setAttribute("role", "tablist");
        content.className = "lm-TabBar-content";
        node.appendChild(content);
        let add = document.createElement("div");
        add.className = "lm-TabBar-addButton lm-mod-hidden";
        add.setAttribute("tabindex", "-1");
        add.setAttribute("role", "button");
        node.appendChild(add);
        return node;
      }
      Private22.createNode = createNode;
      function asTitle(value) {
        return value instanceof Title4 ? value : new Title4(value);
      }
      Private22.asTitle = asTitle;
      function parseTransitionDuration(tab) {
        let style = window.getComputedStyle(tab);
        return 1e3 * (parseFloat(style.transitionDuration) || 0);
      }
      Private22.parseTransitionDuration = parseTransitionDuration;
      function snapTabLayout(tabs, orientation) {
        let layout = new Array(tabs.length);
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let node = tabs[i6];
          let style = window.getComputedStyle(node);
          if (orientation === "horizontal") {
            layout[i6] = {
              pos: node.offsetLeft,
              size: node.offsetWidth,
              margin: parseFloat(style.marginLeft) || 0
            };
          } else {
            layout[i6] = {
              pos: node.offsetTop,
              size: node.offsetHeight,
              margin: parseFloat(style.marginTop) || 0
            };
          }
        }
        return layout;
      }
      Private22.snapTabLayout = snapTabLayout;
      function dragExceeded(data, event) {
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        return dx >= Private22.DRAG_THRESHOLD || dy >= Private22.DRAG_THRESHOLD;
      }
      Private22.dragExceeded = dragExceeded;
      function detachExceeded(data, event) {
        let rect = data.contentRect;
        return event.clientX < rect.left - Private22.DETACH_THRESHOLD || event.clientX >= rect.right + Private22.DETACH_THRESHOLD || event.clientY < rect.top - Private22.DETACH_THRESHOLD || event.clientY >= rect.bottom + Private22.DETACH_THRESHOLD;
      }
      Private22.detachExceeded = detachExceeded;
      function layoutTabs(tabs, data, event, orientation) {
        let pressPos;
        let localPos;
        let clientPos;
        let clientSize;
        if (orientation === "horizontal") {
          pressPos = data.pressX;
          localPos = event.clientX - data.contentRect.left;
          clientPos = event.clientX;
          clientSize = data.contentRect.width;
        } else {
          pressPos = data.pressY;
          localPos = event.clientY - data.contentRect.top;
          clientPos = event.clientY;
          clientSize = data.contentRect.height;
        }
        let targetIndex = data.index;
        let targetPos = localPos - data.tabPressPos;
        let targetEnd = targetPos + data.tabSize;
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let pxPos;
          let layout = data.tabLayout[i6];
          let threshold = layout.pos + (layout.size >> 1);
          if (i6 < data.index && targetPos < threshold) {
            pxPos = `${data.tabSize + data.tabLayout[i6 + 1].margin}px`;
            targetIndex = Math.min(targetIndex, i6);
          } else if (i6 > data.index && targetEnd > threshold) {
            pxPos = `${-data.tabSize - layout.margin}px`;
            targetIndex = Math.max(targetIndex, i6);
          } else if (i6 === data.index) {
            let ideal = clientPos - pressPos;
            let limit = clientSize - (data.tabPos + data.tabSize);
            pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;
          } else {
            pxPos = "";
          }
          if (orientation === "horizontal") {
            tabs[i6].style.left = pxPos;
          } else {
            tabs[i6].style.top = pxPos;
          }
        }
        data.targetIndex = targetIndex;
      }
      Private22.layoutTabs = layoutTabs;
      function finalizeTabPosition(data, orientation) {
        let clientSize;
        if (orientation === "horizontal") {
          clientSize = data.contentRect.width;
        } else {
          clientSize = data.contentRect.height;
        }
        let ideal;
        if (data.targetIndex === data.index) {
          ideal = 0;
        } else if (data.targetIndex > data.index) {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        } else {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos - data.tabPos;
        }
        let limit = clientSize - (data.tabPos + data.tabSize);
        let final = Math.max(-data.tabPos, Math.min(ideal, limit));
        if (orientation === "horizontal") {
          data.tab.style.left = `${final}px`;
        } else {
          data.tab.style.top = `${final}px`;
        }
      }
      Private22.finalizeTabPosition = finalizeTabPosition;
      function resetTabPositions(tabs, orientation) {
        for (const tab of tabs) {
          if (orientation === "horizontal") {
            tab.style.left = "";
          } else {
            tab.style.top = "";
          }
        }
      }
      Private22.resetTabPositions = resetTabPositions;
    })(Private$73 || (Private$73 = {}));
    DockLayout3 = class extends Layout3 {
      /**
       * Construct a new dock layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this._spacing = 4;
        this._dirty = false;
        this._root = null;
        this._box = null;
        this._items = /* @__PURE__ */ new Map();
        this.renderer = options.renderer;
        if (options.spacing !== void 0) {
          this._spacing = Utils$13.clampDimension(options.spacing);
        }
        this._document = options.document || document;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget4.HiddenMode.Display;
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       */
      dispose() {
        let widgets = this[Symbol.iterator]();
        this._items.forEach((item) => {
          item.dispose();
        });
        this._box = null;
        this._root = null;
        this._items.clear();
        for (const widget of widgets) {
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding child widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        for (const bar of this.tabBars()) {
          if (bar.titles.length > 1) {
            for (const title of bar.titles) {
              title.owner.hiddenMode = this._hiddenMode;
            }
          }
        }
      }
      /**
       * Get the inter-element spacing for the dock layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the dock layout.
       */
      set spacing(value) {
        value = Utils$13.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Whether the dock layout is empty.
       */
      get isEmpty() {
        return this._root === null;
      }
      /**
       * Create an iterator over all widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       *
       * #### Notes
       * This iterator includes the generated tab bars.
       */
      [Symbol.iterator]() {
        return this._root ? this._root.iterAllWidgets() : empty();
      }
      /**
       * Create an iterator over the user widgets in the layout.
       *
       * @returns A new iterator over the user widgets in the layout.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      widgets() {
        return this._root ? this._root.iterUserWidgets() : empty();
      }
      /**
       * Create an iterator over the selected widgets in the layout.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the layout.
       */
      selectedWidgets() {
        return this._root ? this._root.iterSelectedWidgets() : empty();
      }
      /**
       * Create an iterator over the tab bars in the layout.
       *
       * @returns A new iterator over the tab bars in the layout.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      tabBars() {
        return this._root ? this._root.iterTabBars() : empty();
      }
      /**
       * Create an iterator over the handles in the layout.
       *
       * @returns A new iterator over the handles in the layout.
       */
      handles() {
        return this._root ? this._root.iterHandles() : empty();
      }
      /**
       * Move a handle to the given offset position.
       *
       * @param handle - The handle to move.
       *
       * @param offsetX - The desired offset X position of the handle.
       *
       * @param offsetY - The desired offset Y position of the handle.
       *
       * #### Notes
       * If the given handle is not contained in the layout, this is no-op.
       *
       * The handle will be moved as close as possible to the desired
       * position without violating any of the layout constraints.
       *
       * Only one of the coordinates is used depending on the orientation
       * of the handle. This method accepts both coordinates to make it
       * easy to invoke from a mouse move event without needing to know
       * the handle orientation.
       */
      moveHandle(handle, offsetX, offsetY) {
        let hidden = handle.classList.contains("lm-mod-hidden");
        if (!this._root || hidden) {
          return;
        }
        let data = this._root.findSplitNode(handle);
        if (!data) {
          return;
        }
        let delta;
        if (data.node.orientation === "horizontal") {
          delta = offsetX - handle.offsetLeft;
        } else {
          delta = offsetY - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        data.node.holdSizes();
        BoxEngine3.adjust(data.node.sizers, data.index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Save the current configuration of the dock layout.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        if (!this._root) {
          return { main: null };
        }
        this._root.holdAllSizes();
        return { main: this._root.createConfig() };
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       */
      restoreLayout(config) {
        let widgetSet = /* @__PURE__ */ new Set();
        let mainConfig;
        if (config.main) {
          mainConfig = Private$63.normalizeAreaConfig(config.main, widgetSet);
        } else {
          mainConfig = null;
        }
        let oldWidgets = this.widgets();
        let oldTabBars = this.tabBars();
        let oldHandles = this.handles();
        this._root = null;
        for (const widget of oldWidgets) {
          if (!widgetSet.has(widget)) {
            widget.parent = null;
          }
        }
        for (const tabBar of oldTabBars) {
          tabBar.dispose();
        }
        for (const handle of oldHandles) {
          if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
          }
        }
        for (const widget of widgetSet) {
          widget.parent = this.parent;
        }
        if (mainConfig) {
          this._root = Private$63.realizeAreaConfig(mainConfig, {
            // Ignoring optional `document` argument as we must reuse `this._document`
            createTabBar: (document2) => this._createTabBar(),
            createHandle: () => this._createHandle()
          }, this._document);
        } else {
          this._root = null;
        }
        if (!this.parent) {
          return;
        }
        widgetSet.forEach((widget) => {
          this.attachWidget(widget);
        });
        this.parent.fit();
      }
      /**
       * Add a widget to the dock layout.
       *
       * @param widget - The widget to add to the dock layout.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * The widget will be moved if it is already contained in the layout.
       *
       * An error will be thrown if the reference widget is invalid.
       */
      addWidget(widget, options = {}) {
        let ref = options.ref || null;
        let mode = options.mode || "tab-after";
        let refNode = null;
        if (this._root && ref) {
          refNode = this._root.findTabNode(ref);
        }
        if (ref && !refNode) {
          throw new Error("Reference widget is not in the layout.");
        }
        widget.parent = this.parent;
        switch (mode) {
          case "tab-after":
            this._insertTab(widget, ref, refNode, true);
            break;
          case "tab-before":
            this._insertTab(widget, ref, refNode, false);
            break;
          case "split-top":
            this._insertSplit(widget, ref, refNode, "vertical", false);
            break;
          case "split-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false);
            break;
          case "split-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true);
            break;
          case "split-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true);
            break;
          case "merge-top":
            this._insertSplit(widget, ref, refNode, "vertical", false, true);
            break;
          case "merge-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false, true);
            break;
          case "merge-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true, true);
            break;
          case "merge-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true, true);
            break;
        }
        if (!this.parent) {
          return;
        }
        this.attachWidget(widget);
        this.parent.fit();
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this._removeWidget(widget);
        if (!this.parent) {
          return;
        }
        this.detachWidget(widget);
        this.parent.fit();
      }
      /**
       * Find the tab area which contains the given client position.
       *
       * @param clientX - The client X position of interest.
       *
       * @param clientY - The client Y position of interest.
       *
       * @returns The geometry of the tab area at the given position, or
       *   `null` if there is no tab area at the given position.
       */
      hitTestTabAreas(clientX, clientY) {
        if (!this._root || !this.parent || !this.parent.isVisible) {
          return null;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let rect = this.parent.node.getBoundingClientRect();
        let x2 = clientX - rect.left - this._box.borderLeft;
        let y4 = clientY - rect.top - this._box.borderTop;
        let tabNode = this._root.hitTestTabNodes(x2, y4);
        if (!tabNode) {
          return null;
        }
        let { tabBar, top, left, width, height } = tabNode;
        let borderWidth = this._box.borderLeft + this._box.borderRight;
        let borderHeight = this._box.borderTop + this._box.borderBottom;
        let right = rect.width - borderWidth - (left + width);
        let bottom = rect.height - borderHeight - (top + height);
        return { tabBar, x: x2, y: y4, top, left, right, bottom, width, height };
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
        for (const handle of this.handles()) {
          this.parent.node.appendChild(handle);
        }
        this.parent.fit();
      }
      /**
       * Attach the widget to the layout parent widget.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a no-op if the widget is already attached.
       */
      attachWidget(widget) {
        if (this.parent.node === widget.node.parentNode) {
          return;
        }
        this._items.set(widget, new LayoutItem3(widget));
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
      }
      /**
       * Detach the widget from the layout parent widget.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a no-op if the widget is not attached.
       */
      detachWidget(widget) {
        if (this.parent.node !== widget.node.parentNode) {
          return;
        }
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
        let item = this._items.get(widget);
        if (item) {
          this._items.delete(widget);
          item.dispose();
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Remove the specified widget from the layout structure.
       *
       * #### Notes
       * This is a no-op if the widget is not in the layout tree.
       *
       * This does not detach the widget from the parent node.
       */
      _removeWidget(widget) {
        if (!this._root) {
          return;
        }
        let tabNode = this._root.findTabNode(widget);
        if (!tabNode) {
          return;
        }
        Private$63.removeAria(widget);
        if (tabNode.tabBar.titles.length > 1) {
          tabNode.tabBar.removeTab(widget.title);
          if (this._hiddenMode === Widget4.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
            const existingWidget = tabNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget4.HiddenMode.Display;
          }
          return;
        }
        tabNode.tabBar.dispose();
        if (this._root === tabNode) {
          this._root = null;
          return;
        }
        this._root.holdAllSizes();
        let splitNode = tabNode.parent;
        tabNode.parent = null;
        let i6 = ArrayExt.removeFirstOf(splitNode.children, tabNode);
        let handle = ArrayExt.removeAt(splitNode.handles, i6);
        ArrayExt.removeAt(splitNode.sizers, i6);
        if (handle.parentNode) {
          handle.parentNode.removeChild(handle);
        }
        if (splitNode.children.length > 1) {
          splitNode.syncHandles();
          return;
        }
        let maybeParent = splitNode.parent;
        splitNode.parent = null;
        let childNode = splitNode.children[0];
        let childHandle = splitNode.handles[0];
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        if (childHandle.parentNode) {
          childHandle.parentNode.removeChild(childHandle);
        }
        if (this._root === splitNode) {
          childNode.parent = null;
          this._root = childNode;
          return;
        }
        let parentNode = maybeParent;
        let j2 = parentNode.children.indexOf(splitNode);
        if (childNode instanceof Private$63.TabLayoutNode) {
          childNode.parent = parentNode;
          parentNode.children[j2] = childNode;
          return;
        }
        let splitHandle = ArrayExt.removeAt(parentNode.handles, j2);
        ArrayExt.removeAt(parentNode.children, j2);
        ArrayExt.removeAt(parentNode.sizers, j2);
        if (splitHandle.parentNode) {
          splitHandle.parentNode.removeChild(splitHandle);
        }
        for (let i7 = 0, n5 = childNode.children.length; i7 < n5; ++i7) {
          let gChild = childNode.children[i7];
          let gHandle = childNode.handles[i7];
          let gSizer = childNode.sizers[i7];
          ArrayExt.insert(parentNode.children, j2 + i7, gChild);
          ArrayExt.insert(parentNode.handles, j2 + i7, gHandle);
          ArrayExt.insert(parentNode.sizers, j2 + i7, gSizer);
          gChild.parent = parentNode;
        }
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        parentNode.syncHandles();
      }
      /**
       * Create the tab layout node to hold the widget.
       */
      _createTabNode(widget) {
        let tabNode = new Private$63.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        Private$63.addAria(widget, tabNode.tabBar);
        return tabNode;
      }
      /**
       * Insert a widget next to an existing tab.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertTab(widget, ref, refNode, after2) {
        if (widget === ref) {
          return;
        }
        if (!this._root) {
          let tabNode = new Private$63.TabLayoutNode(this._createTabBar());
          tabNode.tabBar.addTab(widget.title);
          this._root = tabNode;
          Private$63.addAria(widget, tabNode.tabBar);
          return;
        }
        if (!refNode) {
          refNode = this._root.findFirstTabNode();
        }
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
          this._removeWidget(widget);
          widget.hide();
        }
        let index2;
        if (ref) {
          index2 = refNode.tabBar.titles.indexOf(ref.title);
        } else {
          index2 = refNode.tabBar.currentIndex;
        }
        if (this._hiddenMode === Widget4.HiddenMode.Scale) {
          if (refNode.tabBar.titles.length === 0) {
            widget.hiddenMode = Widget4.HiddenMode.Display;
          } else if (refNode.tabBar.titles.length == 1) {
            const existingWidget = refNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget4.HiddenMode.Scale;
          } else {
            widget.hiddenMode = Widget4.HiddenMode.Scale;
          }
        } else {
          widget.hiddenMode = this._hiddenMode;
        }
        refNode.tabBar.insertTab(index2 + (after2 ? 1 : 0), widget.title);
        Private$63.addAria(widget, refNode.tabBar);
      }
      /**
       * Insert a widget as a new split area.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertSplit(widget, ref, refNode, orientation, after2, merge = false) {
        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {
          return;
        }
        this._removeWidget(widget);
        if (!this._root) {
          this._root = this._createTabNode(widget);
          return;
        }
        if (!refNode || !refNode.parent) {
          let root2 = this._splitRoot(orientation);
          let i7 = after2 ? root2.children.length : 0;
          root2.normalizeSizes();
          let sizer = Private$63.createSizer(refNode ? 1 : Private$63.GOLDEN_RATIO);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(root2.children, i7, tabNode2);
          ArrayExt.insert(root2.sizers, i7, sizer);
          ArrayExt.insert(root2.handles, i7, this._createHandle());
          tabNode2.parent = root2;
          root2.normalizeSizes();
          root2.syncHandles();
          return;
        }
        let splitNode = refNode.parent;
        if (splitNode.orientation === orientation) {
          let i7 = splitNode.children.indexOf(refNode);
          if (merge) {
            let j4 = i7 + (after2 ? 1 : -1);
            let sibling = splitNode.children[j4];
            if (sibling instanceof Private$63.TabLayoutNode) {
              this._insertTab(widget, null, sibling, true);
              ++sibling.tabBar.currentIndex;
              return;
            }
          }
          splitNode.normalizeSizes();
          let s8 = splitNode.sizers[i7].sizeHint /= 2;
          let j3 = i7 + (after2 ? 1 : 0);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(splitNode.children, j3, tabNode2);
          ArrayExt.insert(splitNode.sizers, j3, Private$63.createSizer(s8));
          ArrayExt.insert(splitNode.handles, j3, this._createHandle());
          tabNode2.parent = splitNode;
          splitNode.syncHandles();
          return;
        }
        let i6 = ArrayExt.removeFirstOf(splitNode.children, refNode);
        let childNode = new Private$63.SplitLayoutNode(orientation);
        childNode.normalized = true;
        childNode.children.push(refNode);
        childNode.sizers.push(Private$63.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        let j2 = after2 ? 1 : 0;
        let tabNode = this._createTabNode(widget);
        ArrayExt.insert(childNode.children, j2, tabNode);
        ArrayExt.insert(childNode.sizers, j2, Private$63.createSizer(0.5));
        ArrayExt.insert(childNode.handles, j2, this._createHandle());
        tabNode.parent = childNode;
        childNode.syncHandles();
        ArrayExt.insert(splitNode.children, i6, childNode);
        childNode.parent = splitNode;
      }
      /**
       * Ensure the root is a split node with the given orientation.
       */
      _splitRoot(orientation) {
        let oldRoot = this._root;
        if (oldRoot instanceof Private$63.SplitLayoutNode) {
          if (oldRoot.orientation === orientation) {
            return oldRoot;
          }
        }
        let newRoot = this._root = new Private$63.SplitLayoutNode(orientation);
        if (oldRoot) {
          newRoot.children.push(oldRoot);
          newRoot.sizers.push(Private$63.createSizer(0));
          newRoot.handles.push(this._createHandle());
          oldRoot.parent = newRoot;
        }
        return newRoot;
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        if (this._root) {
          let limits = this._root.fit(this._spacing, this._items);
          minW = limits.minWidth;
          minH = limits.minHeight;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop4.sendMessage(this.parent.parent, Widget4.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop4.sendMessage(this.parent, Widget4.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (!this._root) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let x2 = this._box.paddingTop;
        let y4 = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        this._root.update(x2, y4, width, height, this._spacing, this._items);
      }
      /**
       * Create a new tab bar for use by the dock layout.
       *
       * #### Notes
       * The tab bar will be attached to the parent if it exists.
       */
      _createTabBar() {
        let tabBar = this.renderer.createTabBar(this._document);
        tabBar.orientation = "horizontal";
        if (this.parent) {
          this.attachWidget(tabBar);
        }
        return tabBar;
      }
      /**
       * Create a new handle for the dock layout.
       *
       * #### Notes
       * The handle will be attached to the parent if it exists.
       */
      _createHandle() {
        let handle = this.renderer.createHandle();
        let style = handle.style;
        style.position = "absolute";
        style.contain = "strict";
        style.top = "0";
        style.left = "0";
        style.width = "0";
        style.height = "0";
        if (this.parent) {
          this.parent.node.appendChild(handle);
        }
        return handle;
      }
    };
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      function createSizer(hint) {
        let sizer = new BoxSizer3();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
      }
      Private22.createSizer = createSizer;
      function normalizeAreaConfig(config, widgetSet) {
        let result2;
        if (config.type === "tab-area") {
          result2 = normalizeTabAreaConfig(config, widgetSet);
        } else {
          result2 = normalizeSplitAreaConfig(config, widgetSet);
        }
        return result2;
      }
      Private22.normalizeAreaConfig = normalizeAreaConfig;
      function realizeAreaConfig(config, renderer, document2) {
        let node;
        if (config.type === "tab-area") {
          node = realizeTabAreaConfig(config, renderer, document2);
        } else {
          node = realizeSplitAreaConfig(config, renderer, document2);
        }
        return node;
      }
      Private22.realizeAreaConfig = realizeAreaConfig;
      class TabLayoutNode {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        constructor(tabBar) {
          this.parent = null;
          this._top = 0;
          this._left = 0;
          this._width = 0;
          this._height = 0;
          let tabSizer = new BoxSizer3();
          let widgetSizer = new BoxSizer3();
          tabSizer.stretch = 0;
          widgetSizer.stretch = 1;
          this.tabBar = tabBar;
          this.sizers = [tabSizer, widgetSizer];
        }
        /**
         * The most recent value for the `top` edge of the layout box.
         */
        get top() {
          return this._top;
        }
        /**
         * The most recent value for the `left` edge of the layout box.
         */
        get left() {
          return this._left;
        }
        /**
         * The most recent value for the `width` of the layout box.
         */
        get width() {
          return this._width;
        }
        /**
         * The most recent value for the `height` of the layout box.
         */
        get height() {
          return this._height;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          yield this.tabBar;
          yield* this.iterUserWidgets();
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const title of this.tabBar.titles) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          let title = this.tabBar.currentTitle;
          if (title) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          yield this.tabBar;
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        // eslint-disable-next-line require-yield
        *iterHandles() {
          return;
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          return this;
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          if (x2 < this._left || x2 >= this._left + this._width) {
            return null;
          }
          if (y4 < this._top || y4 >= this._top + this._height) {
            return null;
          }
          return this;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let widgets = this.tabBar.titles.map((title) => title.owner);
          let currentIndex = this.tabBar.currentIndex;
          return { type: "tab-area", widgets, currentIndex };
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          return;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let minWidth = 0;
          let minHeight = 0;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          let [tabBarSizer, widgetSizer] = this.sizers;
          if (tabBarItem) {
            tabBarItem.fit();
          }
          if (widgetItem) {
            widgetItem.fit();
          }
          if (tabBarItem && !tabBarItem.isHidden) {
            minWidth = Math.max(minWidth, tabBarItem.minWidth);
            minHeight += tabBarItem.minHeight;
            tabBarSizer.minSize = tabBarItem.minHeight;
            tabBarSizer.maxSize = tabBarItem.maxHeight;
          } else {
            tabBarSizer.minSize = 0;
            tabBarSizer.maxSize = 0;
          }
          if (widgetItem && !widgetItem.isHidden) {
            minWidth = Math.max(minWidth, widgetItem.minWidth);
            minHeight += widgetItem.minHeight;
            widgetSizer.minSize = widgetItem.minHeight;
            widgetSizer.maxSize = Infinity;
          } else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = Infinity;
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          this._top = top;
          this._left = left;
          this._width = width;
          this._height = height;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          BoxEngine3.calc(this.sizers, height);
          if (tabBarItem && !tabBarItem.isHidden) {
            let size5 = this.sizers[0].size;
            tabBarItem.update(left, top, width, size5);
            top += size5;
          }
          if (widgetItem && !widgetItem.isHidden) {
            let size5 = this.sizers[1].size;
            widgetItem.update(left, top, width, size5);
          }
        }
      }
      Private22.TabLayoutNode = TabLayoutNode;
      class SplitLayoutNode {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        constructor(orientation) {
          this.parent = null;
          this.normalized = false;
          this.children = [];
          this.sizers = [];
          this.handles = [];
          this.orientation = orientation;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          for (const child of this.children) {
            yield* child.iterAllWidgets();
          }
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const child of this.children) {
            yield* child.iterUserWidgets();
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          for (const child of this.children) {
            yield* child.iterSelectedWidgets();
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          for (const child of this.children) {
            yield* child.iterTabBars();
          }
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        *iterHandles() {
          yield* this.handles;
          for (const child of this.children) {
            yield* child.iterHandles();
          }
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findTabNode(widget);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          let index2 = this.handles.indexOf(handle);
          if (index2 !== -1) {
            return { index: index2, node: this };
          }
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findSplitNode(handle);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          if (this.children.length === 0) {
            return null;
          }
          return this.children[0].findFirstTabNode();
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].hitTestTabNodes(x2, y4);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let orientation = this.orientation;
          let sizes = this.createNormalizedSizes();
          let children = this.children.map((child) => child.createConfig());
          return { type: "split-area", orientation, children, sizes };
        }
        /**
         * Sync the visibility and orientation of the handles.
         */
        syncHandles() {
          this.handles.forEach((handle, i6) => {
            handle.setAttribute("data-orientation", this.orientation);
            if (i6 === this.handles.length - 1) {
              handle.classList.add("lm-mod-hidden");
            } else {
              handle.classList.remove("lm-mod-hidden");
            }
          });
        }
        /**
         * Hold the current sizes of the box sizers.
         *
         * This sets the size hint of each sizer to its current size.
         */
        holdSizes() {
          for (const sizer of this.sizers) {
            sizer.sizeHint = sizer.size;
          }
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          for (const child of this.children) {
            child.holdAllSizes();
          }
          this.holdSizes();
        }
        /**
         * Normalize the sizes of the split layout node.
         */
        normalizeSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return;
          }
          this.holdSizes();
          let sum = this.sizers.reduce((v4, sizer) => v4 + sizer.sizeHint, 0);
          if (sum === 0) {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint = 1 / n5;
            }
          } else {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint /= sum;
            }
          }
          this.normalized = true;
        }
        /**
         * Snap the normalized sizes of the split layout node.
         */
        createNormalizedSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return [];
          }
          let sizes = this.sizers.map((sizer) => sizer.size);
          let sum = sizes.reduce((v4, size5) => v4 + size5, 0);
          if (sum === 0) {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] = 1 / n5;
            }
          } else {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] /= sum;
            }
          }
          return sizes;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let minWidth = horizontal ? fixed : 0;
          let minHeight = horizontal ? 0 : fixed;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let limits = this.children[i6].fit(spacing, items);
            if (horizontal) {
              minHeight = Math.max(minHeight, limits.minHeight);
              minWidth += limits.minWidth;
              this.sizers[i6].minSize = limits.minWidth;
            } else {
              minWidth = Math.max(minWidth, limits.minWidth);
              minHeight += limits.minHeight;
              this.sizers[i6].minSize = limits.minHeight;
            }
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let space = Math.max(0, (horizontal ? width : height) - fixed);
          if (this.normalized) {
            for (const sizer of this.sizers) {
              sizer.sizeHint *= space;
            }
            this.normalized = false;
          }
          BoxEngine3.calc(this.sizers, space);
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let child = this.children[i6];
            let size5 = this.sizers[i6].size;
            let handleStyle = this.handles[i6].style;
            if (horizontal) {
              child.update(left, top, size5, height, spacing, items);
              left += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${spacing}px`;
              handleStyle.height = `${height}px`;
              left += spacing;
            } else {
              child.update(left, top, width, size5, spacing, items);
              top += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${width}px`;
              handleStyle.height = `${spacing}px`;
              top += spacing;
            }
          }
        }
      }
      Private22.SplitLayoutNode = SplitLayoutNode;
      function addAria(widget, tabBar) {
        widget.node.setAttribute("role", "tabpanel");
        let renderer = tabBar.renderer;
        if (renderer instanceof TabBar4.Renderer) {
          let tabId = renderer.createTabKey({
            title: widget.title,
            current: false,
            zIndex: 0
          });
          widget.node.setAttribute("aria-labelledby", tabId);
        }
      }
      Private22.addAria = addAria;
      function removeAria(widget) {
        widget.node.removeAttribute("role");
        widget.node.removeAttribute("aria-labelledby");
      }
      Private22.removeAria = removeAria;
      function normalizeTabAreaConfig(config, widgetSet) {
        if (config.widgets.length === 0) {
          return null;
        }
        let widgets = [];
        for (const widget of config.widgets) {
          if (!widgetSet.has(widget)) {
            widgetSet.add(widget);
            widgets.push(widget);
          }
        }
        if (widgets.length === 0) {
          return null;
        }
        let index2 = config.currentIndex;
        if (index2 !== -1 && (index2 < 0 || index2 >= widgets.length)) {
          index2 = 0;
        }
        return { type: "tab-area", widgets, currentIndex: index2 };
      }
      function normalizeSplitAreaConfig(config, widgetSet) {
        let orientation = config.orientation;
        let children = [];
        let sizes = [];
        for (let i6 = 0, n5 = config.children.length; i6 < n5; ++i6) {
          let child = normalizeAreaConfig(config.children[i6], widgetSet);
          if (!child) {
            continue;
          }
          if (child.type === "tab-area" || child.orientation !== orientation) {
            children.push(child);
            sizes.push(Math.abs(config.sizes[i6] || 0));
          } else {
            children.push(...child.children);
            sizes.push(...child.sizes);
          }
        }
        if (children.length === 0) {
          return null;
        }
        if (children.length === 1) {
          return children[0];
        }
        return { type: "split-area", orientation, children, sizes };
      }
      function realizeTabAreaConfig(config, renderer, document2) {
        let tabBar = renderer.createTabBar(document2);
        for (const widget of config.widgets) {
          widget.hide();
          tabBar.addTab(widget.title);
          Private22.addAria(widget, tabBar);
        }
        tabBar.currentIndex = config.currentIndex;
        return new TabLayoutNode(tabBar);
      }
      function realizeSplitAreaConfig(config, renderer, document2) {
        let node = new SplitLayoutNode(config.orientation);
        config.children.forEach((child, i6) => {
          let childNode = realizeAreaConfig(child, renderer, document2);
          let sizer = createSizer(config.sizes[i6]);
          let handle = renderer.createHandle();
          node.children.push(childNode);
          node.handles.push(handle);
          node.sizers.push(sizer);
          childNode.parent = node;
        });
        node.syncHandles();
        node.normalizeSizes();
        return node;
      }
    })(Private$63 || (Private$63 = {}));
    DockPanel3 = class extends Widget4 {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this._drag = null;
        this._tabsMovable = true;
        this._tabsConstrained = false;
        this._addButtonEnabled = false;
        this._pressData = null;
        this._layoutModified = new Signal(this);
        this._addRequested = new Signal(this);
        this.addClass("lm-DockPanel");
        this._document = options.document || document;
        this._mode = options.mode || "multiple-document";
        this._renderer = options.renderer || DockPanel3.defaultRenderer;
        this._edges = options.edges || Private$53.DEFAULT_EDGES;
        if (options.tabsMovable !== void 0) {
          this._tabsMovable = options.tabsMovable;
        }
        if (options.tabsConstrained !== void 0) {
          this._tabsConstrained = options.tabsConstrained;
        }
        if (options.addButtonEnabled !== void 0) {
          this._addButtonEnabled = options.addButtonEnabled;
        }
        this.dataset["mode"] = this._mode;
        let renderer = {
          createTabBar: () => this._createTabBar(),
          createHandle: () => this._createHandle()
        };
        this.layout = new DockLayout3({
          document: this._document,
          renderer,
          spacing: options.spacing,
          hiddenMode: options.hiddenMode
        });
        this.overlay = options.overlay || new DockPanel3.Overlay();
        this.node.appendChild(this.overlay.node);
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        this.overlay.hide(0);
        if (this._drag) {
          this._drag.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding widgets.
       */
      get hiddenMode() {
        return this.layout.hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       */
      set hiddenMode(v4) {
        this.layout.hiddenMode = v4;
      }
      /**
       * A signal emitted when the layout configuration is modified.
       *
       * #### Notes
       * This signal is emitted whenever the current layout configuration
       * may have changed.
       *
       * This signal is emitted asynchronously in a collapsed fashion, so
       * that multiple synchronous modifications results in only a single
       * emit of the signal.
       */
      get layoutModified() {
        return this._layoutModified;
      }
      /**
       * A signal emitted when the add button on a tab bar is clicked.
       *
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * The renderer used by the dock panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * Get the spacing between the widgets.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the spacing between the widgets.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * Get the mode for the dock panel.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Set the mode for the dock panel.
       *
       * #### Notes
       * Changing the mode is a destructive operation with respect to the
       * panel's layout configuration. If layout state must be preserved,
       * save the current layout config before changing the mode.
       */
      set mode(value) {
        if (this._mode === value) {
          return;
        }
        this._mode = value;
        this.dataset["mode"] = value;
        let layout = this.layout;
        switch (value) {
          case "multiple-document":
            for (const tabBar of layout.tabBars()) {
              tabBar.show();
            }
            break;
          case "single-document":
            layout.restoreLayout(Private$53.createSingleDocumentConfig(this));
            break;
          default:
            throw "unreachable";
        }
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Whether the tabs can be dragged / moved at runtime.
       */
      get tabsMovable() {
        return this._tabsMovable;
      }
      /**
       * Enable / Disable draggable / movable tabs.
       */
      set tabsMovable(value) {
        this._tabsMovable = value;
        for (const tabBar of this.tabBars()) {
          tabBar.tabsMovable = value;
        }
      }
      /**
       * Whether the tabs are constrained to their source dock panel
       */
      get tabsConstrained() {
        return this._tabsConstrained;
      }
      /**
       * Constrain/Allow tabs to be dragged outside of this dock panel
       */
      set tabsConstrained(value) {
        this._tabsConstrained = value;
      }
      /**
       * Whether the add buttons for each tab bar are enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add buttons for each tab bar are enabled.
       */
      set addButtonEnabled(value) {
        this._addButtonEnabled = value;
        for (const tabBar of this.tabBars()) {
          tabBar.addButtonEnabled = value;
        }
      }
      /**
       * Whether the dock panel is empty.
       */
      get isEmpty() {
        return this.layout.isEmpty;
      }
      /**
       * Create an iterator over the user widgets in the panel.
       *
       * @returns A new iterator over the user widgets in the panel.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      *widgets() {
        yield* this.layout.widgets();
      }
      /**
       * Create an iterator over the selected widgets in the panel.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the panel.
       */
      *selectedWidgets() {
        yield* this.layout.selectedWidgets();
      }
      /**
       * Create an iterator over the tab bars in the panel.
       *
       * @returns A new iterator over the tab bars in the panel.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      *tabBars() {
        yield* this.layout.tabBars();
      }
      /**
       * Create an iterator over the handles in the panel.
       *
       * @returns A new iterator over the handles in the panel.
       */
      *handles() {
        yield* this.layout.handles();
      }
      /**
       * Select a specific widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will make the widget the current widget in its tab area.
       */
      selectWidget(widget) {
        let tabBar = find(this.tabBars(), (bar) => {
          return bar.titles.indexOf(widget.title) !== -1;
        });
        if (!tabBar) {
          throw new Error("Widget is not contained in the dock panel.");
        }
        tabBar.currentTitle = widget.title;
      }
      /**
       * Activate a specified widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will select and activate the given widget.
       */
      activateWidget(widget) {
        this.selectWidget(widget);
        widget.activate();
      }
      /**
       * Save the current layout configuration of the dock panel.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        return this.layout.saveLayout();
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       *
       * The dock panel automatically reverts to `'multiple-document'`
       * mode when a layout config is restored.
       */
      restoreLayout(config) {
        this._mode = "multiple-document";
        this.layout.restoreLayout(config);
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop4.flush();
        }
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Add a widget to the dock panel.
       *
       * @param widget - The widget to add to the dock panel.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * If the panel is in single document mode, the options are ignored
       * and the widget is always added as tab in the hidden tab bar.
       */
      addWidget(widget, options = {}) {
        if (this._mode === "single-document") {
          this.layout.addWidget(widget);
        } else {
          this.layout.addWidget(widget, options);
        }
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       */
      processMessage(msg) {
        if (msg.type === "layout-modified") {
          this._layoutModified.emit(void 0);
        } else {
          super.processMessage(msg);
        }
      }
      /**
       * Handle the DOM events for the dock panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "lm-dragenter":
            this._evtDragEnter(event);
            break;
          case "lm-dragleave":
            this._evtDragLeave(event);
            break;
          case "lm-dragover":
            this._evtDragOver(event);
            break;
          case "lm-drop":
            this._evtDrop(event);
            break;
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("lm-dragenter", this);
        this.node.addEventListener("lm-dragleave", this);
        this.node.addEventListener("lm-dragover", this);
        this.node.addEventListener("lm-drop", this);
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("lm-dragenter", this);
        this.node.removeEventListener("lm-dragleave", this);
        this.node.removeEventListener("lm-dragover", this);
        this.node.removeEventListener("lm-drop", this);
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        if (Private$53.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.addClass("lm-DockPanel-widget");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        if (Private$53.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.removeClass("lm-DockPanel-widget");
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Handle the `'lm-dragenter'` event for the dock panel.
       */
      _evtDragEnter(event) {
        if (event.mimeData.hasData("application/vnd.lumino.widget-factory")) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /**
       * Handle the `'lm-dragleave'` event for the dock panel.
       */
      _evtDragLeave(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this)
          return;
        event.stopPropagation();
        this.overlay.hide(1);
      }
      /**
       * Handle the `'lm-dragover'` event for the dock panel.
       */
      _evtDragOver(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this || this._showOverlay(event.clientX, event.clientY) === "invalid") {
          event.dropAction = "none";
        } else {
          event.stopPropagation();
          event.dropAction = event.proposedAction;
        }
      }
      /**
       * Handle the `'lm-drop'` event for the dock panel.
       */
      _evtDrop(event) {
        event.preventDefault();
        this.overlay.hide(0);
        if (event.proposedAction === "none") {
          event.dropAction = "none";
          return;
        }
        let { clientX, clientY } = event;
        let { zone, target } = Private$53.findDropTarget(this, clientX, clientY, this._edges);
        if (this._tabsConstrained && event.source !== this || zone === "invalid") {
          event.dropAction = "none";
          return;
        }
        let mimeData = event.mimeData;
        let factory = mimeData.getData("application/vnd.lumino.widget-factory");
        if (typeof factory !== "function") {
          event.dropAction = "none";
          return;
        }
        let widget = factory();
        if (!(widget instanceof Widget4)) {
          event.dropAction = "none";
          return;
        }
        if (widget.contains(this)) {
          event.dropAction = "none";
          return;
        }
        let ref = target ? Private$53.getDropRef(target.tabBar) : null;
        switch (zone) {
          case "root-all":
            this.addWidget(widget);
            break;
          case "root-top":
            this.addWidget(widget, { mode: "split-top" });
            break;
          case "root-left":
            this.addWidget(widget, { mode: "split-left" });
            break;
          case "root-right":
            this.addWidget(widget, { mode: "split-right" });
            break;
          case "root-bottom":
            this.addWidget(widget, { mode: "split-bottom" });
            break;
          case "widget-all":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          case "widget-top":
            this.addWidget(widget, { mode: "split-top", ref });
            break;
          case "widget-left":
            this.addWidget(widget, { mode: "split-left", ref });
            break;
          case "widget-right":
            this.addWidget(widget, { mode: "split-right", ref });
            break;
          case "widget-bottom":
            this.addWidget(widget, { mode: "split-bottom", ref });
            break;
          case "widget-tab":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          default:
            throw "unreachable";
        }
        event.dropAction = event.proposedAction;
        event.stopPropagation();
        this.activateWidget(widget);
      }
      /**
       * Handle the `'keydown'` event for the dock panel.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this._releaseMouse();
          MessageLoop4.postMessage(this, Private$53.LayoutModified);
        }
      }
      /**
       * Handle the `'pointerdown'` event for the dock panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let target = event.target;
        let handle = find(layout.handles(), (handle2) => handle2.contains(target));
        if (!handle) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._document.addEventListener("keydown", this, true);
        this._document.addEventListener("pointerup", this, true);
        this._document.addEventListener("pointermove", this, true);
        this._document.addEventListener("contextmenu", this, true);
        let rect = handle.getBoundingClientRect();
        let deltaX = event.clientX - rect.left;
        let deltaY = event.clientY - rect.top;
        let style = window.getComputedStyle(handle);
        let override = Drag3.overrideCursor(style.cursor, this._document);
        this._pressData = { handle, deltaX, deltaY, override };
      }
      /**
       * Handle the `'pointermove'` event for the dock panel.
       */
      _evtPointerMove(event) {
        if (!this._pressData) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let rect = this.node.getBoundingClientRect();
        let xPos = event.clientX - rect.left - this._pressData.deltaX;
        let yPos = event.clientY - rect.top - this._pressData.deltaY;
        let layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
      }
      /**
       * Handle the `'pointerup'` event for the dock panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Release the mouse grab for the dock panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._document.removeEventListener("keydown", this, true);
        this._document.removeEventListener("pointerup", this, true);
        this._document.removeEventListener("pointermove", this, true);
        this._document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Show the overlay indicator at the given client position.
       *
       * Returns the drop zone at the specified client position.
       *
       * #### Notes
       * If the position is not over a valid zone, the overlay is hidden.
       */
      _showOverlay(clientX, clientY) {
        let { zone, target } = Private$53.findDropTarget(this, clientX, clientY, this._edges);
        if (zone === "invalid") {
          this.overlay.hide(100);
          return zone;
        }
        let top;
        let left;
        let right;
        let bottom;
        let box = ElementExt.boxSizing(this.node);
        let rect = this.node.getBoundingClientRect();
        switch (zone) {
          case "root-all":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-top":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = rect.height * Private$53.GOLDEN_RATIO;
            break;
          case "root-left":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = rect.width * Private$53.GOLDEN_RATIO;
            bottom = box.paddingBottom;
            break;
          case "root-right":
            top = box.paddingTop;
            left = rect.width * Private$53.GOLDEN_RATIO;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-bottom":
            top = rect.height * Private$53.GOLDEN_RATIO;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "widget-all":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-top":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height / 2;
            break;
          case "widget-left":
            top = target.top;
            left = target.left;
            right = target.right + target.width / 2;
            bottom = target.bottom;
            break;
          case "widget-right":
            top = target.top;
            left = target.left + target.width / 2;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-bottom":
            top = target.top + target.height / 2;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-tab": {
            const tabHeight = target.tabBar.node.getBoundingClientRect().height;
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height - tabHeight;
            break;
          }
          default:
            throw "unreachable";
        }
        this.overlay.show({ top, left, right, bottom });
        return zone;
      }
      /**
       * Create a new tab bar for use by the panel.
       */
      _createTabBar() {
        let tabBar = this._renderer.createTabBar(this._document);
        Private$53.isGeneratedTabBarProperty.set(tabBar, true);
        if (this._mode === "single-document") {
          tabBar.hide();
        }
        tabBar.tabsMovable = this._tabsMovable;
        tabBar.allowDeselect = false;
        tabBar.addButtonEnabled = this._addButtonEnabled;
        tabBar.removeBehavior = "select-previous-tab";
        tabBar.insertBehavior = "select-tab-if-needed";
        tabBar.tabMoved.connect(this._onTabMoved, this);
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        tabBar.addRequested.connect(this._onTabAddRequested, this);
        return tabBar;
      }
      /**
       * Create a new handle for use by the panel.
       */
      _createHandle() {
        return this._renderer.createHandle();
      }
      /**
       * Handle the `tabMoved` signal from a tab bar.
       */
      _onTabMoved() {
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Handle the `currentChanged` signal from a tab bar.
       */
      _onCurrentChanged(sender, args) {
        let { previousTitle, currentTitle } = args;
        if (previousTitle) {
          previousTitle.owner.hide();
        }
        if (currentTitle) {
          currentTitle.owner.show();
        }
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop4.flush();
        }
        MessageLoop4.postMessage(this, Private$53.LayoutModified);
      }
      /**
       * Handle the `addRequested` signal from a tab bar.
       */
      _onTabAddRequested(sender) {
        this._addRequested.emit(sender);
      }
      /**
       * Handle the `tabActivateRequested` signal from a tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from a tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabDetachRequested` signal from a tab bar.
       */
      _onTabDetachRequested(sender, args) {
        if (this._drag) {
          return;
        }
        sender.releaseMouse();
        let { title, tab, clientX, clientY, offset: offset4 } = args;
        let mimeData = new import_coreutils10.MimeData();
        let factory = () => title.owner;
        mimeData.setData("application/vnd.lumino.widget-factory", factory);
        let dragImage = tab.cloneNode(true);
        if (offset4) {
          dragImage.style.top = `-${offset4.y}px`;
          dragImage.style.left = `-${offset4.x}px`;
        }
        this._drag = new Drag3({
          document: this._document,
          mimeData,
          dragImage,
          proposedAction: "move",
          supportedActions: "move",
          source: this
        });
        tab.classList.add("lm-mod-hidden");
        let cleanup = () => {
          this._drag = null;
          tab.classList.remove("lm-mod-hidden");
        };
        this._drag.start(clientX, clientY).then(cleanup);
      }
    };
    (function(DockPanel5) {
      class Overlay2 {
        /**
         * Construct a new overlay.
         */
        constructor() {
          this._timer = -1;
          this._hidden = true;
          this.node = document.createElement("div");
          this.node.classList.add("lm-DockPanel-overlay");
          this.node.classList.add("lm-mod-hidden");
          this.node.style.position = "absolute";
          this.node.style.contain = "strict";
        }
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo) {
          let style = this.node.style;
          style.top = `${geo.top}px`;
          style.left = `${geo.left}px`;
          style.right = `${geo.right}px`;
          style.bottom = `${geo.bottom}px`;
          clearTimeout(this._timer);
          this._timer = -1;
          if (!this._hidden) {
            return;
          }
          this._hidden = false;
          this.node.classList.remove("lm-mod-hidden");
        }
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay) {
          if (this._hidden) {
            return;
          }
          if (delay <= 0) {
            clearTimeout(this._timer);
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
            return;
          }
          if (this._timer !== -1) {
            return;
          }
          this._timer = window.setTimeout(() => {
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
          }, delay);
        }
      }
      DockPanel5.Overlay = Overlay2;
      class Renderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(document2) {
          let bar = new TabBar4({ document: document2 });
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-DockPanel-handle";
          return handle;
        }
      }
      DockPanel5.Renderer = Renderer;
      DockPanel5.defaultRenderer = new Renderer();
    })(DockPanel3 || (DockPanel3 = {}));
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      Private22.DEFAULT_EDGES = {
        /**
         * The size of the top edge dock zone for the root panel, in pixels.
         * This is different from the others to distinguish between the top
         * tab bar and the top root zone.
         */
        top: 12,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        right: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        bottom: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        left: 40
      };
      Private22.LayoutModified = new ConflatableMessage3("layout-modified");
      Private22.isGeneratedTabBarProperty = new AttachedProperty({
        name: "isGeneratedTabBar",
        create: () => false
      });
      function createSingleDocumentConfig(panel) {
        if (panel.isEmpty) {
          return { main: null };
        }
        let widgets = Array.from(panel.widgets());
        let selected = panel.selectedWidgets().next().value;
        let currentIndex = selected ? widgets.indexOf(selected) : -1;
        return { main: { type: "tab-area", widgets, currentIndex } };
      }
      Private22.createSingleDocumentConfig = createSingleDocumentConfig;
      function findDropTarget(panel, clientX, clientY, edges) {
        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
          return { zone: "invalid", target: null };
        }
        let layout = panel.layout;
        if (layout.isEmpty) {
          return { zone: "root-all", target: null };
        }
        if (panel.mode === "multiple-document") {
          let panelRect = panel.node.getBoundingClientRect();
          let pl = clientX - panelRect.left + 1;
          let pt = clientY - panelRect.top + 1;
          let pr = panelRect.right - clientX;
          let pb = panelRect.bottom - clientY;
          let pd = Math.min(pt, pr, pb, pl);
          switch (pd) {
            case pt:
              if (pt < edges.top) {
                return { zone: "root-top", target: null };
              }
              break;
            case pr:
              if (pr < edges.right) {
                return { zone: "root-right", target: null };
              }
              break;
            case pb:
              if (pb < edges.bottom) {
                return { zone: "root-bottom", target: null };
              }
              break;
            case pl:
              if (pl < edges.left) {
                return { zone: "root-left", target: null };
              }
              break;
            default:
              throw "unreachable";
          }
        }
        let target = layout.hitTestTabAreas(clientX, clientY);
        if (!target) {
          return { zone: "invalid", target: null };
        }
        if (panel.mode === "single-document") {
          return { zone: "widget-all", target };
        }
        let al = target.x - target.left + 1;
        let at = target.y - target.top + 1;
        let ar = target.left + target.width - target.x;
        let ab = target.top + target.height - target.y;
        const tabHeight = target.tabBar.node.getBoundingClientRect().height;
        if (at < tabHeight) {
          return { zone: "widget-tab", target };
        }
        let rx = Math.round(target.width / 3);
        let ry = Math.round(target.height / 3);
        if (al > rx && ar > rx && at > ry && ab > ry) {
          return { zone: "widget-all", target };
        }
        al /= rx;
        at /= ry;
        ar /= rx;
        ab /= ry;
        let ad = Math.min(al, at, ar, ab);
        let zone;
        switch (ad) {
          case al:
            zone = "widget-left";
            break;
          case at:
            zone = "widget-top";
            break;
          case ar:
            zone = "widget-right";
            break;
          case ab:
            zone = "widget-bottom";
            break;
          default:
            throw "unreachable";
        }
        return { zone, target };
      }
      Private22.findDropTarget = findDropTarget;
      function getDropRef(tabBar) {
        if (tabBar.titles.length === 0) {
          return null;
        }
        if (tabBar.currentTitle) {
          return tabBar.currentTitle.owner;
        }
        return tabBar.titles[tabBar.titles.length - 1].owner;
      }
      Private22.getDropRef = getDropRef;
    })(Private$53 || (Private$53 = {}));
    GridLayout3 = class extends Layout3 {
      /**
       * Construct a new grid layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._rowSpacing = 4;
        this._columnSpacing = 4;
        this._items = [];
        this._rowStarts = [];
        this._columnStarts = [];
        this._rowSizers = [new BoxSizer3()];
        this._columnSizers = [new BoxSizer3()];
        this._box = null;
        if (options.rowCount !== void 0) {
          Private$43.reallocSizers(this._rowSizers, options.rowCount);
        }
        if (options.columnCount !== void 0) {
          Private$43.reallocSizers(this._columnSizers, options.columnCount);
        }
        if (options.rowSpacing !== void 0) {
          this._rowSpacing = Private$43.clampValue(options.rowSpacing);
        }
        if (options.columnSpacing !== void 0) {
          this._columnSpacing = Private$43.clampValue(options.columnSpacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          let widget = item.widget;
          item.dispose();
          widget.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._rowStarts.length = 0;
        this._rowSizers.length = 0;
        this._columnStarts.length = 0;
        this._columnSizers.length = 0;
        super.dispose();
      }
      /**
       * Get the number of rows in the layout.
       */
      get rowCount() {
        return this._rowSizers.length;
      }
      /**
       * Set the number of rows in the layout.
       *
       * #### Notes
       * The minimum row count is `1`.
       */
      set rowCount(value) {
        if (value === this.rowCount) {
          return;
        }
        Private$43.reallocSizers(this._rowSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the number of columns in the layout.
       */
      get columnCount() {
        return this._columnSizers.length;
      }
      /**
       * Set the number of columns in the layout.
       *
       * #### Notes
       * The minimum column count is `1`.
       */
      set columnCount(value) {
        if (value === this.columnCount) {
          return;
        }
        Private$43.reallocSizers(this._columnSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the row spacing for the layout.
       */
      get rowSpacing() {
        return this._rowSpacing;
      }
      /**
       * Set the row spacing for the layout.
       */
      set rowSpacing(value) {
        value = Private$43.clampValue(value);
        if (this._rowSpacing === value) {
          return;
        }
        this._rowSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the column spacing for the layout.
       */
      get columnSpacing() {
        return this._columnSpacing;
      }
      /**
       * Set the col spacing for the layout.
       */
      set columnSpacing(value) {
        value = Private$43.clampValue(value);
        if (this._columnSpacing === value) {
          return;
        }
        this._columnSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @returns The stretch factor for the row.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      rowStretch(index2) {
        let sizer = this._rowSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @param value - The stretch factor for the row.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setRowStretch(index2, value) {
        let sizer = this._rowSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$43.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Get the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @returns The stretch factor for the column.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      columnStretch(index2) {
        let sizer = this._columnSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @param value - The stretch factor for the column.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setColumnStretch(index2, value) {
        let sizer = this._columnSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$43.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        for (const item of this._items) {
          yield item.widget;
        }
      }
      /**
       * Add a widget to the grid layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, this is no-op.
       */
      addWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 !== -1) {
          return;
        }
        this._items.push(new LayoutItem3(widget));
        if (this.parent) {
          this.attachWidget(widget);
        }
      }
      /**
       * Remove a widget from the grid layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 === -1) {
          return;
        }
        let item = ArrayExt.removeAt(this._items, i6);
        if (this.parent) {
          this.detachWidget(widget);
        }
        item.dispose();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowSizers[i6].minSize = 0;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnSizers[i6].minSize = 0;
        }
        let items = this._items.filter((it) => !it.isHidden);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          items[i6].fit();
        }
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        items.sort(Private$43.rowSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout3.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          Private$43.distributeMin(this._rowSizers, r1, r22, item.minHeight);
        }
        items.sort(Private$43.columnSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout3.getCellConfig(item.widget);
          let c1 = Math.min(config.column, maxCol);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          Private$43.distributeMin(this._columnSizers, c1, c22, item.minWidth);
        }
        if (this.fitPolicy === "set-no-constraint") {
          MessageLoop4.sendMessage(this.parent, Widget4.Msg.UpdateRequest);
          return;
        }
        let minH = maxRow * this._rowSpacing;
        let minW = maxCol * this._columnSpacing;
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          minH += this._rowSizers[i6].minSize;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          minW += this._columnSizers[i6].minSize;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop4.sendMessage(this.parent.parent, Widget4.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop4.sendMessage(this.parent, Widget4.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        let fixedRowSpace = maxRow * this._rowSpacing;
        let fixedColSpace = maxCol * this._columnSpacing;
        BoxEngine3.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
        BoxEngine3.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
        for (let i6 = 0, pos = top, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowStarts[i6] = pos;
          pos += this._rowSizers[i6].size + this._rowSpacing;
        }
        for (let i6 = 0, pos = left, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnStarts[i6] = pos;
          pos += this._columnSizers[i6].size + this._columnSpacing;
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let config = GridLayout3.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let c1 = Math.min(config.column, maxCol);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          let x2 = this._columnStarts[c1];
          let y4 = this._rowStarts[r1];
          let w3 = this._columnStarts[c22] + this._columnSizers[c22].size - x2;
          let h4 = this._rowStarts[r22] + this._rowSizers[r22].size - y4;
          item.update(x2, y4, w3, h4);
        }
      }
    };
    (function(GridLayout5) {
      function getCellConfig(widget) {
        return Private$43.cellConfigProperty.get(widget);
      }
      GridLayout5.getCellConfig = getCellConfig;
      function setCellConfig(widget, value) {
        Private$43.cellConfigProperty.set(widget, Private$43.normalizeConfig(value));
      }
      GridLayout5.setCellConfig = setCellConfig;
    })(GridLayout3 || (GridLayout3 = {}));
    (function(Private22) {
      Private22.cellConfigProperty = new AttachedProperty({
        name: "cellConfig",
        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
        changed: onChildCellConfigChanged
      });
      function normalizeConfig(config) {
        let row = Math.max(0, Math.floor(config.row || 0));
        let column = Math.max(0, Math.floor(config.column || 0));
        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));
        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));
        return { row, column, rowSpan, columnSpan };
      }
      Private22.normalizeConfig = normalizeConfig;
      function clampValue(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampValue = clampValue;
      function rowSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.rowSpan - c22.rowSpan;
      }
      Private22.rowSpanCmp = rowSpanCmp;
      function columnSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.columnSpan - c22.columnSpan;
      }
      Private22.columnSpanCmp = columnSpanCmp;
      function reallocSizers(sizers, count3) {
        count3 = Math.max(1, Math.floor(count3));
        while (sizers.length < count3) {
          sizers.push(new BoxSizer3());
        }
        if (sizers.length > count3) {
          sizers.length = count3;
        }
      }
      Private22.reallocSizers = reallocSizers;
      function distributeMin(sizers, i1, i22, minSize) {
        if (i22 < i1) {
          return;
        }
        if (i1 === i22) {
          let sizer = sizers[i1];
          sizer.minSize = Math.max(sizer.minSize, minSize);
          return;
        }
        let totalMin = 0;
        for (let i6 = i1; i6 <= i22; ++i6) {
          totalMin += sizers[i6].minSize;
        }
        if (totalMin >= minSize) {
          return;
        }
        let portion = (minSize - totalMin) / (i22 - i1 + 1);
        for (let i6 = i1; i6 <= i22; ++i6) {
          sizers[i6].minSize += portion;
        }
      }
      Private22.distributeMin = distributeMin;
      function onChildCellConfigChanged(child) {
        if (child.parent && child.parent.layout instanceof GridLayout3) {
          child.parent.fit();
        }
      }
    })(Private$43 || (Private$43 = {}));
    MenuBar3 = class extends Widget4 {
      /**
       * Construct a new menu bar.
       *
       * @param options - The options for initializing the menu bar.
       */
      constructor(options = {}) {
        super({ node: Private$33.createNode() });
        this._activeIndex = -1;
        this._tabFocusIndex = 0;
        this._menus = [];
        this._childMenu = null;
        this._overflowMenu = null;
        this._menuItemSizes = [];
        this._overflowIndex = -1;
        this.addClass("lm-MenuBar");
        this.setFlag(Widget4.Flag.DisallowLayout);
        this.renderer = options.renderer || MenuBar3.defaultRenderer;
        this._forceItemsPosition = options.forceItemsPosition || {
          forceX: true,
          forceY: true
        };
        this._overflowMenuOptions = options.overflowMenuOptions || {
          isVisible: true
        };
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._closeChildMenu();
        this._menus.length = 0;
        super.dispose();
      }
      /**
       * The child menu of the menu bar.
       *
       * #### Notes
       * This will be `null` if the menu bar does not have an open menu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The overflow index of the menu bar.
       */
      get overflowIndex() {
        return this._overflowIndex;
      }
      /**
       * The overflow menu of the menu bar.
       */
      get overflowMenu() {
        return this._overflowMenu;
      }
      /**
       * Get the menu bar content node.
       *
       * #### Notes
       * This is the node which holds the menu title nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-MenuBar-content")[0];
      }
      /**
       * Get the currently active menu.
       */
      get activeMenu() {
        return this._menus[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu.
       *
       * #### Notes
       * If the menu does not exist, the menu will be set to `null`.
       */
      set activeMenu(value) {
        this.activeIndex = value ? this._menus.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu.
       *
       * #### Notes
       * This will be `-1` if no menu is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu.
       *
       * #### Notes
       * If the menu cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._menus.length) {
          value = -1;
        }
        if (value > -1 && this._menus[value].items.length === 0) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        this.update();
      }
      /**
       * A read-only array of the menus in the menu bar.
       */
      get menus() {
        return this._menus;
      }
      /**
       * Open the active menu and activate its first menu item.
       *
       * #### Notes
       * If there is no active menu, this is a no-op.
       */
      openActiveMenu() {
        if (this._activeIndex === -1) {
          return;
        }
        this._openChildMenu();
        if (this._childMenu) {
          this._childMenu.activeIndex = -1;
          this._childMenu.activateNextItem();
        }
      }
      /**
       * Add a menu to the end of the menu bar.
       *
       * @param menu - The menu to add to the menu bar.
       *
       * #### Notes
       * If the menu is already added to the menu bar, it will be moved.
       */
      addMenu(menu, update = true) {
        this.insertMenu(this._menus.length, menu, update);
      }
      /**
       * Insert a menu into the menu bar at the specified index.
       *
       * @param index - The index at which to insert the menu.
       *
       * @param menu - The menu to insert into the menu bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the menus.
       *
       * If the menu is already added to the menu bar, it will be moved.
       */
      insertMenu(index2, menu, update = true) {
        this._closeChildMenu();
        let i6 = this._menus.indexOf(menu);
        let j2 = Math.max(0, Math.min(index2, this._menus.length));
        if (i6 === -1) {
          ArrayExt.insert(this._menus, j2, menu);
          menu.addClass("lm-MenuBar-menu");
          menu.aboutToClose.connect(this._onMenuAboutToClose, this);
          menu.menuRequested.connect(this._onMenuMenuRequested, this);
          menu.title.changed.connect(this._onTitleChanged, this);
          if (update) {
            this.update();
          }
          return;
        }
        if (j2 === this._menus.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._menus, i6, j2);
        if (update) {
          this.update();
        }
      }
      /**
       * Remove a menu from the menu bar.
       *
       * @param menu - The menu to remove from the menu bar.
       *
       * #### Notes
       * This is a no-op if the menu is not in the menu bar.
       */
      removeMenu(menu, update = true) {
        this.removeMenuAt(this._menus.indexOf(menu), update);
      }
      /**
       * Remove the menu at a given index from the menu bar.
       *
       * @param index - The index of the menu to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeMenuAt(index2, update = true) {
        this._closeChildMenu();
        let menu = ArrayExt.removeAt(this._menus, index2);
        if (!menu) {
          return;
        }
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        menu.removeClass("lm-MenuBar-menu");
        if (update) {
          this.update();
        }
      }
      /**
       * Remove all menus from the menu bar.
       */
      clearMenus() {
        if (this._menus.length === 0) {
          return;
        }
        this._closeChildMenu();
        for (let menu of this._menus) {
          menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
          menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
          menu.title.changed.disconnect(this._onTitleChanged, this);
          menu.removeClass("lm-MenuBar-menu");
        }
        this._menus.length = 0;
        this.update();
      }
      /**
       * Handle the DOM events for the menu bar.
       *
       * @param event - The DOM event sent to the menu bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu bar's DOM nodes. It
       * should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "mousemove":
          case "mouseleave":
            this._evtMouseMove(event);
            break;
          case "focusout":
            this._evtFocusOut(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mousedown", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("focusout", this);
        this.node.addEventListener("contextmenu", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mousedown", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("focusout", this);
        this.node.removeEventListener("contextmenu", this);
        this._closeChildMenu();
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this._focusItemAt(0);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        this.update();
        super.onResize(msg);
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let menus = this._menus;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
        let totalMenuSize = 0;
        let isVisible2 = false;
        length = this._overflowMenu !== null ? length - 1 : length;
        let content = new Array(length);
        for (let i6 = 0; i6 < length; ++i6) {
          content[i6] = renderer.renderItem({
            title: menus[i6].title,
            active: i6 === activeIndex,
            tabbable: i6 === tabFocusIndex,
            disabled: menus[i6].items.length === 0,
            onfocus: () => {
              this._tabFocusIndex = i6;
              this.activeIndex = i6;
            }
          });
          totalMenuSize += this._menuItemSizes[i6];
          if (menus[i6].title.label === this._overflowMenuOptions.title) {
            isVisible2 = true;
            length--;
          }
        }
        if (this._overflowMenuOptions.isVisible) {
          if (this._overflowIndex > -1 && !isVisible2) {
            if (this._overflowMenu === null) {
              const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
              this._overflowMenu = new Menu3({ commands: new CommandRegistry() });
              this._overflowMenu.title.label = overflowMenuTitle;
              this._overflowMenu.title.mnemonic = 0;
              this.addMenu(this._overflowMenu, false);
            }
            for (let i6 = menus.length - 2; i6 >= length; i6--) {
              const submenu = this.menus[i6];
              submenu.title.mnemonic = 0;
              this._overflowMenu.insertItem(0, {
                type: "submenu",
                submenu
              });
              this.removeMenu(submenu, false);
            }
            content[length] = renderer.renderItem({
              title: this._overflowMenu.title,
              active: length === activeIndex && menus[length].items.length !== 0,
              tabbable: length === tabFocusIndex,
              disabled: menus[length].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length;
                this.activeIndex = length;
              }
            });
            length++;
          } else if (this._overflowMenu !== null) {
            let overflowMenuItems = this._overflowMenu.items;
            let screenSize = this.node.offsetWidth;
            let n5 = this._overflowMenu.items.length;
            for (let i6 = 0; i6 < n5; ++i6) {
              let index2 = menus.length - 1 - i6;
              if (screenSize - totalMenuSize > this._menuItemSizes[index2]) {
                let menu = overflowMenuItems[0].submenu;
                this._overflowMenu.removeItemAt(0);
                this.insertMenu(length, menu, false);
                content[length] = renderer.renderItem({
                  title: menu.title,
                  active: false,
                  tabbable: length === tabFocusIndex,
                  disabled: menus[length].items.length === 0,
                  onfocus: () => {
                    this._tabFocusIndex = length;
                    this.activeIndex = length;
                  }
                });
                length++;
              }
            }
            if (this._overflowMenu.items.length === 0) {
              this.removeMenu(this._overflowMenu, false);
              content.pop();
              this._overflowMenu = null;
              this._overflowIndex = -1;
            }
          }
        }
        VirtualDOM.render(content, this.contentNode);
        this._updateOverflowIndex();
      }
      /**
       * Calculate and update the current overflow index.
       */
      _updateOverflowIndex() {
        if (!this._overflowMenuOptions.isVisible) {
          return;
        }
        const itemMenus = this.contentNode.childNodes;
        let screenSize = this.node.offsetWidth;
        let totalMenuSize = 0;
        let index2 = -1;
        let n5 = itemMenus.length;
        if (this._menuItemSizes.length == 0) {
          for (let i6 = 0; i6 < n5; i6++) {
            let item = itemMenus[i6];
            totalMenuSize += item.offsetWidth;
            this._menuItemSizes.push(item.offsetWidth);
            if (totalMenuSize > screenSize && index2 === -1) {
              index2 = i6;
            }
          }
        } else {
          for (let i6 = 0; i6 < this._menuItemSizes.length; i6++) {
            totalMenuSize += this._menuItemSizes[i6];
            if (totalMenuSize > screenSize) {
              index2 = i6;
              break;
            }
          }
        }
        this._overflowIndex = index2;
      }
      /**
       * Handle the `'keydown'` event for the menu bar.
       *
       * #### Notes
       * All keys are trapped except the tab key that is ignored.
       */
      _evtKeyDown(event) {
        let kc = event.keyCode;
        if (kc === 9) {
          this.activeIndex = -1;
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
          this.activeIndex = this._tabFocusIndex;
          if (this.activeIndex !== this._tabFocusIndex) {
            return;
          }
          this.openActiveMenu();
          return;
        }
        if (kc === 27) {
          this._closeChildMenu();
          this._focusItemAt(this.activeIndex);
          return;
        }
        if (kc === 37 || kc === 39) {
          let direction = kc === 37 ? -1 : 1;
          let start2 = this._tabFocusIndex + direction;
          let n5 = this._menus.length;
          for (let i6 = 0; i6 < n5; i6++) {
            let index2 = (n5 + start2 + direction * i6) % n5;
            if (this._menus[index2].items.length) {
              this._focusItemAt(index2);
              return;
            }
          }
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$33.findMnemonic(this._menus, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.openActiveMenu();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
          this._focusItemAt(this.activeIndex);
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
          this._focusItemAt(this.activeIndex);
        }
      }
      /**
       * Handle the `'mousedown'` event for the menu bar.
       */
      _evtMouseDown(event) {
        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {
          return;
        }
        event.stopPropagation();
        event.stopImmediatePropagation();
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          this._closeChildMenu();
          return;
        }
        if (event.button !== 0) {
          return;
        }
        if (this._childMenu) {
          this._closeChildMenu();
          this.activeIndex = index2;
        } else {
          event.preventDefault();
          const position = this._positionForMenu(index2);
          Menu3.saveWindowData();
          this.activeIndex = index2;
          this._openChildMenu(position);
        }
      }
      /**
       * Handle the `'mousemove'` event for the menu bar.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        if (index2 === -1 && this._childMenu) {
          return;
        }
        const position = index2 >= 0 && this._childMenu ? this._positionForMenu(index2) : null;
        Menu3.saveWindowData();
        this.activeIndex = index2;
        if (position) {
          this._openChildMenu(position);
        }
      }
      /**
       * Find initial position for the menu based on menubar item position.
       *
       * NOTE: this should be called before updating active index to avoid
       * an additional layout and style invalidation as changing active
       * index modifies DOM.
       */
      _positionForMenu(index2) {
        let itemNode = this.contentNode.children[index2];
        let { left, bottom } = itemNode.getBoundingClientRect();
        return {
          top: bottom,
          left
        };
      }
      /**
       * Handle the `'focusout'` event for the menu bar.
       */
      _evtFocusOut(event) {
        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {
          this.activeIndex = -1;
        }
      }
      /**
       * Focus an item in the menu bar.
       *
       * #### Notes
       * Does not open the associated menu.
       */
      _focusItemAt(index2) {
        const itemNode = this.contentNode.childNodes[index2];
        if (itemNode) {
          itemNode.focus();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if there is no active menu.
       */
      _openChildMenu(options = {}) {
        let newMenu = this.activeMenu;
        if (!newMenu) {
          this._closeChildMenu();
          return;
        }
        let oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
          return;
        }
        this._childMenu = newMenu;
        if (oldMenu) {
          oldMenu.close();
        } else {
          document.addEventListener("mousedown", this, true);
        }
        this._tabFocusIndex = this.activeIndex;
        MessageLoop4.sendMessage(this, Widget4.Msg.UpdateRequest);
        let { left, top } = options;
        if (typeof left === "undefined" || typeof top === "undefined") {
          ({ left, top } = this._positionForMenu(this._activeIndex));
        }
        if (!oldMenu) {
          this.addClass("lm-mod-active");
        }
        if (newMenu.items.length > 0) {
          newMenu.open(left, top, this._forceItemsPosition);
        }
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (!this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        let menu = this._childMenu;
        this._childMenu = null;
        menu.close();
        this.activeIndex = -1;
      }
      /**
       * Handle the `aboutToClose` signal of a menu.
       */
      _onMenuAboutToClose(sender) {
        if (sender !== this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        this._childMenu = null;
        this.activeIndex = -1;
      }
      /**
       * Handle the `menuRequested` signal of a child menu.
       */
      _onMenuMenuRequested(sender, args) {
        if (sender !== this._childMenu) {
          return;
        }
        let i6 = this._activeIndex;
        let n5 = this._menus.length;
        switch (args) {
          case "next":
            this.activeIndex = i6 === n5 - 1 ? 0 : i6 + 1;
            break;
          case "previous":
            this.activeIndex = i6 === 0 ? n5 - 1 : i6 - 1;
            break;
        }
        this.openActiveMenu();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged() {
        this.update();
      }
    };
    (function(MenuBar5) {
      class Renderer {
        /**
         * Render the virtual element for a menu bar item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data));
        }
        /**
         * Render the icon element for a menu bar item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.title.icon, data.title.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-MenuBar-itemLabel" }, content);
        }
        /**
         * Create the class name for the menu bar item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-MenuBar-item";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.active && !data.disabled) {
            name += " lm-mod-active";
          }
          return name;
        }
        /**
         * Create the dataset for a menu bar item.
         *
         * @param data - The data to use for the item.
         *
         * @returns The dataset for the menu bar item.
         */
        createItemDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the aria attributes for menu bar item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          return {
            role: "menuitem",
            "aria-haspopup": "true",
            "aria-disabled": data.disabled ? "true" : "false"
          };
        }
        /**
         * Create the class name for the menu bar item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-MenuBar-itemIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.title;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
      }
      MenuBar5.Renderer = Renderer;
      MenuBar5.defaultRenderer = new Renderer();
    })(MenuBar3 || (MenuBar3 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-MenuBar-content";
        node.appendChild(content);
        content.setAttribute("role", "menubar");
        return node;
      }
      Private22.createNode = createNode;
      function findMnemonic(menus, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = menus.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let title = menus[k2].title;
          if (title.label.length === 0) {
            continue;
          }
          let mn = title.mnemonic;
          if (mn >= 0 && mn < title.label.length) {
            if (title.label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
    })(Private$33 || (Private$33 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let decrement = document.createElement("div");
        let increment = document.createElement("div");
        let track = document.createElement("div");
        let thumb = document.createElement("div");
        decrement.className = "lm-ScrollBar-button";
        increment.className = "lm-ScrollBar-button";
        decrement.dataset["action"] = "decrement";
        increment.dataset["action"] = "increment";
        track.className = "lm-ScrollBar-track";
        thumb.className = "lm-ScrollBar-thumb";
        track.appendChild(thumb);
        node.appendChild(decrement);
        node.appendChild(track);
        node.appendChild(increment);
        return node;
      }
      Private22.createNode = createNode;
      function findPart(scrollBar, target) {
        if (scrollBar.thumbNode.contains(target)) {
          return "thumb";
        }
        if (scrollBar.trackNode.contains(target)) {
          return "track";
        }
        if (scrollBar.decrementNode.contains(target)) {
          return "decrement";
        }
        if (scrollBar.incrementNode.contains(target)) {
          return "increment";
        }
        return null;
      }
      Private22.findPart = findPart;
    })(Private$23 || (Private$23 = {}));
    SingletonLayout3 = class extends Layout3 {
      constructor() {
        super(...arguments);
        this._widget = null;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this._widget) {
          let widget = this._widget;
          this._widget = null;
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * Get the child widget for the layout.
       */
      get widget() {
        return this._widget;
      }
      /**
       * Set the child widget for the layout.
       *
       * #### Notes
       * Setting the child widget will cause the old child widget to be
       * automatically disposed. If that is not desired, set the parent
       * of the old child to `null` before assigning a new child.
       */
      set widget(widget) {
        if (widget) {
          widget.parent = this.parent;
        }
        if (this._widget === widget) {
          return;
        }
        if (this._widget) {
          this._widget.dispose();
        }
        this._widget = widget;
        if (this.parent && widget) {
          this.attachWidget(widget);
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        if (this._widget) {
          yield this._widget;
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        if (this._widget !== widget) {
          return;
        }
        this._widget = null;
        if (this.parent) {
          this.detachWidget(widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
      }
    };
    StackedLayout3 = class extends PanelLayout4 {
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._items = [];
        this._box = null;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget4.HiddenMode.Display;
      }
      /**
       * The method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        if (this.widgets.length > 1) {
          this.widgets.forEach((w3) => {
            w3.hiddenMode = this._hiddenMode;
          });
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        super.dispose();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        if (this._hiddenMode === Widget4.HiddenMode.Scale && this._items.length > 0) {
          if (this._items.length === 1) {
            this.widgets[0].hiddenMode = Widget4.HiddenMode.Scale;
          }
          widget.hiddenMode = Widget4.HiddenMode.Scale;
        } else {
          widget.hiddenMode = Widget4.HiddenMode.Display;
        }
        ArrayExt.insert(this._items, index2, new LayoutItem3(widget));
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop4.sendMessage(widget, Widget4.Msg.AfterDetach);
        }
        item.widget.node.style.zIndex = "";
        if (this._hiddenMode === Widget4.HiddenMode.Scale) {
          widget.hiddenMode = Widget4.HiddenMode.Display;
          if (this._items.length === 1) {
            this._items[0].widget.hiddenMode = Widget4.HiddenMode.Display;
          }
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.fit();
          minW = Math.max(minW, item.minWidth);
          minH = Math.max(minH, item.minHeight);
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop4.sendMessage(this.parent.parent, Widget4.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop4.sendMessage(this.parent, Widget4.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.widget.node.style.zIndex = `${i6}`;
          item.update(left, top, width, height);
        }
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new StackedLayout3();
      }
      Private22.createLayout = createLayout;
    })(Private$13 || (Private$13 = {}));
    (function(Private22) {
      function orientationFromPlacement(plc) {
        return placementToOrientationMap[plc];
      }
      Private22.orientationFromPlacement = orientationFromPlacement;
      function directionFromPlacement(plc) {
        return placementToDirectionMap[plc];
      }
      Private22.directionFromPlacement = directionFromPlacement;
      const placementToOrientationMap = {
        top: "horizontal",
        left: "vertical",
        right: "vertical",
        bottom: "horizontal"
      };
      const placementToDirectionMap = {
        top: "top-to-bottom",
        left: "left-to-right",
        right: "right-to-left",
        bottom: "bottom-to-top"
      };
    })(Private16 || (Private16 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/widget.js
var import_services2, import_coreutils11, OUTPUT_AREA_CLASS, OUTPUT_AREA_ITEM_CLASS, OUTPUT_AREA_OUTPUT_CLASS, OUTPUT_AREA_PROMPT_CLASS, OUTPUT_AREA_STDIN_HIDING_CLASS, OUTPUT_PROMPT_CLASS, EXECUTE_CLASS, OUTPUT_AREA_STDIN_ITEM_CLASS, STDIN_CLASS, STDIN_PROMPT_CLASS, STDIN_INPUT_CLASS, OUTPUT_PROMPT_OVERLAY, OutputArea, OutputPrompt, Stdin, Private17;
var init_widget = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/widget.js"() {
    init_lib3();
    import_services2 = __toESM(require_lib2());
    init_lib();
    import_coreutils11 = __toESM(require_dist());
    init_index_es64();
    init_index_es62();
    init_index_es622();
    OUTPUT_AREA_CLASS = "jp-OutputArea";
    OUTPUT_AREA_ITEM_CLASS = "jp-OutputArea-child";
    OUTPUT_AREA_OUTPUT_CLASS = "jp-OutputArea-output";
    OUTPUT_AREA_PROMPT_CLASS = "jp-OutputArea-prompt";
    OUTPUT_AREA_STDIN_HIDING_CLASS = "jp-OutputArea-stdin-hiding";
    OUTPUT_PROMPT_CLASS = "jp-OutputPrompt";
    EXECUTE_CLASS = "jp-OutputArea-executeResult";
    OUTPUT_AREA_STDIN_ITEM_CLASS = "jp-OutputArea-stdin-item";
    STDIN_CLASS = "jp-Stdin";
    STDIN_PROMPT_CLASS = "jp-Stdin-prompt";
    STDIN_INPUT_CLASS = "jp-Stdin-input";
    OUTPUT_PROMPT_OVERLAY = "jp-OutputArea-promptOverlay";
    OutputArea = class extends Widget4 {
      /**
       * Construct an output area widget.
       */
      constructor(options) {
        var _a, _b, _c, _d, _e2;
        super();
        this.outputLengthChanged = new Signal(this);
        this._onIOPub = (msg) => {
          const model2 = this.model;
          const msgType = msg.header.msg_type;
          let output;
          const transient = msg.content.transient || {};
          const displayId = transient["display_id"];
          let targets;
          switch (msgType) {
            case "execute_result":
            case "display_data":
            case "stream":
            case "error":
              output = { ...msg.content, output_type: msgType };
              model2.add(output);
              break;
            case "clear_output": {
              const wait = msg.content.wait;
              model2.clear(wait);
              break;
            }
            case "update_display_data":
              output = { ...msg.content, output_type: "display_data" };
              targets = this._displayIdMap.get(displayId);
              if (targets) {
                for (const index2 of targets) {
                  model2.set(index2, output);
                }
              }
              break;
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "idle") {
                this._pendingInput = false;
              }
              break;
            }
            default:
              break;
          }
          if (displayId && msgType === "display_data") {
            targets = this._displayIdMap.get(displayId) || [];
            targets.push(model2.length - 1);
            this._displayIdMap.set(displayId, targets);
          }
        };
        this._onExecuteReply = (msg) => {
          const model2 = this.model;
          const content = msg.content;
          if (content.status !== "ok") {
            return;
          }
          const payload = content && content.payload;
          if (!payload || !payload.length) {
            return;
          }
          const pages = payload.filter((i6) => i6.source === "page");
          if (!pages.length) {
            return;
          }
          const page = JSON.parse(JSON.stringify(pages[0]));
          const output = {
            output_type: "display_data",
            data: page.data,
            metadata: {}
          };
          model2.add(output);
        };
        this._displayIdMap = /* @__PURE__ */ new Map();
        this._minHeightTimeout = null;
        this._inputRequested = new Signal(this);
        this._toggleScrolling = new Signal(this);
        this._initialize = new Signal(this);
        this._outputTracker = new WidgetTracker({
          namespace: import_coreutils11.UUID.uuid4()
        });
        this._inputHistoryScope = "global";
        this._pendingInput = false;
        this._showInputPlaceholder = true;
        super.layout = new PanelLayout4();
        this.addClass(OUTPUT_AREA_CLASS);
        this.contentFactory = (_a = options.contentFactory) !== null && _a !== void 0 ? _a : OutputArea.defaultContentFactory;
        this.rendermime = options.rendermime;
        this._maxNumberOutputs = (_b = options.maxNumberOutputs) !== null && _b !== void 0 ? _b : Infinity;
        this._translator = (_c = options.translator) !== null && _c !== void 0 ? _c : nullTranslator;
        this._inputHistoryScope = (_d = options.inputHistoryScope) !== null && _d !== void 0 ? _d : "global";
        this._showInputPlaceholder = (_e2 = options.showInputPlaceholder) !== null && _e2 !== void 0 ? _e2 : true;
        const model = this.model = options.model;
        for (let i6 = 0; i6 < Math.min(model.length, this._maxNumberOutputs + 1); i6++) {
          const output = model.get(i6);
          this._insertOutput(i6, output);
          if (output.type === "stream") {
            output.streamText.changed.connect((sender, event) => {
              this._setOutput(i6, output);
            });
          }
        }
        model.changed.connect(this.onModelChanged, this);
        model.stateChanged.connect(this.onStateChanged, this);
        if (options.promptOverlay) {
          this._addPromptOverlay();
        }
      }
      /**
       * Narrow the type of OutputArea's layout prop
       */
      get layout() {
        return super.layout;
      }
      /**
       * A read-only sequence of the children widgets in the output area.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * The kernel future associated with the output area.
       */
      get future() {
        return this._future;
      }
      set future(value) {
        if (this.model.isDisposed) {
          throw Error("Model is disposed");
        }
        if (this._future === value) {
          return;
        }
        if (this._future) {
          this._future.dispose();
        }
        this._future = value;
        value.done.finally(() => {
          this._pendingInput = false;
        }).catch(() => {
        });
        this.model.clear();
        if (this.widgets.length) {
          this._clear();
          this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
        }
        value.onIOPub = this._onIOPub;
        value.onReply = this._onExecuteReply;
        value.onStdin = (msg) => {
          if (import_services2.KernelMessage.isInputRequestMsg(msg)) {
            this.onInputRequest(msg, value);
          }
        };
      }
      /**
       * Signal emitted when an output area is requesting an input. The signal
       * carries the input widget that this class creates in response to the input
       * request.
       */
      get inputRequested() {
        return this._inputRequested;
      }
      /**
       * A flag indicating if the output area has pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The maximum number of output items to display on top and bottom of cell output.
       *
       * ### Notes
       * It is set to Infinity if no trim is applied.
       */
      get maxNumberOutputs() {
        return this._maxNumberOutputs;
      }
      set maxNumberOutputs(limit) {
        if (limit <= 0) {
          console.warn(`OutputArea.maxNumberOutputs must be strictly positive.`);
          return;
        }
        const lastShown = this._maxNumberOutputs;
        this._maxNumberOutputs = limit;
        if (lastShown < limit) {
          this._showTrimmedOutputs(lastShown);
        }
      }
      /**
       * Dispose of the resources used by the output area.
       */
      dispose() {
        if (this._future) {
          this._future.dispose();
          this._future = null;
        }
        this._displayIdMap.clear();
        this._outputTracker.dispose();
        super.dispose();
      }
      /**
       * Follow changes on the model state.
       */
      onModelChanged(sender, args) {
        switch (args.type) {
          case "add":
            const output = args.newValues[0];
            this._insertOutput(args.newIndex, output);
            if (output.type === "stream") {
              output.streamText.changed.connect((sender2, event) => {
                this._setOutput(args.newIndex, output);
              });
            }
            break;
          case "remove":
            if (this.widgets.length) {
              if (this.model.length === 0) {
                this._clear();
              } else {
                const startIndex = args.oldIndex;
                for (let i6 = 0; i6 < args.oldValues.length && startIndex < this.widgets.length; ++i6) {
                  const widget = this.widgets[startIndex];
                  widget.parent = null;
                  widget.dispose();
                }
                this._moveDisplayIdIndices(startIndex, args.oldValues.length);
                this._preventHeightChangeJitter();
              }
            }
            break;
          case "clear":
            this._clear();
            break;
          case "set":
            this._setOutput(args.newIndex, args.newValues[0]);
            break;
          default:
            break;
        }
        this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
      }
      /**
       * Emitted when user requests toggling of the output scrolling mode.
       */
      get toggleScrolling() {
        return this._toggleScrolling;
      }
      get initialize() {
        return this._initialize;
      }
      /**
       * Add overlay allowing to toggle scrolling.
       */
      _addPromptOverlay() {
        const overlay = document.createElement("div");
        overlay.className = OUTPUT_PROMPT_OVERLAY;
        overlay.addEventListener("click", () => {
          this._toggleScrolling.emit();
        });
        this.node.appendChild(overlay);
        const resize = () => {
          const panel = this.node.querySelector(".jp-OutputArea-child");
          if (panel) {
            overlay.style.height = `${Math.max(panel.getBoundingClientRect().height, this.node.getBoundingClientRect().height)}px`;
          }
        };
        const observer = new ResizeObserver(resize);
        observer.observe(this.node);
        this.disposed.connect(() => {
          observer.disconnect();
        });
        requestAnimationFrame(() => {
          this._initialize.emit();
        });
      }
      /**
       * Update indices in _displayIdMap in response to element remove from model items
       *
       * @param startIndex - The index of first element removed
       *
       * @param count - The number of elements removed from model items
       *
       */
      _moveDisplayIdIndices(startIndex, count3) {
        this._displayIdMap.forEach((indices) => {
          const rangeEnd = startIndex + count3;
          const numIndices = indices.length;
          for (let i6 = numIndices - 1; i6 >= 0; --i6) {
            const index2 = indices[i6];
            if (index2 >= startIndex && index2 < rangeEnd) {
              indices.splice(i6, 1);
            } else if (index2 >= rangeEnd) {
              indices[i6] -= count3;
            }
          }
        });
      }
      /**
       * Follow changes on the output model state.
       */
      onStateChanged(sender, change) {
        const outputLength = Math.min(this.model.length, this._maxNumberOutputs);
        if (change) {
          if (change >= this._maxNumberOutputs) {
            return;
          }
          this._setOutput(change, this.model.get(change));
        } else {
          for (let i6 = 0; i6 < outputLength; i6++) {
            this._setOutput(i6, this.model.get(i6));
          }
        }
        this.outputLengthChanged.emit(outputLength);
      }
      /**
       * Clear the widget outputs.
       */
      _clear() {
        if (!this.widgets.length) {
          return;
        }
        const length = this.widgets.length;
        for (let i6 = 0; i6 < length; i6++) {
          const widget = this.widgets[0];
          widget.parent = null;
          widget.dispose();
        }
        this._displayIdMap.clear();
        this._preventHeightChangeJitter();
      }
      _preventHeightChangeJitter() {
        const rect = this.node.getBoundingClientRect();
        this.node.style.minHeight = `${rect.height}px`;
        if (this._minHeightTimeout) {
          window.clearTimeout(this._minHeightTimeout);
        }
        this._minHeightTimeout = window.setTimeout(() => {
          if (this.isDisposed) {
            return;
          }
          this.node.style.minHeight = "";
        }, 50);
      }
      /**
       * Handle an input request from a kernel.
       */
      onInputRequest(msg, future) {
        const factory = this.contentFactory;
        const stdinPrompt = msg.content.prompt;
        const password = msg.content.password;
        const panel = new Panel4();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        panel.addClass(OUTPUT_AREA_STDIN_ITEM_CLASS);
        const prompt = factory.createOutputPrompt();
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        this._pendingInput = true;
        const input = factory.createStdin({
          parent_header: msg.header,
          prompt: stdinPrompt,
          password,
          future,
          translator: this._translator,
          inputHistoryScope: this._inputHistoryScope,
          showInputPlaceholder: this._showInputPlaceholder
        });
        input.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(input);
        if (this.model.length >= this.maxNumberOutputs) {
          this.maxNumberOutputs = this.model.length;
        }
        this._inputRequested.emit(input);
        const inputNode = input.node.getElementsByTagName("input")[0];
        void input.value.then((value) => {
          if (this.model.length >= this.maxNumberOutputs) {
            this.maxNumberOutputs = this.model.length + 1;
          }
          panel.addClass(OUTPUT_AREA_STDIN_HIDING_CLASS);
          this.model.add({
            output_type: "stream",
            name: "stdin",
            text: value + "\n"
          });
          inputNode.focus();
          this._pendingInput = false;
          window.setTimeout(() => {
            const focusedElement = document.activeElement;
            panel.dispose();
            if (focusedElement && focusedElement instanceof HTMLElement) {
              focusedElement.focus();
            }
          }, 500);
        });
        this.layout.addWidget(panel);
      }
      /**
       * Update an output in the layout in place.
       */
      _setOutput(index2, model) {
        if (index2 >= this._maxNumberOutputs) {
          return;
        }
        const panel = this.layout.widgets[index2];
        const renderer = panel.widgets ? panel.widgets.filter((it) => "renderModel" in it).pop() : panel;
        const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
        if (Private17.currentPreferredMimetype.get(renderer) === mimeType && OutputArea.isIsolated(mimeType, model.metadata) === renderer instanceof Private17.IsolatedRenderer) {
          void renderer.renderModel(model);
        } else {
          this.layout.widgets[index2].dispose();
          this._insertOutput(index2, model);
        }
      }
      /**
       * Render and insert a single output into the layout.
       *
       * @param index - The index of the output to be inserted.
       * @param model - The model of the output to be inserted.
       */
      _insertOutput(index2, model) {
        if (index2 > this._maxNumberOutputs) {
          return;
        }
        const layout = this.layout;
        if (index2 === this._maxNumberOutputs) {
          const warning = new Private17.TrimmedOutputs(this._maxNumberOutputs, () => {
            const lastShown = this._maxNumberOutputs;
            this._maxNumberOutputs = Infinity;
            this._showTrimmedOutputs(lastShown);
          }, this._translator);
          layout.insertWidget(index2, this._wrappedOutput(warning));
        } else {
          let output = this.createOutputItem(model);
          if (output) {
            output.toggleClass(EXECUTE_CLASS, model.executionCount !== null);
          } else {
            output = new Widget4();
          }
          if (!this._outputTracker.has(output)) {
            void this._outputTracker.add(output);
          }
          layout.insertWidget(index2, output);
        }
      }
      /**
       * A widget tracker for individual output widgets in the output area.
       */
      get outputTracker() {
        return this._outputTracker;
      }
      /**
       * Dispose information message and show output models from the given
       * index to maxNumberOutputs
       *
       * @param lastShown Starting model index to insert.
       */
      _showTrimmedOutputs(lastShown) {
        this.widgets[lastShown].dispose();
        for (let idx = lastShown; idx < this.model.length; idx++) {
          this._insertOutput(idx, this.model.get(idx));
        }
        this.outputLengthChanged.emit(Math.min(this.model.length, this._maxNumberOutputs));
      }
      /**
       * Create an output item with a prompt and actual output
       *
       * @returns a rendered widget, or null if we cannot render
       * #### Notes
       */
      createOutputItem(model) {
        const output = this.createRenderedMimetype(model);
        if (!output) {
          return null;
        }
        return this._wrappedOutput(output, model.executionCount);
      }
      /**
       * Render a mimetype
       */
      createRenderedMimetype(model) {
        const mimeType = this.rendermime.preferredMimeType(model.data, model.trusted ? "any" : "ensure");
        if (!mimeType) {
          return null;
        }
        let output = this.rendermime.createRenderer(mimeType);
        const isolated = OutputArea.isIsolated(mimeType, model.metadata);
        if (isolated === true) {
          output = new Private17.IsolatedRenderer(output);
        }
        Private17.currentPreferredMimetype.set(output, mimeType);
        output.renderModel(model).catch((error) => {
          const pre = document.createElement("pre");
          const trans = this._translator.load("jupyterlab");
          pre.textContent = trans.__("Javascript Error: %1", error.message);
          output.node.appendChild(pre);
          output.node.className = "lm-Widget jp-RenderedText";
          output.node.setAttribute("data-mime-type", "application/vnd.jupyter.stderr");
        });
        return output;
      }
      /**
       * Wrap a output widget within a output panel
       *
       * @param output Output widget to wrap
       * @param executionCount Execution count
       * @returns The output panel
       */
      _wrappedOutput(output, executionCount = null) {
        const panel = new Private17.OutputPanel();
        panel.addClass(OUTPUT_AREA_ITEM_CLASS);
        const prompt = this.contentFactory.createOutputPrompt();
        prompt.executionCount = executionCount;
        prompt.addClass(OUTPUT_AREA_PROMPT_CLASS);
        panel.addWidget(prompt);
        output.addClass(OUTPUT_AREA_OUTPUT_CLASS);
        panel.addWidget(output);
        return panel;
      }
    };
    (function(OutputArea2) {
      async function execute(code3, output, sessionContext, metadata) {
        var _a;
        let stopOnError = true;
        if (metadata && Array.isArray(metadata.tags) && metadata.tags.indexOf("raises-exception") !== -1) {
          stopOnError = false;
        }
        const content = {
          code: code3,
          stop_on_error: stopOnError
        };
        const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel) {
          throw new Error("Session has no kernel.");
        }
        const future = kernel.requestExecute(content, false, metadata);
        output.future = future;
        return future.done;
      }
      OutputArea2.execute = execute;
      function isIsolated(mimeType, metadata) {
        const mimeMd = metadata[mimeType];
        if (mimeMd && mimeMd["isolated"] !== void 0) {
          return !!mimeMd["isolated"];
        } else {
          return !!metadata["isolated"];
        }
      }
      OutputArea2.isIsolated = isIsolated;
      class ContentFactory {
        /**
         * Create the output prompt for the widget.
         */
        createOutputPrompt() {
          return new OutputPrompt();
        }
        /**
         * Create an stdin widget.
         */
        createStdin(options) {
          return new Stdin(options);
        }
      }
      OutputArea2.ContentFactory = ContentFactory;
      OutputArea2.defaultContentFactory = new ContentFactory();
    })(OutputArea || (OutputArea = {}));
    OutputPrompt = class extends Widget4 {
      /*
       * Create an output prompt widget.
       */
      constructor() {
        super();
        this._executionCount = null;
        this.addClass(OUTPUT_PROMPT_CLASS);
      }
      /**
       * The execution count for the prompt.
       */
      get executionCount() {
        return this._executionCount;
      }
      set executionCount(value) {
        this._executionCount = value;
        if (value === null) {
          this.node.textContent = "";
        } else {
          this.node.textContent = `[${value}]:`;
        }
      }
    };
    Stdin = class extends Widget4 {
      static _historyIx(key, ix) {
        const history2 = Stdin._history.get(key);
        if (!history2) {
          return void 0;
        }
        const len = history2.length;
        if (ix <= 0) {
          return len + ix;
        }
      }
      static _historyAt(key, ix) {
        const history2 = Stdin._history.get(key);
        if (!history2) {
          return void 0;
        }
        const len = history2.length;
        const ixpos = Stdin._historyIx(key, ix);
        if (ixpos !== void 0 && ixpos < len) {
          return history2[ixpos];
        }
      }
      static _historyPush(key, line) {
        const history2 = Stdin._history.get(key);
        history2.push(line);
        if (history2.length > 1e3) {
          history2.shift();
        }
      }
      static _historySearch(key, pat, ix, reverse = true) {
        const history2 = Stdin._history.get(key);
        const len = history2.length;
        const ixpos = Stdin._historyIx(key, ix);
        const substrFound = (x2) => x2.search(pat) !== -1;
        if (ixpos === void 0) {
          return;
        }
        if (reverse) {
          if (ixpos === 0) {
            return;
          }
          const ixFound = history2.slice(0, ixpos).findLastIndex(substrFound);
          if (ixFound !== -1) {
            return ixFound - len;
          }
        } else {
          if (ixpos >= len - 1) {
            return;
          }
          const ixFound = history2.slice(ixpos + 1).findIndex(substrFound);
          if (ixFound !== -1) {
            return ixFound - len + ixpos + 1;
          }
        }
      }
      /**
       * Construct a new input widget.
       */
      constructor(options) {
        var _a;
        super({
          node: Private17.createInputWidgetNode(options.prompt, options.password)
        });
        this._promise = new import_coreutils11.PromiseDelegate();
        this._resolved = false;
        this.addClass(STDIN_CLASS);
        this._future = options.future;
        this._historyIndex = 0;
        this._historyKey = options.inputHistoryScope === "session" ? options.parent_header.session : "";
        this._historyPat = "";
        this._parentHeader = options.parent_header;
        this._password = options.password;
        this._trans = ((_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator).load("jupyterlab");
        this._value = options.prompt + " ";
        this._input = this.node.getElementsByTagName("input")[0];
        if (options.showInputPlaceholder && !this._password) {
          this._input.placeholder = this._trans.__("\u2191\u2193 for history. Search history with c-\u2191/c-\u2193");
        } else {
          this._input.placeholder = "";
        }
        if (!Stdin._history.has(this._historyKey)) {
          Stdin._history.set(this._historyKey, []);
        }
      }
      /**
       * The value of the widget.
       */
      get value() {
        return this._promise.promise.then(() => this._value);
      }
      /**
       * Handle the DOM events for the widget.
       *
       * @param event - The DOM event sent to the widget.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the dock panel's node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        event.stopPropagation();
        if (this._resolved) {
          event.preventDefault();
          return;
        }
        const input = this._input;
        if (event.type === "keydown") {
          if (event.key === "Enter") {
            this.resetSearch();
            this._future.sendInputReply({
              status: "ok",
              value: input.value
            }, this._parentHeader);
            if (this._password) {
              this._value += "\xB7\xB7\xB7\xB7\xB7\xB7\xB7\xB7";
            } else {
              this._value += input.value;
              Stdin._historyPush(this._historyKey, input.value);
            }
            this._resolved = true;
            this._promise.resolve(void 0);
          } else if (event.key === "Escape") {
            this.resetSearch();
            input.blur();
          } else if (event.ctrlKey && (event.key === "ArrowUp" || event.key === "ArrowDown")) {
            if (this._historyPat === "") {
              this._historyPat = input.value;
            }
            const reverse = event.key === "ArrowUp";
            const searchHistoryIx = Stdin._historySearch(this._historyKey, this._historyPat, this._historyIndex, reverse);
            if (searchHistoryIx !== void 0) {
              const historyLine = Stdin._historyAt(this._historyKey, searchHistoryIx);
              if (historyLine !== void 0) {
                if (this._historyIndex === 0) {
                  this._valueCache = input.value;
                }
                this._setInputValue(historyLine);
                this._historyIndex = searchHistoryIx;
                event.preventDefault();
              }
            }
          } else if (event.key === "ArrowUp") {
            this.resetSearch();
            const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex - 1);
            if (historyLine) {
              if (this._historyIndex === 0) {
                this._valueCache = input.value;
              }
              this._setInputValue(historyLine);
              --this._historyIndex;
              event.preventDefault();
            }
          } else if (event.key === "ArrowDown") {
            this.resetSearch();
            if (this._historyIndex === 0) {
            } else if (this._historyIndex === -1) {
              this._setInputValue(this._valueCache);
              ++this._historyIndex;
            } else {
              const historyLine = Stdin._historyAt(this._historyKey, this._historyIndex + 1);
              if (historyLine) {
                this._setInputValue(historyLine);
                ++this._historyIndex;
              }
            }
          }
        }
      }
      resetSearch() {
        this._historyPat = "";
      }
      /**
       * Handle `after-attach` messages sent to the widget.
       */
      onAfterAttach(msg) {
        this._input.addEventListener("keydown", this);
        this._input.focus();
      }
      /**
       * Handle `before-detach` messages sent to the widget.
       */
      onBeforeDetach(msg) {
        this._input.removeEventListener("keydown", this);
      }
      _setInputValue(value) {
        this._input.value = value;
        this._input.setSelectionRange(value.length, value.length);
      }
    };
    Stdin._history = /* @__PURE__ */ new Map();
    (function(Private22) {
      function createInputWidgetNode(prompt, password) {
        const node = document.createElement("div");
        const promptNode = document.createElement("pre");
        promptNode.className = STDIN_PROMPT_CLASS;
        promptNode.textContent = prompt;
        const input = document.createElement("input");
        input.className = STDIN_INPUT_CLASS;
        if (password) {
          input.type = "password";
        }
        node.appendChild(promptNode);
        promptNode.appendChild(input);
        return node;
      }
      Private22.createInputWidgetNode = createInputWidgetNode;
      class IsolatedRenderer extends Widget4 {
        /**
         * Create an isolated renderer.
         */
        constructor(wrapped) {
          super({ node: document.createElement("iframe") });
          this.addClass("jp-mod-isolated");
          this._wrapped = wrapped;
          const iframe = this.node;
          iframe.frameBorder = "0";
          iframe.scrolling = "auto";
          iframe.addEventListener("load", () => {
            iframe.contentDocument.open();
            iframe.contentDocument.write(this._wrapped.node.innerHTML);
            iframe.contentDocument.close();
            const body = iframe.contentDocument.body;
            iframe.style.height = `${body.scrollHeight}px`;
            iframe.heightChangeObserver = new ResizeObserver(() => {
              iframe.style.height = `${body.scrollHeight}px`;
            });
            iframe.heightChangeObserver.observe(body);
          });
        }
        /**
         * Render a mime model.
         *
         * @param model - The mime model to render.
         *
         * @returns A promise which resolves when rendering is complete.
         *
         * #### Notes
         * This method may be called multiple times during the lifetime
         * of the widget to update it if and when new data is available.
         */
        renderModel(model) {
          return this._wrapped.renderModel(model);
        }
      }
      Private22.IsolatedRenderer = IsolatedRenderer;
      Private22.currentPreferredMimetype = new AttachedProperty({
        name: "preferredMimetype",
        create: (owner) => ""
      });
      class OutputPanel extends Panel4 {
        /**
         * Construct a new `OutputPanel` widget.
         */
        constructor(options) {
          super(options);
        }
        /**
         * A callback that focuses on the widget.
         */
        _onContext(_4) {
          this.node.focus();
        }
        /**
         * Handle `after-attach` messages sent to the widget.
         */
        onAfterAttach(msg) {
          super.onAfterAttach(msg);
          this.node.addEventListener("contextmenu", this._onContext.bind(this));
        }
        /**
         * Handle `before-detach` messages sent to the widget.
         */
        onBeforeDetach(msg) {
          super.onAfterDetach(msg);
          this.node.removeEventListener("contextmenu", this._onContext.bind(this));
        }
      }
      Private22.OutputPanel = OutputPanel;
      class TrimmedOutputs extends Widget4 {
        /**
         * Widget constructor
         *
         * ### Notes
         * The widget will be disposed on click after calling the callback.
         *
         * @param maxNumberOutputs Maximal number of outputs to display
         * @param _onClick Callback on click event on the widget
         */
        constructor(maxNumberOutputs, onClick, translator) {
          const node = document.createElement("div");
          const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load("jupyterlab");
          const button = document.createElement("button");
          button.type = "button";
          button.className = "jp-TrimmedOutputs-button";
          button.title = trans.__("The first %1 are displayed", maxNumberOutputs);
          button.textContent = trans.__("Show more outputs");
          node.appendChild(button);
          super({
            node
          });
          this._onClick = onClick;
          this.addClass("jp-TrimmedOutputs");
        }
        /**
         * Handle the DOM events for widget.
         *
         * @param event - The DOM event sent to the widget.
         *
         * #### Notes
         * This method implements the DOM `EventListener` interface and is
         * called in response to events on the widget's DOM node. It should
         * not be called directly by user code.
         */
        handleEvent(event) {
          if (event.type === "click") {
            this._onClick(event);
          }
        }
        /**
         * Handle `after-attach` messages for the widget.
         */
        onAfterAttach(msg) {
          super.onAfterAttach(msg);
          this.node.addEventListener("click", this);
        }
        /**
         * A message handler invoked on a `'before-detach'`
         * message
         */
        onBeforeDetach(msg) {
          super.onBeforeDetach(msg);
          this.node.removeEventListener("click", this);
        }
      }
      Private22.TrimmedOutputs = TrimmedOutputs;
    })(Private17 || (Private17 = {}));
  }
});

// ../../node_modules/@jupyterlab/outputarea/lib/index.js
var init_lib7 = __esm({
  "../../node_modules/@jupyterlab/outputarea/lib/index.js"() {
    init_model();
    init_widget();
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js
var import_coreutils12, WidgetRenderer;
var init_renderer = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/renderer.js"() {
    import_coreutils12 = __toESM(require_dist());
    init_index_es610();
    WidgetRenderer = class extends Panel {
      constructor(options, manager) {
        super();
        this._manager = new import_coreutils12.PromiseDelegate();
        this._rerenderMimeModel = null;
        this.mimeType = options.mimeType;
        if (manager) {
          this.manager = manager;
        }
      }
      /**
       * The widget manager.
       */
      set manager(value) {
        value.restored.connect(this._rerender, this);
        this._manager.resolve(value);
      }
      async renderModel(model) {
        const source = model.data[this.mimeType];
        this.node.textContent = "Loading widget...";
        const manager = await this._manager.promise;
        if (source.model_id === "") {
          this.hide();
          return Promise.resolve();
        }
        let wModel;
        try {
          wModel = await manager.get_model(source.model_id);
        } catch (err) {
          if (manager.restoredStatus) {
            this.node.textContent = "Error displaying widget: model not found";
            this.addClass("jupyter-widgets");
            console.error(err);
            return;
          }
          this._rerenderMimeModel = model;
          return;
        }
        this._rerenderMimeModel = null;
        let widget;
        try {
          const view = await manager.create_view(wModel);
          widget = view.luminoWidget || view.pWidget;
        } catch (err) {
          this.node.textContent = "Error displaying widget";
          this.addClass("jupyter-widgets");
          console.error(err);
          return;
        }
        this.node.textContent = "";
        this.addWidget(widget);
        widget.disposed.connect(() => {
          this.hide();
          source.model_id = "";
        });
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._manager = null;
        super.dispose();
      }
      _rerender() {
        if (this._rerenderMimeModel) {
          this.node.textContent = "";
          this.removeClass("jupyter-widgets");
          this.renderModel(this._rerenderMimeModel);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/utils.js
function difference(a3, b2) {
  return a3.filter((v4) => b2.indexOf(v4) === -1);
}
function isEqual(a3, b2) {
  return (0, import_isEqual.default)(a3, b2);
}
function uuid() {
  return import_coreutils13.UUID.uuid4();
}
function resolvePromisesDict(d6) {
  const keys2 = Object.keys(d6);
  const values2 = [];
  keys2.forEach(function(key) {
    values2.push(d6[key]);
  });
  return Promise.all(values2).then((v4) => {
    const d7 = {};
    for (let i6 = 0; i6 < keys2.length; i6++) {
      d7[keys2[i6]] = v4[i6];
    }
    return d7;
  });
}
function reject(message, log) {
  return function promiseRejection(error) {
    if (log) {
      console.error(new Error(message));
    }
    throw error;
  };
}
function put_buffers(state, buffer_paths, buffers) {
  for (let i6 = 0; i6 < buffer_paths.length; i6++) {
    const buffer_path = buffer_paths[i6];
    let buffer = buffers[i6];
    if (!(buffer instanceof DataView)) {
      buffer = new DataView(buffer instanceof ArrayBuffer ? buffer : buffer.buffer);
    }
    let obj = state;
    for (let j2 = 0; j2 < buffer_path.length - 1; j2++) {
      obj = obj[buffer_path[j2]];
    }
    obj[buffer_path[buffer_path.length - 1]] = buffer;
  }
}
function isSerializable(object2) {
  var _a;
  return (_a = typeof object2 === "object" && object2 && "toJSON" in object2) !== null && _a !== void 0 ? _a : false;
}
function isObject2(data) {
  return import_coreutils13.JSONExt.isObject(data);
}
function remove_buffers(state) {
  const buffers = [];
  const buffer_paths = [];
  function remove2(obj, path) {
    if (isSerializable(obj)) {
      obj = obj.toJSON();
    }
    if (Array.isArray(obj)) {
      let is_cloned = false;
      for (let i6 = 0; i6 < obj.length; i6++) {
        const value = obj[i6];
        if (value) {
          if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
            if (!is_cloned) {
              obj = obj.slice();
              is_cloned = true;
            }
            buffers.push(ArrayBuffer.isView(value) ? value.buffer : value);
            buffer_paths.push(path.concat([i6]));
            obj[i6] = null;
          } else {
            const new_value = remove2(value, path.concat([i6]));
            if (new_value !== value) {
              if (!is_cloned) {
                obj = obj.slice();
                is_cloned = true;
              }
              obj[i6] = new_value;
            }
          }
        }
      }
    } else if (isObject2(obj)) {
      for (const key in obj) {
        let is_cloned = false;
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          if (value) {
            if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
              if (!is_cloned) {
                obj = Object.assign({}, obj);
                is_cloned = true;
              }
              buffers.push(ArrayBuffer.isView(value) ? value.buffer : value);
              buffer_paths.push(path.concat([key]));
              delete obj[key];
            } else {
              const new_value = remove2(value, path.concat([key]));
              if (new_value !== value) {
                if (!is_cloned) {
                  obj = Object.assign({}, obj);
                  is_cloned = true;
                }
                obj[key] = new_value;
              }
            }
          }
        }
      }
    }
    return obj;
  }
  const new_state = remove2(state, []);
  return { state: new_state, buffers, buffer_paths };
}
var import_coreutils13, import_isEqual, assign, BROKEN_FILE_SVG_ICON;
var init_utils = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/utils.js"() {
    import_coreutils13 = __toESM(require_dist());
    import_isEqual = __toESM(require_isEqual());
    assign = Object.assign || function(t11, ...args) {
      for (let i6 = 1; i6 < args.length; i6++) {
        const s8 = args[i6];
        for (const p3 in s8) {
          if (Object.prototype.hasOwnProperty.call(s8, p3)) {
            t11[p3] = s8[p3];
          }
        }
      }
      return t11;
    };
    BROKEN_FILE_SVG_ICON = `<svg style="height:50%;max-height: 50px;" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
<g >
  <g transform="translate(0.24520123,0.93464292)">
    <path  d="M 8.2494641,21.074514 V 5.6225142 c 0,-0.314 0.254,-0.567 0.57,-0.567 H 29.978464 c 2.388,0 9.268,5.8269998 9.268,8.3029998 v 5.5835 l -3.585749,4.407396 -2.772971,-3.535534 -5.126524,3.414213 -5.944543,-3.237436 -5.722718,3.06066 z m 30.9969999,3.8675 v 15.5835 c 0,0.314 -0.254,0.567 -0.57,0.567 H 8.8194641 c -0.315,0.002 -0.57,-0.251 -0.57,-0.566 v -15.452 l 7.8444949,2.628449 5.656854,-2.65165 4.24264,3.005204 5.833631,-3.237437 3.712311,3.944543 z" style="fill:url(#linearGradient3448);stroke:#888a85"  />
    <path d="m 30.383464,12.110514 c 4.108,0.159 7.304,-0.978 8.867,1.446 0.304,-3.9679998 -7.254,-8.8279998 -9.285,-8.4979998 0.813,0.498 0.418,7.0519998 0.418,7.0519998 z" style="fill:url(#linearGradient3445);stroke:#868a84" />
    <path enable-background="new" d="m 31.443464,11.086514 c 2.754,-0.019 4.106,-0.49 5.702,0.19 -1.299,-1.8809998 -4.358,-3.3439998 -5.728,-4.0279998 0.188,0.775 0.026,3.8379998 0.026,3.8379998 z" style="opacity:0.36930003;fill:none;stroke:url(#linearGradient3442)" />
  </g>
</g>
</svg>`;
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/backbone-patch.js
function set(key, val, options) {
  if (key == null) {
    return this;
  }
  let attrs;
  if (import_coreutils14.JSONExt.isObject(key)) {
    attrs = key;
    options = val;
  } else {
    (attrs = {})[key] = val;
  }
  options || (options = {});
  if (!this._validate(attrs, options)) {
    return false;
  }
  const unset = options.unset;
  const silent = options.silent;
  const changes = [];
  const changing = this._changing;
  this._changing = true;
  try {
    if (!changing) {
      this._previousAttributes = Object.assign({}, this.attributes);
      this.changed = {};
    }
    const current = this.attributes;
    const changed = this.changed;
    const prev = this._previousAttributes;
    for (const attr in attrs) {
      val = attrs[attr];
      if (!isEqual(current[attr], val)) {
        changes.push(attr);
      }
      if (!isEqual(prev[attr], val)) {
        changed[attr] = val;
      } else {
        delete changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }
    this.id = this.get(this.idAttribute);
    if (!silent) {
      if (changes.length) {
        this._pending = options;
      }
      for (let i6 = 0; i6 < changes.length; i6++) {
        this.trigger("change:" + changes[i6], this, current[changes[i6]], options);
      }
    }
    if (changing) {
      return this;
    }
    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger("change", this, options);
      }
    }
  } finally {
    this._pending = false;
    this._changing = false;
  }
  return this;
}
var import_coreutils14;
var init_backbone_patch = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/backbone-patch.js"() {
    init_utils();
    import_coreutils14 = __toESM(require_dist());
  }
});

// ../../node_modules/underscore/modules/_setup.js
var VERSION4, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "../../node_modules/underscore/modules/_setup.js"() {
    VERSION4 = "1.13.7";
    root = typeof self == "object" && self.self === self && self || typeof globalThis == "object" && globalThis.global === globalThis && globalThis || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// ../../node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
    for (; index2 < length; index2++) {
      rest2[index2] = arguments[index2 + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index2 = 0; index2 < startIndex; index2++) {
      args[index2] = arguments[index2];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "../../node_modules/underscore/modules/restArguments.js"() {
  }
});

// ../../node_modules/underscore/modules/isObject.js
function isObject3(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}
var init_isObject = __esm({
  "../../node_modules/underscore/modules/isObject.js"() {
  }
});

// ../../node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}
var init_isNull = __esm({
  "../../node_modules/underscore/modules/isNull.js"() {
  }
});

// ../../node_modules/underscore/modules/isUndefined.js
function isUndefined2(obj) {
  return obj === void 0;
}
var init_isUndefined = __esm({
  "../../node_modules/underscore/modules/isUndefined.js"() {
  }
});

// ../../node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "../../node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isElement.js
function isElement2(obj) {
  return !!(obj && obj.nodeType === 1);
}
var init_isElement = __esm({
  "../../node_modules/underscore/modules/isElement.js"() {
  }
});

// ../../node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
var init_tagTester = __esm({
  "../../node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "../../node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// ../../node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "../../node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// ../../node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "../../node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// ../../node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "../../node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// ../../node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "../../node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// ../../node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "../../node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// ../../node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "../../node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// ../../node_modules/underscore/modules/isFunction.js
var isFunction3, nodelist, isFunction_default;
var init_isFunction = __esm({
  "../../node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction3 = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction3 = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    isFunction_default = isFunction3;
  }
});

// ../../node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "../../node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// ../../node_modules/underscore/modules/_stringTagBug.js
var hasDataViewBug, isIE11;
var init_stringTagBug = __esm({
  "../../node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag_default(new DataView(new ArrayBuffer(8))));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// ../../node_modules/underscore/modules/isDataView.js
function alternateIsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "../../node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasDataViewBug ? alternateIsDataView : isDataView;
  }
});

// ../../node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "../../node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// ../../node_modules/underscore/modules/_has.js
function has2(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var init_has = __esm({
  "../../node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "../../node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has2(obj, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// ../../node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
var init_isFinite = __esm({
  "../../node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// ../../node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}
var init_isNaN = __esm({
  "../../node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// ../../node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "../../node_modules/underscore/modules/constant.js"() {
  }
});

// ../../node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "../../node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
var init_shallowProperty = __esm({
  "../../node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// ../../node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "../../node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// ../../node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "../../node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// ../../node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "../../node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// ../../node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "../../node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// ../../node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l7 = keys2.length, i6 = 0; i6 < l7; ++i6)
    hash[keys2[i6]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has2(obj, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "../../node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// ../../node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject3(obj))
    return [];
  if (nativeKeys)
    return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj)
    if (has2(obj, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_keys = __esm({
  "../../node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// ../../node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null)
    return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj)))
    return length === 0;
  return getLength_default(keys(obj)) === 0;
}
var init_isEmpty = __esm({
  "../../node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj = Object(object2);
  for (var i6 = 0; i6 < length; i6++) {
    var key = _keys[i6];
    if (attrs[key] !== obj[key] || !(key in obj))
      return false;
  }
  return true;
}
var init_isMatch = __esm({
  "../../node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/underscore.js
function _2(obj) {
  if (obj instanceof _2)
    return obj;
  if (!(this instanceof _2))
    return new _2(obj);
  this._wrapped = obj;
}
var init_underscore = __esm({
  "../../node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _2.VERSION = VERSION4;
    _2.prototype.value = function() {
      return this._wrapped;
    };
    _2.prototype.valueOf = _2.prototype.toJSON = _2.prototype.value;
    _2.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// ../../node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "../../node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// ../../node_modules/underscore/modules/isEqual.js
function eq(a3, b2, aStack, bStack) {
  if (a3 === b2)
    return a3 !== 0 || 1 / a3 === 1 / b2;
  if (a3 == null || b2 == null)
    return false;
  if (a3 !== a3)
    return b2 !== b2;
  var type = typeof a3;
  if (type !== "function" && type !== "object" && typeof b2 != "object")
    return false;
  return deepEq(a3, b2, aStack, bStack);
}
function deepEq(a3, b2, aStack, bStack) {
  if (a3 instanceof _2)
    a3 = a3._wrapped;
  if (b2 instanceof _2)
    b2 = b2._wrapped;
  var className = toString.call(a3);
  if (className !== toString.call(b2))
    return false;
  if (hasDataViewBug && className == "[object Object]" && isDataView_default(a3)) {
    if (!isDataView_default(b2))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a3 === "" + b2;
    case "[object Number]":
      if (+a3 !== +a3)
        return +b2 !== +b2;
      return +a3 === 0 ? 1 / +a3 === 1 / b2 : +a3 === +b2;
    case "[object Date]":
    case "[object Boolean]":
      return +a3 === +b2;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a3) === SymbolProto.valueOf.call(b2);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a3), toBufferView(b2), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a3)) {
    var byteLength = getByteLength_default(a3);
    if (byteLength !== getByteLength_default(b2))
      return false;
    if (a3.buffer === b2.buffer && a3.byteOffset === b2.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a3 != "object" || typeof b2 != "object")
      return false;
    var aCtor = a3.constructor, bCtor = b2.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a3 && "constructor" in b2)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a3)
      return bStack[length] === b2;
  }
  aStack.push(a3);
  bStack.push(b2);
  if (areArrays) {
    length = a3.length;
    if (length !== b2.length)
      return false;
    while (length--) {
      if (!eq(a3[length], b2[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a3), key;
    length = _keys.length;
    if (keys(b2).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has2(b2, key) && eq(a3[key], b2[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual2(a3, b2) {
  return eq(a3, b2);
}
var tagDataView;
var init_isEqual = __esm({
  "../../node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// ../../node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject3(obj))
    return [];
  var keys2 = [];
  for (var key in obj)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "../../node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// ../../node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null)
      return false;
    var keys2 = allKeys(obj);
    if (getLength_default(keys2))
      return false;
    for (var i6 = 0; i6 < length; i6++) {
      if (!isFunction_default(obj[methods[i6]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "../../node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// ../../node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "../../node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// ../../node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "../../node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// ../../node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "../../node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// ../../node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "../../node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// ../../node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i6 = 0; i6 < length; i6++) {
    values2[i6] = obj[_keys[i6]];
  }
  return values2;
}
var init_values = __esm({
  "../../node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i6 = 0; i6 < length; i6++) {
    pairs2[i6] = [_keys[i6], obj[_keys[i6]]];
  }
  return pairs2;
}
var init_pairs = __esm({
  "../../node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i6 = 0, length = _keys.length; i6 < length; i6++) {
    result2[obj[_keys[i6]]] = _keys[i6];
  }
  return result2;
}
var init_invert = __esm({
  "../../node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key]))
      names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "../../node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// ../../node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults)
      obj = Object(obj);
    if (length < 2 || obj == null)
      return obj;
    for (var index2 = 1; index2 < length; index2++) {
      var source = arguments[index2], keys2 = keysFunc(source), l7 = keys2.length;
      for (var i6 = 0; i6 < l7; i6++) {
        var key = keys2[i6];
        if (!defaults || obj[key] === void 0)
          obj[key] = source[key];
      }
    }
    return obj;
  };
}
var init_createAssigner = __esm({
  "../../node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// ../../node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "../../node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// ../../node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "../../node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// ../../node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "../../node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// ../../node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject3(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "../../node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// ../../node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "../../node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// ../../node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject3(obj))
    return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}
var init_clone = __esm({
  "../../node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// ../../node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
var init_tap = __esm({
  "../../node_modules/underscore/modules/tap.js"() {
  }
});

// ../../node_modules/underscore/modules/toPath.js
function toPath(path) {
  return isArray_default(path) ? path : [path];
}
var init_toPath = __esm({
  "../../node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _2.toPath = toPath;
  }
});

// ../../node_modules/underscore/modules/_toPath.js
function toPath2(path) {
  return _2.toPath(path);
}
var init_toPath2 = __esm({
  "../../node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// ../../node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path) {
  var length = path.length;
  for (var i6 = 0; i6 < length; i6++) {
    if (obj == null)
      return void 0;
    obj = obj[path[i6]];
  }
  return length ? obj : void 0;
}
var init_deepGet = __esm({
  "../../node_modules/underscore/modules/_deepGet.js"() {
  }
});

// ../../node_modules/underscore/modules/get.js
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath2(path));
  return isUndefined2(value) ? defaultValue : value;
}
var init_get = __esm({
  "../../node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// ../../node_modules/underscore/modules/has.js
function has3(obj, path) {
  path = toPath2(path);
  var length = path.length;
  for (var i6 = 0; i6 < length; i6++) {
    var key = path[i6];
    if (!has2(obj, key))
      return false;
    obj = obj[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "../../node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "../../node_modules/underscore/modules/identity.js"() {
  }
});

// ../../node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
var init_matcher = __esm({
  "../../node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// ../../node_modules/underscore/modules/property.js
function property(path) {
  path = toPath2(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}
var init_property = __esm({
  "../../node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0)
    return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    case 3:
      return function(value, index2, collection) {
        return func.call(context, value, index2, collection);
      };
    case 4:
      return function(accumulator, value, index2, collection) {
        return func.call(context, accumulator, value, index2, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "../../node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// ../../node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction_default(value))
    return optimizeCb(value, context, argCount);
  if (isObject3(value) && !isArray_default(value))
    return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "../../node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "../../node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _2.iteratee = iteratee;
  }
});

// ../../node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_2.iteratee !== iteratee)
    return _2.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "../../node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// ../../node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys[index2];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_mapObject = __esm({
  "../../node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/noop.js
function noop5() {
}
var init_noop = __esm({
  "../../node_modules/underscore/modules/noop.js"() {
  }
});

// ../../node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null)
    return noop5;
  return function(path) {
    return get(obj, path);
  };
}
var init_propertyOf = __esm({
  "../../node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// ../../node_modules/underscore/modules/times.js
function times(n5, iteratee2, context) {
  var accum = Array(Math.max(0, n5));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i6 = 0; i6 < n5; i6++)
    accum[i6] = iteratee2(i6);
  return accum;
}
var init_times = __esm({
  "../../node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/random.js
function random(min3, max4) {
  if (max4 == null) {
    max4 = min3;
    min3 = 0;
  }
  return min3 + Math.floor(Math.random() * (max4 - min3 + 1));
}
var init_random = __esm({
  "../../node_modules/underscore/modules/random.js"() {
  }
});

// ../../node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "../../node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// ../../node_modules/underscore/modules/_createEscaper.js
function createEscaper(map4) {
  var escaper = function(match) {
    return map4[match];
  };
  var source = "(?:" + keys(map4).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "../../node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "../../node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// ../../node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "../../node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// ../../node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "../../node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// ../../node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "../../node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// ../../node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "../../node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _2.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// ../../node_modules/underscore/modules/template.js
function escapeChar(match) {
  return "\\" + escapes[match];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults_default({}, settings, _2.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index2 = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate2, offset4) {
    source += text.slice(index2, offset4).replace(escapeRegExp, escapeChar);
    index2 = offset4 + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate2) {
      source += "';\n" + evaluate2 + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e3) {
    e3.source = source;
    throw e3;
  }
  var template2 = function(data) {
    return render.call(this, data, _2);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "../../node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// ../../node_modules/underscore/modules/result.js
function result(obj, path, fallback) {
  path = toPath2(path);
  var length = path.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i6 = 0; i6 < length; i6++) {
    var prop = obj == null ? void 0 : obj[path[i6]];
    if (prop === void 0) {
      prop = fallback;
      i6 = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var init_result = __esm({
  "../../node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// ../../node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter2 + "";
  return prefix ? prefix + id : id;
}
var idCounter2;
var init_uniqueId = __esm({
  "../../node_modules/underscore/modules/uniqueId.js"() {
    idCounter2 = 0;
  }
});

// ../../node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _2(obj);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "../../node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// ../../node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject3(result2))
    return result2;
  return self2;
}
var init_executeBound = __esm({
  "../../node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// ../../node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "../../node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder2 = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i6 = 0; i6 < length; i6++) {
          args[i6] = boundArgs[i6] === placeholder2 ? arguments[position++] : boundArgs[i6];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _2;
    partial_default = partial;
  }
});

// ../../node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "../../node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func))
        throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// ../../node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "../../node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// ../../node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i6 = 0, length = getLength_default(input); i6 < length; i6++) {
    var value = input[i6];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j2 = 0, len = value.length;
        while (j2 < len)
          output[idx++] = value[j2++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "../../node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// ../../node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "../../node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj, keys2) {
      keys2 = flatten(keys2, false, false);
      var index2 = keys2.length;
      if (index2 < 1)
        throw new Error("bindAll must be passed function names");
      while (index2--) {
        var key = keys2[index2];
        obj[key] = bind_default(obj[key], obj);
      }
      return obj;
    });
  }
});

// ../../node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache2 = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has2(cache2, address))
      cache2[address] = func.apply(this, arguments);
    return cache2[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "../../node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// ../../node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "../../node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// ../../node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "../../node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _2, 1);
  }
});

// ../../node_modules/underscore/modules/throttle.js
function throttle2(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "../../node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// ../../node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate)
        result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "../../node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// ../../node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "../../node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// ../../node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "../../node_modules/underscore/modules/negate.js"() {
  }
});

// ../../node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i6 = start;
    var result2 = args[start].apply(this, arguments);
    while (i6--)
      result2 = args[i6].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "../../node_modules/underscore/modules/compose.js"() {
  }
});

// ../../node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "../../node_modules/underscore/modules/after.js"() {
  }
});

// ../../node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1)
      func = null;
    return memo;
  };
}
var init_before = __esm({
  "../../node_modules/underscore/modules/before.js"() {
  }
});

// ../../node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "../../node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// ../../node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i6 = 0, length = _keys.length; i6 < length; i6++) {
    key = _keys[i6];
    if (predicate(obj[key], key, obj))
      return key;
  }
}
var init_findKey = __esm({
  "../../node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index2 = dir > 0 ? 0 : length - 1;
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      if (predicate(array[index2], index2, array))
        return index2;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "../../node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "../../node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// ../../node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "../../node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// ../../node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "../../node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i6 = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i6 = idx >= 0 ? idx : Math.max(idx + length, i6);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i6, length), isNaN2);
      return idx >= 0 ? idx + i6 : -1;
    }
    for (idx = dir > 0 ? i6 : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "../../node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// ../../node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "../../node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// ../../node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "../../node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// ../../node_modules/underscore/modules/find.js
function find2(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj[key];
}
var init_find = __esm({
  "../../node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// ../../node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find2(obj, matcher(attrs));
}
var init_findWhere = __esm({
  "../../node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// ../../node_modules/underscore/modules/each.js
function each2(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i6, length;
  if (isArrayLike_default(obj)) {
    for (i6 = 0, length = obj.length; i6 < length; i6++) {
      iteratee2(obj[i6], i6, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i6 = 0, length = _keys.length; i6 < length; i6++) {
      iteratee2(obj[_keys[i6]], _keys[i6], obj);
    }
  }
  return obj;
}
var init_each = __esm({
  "../../node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/map.js
function map2(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    results[index2] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_map = __esm({
  "../../node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer3 = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index2] : index2];
      index2 += dir;
    }
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      var currentKey = _keys ? _keys[index2] : index2;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer3(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "../../node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// ../../node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "../../node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// ../../node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "../../node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// ../../node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each2(obj, function(value, index2, list) {
    if (predicate(value, index2, list))
      results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "../../node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/reject.js
function reject2(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "../../node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// ../../node_modules/underscore/modules/every.js
function every2(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (!predicate(obj[currentKey], currentKey, obj))
      return false;
  }
  return true;
}
var init_every = __esm({
  "../../node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/some.js
function some2(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (predicate(obj[currentKey], currentKey, obj))
      return true;
  }
  return false;
}
var init_some = __esm({
  "../../node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj))
    obj = values(obj);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "../../node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// ../../node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "../../node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (isFunction_default(path)) {
        func = path;
      } else {
        path = toPath2(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map2(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null)
            return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// ../../node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map2(obj, property(key));
}
var init_pluck = __esm({
  "../../node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// ../../node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
var init_where = __esm({
  "../../node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// ../../node_modules/underscore/modules/max.js
function max3(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i6 = 0, length = obj.length; i6 < length; i6++) {
      value = obj[i6];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(v4, index2, list) {
      computed = iteratee2(v4, index2, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v4;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "../../node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/min.js
function min2(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i6 = 0, length = obj.length; i6 < length; i6++) {
      value = obj[i6];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(v4, index2, list) {
      computed = iteratee2(v4, index2, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v4;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "../../node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/toArray.js
function toArray(obj) {
  if (!obj)
    return [];
  if (isArray_default(obj))
    return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj))
    return map2(obj, identity);
  return values(obj);
}
var reStrSymbol;
var init_toArray = __esm({
  "../../node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// ../../node_modules/underscore/modules/sample.js
function sample(obj, n5, guard) {
  if (n5 == null || guard) {
    if (!isArrayLike_default(obj))
      obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n5 = Math.max(Math.min(n5, length), 0);
  var last2 = length - 1;
  for (var index2 = 0; index2 < n5; index2++) {
    var rand = random(index2, last2);
    var temp = sample2[index2];
    sample2[index2] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n5);
}
var init_sample = __esm({
  "../../node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// ../../node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}
var init_shuffle = __esm({
  "../../node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// ../../node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index2 = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map2(obj, function(value, key, list) {
    return {
      value,
      index: index2++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a3 = left.criteria;
    var b2 = right.criteria;
    if (a3 !== b2) {
      if (a3 > b2 || a3 === void 0)
        return 1;
      if (a3 < b2 || b2 === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "../../node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// ../../node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each2(obj, function(value, index2) {
      var key = iteratee2(value, index2, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "../../node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// ../../node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "../../node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has2(result2, key))
        result2[key].push(value);
      else
        result2[key] = [value];
    });
  }
});

// ../../node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "../../node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// ../../node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "../../node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has2(result2, key))
        result2[key]++;
      else
        result2[key] = 1;
    });
  }
});

// ../../node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "../../node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// ../../node_modules/underscore/modules/size.js
function size4(obj) {
  if (obj == null)
    return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}
var init_size = __esm({
  "../../node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// ../../node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}
var init_keyInObj = __esm({
  "../../node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// ../../node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "../../node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null)
        return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1)
          iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj = Object(obj);
      }
      for (var i6 = 0, length = keys2.length; i6 < length; i6++) {
        var key = keys2[i6];
        var value = obj[key];
        if (iteratee2(value, key, obj))
          result2[key] = value;
      }
      return result2;
    });
  }
});

// ../../node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "../../node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1)
          context = keys2[1];
      } else {
        keys2 = map2(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj, iteratee2, context);
    });
  }
});

// ../../node_modules/underscore/modules/initial.js
function initial(array, n5, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n5 == null || guard ? 1 : n5)));
}
var init_initial = __esm({
  "../../node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/first.js
function first(array, n5, guard) {
  if (array == null || array.length < 1)
    return n5 == null || guard ? void 0 : [];
  if (n5 == null || guard)
    return array[0];
  return initial(array, array.length - n5);
}
var init_first = __esm({
  "../../node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// ../../node_modules/underscore/modules/rest.js
function rest(array, n5, guard) {
  return slice.call(array, n5 == null || guard ? 1 : n5);
}
var init_rest = __esm({
  "../../node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/last.js
function last(array, n5, guard) {
  if (array == null || array.length < 1)
    return n5 == null || guard ? void 0 : [];
  if (n5 == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n5));
}
var init_last = __esm({
  "../../node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// ../../node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "../../node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// ../../node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "../../node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// ../../node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "../../node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// ../../node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "../../node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// ../../node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i6 = 0, length = getLength_default(array); i6 < length; i6++) {
    var value = array[i6], computed = iteratee2 ? iteratee2(value, i6, array) : value;
    if (isSorted && !iteratee2) {
      if (!i6 || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "../../node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// ../../node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "../../node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// ../../node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i6 = 0, length = getLength_default(array); i6 < length; i6++) {
    var item = array[i6];
    if (contains(result2, item))
      continue;
    var j2;
    for (j2 = 1; j2 < argsLength; j2++) {
      if (!contains(arguments[j2], item))
        break;
    }
    if (j2 === argsLength)
      result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "../../node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// ../../node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max3(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    result2[index2] = pluck(array, index2);
  }
  return result2;
}
var init_unzip = __esm({
  "../../node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// ../../node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "../../node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// ../../node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i6 = 0, length = getLength_default(list); i6 < length; i6++) {
    if (values2) {
      result2[list[i6]] = values2[i6];
    } else {
      result2[list[i6][0]] = list[i6][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "../../node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// ../../node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "../../node_modules/underscore/modules/range.js"() {
  }
});

// ../../node_modules/underscore/modules/chunk.js
function chunk(array, count3) {
  if (count3 == null || count3 < 1)
    return [];
  var result2 = [];
  var i6 = 0, length = array.length;
  while (i6 < length) {
    result2.push(slice.call(array, i6, i6 += count3));
  }
  return result2;
}
var init_chunk = __esm({
  "../../node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// ../../node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _2(obj).chain() : obj;
}
var init_chainResult = __esm({
  "../../node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// ../../node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each2(functions(obj), function(name) {
    var func = _2[name] = obj[name];
    _2.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_2, args));
    };
  });
  return _2;
}
var init_mixin = __esm({
  "../../node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// ../../node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "../../node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each2(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _2.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === "shift" || name === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each2(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _2.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null)
          obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    underscore_array_methods_default = _2;
  }
});

// ../../node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION4,
  after: () => after,
  all: () => every2,
  allKeys: () => allKeys,
  any: () => some2,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find2,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each2,
  escape: () => escape_default,
  every: () => every2,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find2,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each2,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has3,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual2,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject3,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max3,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop5,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject2,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size4,
  some: () => some2,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle2,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "../../node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// ../../node_modules/underscore/modules/index-default.js
var _3, index_default_default;
var init_index_default = __esm({
  "../../node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _3 = mixin(modules_exports);
    _3._ = _3;
    index_default_default = _3;
  }
});

// ../../node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION4,
  after: () => after,
  all: () => every2,
  allKeys: () => allKeys,
  any: () => some2,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map2,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find2,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each2,
  escape: () => escape_default,
  every: () => every2,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find2,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each2,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has3,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement2,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual2,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject3,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined2,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map2,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max3,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min2,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop5,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject2,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size4,
  some: () => some2,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle2,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "../../node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// ../../node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "../../node_modules/jquery/dist/jquery.js"(exports, module) {
    (function(global2, factory) {
      "use strict";
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global2.document ? factory(global2, true) : function(w3) {
          if (!w3.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w3);
        };
      } else {
        factory(global2);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice2 = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push2 = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString2 = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction4 = function isFunction5(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code3, node, doc) {
        doc = doc || document2;
        var i6, val, script = doc.createElement("script");
        script.text = code3;
        if (node) {
          for (i6 in preservedScriptAttributes) {
            val = node[i6] || node.getAttribute && node.getAttribute(i6);
            if (val) {
              script.setAttribute(i6, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
      }
      var version3 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      };
      jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version3,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice2.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice2.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i6) {
            return callback.call(elem, i6, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice2.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i6) {
            return (i6 + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i6) {
            return i6 % 2;
          }));
        },
        eq: function(i6) {
          var len = this.length, j2 = +i6 + (i6 < 0 ? len : 0);
          return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push2,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone2, target = arguments[0] || {}, i6 = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i6] || {};
          i6++;
        }
        if (typeof target !== "object" && !isFunction4(target)) {
          target = {};
        }
        if (i6 === length) {
          target = this;
          i6--;
        }
        for (; i6 < length; i6++) {
          if ((options = arguments[i6]) != null) {
            for (name in options) {
              copy = options[name];
              if (name === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name];
                if (copyIsArray && !Array.isArray(src)) {
                  clone2 = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone2 = {};
                } else {
                  clone2 = src;
                }
                copyIsArray = false;
                target[name] = jQuery.extend(deep, clone2, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version3 + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString2.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code3, options, doc) {
          DOMEval(code3, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i6 = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i6 < length; i6++) {
              if (callback.call(obj[i6], i6, obj[i6]) === false) {
                break;
              }
            }
          } else {
            for (i6 in obj) {
              if (callback.call(obj[i6], i6, obj[i6]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i6 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i6++]) {
              ret += jQuery.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push2.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i6) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i6);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first2, second) {
          var len = +second.length, j2 = 0, i6 = first2.length;
          for (; j2 < len; j2++) {
            first2[i6++] = second[j2];
          }
          first2.length = i6;
          return first2;
        },
        grep: function(elems, callback, invert2) {
          var callbackInverse, matches2 = [], i6 = 0, length = elems.length, callbackExpect = !invert2;
          for (; i6 < length; i6++) {
            callbackInverse = !callback(elems[i6], i6);
            if (callbackInverse !== callbackExpect) {
              matches2.push(elems[i6]);
            }
          }
          return matches2;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
          var length, value, i6 = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i6 < length; i6++) {
              value = callback(elems[i6], i6, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i6 in elems) {
              value = callback(elems[i6], i6, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction4(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      );
      jQuery.contains = function(a3, b2) {
        var bup = b2 && b2.parentNode;
        return a3 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a3.contains ? a3.contains(bup) : a3.compareDocumentPosition && a3.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push2;
      (function() {
        var i6, Expr, outermostContext, sortInput, hasDuplicate, push3 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches2, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a3, b2) {
          if (a3 === b2) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push3.apply(
            arr = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e3) {
          push3 = {
            apply: function(target, els) {
              pushNative.apply(target, slice2.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice2.call(arguments, 1));
            }
          };
        }
        function find3(selector, context, results, seed) {
          var m5, i7, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m5 = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m5)) {
                      if (elem.id === m5) {
                        push3.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m5)) && find3.contains(context, elem) && elem.id === m5) {
                      push3.call(results, elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push3.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m5 = match[3]) && context.getElementsByClassName) {
                  push3.apply(results, context.getElementsByClassName(m5));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i7 = groups.length;
                  while (i7--) {
                    groups[i7] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i7]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push3.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select2(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys2 = [];
          function cache2(key, value) {
            if (keys2.push(key + " ") > Expr.cacheLength) {
              delete cache2[keys2.shift()];
            }
            return cache2[key + " "] = value;
          }
          return cache2;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e3) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches3) {
              var j2, matchIndexes = fn([], seed.length, argument), i7 = matchIndexes.length;
              while (i7--) {
                if (seed[j2 = matchIndexes[i7]]) {
                  seed[j2] = !(matches3[j2] = seed[j2]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery.isXMLDoc(document3);
          matches2 = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el) {
            documentElement2.appendChild(el).id = jQuery.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
          });
          support.disconnectedMatch = assert(function(el) {
            return matches2.call(el, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e3) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i7, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i7 = 0;
                  while (elem = elems[i7++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert(function(el) {
            var input;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a3, b2) {
            if (a3 === b2) {
              hasDuplicate = true;
              return 0;
            }
            var compare2 = !a3.compareDocumentPosition - !b2.compareDocumentPosition;
            if (compare2) {
              return compare2;
            }
            compare2 = (a3.ownerDocument || a3) == (b2.ownerDocument || b2) ? a3.compareDocumentPosition(b2) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare2 & 1 || !support.sortDetached && b2.compareDocumentPosition(a3) === compare2) {
              if (a3 === document3 || a3.ownerDocument == preferredDoc && find3.contains(preferredDoc, a3)) {
                return -1;
              }
              if (b2 === document3 || b2.ownerDocument == preferredDoc && find3.contains(preferredDoc, b2)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a3) - indexOf.call(sortInput, b2) : 0;
            }
            return compare2 & 4 ? -1 : 1;
          };
          return document3;
        }
        find3.matches = function(expr, elements) {
          return find3(expr, null, null, elements);
        };
        find3.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches2.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e3) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find3(expr, document3, null, [elem]).length > 0;
        };
        find3.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery.contains(context, elem);
        };
        find3.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name);
        };
        find3.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery.uniqueSort = function(results) {
          var elem, duplicates = [], j2 = 0, i7 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice2.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i7++]) {
              if (elem === results[i7]) {
                j2 = duplicates.push(i7);
              }
            }
            while (j2--) {
              splice.call(results, duplicates[j2], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery.fn.uniqueSort = function() {
          return this.pushStack(jQuery.uniqueSort(slice2.apply(this)));
        };
        Expr = jQuery.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            CHILD: function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  find3.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                find3.error(match[0]);
              }
              return match;
            },
            PSEUDO: function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr.CHILD.test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name, operator, check) {
              return function(elem) {
                var result2 = find3.attr(elem, name);
                if (result2 == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result2 += "";
                if (operator === "=") {
                  return result2 === check;
                }
                if (operator === "!=") {
                  return result2 !== check;
                }
                if (operator === "^=") {
                  return check && result2.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result2.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result2.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result2.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result2 === check || result2.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type, what, _argument, first2, last2) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first2 === 1 && last2 === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache2, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache2 = outerCache[type] || [];
                    nodeIndex = cache2[0] === dirruns && cache2[1];
                    diff = nodeIndex && cache2[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache2 = outerCache[type] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last2;
                  return diff === first2 || diff % first2 === 0 && diff / first2 >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find3.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches3) {
                  var idx, matched = fn(seed, argument), i7 = matched.length;
                  while (i7--) {
                    idx = indexOf.call(seed, matched[i7]);
                    seed[idx] = !(matches3[idx] = matched[i7]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher2 = compile(selector.replace(rtrimCSS, "$1"));
              return matcher2[expando] ? markFunction(function(seed, matches3, _context, xml) {
                var elem, unmatched = matcher2(seed, null, xml, []), i7 = seed.length;
                while (i7--) {
                  if (elem = unmatched[i7]) {
                    seed[i7] = !(matches3[i7] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher2(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find3(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find3.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash = window2.location && window2.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i7 = 0;
              for (; i7 < length; i7 += 2) {
                matchIndexes.push(i7);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i7 = 1;
              for (; i7 < length; i7 += 2) {
                matchIndexes.push(i7);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i7;
              if (argument < 0) {
                i7 = argument + length;
              } else if (argument > length) {
                i7 = length;
              } else {
                i7 = argument;
              }
              for (; --i7 >= 0; ) {
                matchIndexes.push(i7);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i7 = argument < 0 ? argument + length : argument;
              for (; ++i7 < length; ) {
                matchIndexes.push(i7);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i6 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i6] = createInputPseudo(i6);
        }
        for (i6 in { submit: true, reset: true }) {
          Expr.pseudos[i6] = createButtonPseudo(i6);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find3.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i7 = 0, len = tokens.length, selector = "";
          for (; i7 < len; i7++) {
            selector += tokens[i7].value;
          }
          return selector;
        }
        function addCombinator(matcher2, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher2(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher2(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher2(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i7 = matchers.length;
            while (i7--) {
              if (!matchers[i7](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i7 = 0, len = contexts.length;
          for (; i7 < len; i7++) {
            find3(selector, contexts[i7], results);
          }
          return results;
        }
        function condense(unmatched, map4, filter2, context, xml) {
          var elem, newUnmatched = [], i7 = 0, len = unmatched.length, mapped = map4 != null;
          for (; i7 < len; i7++) {
            if (elem = unmatched[i7]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map4.push(i7);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher2, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i7, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher2) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher2(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i7 = temp.length;
              while (i7--) {
                if (elem = temp[i7]) {
                  matcherOut[postMap[i7]] = !(matcherIn[postMap[i7]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i7 = matcherOut.length;
                  while (i7--) {
                    if (elem = matcherOut[i7]) {
                      temp.push(matcherIn[i7] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i7 = matcherOut.length;
                while (i7--) {
                  if ((elem = matcherOut[i7]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i7]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push3.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher2, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i7 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i7 < len; i7++) {
            if (matcher2 = Expr.relative[tokens[i7].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher2)];
            } else {
              matcher2 = Expr.filter[tokens[i7].type].apply(null, tokens[i7].matches);
              if (matcher2[expando]) {
                j2 = ++i7;
                for (; j2 < len; j2++) {
                  if (Expr.relative[tokens[j2].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i7 > 1 && elementMatcher(matchers),
                  i7 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i7 - 1).concat({ value: tokens[i7 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher2,
                  i7 < j2 && matcherFromTokens(tokens.slice(i7, j2)),
                  j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                  j2 < len && toSelector(tokens)
                );
              }
              matchers.push(matcher2);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j2, matcher2, matchedCount = 0, i7 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i7 !== len && (elem = elems[i7]) != null; i7++) {
              if (byElement && elem) {
                j2 = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher2 = elementMatchers[j2++]) {
                  if (matcher2(elem, context || document3, xml)) {
                    push3.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher2 && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i7;
            if (bySet && i7 !== matchedCount) {
              j2 = 0;
              while (matcher2 = setMatchers[j2++]) {
                matcher2(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i7--) {
                    if (!(unmatched[i7] || setMatched[i7])) {
                      setMatched[i7] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push3.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match) {
          var i7, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i7 = match.length;
            while (i7--) {
              cached = matcherFromTokens(match[i7]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select2(selector, context, results, seed) {
          var i7, tokens, token, type, find4, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i7 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i7--) {
              token = tokens[i7];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find4 = Expr.find[type]) {
                if (seed = find4(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i7, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push3.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery.find = find3;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = jQuery.uniqueSort;
        find3.compile = compile;
        find3.select = select2;
        find3.setDocument = setDocument;
        find3.tokenize = tokenize;
        find3.escape = jQuery.escapeSelector;
        find3.getText = jQuery.text;
        find3.isXML = jQuery.isXMLDoc;
        find3.selectors = jQuery.expr;
        find3.support = jQuery.support;
        find3.uniqueSort = jQuery.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n5, elem) {
        var matched = [];
        for (; n5; n5 = n5.nextSibling) {
          if (n5.nodeType === 1 && n5 !== elem) {
            matched.push(n5);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction4(qualifier)) {
          return jQuery.grep(elements, function(elem, i6) {
            return !!qualifier.call(elem, i6, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery.filter(qualifier, elements, not);
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i6, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i6 = 0; i6 < len; i6++) {
                if (jQuery.contains(self2[i6], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i6 = 0; i6 < len; i6++) {
            jQuery.find(selector, self2[i6], ret);
          }
          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root2) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root2 = root2 || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction4(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root2).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction4(selector)) {
          return root2.ready !== void 0 ? root2.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery)
          );
        }
        return jQuery.makeArray(selector, this);
      };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this), l7 = targets.length;
          return this.filter(function() {
            var i6 = 0;
            for (; i6 < l7; i6++) {
              if (jQuery.contains(this, targets[i6])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i6 = 0, l7 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i6 < l7; i6++) {
              for (cur = this[i6]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery.uniqueSort(
              jQuery.merge(this.get(), jQuery(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object2 = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_4, flag) {
          object2[flag] = true;
        });
        return object2;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_4, arg) {
                  if (isFunction4(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery.each(arguments, function(_4, arg) {
              var index2;
              while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
                list.splice(index2, 1);
                if (index2 <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v4) {
        return v4;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve, reject4, noValue) {
        var method;
        try {
          if (value && isFunction4(method = value.promise)) {
            method.call(value).done(resolve).fail(reject4);
          } else if (value && isFunction4(method = value.then)) {
            method.call(value, resolve, reject4);
          } else {
            resolve.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject4.apply(void 0, [value2]);
        }
      }
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery.Callbacks("memory"),
              jQuery.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(_i, tuple) {
                  var fn = isFunction4(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction4(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction4(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e3) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(
                          e3,
                          process2.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e3];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery.Deferred.getErrorHook) {
                      process2.error = jQuery.Deferred.getErrorHook();
                    } else if (jQuery.Deferred.getStackHook) {
                      process2.error = jQuery.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction4(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction4(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction4(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery.each(tuples, function(i6, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i6][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i6][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i6 = remaining, resolveContexts = Array(i6), resolveValues = slice2.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i7) {
            return function(value) {
              resolveContexts[i7] = this;
              resolveValues[i7] = arguments.length > 1 ? slice2.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i6)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction4(resolveValues[i6] && resolveValues[i6].then)) {
              return primary.then();
            }
          }
          while (i6--) {
            adoptValue(resolveValues[i6], updateFunc(i6), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery.Deferred.exceptionHook = function(error, asyncError) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error.message,
            error.stack,
            asyncError
          );
        }
      };
      jQuery.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery.Deferred();
      jQuery.fn.ready = function(fn) {
        readyList.then(fn).catch(function(error) {
          jQuery.readyException(error);
        });
        return this;
      };
      jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i6 = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i6 in key) {
            access(elems, fn, i6, key[i6], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction4(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, _key, value2) {
                return bulk.call(jQuery(elem), value2);
              };
            }
          }
          if (fn) {
            for (; i6 < len; i6++) {
              fn(
                elems[i6],
                key,
                raw ? value : value.call(elems[i6], i6, fn(elems[i6], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache2 = this.cache(owner);
          if (typeof data === "string") {
            cache2[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache2[camelCase(prop)] = data[prop];
            }
          }
          return cache2;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i6, cache2 = owner[this.expando];
          if (cache2 === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
            }
            i6 = key.length;
            while (i6--) {
              delete cache2[key[i6]];
            }
          }
          if (key === void 0 || jQuery.isEmptyObject(cache2)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache2 = owner[this.expando];
          return cache2 !== void 0 && !jQuery.isEmptyObject(cache2);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name;
        if (data === void 0 && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e3) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
          return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i6, name, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i6 = attrs.length;
                while (i6--) {
                  if (attrs[i6]) {
                    name = attrs[i6].name;
                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type, data) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
            jQuery.dequeue(elem, type);
          };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }
          return data === void 0 ? this : this.each(function() {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
          var tmp, count3 = 1, defer = jQuery.Deferred(), elements = this, i6 = this.length, resolve = function() {
            if (!--count3) {
              defer.resolveWith(elements, [elements]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i6--) {
            tmp = dataPriv.get(elements[i6], type + "queueHooks");
            if (tmp && tmp.empty) {
              count3++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        }, initial2 = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial2) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial2 = initial2 / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial2 || 1;
          while (maxIterations--) {
            jQuery.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial2 || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial2 || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show) {
        var display, elem, values2 = [], index2 = 0, length = elements.length;
        for (; index2 < length; index2++) {
          elem = elements[index2];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values2[index2] = dataPriv.get(elem, "display") || null;
              if (!values2[index2]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values2[index2] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values2[index2] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index2 = 0; index2 < length; index2++) {
          if (values2[index2] != null) {
            elements[index2].style.display = values2[index2];
          }
        }
        return elements;
      }
      jQuery.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i6 = 0, l7 = elems.length;
        for (; i6 < l7; i6++) {
          dataPriv.set(
            elems[i6],
            "globalEval",
            !refElements || dataPriv.get(refElements[i6], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap2, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i6 = 0, l7 = elems.length;
        for (; i6 < l7; i6++) {
          elem = elems[i6];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap2 = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap2[1] + jQuery.htmlPrefilter(elem) + wrap2[2];
              j2 = wrap2[0];
              while (j2--) {
                tmp = tmp.lastChild;
              }
              jQuery.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i6 = 0;
        while (elem = nodes[i6++]) {
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j2 = 0;
            while (elem = tmp[j2++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type in types) {
            on(elem, type, selector, data, types[type], one);
          }
          return elem;
        }
        if (data == null && fn == null) {
          fn = selector;
          data = selector = void 0;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data;
            data = void 0;
          } else {
            fn = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one === 1) {
          origFn = fn;
          fn = function(event) {
            jQuery().off(event);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
          jQuery.event.add(this, types, fn, data, selector);
        });
      }
      jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events, t11, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e3) {
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e3.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t11 = types.length;
          while (t11--) {
            tmp = rtypenamespace.exec(types[t11]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery.event.special[type] || {};
            handleObj = jQuery.extend({
              type,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j2, origCount, tmp, events, t11, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t11 = types.length;
          while (t11--) {
            tmp = rtypenamespace.exec(types[t11]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t11], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j2 = handlers.length;
            while (j2--) {
              handleObj = handlers[j2];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j2, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i6, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
          args[0] = event;
          for (i6 = 1; i6 < arguments.length; i6++) {
            args[i6] = arguments[i6];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i6 = 0;
          while ((matched = handlerQueue[i6++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j2 = 0;
            while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i6, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i6 = 0; i6 < delegateCount; i6++) {
                  handleObj = handlers[i6];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction4(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type) === void 0) {
            jQuery.event.add(el, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
          namespace: false,
          handler: function(event) {
            var result2, saved = dataPriv.get(this, type);
            if (event.isTrigger & 1 && this[type]) {
              if (!saved) {
                saved = slice2.call(arguments);
                dataPriv.set(this, type, saved);
                this[type]();
                result2 = dataPriv.get(this, type);
                dataPriv.set(this, type, false);
                if (saved !== result2) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result2;
                }
              } else if ((jQuery.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type, jQuery.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e3 = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e3 && !this.isSimulated) {
            e3.preventDefault();
          }
        },
        stopPropagation: function() {
          var e3 = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e3 && !this.isSimulated) {
            e3.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e3 = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e3 && !this.isSimulated) {
            e3.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery.event.addProp);
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true;
            handle(nativeEvent);
            if (event.target === event.currentTarget) {
              handle(event);
            }
          } else {
            jQuery.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery.event.fix(nativeEvent)
            );
          }
        }
        jQuery.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event) {
            return dataPriv.get(event.target, type);
          },
          delegateType
        };
        jQuery.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = void 0;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types, fn, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i6, l7, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;
          if (events) {
            dataPriv.remove(dest, "handle events");
            for (type in events) {
              for (i6 = 0, l7 = events[type].length; i6 < l7; i6++) {
                jQuery.event.add(dest, type, events[type][i6]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first2, scripts, hasScripts, node, doc, i6 = 0, l7 = collection.length, iNoClone = l7 - 1, value = args[0], valueIsFunction = isFunction4(value);
        if (valueIsFunction || l7 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index2) {
            var self2 = collection.eq(index2);
            if (valueIsFunction) {
              args[0] = value.call(this, index2, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l7) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first2 = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first2;
          }
          if (first2 || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i6 < l7; i6++) {
              node = fragment;
              if (i6 !== iNoClone) {
                node = jQuery.clone(node, true, true);
                if (hasScripts) {
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i6], node, i6);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery.map(scripts, restoreScript);
              for (i6 = 0; i6 < hasScripts; i6++) {
                node = scripts[i6];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery._evalUrl && !node.noModule) {
                      jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove2(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i6 = 0;
        for (; (node = nodes[i6]) != null; i6++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i6, l7, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone2);
            srcElements = getAll(elem);
            for (i6 = 0, l7 = srcElements.length; i6 < l7; i6++) {
              fixInput(srcElements[i6], destElements[i6]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone2);
              for (i6 = 0, l7 = srcElements.length; i6 < l7; i6++) {
                cloneCopyEvent(srcElements[i6], destElements[i6]);
              }
            } else {
              cloneCopyEvent(elem, clone2);
            }
          }
          destElements = getAll(clone2, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone2;
        },
        cleanData: function(elems) {
          var data, elem, type, special = jQuery.event.special, i6 = 0;
          for (; (elem = elems[i6]) !== void 0; i6++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type);
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function(selector) {
          return remove2(this, selector, true);
        },
        remove: function(selector) {
          return remove2(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i6 = 0;
          for (; (elem = this[i6]) != null; i6++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i6 = 0, l7 = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery.htmlPrefilter(value2);
              try {
                for (; i6 < l7; i6++) {
                  elem = this[i6] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e3) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery.fn[name] = function(selector) {
          var elems, ret = [], insert = jQuery(selector), last2 = insert.length - 1, i6 = 0;
          for (; i6 <= last2; i6++) {
            elems = i6 === last2 ? this : this.clone(true);
            jQuery(insert[i6])[original](elems);
            push2.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles2 = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name, old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table2, tr, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table2 = document2.createElement("table");
              tr = document2.createElement("tr");
              trChild = document2.createElement("div");
              table2.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "box-sizing:content-box;border:1px solid";
              tr.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table2).appendChild(tr).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table2);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
        computed = computed || getStyles2(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i6 = cssPrefixes.length;
        while (i6--) {
          name = cssPrefixes[i6] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) {
          return final;
        }
        if (name in emptyStyle) {
          return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches2 = rcssNum.exec(value);
        return matches2 ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches2[2] - (subtract || 0)) + (matches2[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i6 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i6 < 4; i6 += 2) {
          if (box === "margin") {
            marginDelta += jQuery.css(elem, box + cssExpand[i6], true, styles);
          }
          if (!isBorderBox) {
            delta += jQuery.css(elem, "padding" + cssExpand[i6], true, styles);
            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i6] + "Width", true, styles);
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i6] + "Width", true, styles);
            }
          } else {
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i6], true, styles);
            }
            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i6] + "Width", true, styles);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles2(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (value !== void 0) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name, value);
              } else {
                style[name] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name];
          }
        },
        css: function(elem, name, extra, styles) {
          var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name, styles);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches2, styles = getStyles2(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
              );
            }
            if (subtract && (matches2 = rcssNum.exec(value)) && (matches2[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i6 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i6 < 4; i6++) {
              expanded[prefix + cssExpand[i6] + suffix] = parts[i6] || parts[i6 - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name2, value2) {
            var styles, len, map4 = {}, i6 = 0;
            if (Array.isArray(name2)) {
              styles = getStyles2(elem);
              len = name2.length;
              for (; i6 < len; i6++) {
                map4[name2[i6]] = jQuery.css(elem, name2[i6], false, styles);
              }
              return map4;
            }
            return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
          }, name, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result2;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result2 = jQuery.css(tween.elem, tween.prop, "");
            return !result2 || result2 === "auto" ? 0 : result2;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function(p3) {
          return p3;
        },
        swing: function(p3) {
          return 0.5 - Math.cos(p3 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery.fx.interval);
          }
          jQuery.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i6 = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i6 < 4; i6 += 2 - includeWidth) {
          which = cssExpand[i6];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length = collection.length;
        for (; index2 < length; index2++) {
          if (tween = collection[index2].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index2, name, easing, value, hooks;
        for (index2 in props) {
          name = camelCase(index2);
          easing = specialEasing[name];
          value = props[index2];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index2] = value[0];
          }
          if (index2 !== name) {
            props[name] = value;
            delete props[index2];
          }
          hooks = jQuery.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index2 in value) {
              if (!(index2 in props)) {
                props[index2] = value[index2];
                specialEasing[index2] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result2, stopped, index2 = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
          for (; index3 < length2; index3++) {
            animation.tweens[index3].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(
              elem,
              animation.opts,
              prop,
              end,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index3 < length2; index3++) {
              animation.tweens[index3].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index2 < length; index2++) {
          result2 = Animation.prefilters[index2].call(animation, elem, props, animation.opts);
          if (result2) {
            if (isFunction4(result2.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result2.stop.bind(result2);
            }
            return result2;
          }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction4(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(
          jQuery.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction4(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index2 = 0, length = props.length;
          for (; index2 < length; index2++) {
            prop = props[index2];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction4(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction4(easing) && easing
        };
        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction4(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty2 = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty2 || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty2 || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index2 = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
            if (index2) {
              if (data[index2] && data[index2].stop) {
                stopQueue(data[index2]);
              }
            } else {
              for (index2 in data) {
                if (data[index2] && data[index2].stop && rrun.test(index2)) {
                  stopQueue(data[index2]);
                }
              }
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && (type == null || timers[index2].queue === type)) {
                timers[index2].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index2, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index2, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index2 = timers.length; index2--; ) {
              if (timers[index2].elem === this && timers[index2].queue === type) {
                timers[index2].anim.stop(true);
                timers.splice(index2, 1);
              }
            }
            for (index2 = 0; index2 < length; index2++) {
              if (queue[index2] && queue[index2].finish) {
                queue[index2].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer, i6 = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i6 < timers.length; i6++) {
          timer = timers[i6];
          if (!timer() && timers[i6] === timer) {
            timers.splice(i6--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery.fx.stop = function() {
        inProgress = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select2 = document2.createElement("select"), opt = select2.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery.find.attr(elem, name);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name, i6 = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i6++]) {
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name) {
          if (value === false) {
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle, lowercaseName = name2.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            return elem[name] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery.each(
        [
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ],
        function() {
          jQuery.propFix[this.toLowerCase()] = this;
        }
      );
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery.fn.extend({
        addClass: function(value) {
          var classNames52, cur, curValue, className, i6, finalValue;
          if (isFunction4(value)) {
            return this.each(function(j2) {
              jQuery(this).addClass(value.call(this, j2, getClass(this)));
            });
          }
          classNames52 = classesToArray(value);
          if (classNames52.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i6 = 0; i6 < classNames52.length; i6++) {
                  className = classNames52[i6];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames52, cur, curValue, className, i6, finalValue;
          if (isFunction4(value)) {
            return this.each(function(j2) {
              jQuery(this).removeClass(value.call(this, j2, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames52 = classesToArray(value);
          if (classNames52.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i6 = 0; i6 < classNames52.length; i6++) {
                  className = classNames52[i6];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames52, className, i6, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
          if (isFunction4(value)) {
            return this.each(function(i7) {
              jQuery(this).toggleClass(
                value.call(this, i7, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames52 = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery(this);
              for (i6 = 0; i6 < classNames52.length; i6++) {
                className = classNames52[i6];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i6 = 0;
          className = " " + selector + " ";
          while (elem = this[i6++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction4(value);
          return this.each(function(i6) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i6, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option, i6, options = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max4 = one ? index2 + 1 : options.length;
              if (index2 < 0) {
                i6 = max4;
              } else {
                i6 = one ? index2 : 0;
              }
              for (; i6 < max4; i6++) {
                option = options[i6];
                if ((option.selected || i6 === index2) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one) {
                    return value;
                  }
                  values2.push(value);
                }
              }
              return values2;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values2 = jQuery.makeArray(value), i6 = options.length;
              while (i6--) {
                option = options[i6];
                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values2) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values2;
            }
          }
        }
      });
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location2 = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e3) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery.error(
            "Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data)
          );
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e3) {
        e3.stopPropagation();
      };
      jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i6, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i6 = 0;
          while ((cur = eventPath[i6++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i6 > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction4(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
          var e3 = jQuery.extend(
            new jQuery.Event(),
            event,
            {
              type,
              isSimulated: true
            }
          );
          jQuery.event.trigger(e3, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function(type, data) {
          return this.each(function() {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
          jQuery.each(obj, function(i6, v4) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v4);
            } else {
              buildParams(
                prefix + "[" + (typeof v4 === "object" && v4 != null ? i6 : "") + "]",
                v4,
                traditional,
                add
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery.param = function(a3, traditional) {
        var prefix, s8 = [], add = function(key, valueOrFunction) {
          var value = isFunction4(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s8[s8.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a3 == null) {
          return "";
        }
        if (Array.isArray(a3) || a3.jquery && !jQuery.isPlainObject(a3)) {
          jQuery.each(a3, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a3) {
            buildParams(prefix, a3[prefix], traditional, add);
          }
        }
        return s8.join("&");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i, elem) {
            var val = jQuery(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location2.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i6 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction4(func)) {
            while (dataType = dataTypes[i6++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_4, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s8, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s8.contents, dataTypes = s8.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === void 0) {
            ct = s8.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s8.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s8, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s8.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s8.converters) {
            converters[conv.toLowerCase()] = s8.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s8.responseFields[current]) {
            jqXHR[s8.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s8.dataFilter) {
            response = s8.dataFilter(response, s8.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s8.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e3) {
                    return {
                      state: "parsererror",
                      error: conv ? e3 : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location2.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location2.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i6, uncached, s8 = jQuery.ajaxSetup({}, options), callbackContext = s8.context || s8, globalEventContext = s8.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s8.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name, value) {
              if (completed2 == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s8.mimeType = type;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map4) {
              var code3;
              if (map4) {
                if (completed2) {
                  jqXHR.always(map4[jqXHR.status]);
                } else {
                  for (code3 in map4) {
                    statusCode[code3] = [statusCode[code3], map4[code3]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s8.url = ((url || s8.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
          s8.type = options.method || options.type || s8.method || s8.type;
          s8.dataTypes = (s8.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s8.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s8.url;
              urlAnchor.href = urlAnchor.href;
              s8.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e3) {
              s8.crossDomain = true;
            }
          }
          if (s8.data && s8.processData && typeof s8.data !== "string") {
            s8.data = jQuery.param(s8.data, s8.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s8, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s8.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s8.type = s8.type.toUpperCase();
          s8.hasContent = !rnoContent.test(s8.type);
          cacheURL = s8.url.replace(rhash, "");
          if (!s8.hasContent) {
            uncached = s8.url.slice(cacheURL.length);
            if (s8.data && (s8.processData || typeof s8.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s8.data;
              delete s8.data;
            }
            if (s8.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s8.url = cacheURL + uncached;
          } else if (s8.data && s8.processData && (s8.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s8.data = s8.data.replace(r20, "+");
          }
          if (s8.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s8.data && s8.hasContent && s8.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s8.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s8.dataTypes[0] && s8.accepts[s8.dataTypes[0]] ? s8.accepts[s8.dataTypes[0]] + (s8.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s8.accepts["*"]
          );
          for (i6 in s8.headers) {
            jqXHR.setRequestHeader(i6, s8.headers[i6]);
          }
          if (s8.beforeSend && (s8.beforeSend.call(callbackContext, jqXHR, s8) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s8.complete);
          jqXHR.done(s8.success);
          jqXHR.fail(s8.error);
          transport = inspectPrefiltersOrTransports(transports, s8, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s8]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s8.async && s8.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s8.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e3) {
              if (completed2) {
                throw e3;
              }
              done(-1, e3);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s8, jqXHR, responses);
            }
            if (!isSuccess && jQuery.inArray("script", s8.dataTypes) > -1 && jQuery.inArray("json", s8.dataTypes) < 0) {
              s8.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s8, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s8.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s8.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s8, isSuccess ? success : error]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s8]);
              if (!--jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, void 0, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(_i, method) {
        jQuery[method] = function(url, data, callback, type) {
          if (isFunction4(data)) {
            type = type || callback;
            callback = data;
            data = void 0;
          }
          return jQuery.ajax(jQuery.extend({
            url,
            type: method,
            dataType: type,
            data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery.ajaxPrefilter(function(s8) {
        var i6;
        for (i6 in s8.headers) {
          if (i6.toLowerCase() === "content-type") {
            s8.contentType = s8.headers[i6] || "";
          }
        }
      });
      jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery.globalEval(response, options, doc);
          }
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap2;
          if (this[0]) {
            if (isFunction4(html)) {
              html = html.call(this[0]);
            }
            wrap2 = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap2.insertBefore(this[0]);
            }
            wrap2.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction4(html)) {
            return this.each(function(i6) {
              jQuery(this).wrapInner(html.call(this, i6));
            });
          }
          return this.each(function() {
            var self2 = jQuery(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction4(html);
          return this.each(function(i6) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i6) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };
      jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e3) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i6, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i6 in options.xhrFields) {
                  xhr[i6] = options.xhrFields[i6];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i6 in headers) {
                xhr.setRequestHeader(i6, headers[i6]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e3) {
                if (callback) {
                  throw e3;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxPrefilter(function(s8) {
        if (s8.crossDomain) {
          s8.contents.script = false;
        }
      });
      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      });
      jQuery.ajaxPrefilter("script", function(s8) {
        if (s8.cache === void 0) {
          s8.cache = false;
        }
        if (s8.crossDomain) {
          s8.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s8) {
        if (s8.crossDomain || s8.scriptAttrs) {
          var script, callback;
          return {
            send: function(_4, complete) {
              script = jQuery("<script>").attr(s8.scriptAttrs || {}).prop({ charset: s8.scriptCharset, src: s8.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s8, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s8.jsonp !== false && (rjsonp.test(s8.url) ? "url" : typeof s8.data === "string" && (s8.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s8.data) && "data");
        if (jsonProp || s8.dataTypes[0] === "jsonp") {
          callbackName = s8.jsonpCallback = isFunction4(s8.jsonpCallback) ? s8.jsonpCallback() : s8.jsonpCallback;
          if (jsonProp) {
            s8[jsonProp] = s8[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s8.jsonp !== false) {
            s8.url += (rquery.test(s8.url) ? "&" : "?") + s8.jsonp + "=" + callbackName;
          }
          s8.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s8.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s8[callbackName]) {
              s8.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction4(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction4(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      jQuery.offset = {
        setOffset: function(elem, options, i6) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction4(options)) {
            options = options.call(elem, i6, jQuery.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i6) {
              jQuery.offset.setOffset(this, options, i6);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset4, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery.css(elem, "position") === "fixed") {
            offset4 = elem.getBoundingClientRect();
          } else {
            offset4 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset4.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset4.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top ? val2 : win.pageXOffset,
                top ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery.each(["top", "left"], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type2, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery.css(elem, type2, extra)
              ) : (
                // Set width or height on the element
                jQuery.style(elem, type2, value2, extra)
              );
            }, type, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery.each(
        [
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ],
        function(_i, type) {
          jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        }
      );
      jQuery.fn.extend({
        bind: function(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i, name) {
          jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        }
        if (!isFunction4(fn)) {
          return void 0;
        }
        args = slice2.call(arguments, 2);
        proxy = function() {
          return fn.apply(context || this, args.concat(slice2.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };
      jQuery.holdReady = function(hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };
      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction4;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;
      jQuery.isNumeric = function(obj) {
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery.noConflict = function(deep) {
        if (window2.$ === jQuery) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery) {
          window2.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery;
      }
      return jQuery;
    });
  }
});

// ../../node_modules/backbone/backbone.js
var require_backbone = __commonJS({
  "../../node_modules/backbone/backbone.js"(exports) {
    (function(factory) {
      var root2 = typeof self == "object" && self.self === self && self || typeof globalThis == "object" && globalThis.global === globalThis && globalThis;
      if (typeof define === "function" && define.amd) {
        define(["underscore", "jquery", "exports"], function(_5, $9, exports2) {
          root2.Backbone = factory(root2, exports2, _5, $9);
        });
      } else if (typeof exports !== "undefined") {
        var _4 = (init_index_all(), __toCommonJS(index_all_exports)), $8;
        try {
          $8 = require_jquery();
        } catch (e3) {
        }
        factory(root2, exports, _4, $8);
      } else {
        root2.Backbone = factory(root2, {}, root2._, root2.jQuery || root2.Zepto || root2.ender || root2.$);
      }
    })(function(root2, Backbone3, _4, $8) {
      var previousBackbone = root2.Backbone;
      var slice2 = Array.prototype.slice;
      Backbone3.VERSION = "1.4.0";
      Backbone3.$ = $8;
      Backbone3.noConflict = function() {
        root2.Backbone = previousBackbone;
        return this;
      };
      Backbone3.emulateHTTP = false;
      Backbone3.emulateJSON = false;
      var Events = Backbone3.Events = {};
      var eventSplitter = /\s+/;
      var _listening;
      var eventsApi = function(iteratee2, events, name, callback, opts) {
        var i6 = 0, names;
        if (name && typeof name === "object") {
          if (callback !== void 0 && "context" in opts && opts.context === void 0)
            opts.context = callback;
          for (names = _4.keys(name); i6 < names.length; i6++) {
            events = eventsApi(iteratee2, events, names[i6], name[names[i6]], opts);
          }
        } else if (name && eventSplitter.test(name)) {
          for (names = name.split(eventSplitter); i6 < names.length; i6++) {
            events = iteratee2(events, names[i6], callback, opts);
          }
        } else {
          events = iteratee2(events, name, callback, opts);
        }
        return events;
      };
      Events.on = function(name, callback, context) {
        this._events = eventsApi(onApi, this._events || {}, name, callback, {
          context,
          ctx: this,
          listening: _listening
        });
        if (_listening) {
          var listeners = this._listeners || (this._listeners = {});
          listeners[_listening.id] = _listening;
          _listening.interop = false;
        }
        return this;
      };
      Events.listenTo = function(obj, name, callback) {
        if (!obj)
          return this;
        var id = obj._listenId || (obj._listenId = _4.uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = _listening = listeningTo[id];
        if (!listening) {
          this._listenId || (this._listenId = _4.uniqueId("l"));
          listening = _listening = listeningTo[id] = new Listening(this, obj);
        }
        var error = tryCatchOn(obj, name, callback, this);
        _listening = void 0;
        if (error)
          throw error;
        if (listening.interop)
          listening.on(name, callback);
        return this;
      };
      var onApi = function(events, name, callback, options) {
        if (callback) {
          var handlers = events[name] || (events[name] = []);
          var context = options.context, ctx = options.ctx, listening = options.listening;
          if (listening)
            listening.count++;
          handlers.push({ callback, context, ctx: context || ctx, listening });
        }
        return events;
      };
      var tryCatchOn = function(obj, name, callback, context) {
        try {
          obj.on(name, callback, context);
        } catch (e3) {
          return e3;
        }
      };
      Events.off = function(name, callback, context) {
        if (!this._events)
          return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
          context,
          listeners: this._listeners
        });
        return this;
      };
      Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo)
          return this;
        var ids = obj ? [obj._listenId] : _4.keys(listeningTo);
        for (var i6 = 0; i6 < ids.length; i6++) {
          var listening = listeningTo[ids[i6]];
          if (!listening)
            break;
          listening.obj.off(name, callback, this);
          if (listening.interop)
            listening.off(name, callback);
        }
        if (_4.isEmpty(listeningTo))
          this._listeningTo = void 0;
        return this;
      };
      var offApi = function(events, name, callback, options) {
        if (!events)
          return;
        var context = options.context, listeners = options.listeners;
        var i6 = 0, names;
        if (!name && !context && !callback) {
          for (names = _4.keys(listeners); i6 < names.length; i6++) {
            listeners[names[i6]].cleanup();
          }
          return;
        }
        names = name ? [name] : _4.keys(events);
        for (; i6 < names.length; i6++) {
          name = names[i6];
          var handlers = events[name];
          if (!handlers)
            break;
          var remaining = [];
          for (var j2 = 0; j2 < handlers.length; j2++) {
            var handler = handlers[j2];
            if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
              remaining.push(handler);
            } else {
              var listening = handler.listening;
              if (listening)
                listening.off(name, callback);
            }
          }
          if (remaining.length) {
            events[name] = remaining;
          } else {
            delete events[name];
          }
        }
        return events;
      };
      Events.once = function(name, callback, context) {
        var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
        if (typeof name === "string" && context == null)
          callback = void 0;
        return this.on(events, callback, context);
      };
      Events.listenToOnce = function(obj, name, callback) {
        var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
        return this.listenTo(obj, events);
      };
      var onceMap = function(map4, name, callback, offer) {
        if (callback) {
          var once = map4[name] = _4.once(function() {
            offer(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
        }
        return map4;
      };
      Events.trigger = function(name) {
        if (!this._events)
          return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i6 = 0; i6 < length; i6++)
          args[i6] = arguments[i6 + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
      };
      var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
          var events = objEvents[name];
          var allEvents = objEvents.all;
          if (events && allEvents)
            allEvents = allEvents.slice();
          if (events)
            triggerEvents(events, args);
          if (allEvents)
            triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
      };
      var triggerEvents = function(events, args) {
        var ev, i6 = -1, l7 = events.length, a1 = args[0], a22 = args[1], a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i6 < l7)
              (ev = events[i6]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i6 < l7)
              (ev = events[i6]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i6 < l7)
              (ev = events[i6]).callback.call(ev.ctx, a1, a22);
            return;
          case 3:
            while (++i6 < l7)
              (ev = events[i6]).callback.call(ev.ctx, a1, a22, a3);
            return;
          default:
            while (++i6 < l7)
              (ev = events[i6]).callback.apply(ev.ctx, args);
            return;
        }
      };
      var Listening = function(listener, obj) {
        this.id = listener._listenId;
        this.listener = listener;
        this.obj = obj;
        this.interop = true;
        this.count = 0;
        this._events = void 0;
      };
      Listening.prototype.on = Events.on;
      Listening.prototype.off = function(name, callback) {
        var cleanup;
        if (this.interop) {
          this._events = eventsApi(offApi, this._events, name, callback, {
            context: void 0,
            listeners: void 0
          });
          cleanup = !this._events;
        } else {
          this.count--;
          cleanup = this.count === 0;
        }
        if (cleanup)
          this.cleanup();
      };
      Listening.prototype.cleanup = function() {
        delete this.listener._listeningTo[this.obj._listenId];
        if (!this.interop)
          delete this.obj._listeners[this.id];
      };
      Events.bind = Events.on;
      Events.unbind = Events.off;
      _4.extend(Backbone3, Events);
      var Model2 = Backbone3.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        this.cid = _4.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection)
          this.collection = options.collection;
        if (options.parse)
          attrs = this.parse(attrs, options) || {};
        var defaults = _4.result(this, "defaults");
        attrs = _4.defaults(_4.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
      _4.extend(Model2.prototype, Events, {
        // A hash of attributes whose current and previous value differ.
        changed: null,
        // The value returned during the last failed validation.
        validationError: null,
        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: "id",
        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: "c",
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Model.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return _4.clone(this.attributes);
        },
        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
          return Backbone3.sync.apply(this, arguments);
        },
        // Get the value of an attribute.
        get: function(attr) {
          return this.attributes[attr];
        },
        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
          return _4.escape(this.get(attr));
        },
        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
          return this.get(attr) != null;
        },
        // Special-cased proxy to underscore's `_.matches` method.
        matches: function(attrs) {
          return !!_4.iteratee(attrs, this)(this.attributes);
        },
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null)
            return this;
          var attrs;
          if (typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options))
            return false;
          var unset = options.unset;
          var silent = options.silent;
          var changes = [];
          var changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = _4.clone(this.attributes);
            this.changed = {};
          }
          var current = this.attributes;
          var changed = this.changed;
          var prev = this._previousAttributes;
          for (var attr in attrs) {
            val = attrs[attr];
            if (!_4.isEqual(current[attr], val))
              changes.push(attr);
            if (!_4.isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
          if (this.idAttribute in attrs)
            this.id = this.get(this.idAttribute);
          if (!silent) {
            if (changes.length)
              this._pending = options;
            for (var i6 = 0; i6 < changes.length; i6++) {
              this.trigger("change:" + changes[i6], this, current[changes[i6]], options);
            }
          }
          if (changing)
            return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger("change", this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
          return this.set(attr, void 0, _4.extend({}, options, { unset: true }));
        },
        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes)
            attrs[key] = void 0;
          return this.set(attrs, _4.extend({}, options, { unset: true }));
        },
        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null)
            return !_4.isEmpty(this.changed);
          return _4.has(this.changed, attr);
        },
        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          if (!diff)
            return this.hasChanged() ? _4.clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          var hasChanged;
          for (var attr in diff) {
            var val = diff[attr];
            if (_4.isEqual(old[attr], val))
              continue;
            changed[attr] = val;
            hasChanged = true;
          }
          return hasChanged ? changed : false;
        },
        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes)
            return null;
          return this._previousAttributes[attr];
        },
        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return _4.clone(this._previousAttributes);
        },
        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function(options) {
          options = _4.extend({ parse: true }, options);
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (!model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger("sync", model, resp, options);
          };
          wrapError(this, options);
          return this.sync("read", this, options);
        },
        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
          var attrs;
          if (key == null || typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options = _4.extend({ validate: true, parse: true }, options);
          var wait = options.wait;
          if (attrs && !wait) {
            if (!this.set(attrs, options))
              return false;
          } else if (!this._validate(attrs, options)) {
            return false;
          }
          var model = this;
          var success = options.success;
          var attributes = this.attributes;
          options.success = function(resp) {
            model.attributes = attributes;
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (wait)
              serverAttrs = _4.extend({}, attrs, serverAttrs);
            if (serverAttrs && !model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger("sync", model, resp, options);
          };
          wrapError(this, options);
          if (attrs && wait)
            this.attributes = _4.extend({}, attributes, attrs);
          var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
          if (method === "patch" && !options.attrs)
            options.attrs = attrs;
          var xhr = this.sync(method, this, options);
          this.attributes = attributes;
          return xhr;
        },
        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
          options = options ? _4.clone(options) : {};
          var model = this;
          var success = options.success;
          var wait = options.wait;
          var destroy = function() {
            model.stopListening();
            model.trigger("destroy", model, model.collection, options);
          };
          options.success = function(resp) {
            if (wait)
              destroy();
            if (success)
              success.call(options.context, model, resp, options);
            if (!model.isNew())
              model.trigger("sync", model, resp, options);
          };
          var xhr = false;
          if (this.isNew()) {
            _4.defer(options.success);
          } else {
            wrapError(this, options);
            xhr = this.sync("delete", this, options);
          }
          if (!wait)
            destroy();
          return xhr;
        },
        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
          var base = _4.result(this, "urlRoot") || _4.result(this.collection, "url") || urlError();
          if (this.isNew())
            return base;
          var id = this.get(this.idAttribute);
          return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
        },
        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
          return resp;
        },
        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },
        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
          return !this.has(this.idAttribute);
        },
        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, _4.extend({}, options, { validate: true }));
        },
        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate)
            return true;
          attrs = _4.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error)
            return true;
          this.trigger("invalid", this, error, _4.extend(options, { validationError: error }));
          return false;
        }
      });
      var Collection = Backbone3.Collection = function(models, options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.model)
          this.model = options.model;
        if (options.comparator !== void 0)
          this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
          this.reset(models, _4.extend({ silent: true }, options));
      };
      var setOptions = { add: true, remove: true, merge: true };
      var addOptions = { add: true, remove: false };
      var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i6;
        for (i6 = 0; i6 < tail.length; i6++)
          tail[i6] = array[i6 + at];
        for (i6 = 0; i6 < length; i6++)
          array[i6 + at] = insert[i6];
        for (i6 = 0; i6 < tail.length; i6++)
          array[i6 + length + at] = tail[i6];
      };
      _4.extend(Collection.prototype, Events, {
        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model2,
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Collection.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
        // Proxy `Backbone.sync` by default.
        sync: function() {
          return Backbone3.sync.apply(this, arguments);
        },
        // Add a model, or list of models to the set. `models` may be Backbone
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function(models, options) {
          return this.set(models, _4.extend({ merge: false }, options, addOptions));
        },
        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
          options = _4.extend({}, options);
          var singular = !_4.isArray(models);
          models = singular ? [models] : models.slice();
          var removed = this._removeModels(models, options);
          if (!options.silent && removed.length) {
            options.changes = { added: [], merged: [], removed };
            this.trigger("update", this, options);
          }
          return singular ? removed[0] : removed;
        },
        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
          if (models == null)
            return;
          options = _4.extend({}, setOptions, options);
          if (options.parse && !this._isModel(models)) {
            models = this.parse(models, options) || [];
          }
          var singular = !_4.isArray(models);
          models = singular ? [models] : models.slice();
          var at = options.at;
          if (at != null)
            at = +at;
          if (at > this.length)
            at = this.length;
          if (at < 0)
            at += this.length + 1;
          var set2 = [];
          var toAdd = [];
          var toMerge = [];
          var toRemove = [];
          var modelMap = {};
          var add = options.add;
          var merge = options.merge;
          var remove2 = options.remove;
          var sort = false;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = _4.isString(this.comparator) ? this.comparator : null;
          var model, i6;
          for (i6 = 0; i6 < models.length; i6++) {
            model = models[i6];
            var existing = this.get(model);
            if (existing) {
              if (merge && model !== existing) {
                var attrs = this._isModel(model) ? model.attributes : model;
                if (options.parse)
                  attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                toMerge.push(existing);
                if (sortable && !sort)
                  sort = existing.hasChanged(sortAttr);
              }
              if (!modelMap[existing.cid]) {
                modelMap[existing.cid] = true;
                set2.push(existing);
              }
              models[i6] = existing;
            } else if (add) {
              model = models[i6] = this._prepareModel(model, options);
              if (model) {
                toAdd.push(model);
                this._addReference(model, options);
                modelMap[model.cid] = true;
                set2.push(model);
              }
            }
          }
          if (remove2) {
            for (i6 = 0; i6 < this.length; i6++) {
              model = this.models[i6];
              if (!modelMap[model.cid])
                toRemove.push(model);
            }
            if (toRemove.length)
              this._removeModels(toRemove, options);
          }
          var orderChanged = false;
          var replace = !sortable && add && remove2;
          if (set2.length && replace) {
            orderChanged = this.length !== set2.length || _4.some(this.models, function(m5, index2) {
              return m5 !== set2[index2];
            });
            this.models.length = 0;
            splice(this.models, set2, 0);
            this.length = this.models.length;
          } else if (toAdd.length) {
            if (sortable)
              sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
          }
          if (sort)
            this.sort({ silent: true });
          if (!options.silent) {
            for (i6 = 0; i6 < toAdd.length; i6++) {
              if (at != null)
                options.index = at + i6;
              model = toAdd[i6];
              model.trigger("add", model, this, options);
            }
            if (sort || orderChanged)
              this.trigger("sort", this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
              options.changes = {
                added: toAdd,
                removed: toRemove,
                merged: toMerge
              };
              this.trigger("update", this, options);
            }
          }
          return singular ? models[0] : models;
        },
        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
          options = options ? _4.clone(options) : {};
          for (var i6 = 0; i6 < this.models.length; i6++) {
            this._removeReference(this.models[i6], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _4.extend({ silent: true }, options));
          if (!options.silent)
            this.trigger("reset", this, options);
          return models;
        },
        // Add a model to the end of the collection.
        push: function(model, options) {
          return this.add(model, _4.extend({ at: this.length }, options));
        },
        // Remove a model from the end of the collection.
        pop: function(options) {
          var model = this.at(this.length - 1);
          return this.remove(model, options);
        },
        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
          return this.add(model, _4.extend({ at: 0 }, options));
        },
        // Remove a model from the beginning of the collection.
        shift: function(options) {
          var model = this.at(0);
          return this.remove(model, options);
        },
        // Slice out a sub-array of models from the collection.
        slice: function() {
          return slice2.apply(this.models, arguments);
        },
        // Get a model from the set by id, cid, model object with id or cid
        // properties, or an attributes object that is transformed through modelId.
        get: function(obj) {
          if (obj == null)
            return void 0;
          return this._byId[obj] || this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj)] || obj.cid && this._byId[obj.cid];
        },
        // Returns `true` if the model is in the collection.
        has: function(obj) {
          return this.get(obj) != null;
        },
        // Get the model at the given index.
        at: function(index2) {
          if (index2 < 0)
            index2 += this.length;
          return this.models[index2];
        },
        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first2) {
          return this[first2 ? "find" : "filter"](attrs);
        },
        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },
        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
          var comparator = this.comparator;
          if (!comparator)
            throw new Error("Cannot sort a set without a comparator");
          options || (options = {});
          var length = comparator.length;
          if (_4.isFunction(comparator))
            comparator = comparator.bind(this);
          if (length === 1 || _4.isString(comparator)) {
            this.models = this.sortBy(comparator);
          } else {
            this.models.sort(comparator);
          }
          if (!options.silent)
            this.trigger("sort", this, options);
          return this;
        },
        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
          return this.map(attr + "");
        },
        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
          options = _4.extend({ parse: true }, options);
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? "reset" : "set";
            collection[method](resp, options);
            if (success)
              success.call(options.context, collection, resp, options);
            collection.trigger("sync", collection, resp, options);
          };
          wrapError(this, options);
          return this.sync("read", this, options);
        },
        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
          options = options ? _4.clone(options) : {};
          var wait = options.wait;
          model = this._prepareModel(model, options);
          if (!model)
            return false;
          if (!wait)
            this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(m5, resp, callbackOpts) {
            if (wait)
              collection.add(m5, callbackOpts);
            if (success)
              success.call(callbackOpts.context, m5, resp, callbackOpts);
          };
          model.save(null, options);
          return model;
        },
        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
          return resp;
        },
        // Create a new collection with an identical list of models as this one.
        clone: function() {
          return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
          });
        },
        // Define how to uniquely identify models in the collection.
        modelId: function(attrs) {
          return attrs[this.model.prototype.idAttribute || "id"];
        },
        // Get an iterator of all models in this collection.
        values: function() {
          return new CollectionIterator(this, ITERATOR_VALUES);
        },
        // Get an iterator of all model IDs in this collection.
        keys: function() {
          return new CollectionIterator(this, ITERATOR_KEYS);
        },
        // Get an iterator of all [ID, model] tuples in this collection.
        entries: function() {
          return new CollectionIterator(this, ITERATOR_KEYSVALUES);
        },
        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
          if (this._isModel(attrs)) {
            if (!attrs.collection)
              attrs.collection = this;
            return attrs;
          }
          options = options ? _4.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError)
            return model;
          this.trigger("invalid", this, model.validationError, options);
          return false;
        },
        // Internal method called by both remove and set.
        _removeModels: function(models, options) {
          var removed = [];
          for (var i6 = 0; i6 < models.length; i6++) {
            var model = this.get(models[i6]);
            if (!model)
              continue;
            var index2 = this.indexOf(model);
            this.models.splice(index2, 1);
            this.length--;
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null)
              delete this._byId[id];
            if (!options.silent) {
              options.index = index2;
              model.trigger("remove", model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
          }
          return removed;
        },
        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function(model) {
          return model instanceof Model2;
        },
        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          var id = this.modelId(model.attributes);
          if (id != null)
            this._byId[id] = model;
          model.on("all", this._onModelEvent, this);
        },
        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
          delete this._byId[model.cid];
          var id = this.modelId(model.attributes);
          if (id != null)
            delete this._byId[id];
          if (this === model.collection)
            delete model.collection;
          model.off("all", this._onModelEvent, this);
        },
        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
          if (model) {
            if ((event === "add" || event === "remove") && collection !== this)
              return;
            if (event === "destroy")
              this.remove(model, options);
            if (event === "change") {
              var prevId = this.modelId(model.previousAttributes());
              var id = this.modelId(model.attributes);
              if (prevId !== id) {
                if (prevId != null)
                  delete this._byId[prevId];
                if (id != null)
                  this._byId[id] = model;
              }
            }
          }
          this.trigger.apply(this, arguments);
        }
      });
      var $$iterator = typeof Symbol === "function" && Symbol.iterator;
      if ($$iterator) {
        Collection.prototype[$$iterator] = Collection.prototype.values;
      }
      var CollectionIterator = function(collection, kind) {
        this._collection = collection;
        this._kind = kind;
        this._index = 0;
      };
      var ITERATOR_VALUES = 1;
      var ITERATOR_KEYS = 2;
      var ITERATOR_KEYSVALUES = 3;
      if ($$iterator) {
        CollectionIterator.prototype[$$iterator] = function() {
          return this;
        };
      }
      CollectionIterator.prototype.next = function() {
        if (this._collection) {
          if (this._index < this._collection.length) {
            var model = this._collection.at(this._index);
            this._index++;
            var value;
            if (this._kind === ITERATOR_VALUES) {
              value = model;
            } else {
              var id = this._collection.modelId(model.attributes);
              if (this._kind === ITERATOR_KEYS) {
                value = id;
              } else {
                value = [id, model];
              }
            }
            return { value, done: false };
          }
          this._collection = void 0;
        }
        return { value: void 0, done: true };
      };
      var View2 = Backbone3.View = function(options) {
        this.cid = _4.uniqueId("view");
        this.preinitialize.apply(this, arguments);
        _4.extend(this, _4.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
      };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
      _4.extend(View2.prototype, Events, {
        // The default `tagName` of a View's element is `"div"`.
        tagName: "div",
        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
          return this.$el.find(selector);
        },
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the View
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
          return this;
        },
        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function() {
          this._removeElement();
          this.stopListening();
          return this;
        },
        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function() {
          this.$el.remove();
        },
        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function(element2) {
          this.undelegateEvents();
          this._setElement(element2);
          this.delegateEvents();
          return this;
        },
        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function(el) {
          this.$el = el instanceof Backbone3.$ ? el : Backbone3.$(el);
          this.el = this.$el[0];
        },
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events) {
          events || (events = _4.result(this, "events"));
          if (!events)
            return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_4.isFunction(method))
              method = this[method];
            if (!method)
              continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], method.bind(this));
          }
          return this;
        },
        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
          if (this.$el)
            this.$el.off(".delegateEvents" + this.cid);
          return this;
        },
        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function(tagName) {
          return document.createElement(tagName);
        },
        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
          if (!this.el) {
            var attrs = _4.extend({}, _4.result(this, "attributes"));
            if (this.id)
              attrs.id = _4.result(this, "id");
            if (this.className)
              attrs["class"] = _4.result(this, "className");
            this.setElement(this._createElement(_4.result(this, "tagName")));
            this._setAttributes(attrs);
          } else {
            this.setElement(_4.result(this, "el"));
          }
        },
        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function(attributes) {
          this.$el.attr(attributes);
        }
      });
      var addMethod = function(base, length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
              return base[method](this[attribute]);
            };
          case 2:
            return function(value) {
              return base[method](this[attribute], value);
            };
          case 3:
            return function(iteratee2, context) {
              return base[method](this[attribute], cb2(iteratee2, this), context);
            };
          case 4:
            return function(iteratee2, defaultVal, context) {
              return base[method](this[attribute], cb2(iteratee2, this), defaultVal, context);
            };
          default:
            return function() {
              var args = slice2.call(arguments);
              args.unshift(this[attribute]);
              return base[method].apply(base, args);
            };
        }
      };
      var addUnderscoreMethods = function(Class, base, methods, attribute) {
        _4.each(methods, function(length, method) {
          if (base[method])
            Class.prototype[method] = addMethod(base, length, method, attribute);
        });
      };
      var cb2 = function(iteratee2, instance) {
        if (_4.isFunction(iteratee2))
          return iteratee2;
        if (_4.isObject(iteratee2) && !instance._isModel(iteratee2))
          return modelMatcher(iteratee2);
        if (_4.isString(iteratee2))
          return function(model) {
            return model.get(iteratee2);
          };
        return iteratee2;
      };
      var modelMatcher = function(attrs) {
        var matcher2 = _4.matches(attrs);
        return function(model) {
          return matcher2(model.attributes);
        };
      };
      var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
      };
      var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
      };
      _4.each([
        [Collection, collectionMethods, "models"],
        [Model2, modelMethods, "attributes"]
      ], function(config) {
        var Base = config[0], methods = config[1], attribute = config[2];
        Base.mixin = function(obj) {
          var mappings = _4.reduce(_4.functions(obj), function(memo, name) {
            memo[name] = 0;
            return memo;
          }, {});
          addUnderscoreMethods(Base, obj, mappings, attribute);
        };
        addUnderscoreMethods(Base, _4, methods, attribute);
      });
      Backbone3.sync = function(method, model, options) {
        var type = methodMap[method];
        _4.defaults(options || (options = {}), {
          emulateHTTP: Backbone3.emulateHTTP,
          emulateJSON: Backbone3.emulateJSON
        });
        var params = { type, dataType: "json" };
        if (!options.url) {
          params.url = _4.result(model, "url") || urlError();
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
          params.contentType = "application/json";
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
          params.contentType = "application/x-www-form-urlencoded";
          params.data = params.data ? { model: params.data } : {};
        }
        if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
          params.type = "POST";
          if (options.emulateJSON)
            params.data._method = type;
          var beforeSend = options.beforeSend;
          options.beforeSend = function(xhr2) {
            xhr2.setRequestHeader("X-HTTP-Method-Override", type);
            if (beforeSend)
              return beforeSend.apply(this, arguments);
          };
        }
        if (params.type !== "GET" && !options.emulateJSON) {
          params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr2, textStatus, errorThrown) {
          options.textStatus = textStatus;
          options.errorThrown = errorThrown;
          if (error)
            error.call(options.context, xhr2, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone3.ajax(_4.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
      };
      var methodMap = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        delete: "DELETE",
        read: "GET"
      };
      Backbone3.ajax = function() {
        return Backbone3.$.ajax.apply(Backbone3.$, arguments);
      };
      var Router = Backbone3.Router = function(options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.routes)
          this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
      };
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp2 = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      _4.extend(Router.prototype, Events, {
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Router.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
          if (!_4.isRegExp(route))
            route = this._routeToRegExp(route);
          if (_4.isFunction(name)) {
            callback = name;
            name = "";
          }
          if (!callback)
            callback = this[name];
          var router = this;
          Backbone3.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            if (router.execute(callback, args, name) !== false) {
              router.trigger.apply(router, ["route:" + name].concat(args));
              router.trigger("route", name, args);
              Backbone3.history.trigger("route", router, name, args);
            }
          });
          return this;
        },
        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args, name) {
          if (callback)
            callback.apply(this, args);
        },
        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
          Backbone3.history.navigate(fragment, options);
          return this;
        },
        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
          if (!this.routes)
            return;
          this.routes = _4.result(this, "routes");
          var route, routes = _4.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp2, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
            return optional ? match : "([^/?]+)";
          }).replace(splatParam, "([^?]*?)");
          return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
        },
        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _4.map(params, function(param, i6) {
            if (i6 === params.length - 1)
              return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
      });
      var History = Backbone3.History = function() {
        this.handlers = [];
        this.checkUrl = this.checkUrl.bind(this);
        if (typeof window !== "undefined") {
          this.location = window.location;
          this.history = window.history;
        }
      };
      var routeStripper = /^[#\/]|\s+$/g;
      var rootStripper = /^\/+|\/+$/g;
      var pathStripper = /#.*$/;
      History.started = false;
      _4.extend(History.prototype, Events, {
        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,
        // Are we at the app root?
        atRoot: function() {
          var path = this.location.pathname.replace(/[^\/]$/, "$&/");
          return path === this.root && !this.getSearch();
        },
        // Does the pathname match the root?
        matchRoot: function() {
          var path = this.decodeFragment(this.location.pathname);
          var rootPath = path.slice(0, this.root.length - 1) + "/";
          return rootPath === this.root;
        },
        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function(fragment) {
          return decodeURI(fragment.replace(/%25/g, "%2525"));
        },
        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function() {
          var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
          return match ? match[0] : "";
        },
        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window2) {
          var match = (window2 || this).location.href.match(/#(.*)$/);
          return match ? match[1] : "";
        },
        // Get the pathname and search params, without the root.
        getPath: function() {
          var path = this.decodeFragment(
            this.location.pathname + this.getSearch()
          ).slice(this.root.length - 1);
          return path.charAt(0) === "/" ? path.slice(1) : path;
        },
        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function(fragment) {
          if (fragment == null) {
            if (this._usePushState || !this._wantsHashChange) {
              fragment = this.getPath();
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, "");
        },
        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
          if (History.started)
            throw new Error("Backbone.history has already been started");
          History.started = true;
          this.options = _4.extend({ root: "/" }, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
          this._useHashChange = this._wantsHashChange && this._hasHashChange;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.history && this.history.pushState);
          this._usePushState = this._wantsPushState && this._hasPushState;
          this.fragment = this.getFragment();
          this.root = ("/" + this.root + "/").replace(rootStripper, "/");
          if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
              var rootPath = this.root.slice(0, -1) || "/";
              this.location.replace(rootPath + "#" + this.getPath());
              return true;
            } else if (this._hasPushState && this.atRoot()) {
              this.navigate(this.getHash(), { replace: true });
            }
          }
          if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
            this.iframe = document.createElement("iframe");
            this.iframe.src = "javascript:0";
            this.iframe.style.display = "none";
            this.iframe.tabIndex = -1;
            var body = document.body;
            var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
            iWindow.document.open();
            iWindow.document.close();
            iWindow.location.hash = "#" + this.fragment;
          }
          var addEventListener = window.addEventListener || function(eventName, listener) {
            return attachEvent("on" + eventName, listener);
          };
          if (this._usePushState) {
            addEventListener("popstate", this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            addEventListener("hashchange", this.checkUrl, false);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
          if (!this.options.silent)
            return this.loadUrl();
        },
        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
          var removeEventListener = window.removeEventListener || function(eventName, listener) {
            return detachEvent("on" + eventName, listener);
          };
          if (this._usePushState) {
            removeEventListener("popstate", this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            removeEventListener("hashchange", this.checkUrl, false);
          }
          if (this.iframe) {
            document.body.removeChild(this.iframe);
            this.iframe = null;
          }
          if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
          History.started = false;
        },
        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
          this.handlers.unshift({ route, callback });
        },
        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e3) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getHash(this.iframe.contentWindow);
          }
          if (current === this.fragment)
            return false;
          if (this.iframe)
            this.navigate(current);
          this.loadUrl();
        },
        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
          if (!this.matchRoot())
            return false;
          fragment = this.fragment = this.getFragment(fragment);
          return _4.some(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
          if (!History.started)
            return false;
          if (!options || options === true)
            options = { trigger: !!options };
          fragment = this.getFragment(fragment || "");
          var rootPath = this.root;
          if (fragment === "" || fragment.charAt(0) === "?") {
            rootPath = rootPath.slice(0, -1) || "/";
          }
          var url = rootPath + fragment;
          fragment = fragment.replace(pathStripper, "");
          var decodedFragment = this.decodeFragment(fragment);
          if (this.fragment === decodedFragment)
            return;
          this.fragment = decodedFragment;
          if (this._usePushState) {
            this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
              var iWindow = this.iframe.contentWindow;
              if (!options.replace) {
                iWindow.document.open();
                iWindow.document.close();
              }
              this._updateHash(iWindow.location, fragment, options.replace);
            }
          } else {
            return this.location.assign(url);
          }
          if (options.trigger)
            return this.loadUrl(fragment);
        },
        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location2, fragment, replace) {
          if (replace) {
            var href = location2.href.replace(/(javascript:|#).*$/, "");
            location2.replace(href + "#" + fragment);
          } else {
            location2.hash = "#" + fragment;
          }
        }
      });
      Backbone3.history = new History();
      var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _4.has(protoProps, "constructor")) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
        _4.extend(child, parent, staticProps);
        child.prototype = _4.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
      };
      Model2.extend = Collection.extend = Router.extend = View2.extend = History.extend = extend;
      var urlError = function() {
        throw new Error('A "url" property or function must be specified');
      };
      var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
          if (error)
            error.call(options.context, model, resp, options);
          model.trigger("error", model, resp, options);
        };
      };
      return Backbone3;
    });
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/nativeview.js
function matchesFallback(selector) {
  const matches2 = (this.document || this.ownerDocument).querySelectorAll(selector);
  let i6 = matches2.length;
  while (--i6 >= 0 && matches2.item(i6) !== this) {
    continue;
  }
  return i6 > -1;
}
var Backbone, ElementProto, matchesSelector, NativeView;
var init_nativeview = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/nativeview.js"() {
    Backbone = __toESM(require_backbone());
    ElementProto = typeof Element !== "undefined" ? Element.prototype : void 0;
    matchesSelector = ElementProto ? ElementProto.matches || ElementProto["webkitMatchesSelector"] || ElementProto["mozMatchesSelector"] || ElementProto["msMatchesSelector"] || ElementProto["oMatchesSelector"] || matchesFallback : matchesFallback;
    NativeView = class extends Backbone.View {
      _removeElement() {
        this.undelegateEvents();
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      }
      // Apply the `element` to the view.
      _setElement(element2) {
        this.el = element2;
      }
      // Set a hash of attributes to the view's `el`. We use the "prop" version
      // if available, falling back to `setAttribute` for the catch-all.
      _setAttributes(attrs) {
        for (const attr in attrs) {
          attr in this.el ? this.el[attr] = attrs[attr] : this.el.setAttribute(attr, attrs[attr]);
        }
      }
      delegate(eventName, selector, listener) {
        if (typeof selector !== "string") {
          listener = selector;
          selector = null;
        }
        if (this._domEvents === void 0) {
          this._domEvents = [];
        }
        const root2 = this.el;
        const handler = selector ? function(e3) {
          let node = e3.target || e3.srcElement;
          for (; node && node !== root2; node = node.parentNode) {
            if (matchesSelector.call(node, selector)) {
              e3.delegateTarget = node;
              if (listener.handleEvent) {
                return listener.handleEvent(e3);
              } else {
                return listener(e3);
              }
            }
          }
        } : listener;
        this.el.addEventListener(eventName, handler, false);
        this._domEvents.push({ eventName, handler, listener, selector });
        return handler;
      }
      undelegate(eventName, selector, listener) {
        if (typeof selector === "function") {
          listener = selector;
          selector = null;
        }
        if (this.el && this._domEvents) {
          const handlers = this._domEvents.slice();
          let i6 = handlers.length;
          while (i6--) {
            const item = handlers[i6];
            const match = item.eventName === eventName && (listener ? item.listener === listener : true) && (selector ? item.selector === selector : true);
            if (!match) {
              continue;
            }
            this.el.removeEventListener(item.eventName, item.handler, false);
            this._domEvents.splice(i6, 1);
          }
        }
        return this;
      }
      // Remove all events created with `delegate` from `el`
      undelegateEvents() {
        if (this.el && this._domEvents) {
          const len = this._domEvents.length;
          for (let i6 = 0; i6 < len; i6++) {
            const item = this._domEvents[i6];
            this.el.removeEventListener(item.eventName, item.handler, false);
          }
          this._domEvents.length = 0;
        }
        return this;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/version.js
var JUPYTER_WIDGETS_VERSION, PROTOCOL_VERSION;
var init_version = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/version.js"() {
    JUPYTER_WIDGETS_VERSION = "2.0.0";
    PROTOCOL_VERSION = "2.1.0";
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget.js
function unpack_models(value, manager) {
  if (Array.isArray(value)) {
    const unpacked = [];
    for (const sub_value of value) {
      unpacked.push(unpack_models(sub_value, manager));
    }
    return Promise.all(unpacked);
  } else if (value instanceof Object && typeof value !== "string") {
    const unpacked = {};
    for (const [key, sub_value] of Object.entries(value)) {
      unpacked[key] = unpack_models(sub_value, manager);
    }
    return resolvePromisesDict(unpacked);
  } else if (typeof value === "string" && value.slice(0, 10) === IPY_MODEL_) {
    return manager.get_model(value.slice(10, value.length));
  } else {
    return Promise.resolve(value);
  }
}
function pack_models(value, widget) {
  if (Array.isArray(value)) {
    const model_ids = [];
    for (const model of value) {
      model_ids.push(pack_models(model, widget));
    }
    return model_ids;
  } else if (value instanceof WidgetModel) {
    return `${IPY_MODEL_}${value.model_id}`;
  } else if (value instanceof Object && typeof value !== "string") {
    const packed = {};
    for (const [key, sub_value] of Object.entries(value)) {
      packed[key] = pack_models(sub_value, widget);
    }
    return packed;
  } else {
    return value;
  }
}
var Backbone2, import_jquery, import_coreutils15, IPY_MODEL_, WidgetModel, DOMWidgetModel, WidgetView, JupyterLuminoWidget, JupyterPhosphorWidget, JupyterLuminoPanelWidget, JupyterPhosphorPanelWidget, DOMWidgetView;
var init_widget2 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget.js"() {
    init_utils();
    init_backbone_patch();
    Backbone2 = __toESM(require_backbone());
    import_jquery = __toESM(require_jquery());
    init_nativeview();
    import_coreutils15 = __toESM(require_dist());
    init_index_es69();
    init_index_es610();
    init_version();
    IPY_MODEL_ = "IPY_MODEL_";
    WidgetModel = class extends Backbone2.Model {
      /**
       * The default attributes.
       */
      defaults() {
        return {
          _model_module: "@jupyter-widgets/base",
          _model_name: "WidgetModel",
          _model_module_version: JUPYTER_WIDGETS_VERSION,
          _view_module: "@jupyter-widgets/base",
          _view_name: null,
          _view_module_version: JUPYTER_WIDGETS_VERSION,
          _view_count: null
        };
      }
      /**
       * Test to see if the model has been synced with the server.
       *
       * #### Notes
       * As of backbone 1.1, backbone ignores `patch` if it thinks the
       * model has never been pushed.
       */
      isNew() {
        return false;
      }
      /**
       * Constructor
       *
       * Initializes a WidgetModel instance. Called by the Backbone constructor.
       *
       * Parameters
       * ----------
       * widget_manager : WidgetManager instance
       * model_id : string
       *      An ID unique to this model.
       * comm : Comm instance (optional)
       */
      initialize(attributes, options) {
        this._expectedEchoMsgIds = /* @__PURE__ */ new Map();
        this._attrsToUpdate = /* @__PURE__ */ new Set();
        super.initialize(attributes, options);
        this.widget_manager = options.widget_manager;
        this.model_id = options.model_id;
        const comm = options.comm;
        this.views = /* @__PURE__ */ Object.create(null);
        this.state_change = Promise.resolve();
        this._closed = false;
        this._state_lock = null;
        this._msg_buffer = null;
        this._msg_buffer_callbacks = null;
        this._pending_msgs = 0;
        this._buffered_state_diff = {};
        if (comm) {
          this.comm = comm;
          comm.on_close(this._handle_comm_closed.bind(this));
          comm.on_msg(this._handle_comm_msg.bind(this));
          this.comm_live = true;
        } else {
          this.comm_live = false;
        }
      }
      get comm_live() {
        return this._comm_live;
      }
      set comm_live(x2) {
        this._comm_live = x2;
        this.trigger("comm_live_update");
      }
      /**
       * Send a custom msg over the comm.
       */
      send(content, callbacks, buffers) {
        if (this.comm !== void 0) {
          const data = { method: "custom", content };
          this.comm.send(data, callbacks, {}, buffers);
        }
      }
      /**
       * Close model
       *
       * @param comm_closed - true if the comm is already being closed. If false, the comm will be closed.
       *
       * @returns - a promise that is fulfilled when all the associated views have been removed.
       */
      close(comm_closed = false) {
        if (this._closed) {
          return Promise.resolve();
        }
        this._closed = true;
        if (this.comm && !comm_closed) {
          this.comm.close();
        }
        this.stopListening();
        this.trigger("destroy", this);
        if (this.comm) {
          delete this.comm;
        }
        if (this.views) {
          const views = Object.keys(this.views).map((id) => {
            return this.views[id].then((view) => view.remove());
          });
          delete this.views;
          return Promise.all(views).then(() => {
            return;
          });
        }
        return Promise.resolve();
      }
      /**
       * Handle when a widget comm is closed.
       */
      _handle_comm_closed(msg) {
        this.trigger("comm:close");
        this.close(true);
      }
      /**
       * Handle incoming comm msg.
       */
      _handle_comm_msg(msg) {
        const data = msg.content.data;
        const method = data.method;
        switch (method) {
          case "update":
          case "echo_update":
            this.state_change = this.state_change.then(() => {
              var _a, _b, _c;
              const state = data.state;
              const buffer_paths = (_a = data.buffer_paths) !== null && _a !== void 0 ? _a : [];
              const buffers = (_c = (_b = msg.buffers) === null || _b === void 0 ? void 0 : _b.slice(0, buffer_paths.length)) !== null && _c !== void 0 ? _c : [];
              put_buffers(state, buffer_paths, buffers);
              if (msg.parent_header && method === "echo_update") {
                const msgId = msg.parent_header.msg_id;
                const expectedEcho = Object.keys(state).filter((attrName) => this._expectedEchoMsgIds.has(attrName));
                expectedEcho.forEach((attrName) => {
                  const isOldMessage = this._expectedEchoMsgIds.get(attrName) !== msgId;
                  if (isOldMessage) {
                    delete state[attrName];
                  } else {
                    this._expectedEchoMsgIds.delete(attrName);
                    if (this._msg_buffer !== null && Object.prototype.hasOwnProperty.call(this._msg_buffer, attrName)) {
                      delete state[attrName];
                    }
                  }
                });
              }
              return this.constructor._deserialize_state(
                // Combine the state updates, with preference for kernel updates
                state,
                this.widget_manager
              );
            }).then((state) => {
              this.set_state(state);
            }).catch(reject(`Could not process update msg for model id: ${this.model_id}`, true));
            return this.state_change;
          case "custom":
            this.trigger("msg:custom", data.content, msg.buffers);
            return Promise.resolve();
        }
        return Promise.resolve();
      }
      /**
       * Handle when a widget is updated from the backend.
       *
       * This function is meant for internal use only. Values set here will not be propagated on a sync.
       */
      set_state(state) {
        this._state_lock = state;
        try {
          this.set(state);
        } catch (e3) {
          console.error(`Error setting state: ${e3 instanceof Error ? e3.message : e3}`);
        } finally {
          this._state_lock = null;
        }
      }
      /**
       * Get the serializable state of the model.
       *
       * If drop_default is truthy, attributes that are equal to their default
       * values are dropped.
       */
      get_state(drop_defaults) {
        const fullState = this.attributes;
        if (drop_defaults) {
          const d6 = this.defaults;
          const defaults = typeof d6 === "function" ? d6.call(this) : d6;
          const state = {};
          Object.keys(fullState).forEach((key) => {
            if (!isEqual(fullState[key], defaults[key])) {
              state[key] = fullState[key];
            }
          });
          return state;
        } else {
          return Object.assign({}, fullState);
        }
      }
      /**
       * Handle status msgs.
       *
       * execution_state : ('busy', 'idle', 'starting')
       */
      _handle_status(msg) {
        if (this.comm !== void 0) {
          if (msg.content.execution_state === "idle") {
            this._pending_msgs--;
            if (this._pending_msgs < 0) {
              console.error(`Jupyter Widgets message throttle: Pending messages < 0 (=${this._pending_msgs}), which is unexpected. Resetting to 0 to continue.`);
              this._pending_msgs = 0;
            }
            if (this._msg_buffer !== null && this._pending_msgs < 1) {
              const msgId = this.send_sync_message(this._msg_buffer, this._msg_buffer_callbacks);
              this.rememberLastUpdateFor(msgId);
              this._msg_buffer = null;
              this._msg_buffer_callbacks = null;
            }
          }
        }
      }
      /**
       * Create msg callbacks for a comm msg.
       */
      callbacks(view) {
        return this.widget_manager.callbacks(view);
      }
      /**
       * Set one or more values.
       *
       * We just call the super method, in which val and options are optional.
       * Handles both "key", value and {key: value} -style arguments.
       */
      set(key, val, options) {
        const return_value = set.call(this, key, val, options);
        if (this._buffered_state_diff !== void 0) {
          const attrs = this.changedAttributes() || {};
          if (this._state_lock) {
            for (const key2 of Object.keys(this._state_lock)) {
              if (attrs[key2] === this._state_lock[key2]) {
                delete attrs[key2];
              }
            }
          }
          if (this._buffered_state_diff_synced) {
            for (const key2 of Object.keys(this._buffered_state_diff_synced)) {
              if (attrs[key2] === this._buffered_state_diff_synced[key2]) {
                delete attrs[key2];
              }
            }
          }
          this._buffered_state_diff = assign(this._buffered_state_diff, attrs);
        }
        if (this._changing === false) {
          this._buffered_state_diff_synced = {};
        }
        return return_value;
      }
      /**
       * Handle sync to the back-end.  Called when a model.save() is called.
       *
       * Make sure a comm exists.
       *
       * Parameters
       * ----------
       * method : create, update, patch, delete, read
       *   create/update always send the full attribute set
       *   patch - only send attributes listed in options.attrs, and if we
       *   are queuing up messages, combine with previous messages that have
       *   not been sent yet
       * model : the model we are syncing
       *   will normally be the same as `this`
       * options : dict
       *   the `attrs` key, if it exists, gives an {attr: value} dict that
       *   should be synced, otherwise, sync all attributes.
       *
       */
      sync(method, model, options = {}) {
        if (this.comm === void 0) {
          throw "Syncing error: no comm channel defined";
        }
        const attrs = method === "patch" ? options.attrs : model.get_state(options.drop_defaults);
        if (this._state_lock) {
          for (const key of Object.keys(this._state_lock)) {
            if (attrs[key] === this._state_lock[key]) {
              delete attrs[key];
            }
          }
        }
        Object.keys(attrs).forEach((attrName) => {
          this._attrsToUpdate.add(attrName);
        });
        const msgState = this.serialize(attrs);
        if (Object.keys(msgState).length > 0) {
          const callbacks = options.callbacks || this.callbacks();
          if (this._pending_msgs >= 1) {
            switch (method) {
              case "patch":
                this._msg_buffer = assign(this._msg_buffer || {}, msgState);
                break;
              case "update":
              case "create":
                this._msg_buffer = msgState;
                break;
              default:
                throw "unrecognized syncing method";
            }
            this._msg_buffer_callbacks = callbacks;
          } else {
            const msgId = this.send_sync_message(attrs, callbacks);
            this.rememberLastUpdateFor(msgId);
          }
        }
      }
      rememberLastUpdateFor(msgId) {
        this._attrsToUpdate.forEach((attrName) => {
          this._expectedEchoMsgIds.set(attrName, msgId);
        });
        this._attrsToUpdate = /* @__PURE__ */ new Set();
      }
      /**
       * Serialize widget state.
       *
       * A serializer is a function which takes in a state attribute and a widget,
       * and synchronously returns a JSONable object. The returned object will
       * have toJSON called if possible, and the final result should be a
       * primitive object that is a snapshot of the widget state that may have
       * binary array buffers.
       */
      serialize(state) {
        const serializers = this.constructor.serializers || import_coreutils15.JSONExt.emptyObject;
        for (const k2 of Object.keys(state)) {
          try {
            if (serializers[k2] && serializers[k2].serialize) {
              state[k2] = serializers[k2].serialize(state[k2], this);
            } else {
              state[k2] = JSON.parse(JSON.stringify(state[k2]));
            }
            if (state[k2] && state[k2].toJSON) {
              state[k2] = state[k2].toJSON();
            }
          } catch (e3) {
            console.error("Error serializing widget state attribute: ", k2);
            throw e3;
          }
        }
        return state;
      }
      /**
       * Send a sync message to the kernel.
       *
       * If a message is sent successfully, this returns the message ID of that
       * message. Otherwise it returns an empty string
       */
      send_sync_message(state, callbacks = {}) {
        if (!this.comm) {
          return "";
        }
        try {
          callbacks = {
            shell: Object.assign({}, callbacks.shell),
            iopub: Object.assign({}, callbacks.iopub),
            input: callbacks.input
          };
          const statuscb = callbacks.iopub.status;
          callbacks.iopub.status = (msg) => {
            this._handle_status(msg);
            if (statuscb) {
              statuscb(msg);
            }
          };
          const split = remove_buffers(state);
          const msgId = this.comm.send({
            method: "update",
            state: split.state,
            buffer_paths: split.buffer_paths
          }, callbacks, {}, split.buffers);
          this._pending_msgs++;
          return msgId;
        } catch (e3) {
          console.error("Could not send widget sync message", e3);
        }
        return "";
      }
      /**
       * Push this model's state to the back-end
       *
       * This invokes a Backbone.Sync.
       */
      save_changes(callbacks) {
        if (this.comm_live) {
          const options = { patch: true };
          if (callbacks) {
            options.callbacks = callbacks;
          }
          this.save(this._buffered_state_diff, options);
          if (this._changing) {
            assign(this._buffered_state_diff_synced, this._buffered_state_diff);
          }
          this._buffered_state_diff = {};
        }
      }
      /**
       * on_some_change(['key1', 'key2'], foo, context) differs from
       * on('change:key1 change:key2', foo, context).
       * If the widget attributes key1 and key2 are both modified,
       * the second form will result in foo being called twice
       * while the first will call foo only once.
       */
      on_some_change(keys2, callback, context) {
        this.on("change", (...args) => {
          if (keys2.some(this.hasChanged, this)) {
            callback.apply(context, args);
          }
        }, this);
      }
      /**
       * Serialize the model.  See the deserialization function at the top of this file
       * and the kernel-side serializer/deserializer.
       */
      toJSON(options) {
        return `IPY_MODEL_${this.model_id}`;
      }
      /**
       * Returns a promise for the deserialized state. The second argument
       * is an instance of widget manager, which is required for the
       * deserialization of widget models.
       */
      static _deserialize_state(state, manager) {
        const serializers = this.serializers;
        let deserialized;
        if (serializers) {
          deserialized = {};
          for (const k2 in state) {
            if (serializers[k2] && serializers[k2].deserialize) {
              deserialized[k2] = serializers[k2].deserialize(state[k2], manager);
            } else {
              deserialized[k2] = state[k2];
            }
          }
        } else {
          deserialized = state;
        }
        return resolvePromisesDict(deserialized);
      }
    };
    DOMWidgetModel = class extends WidgetModel {
      defaults() {
        return assign(super.defaults(), {
          _dom_classes: [],
          tabbable: null,
          tooltip: null
          // We do not declare defaults for the layout and style attributes.
          // Those defaults are constructed on the kernel side and synced here
          // as needed, and our code here copes with those attributes being
          // undefined. See
          // https://github.com/jupyter-widgets/ipywidgets/issues/1620 and
          // https://github.com/jupyter-widgets/ipywidgets/pull/1621
        });
      }
    };
    DOMWidgetModel.serializers = Object.assign(Object.assign({}, WidgetModel.serializers), { layout: { deserialize: unpack_models }, style: { deserialize: unpack_models } });
    WidgetView = class extends NativeView {
      /**
       * Public constructor.
       */
      constructor(options) {
        super(options);
      }
      /**
       * Initializer, called at the end of the constructor.
       */
      initialize(parameters) {
        this.listenTo(this.model, "change", (model, options) => {
          const changed = Object.keys(this.model.changedAttributes() || {});
          if (changed[0] === "_view_count" && changed.length === 1) {
            return;
          }
          this.update(options);
        });
        this.options = parameters.options;
        this.once("remove", () => {
          if (typeof this.model.get("_view_count") === "number") {
            this.model.set("_view_count", this.model.get("_view_count") - 1);
            this.model.save_changes();
          }
        });
        this.once("displayed", () => {
          if (typeof this.model.get("_view_count") === "number") {
            this.model.set("_view_count", this.model.get("_view_count") + 1);
            this.model.save_changes();
          }
        });
        this.displayed = new Promise((resolve, reject4) => {
          this.once("displayed", resolve);
          this.model.on("msg:custom", this.handle_message.bind(this));
        });
      }
      /**
       * Handle message sent to the front end.
       *
       * Used to focus or blur the widget.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.el.focus();
        } else if (content.do === "blur") {
          this.el.blur();
        }
      }
      /**
       * Triggered on model change.
       *
       * Update view to be consistent with this.model
       */
      update(options) {
        return;
      }
      /**
       * Render a view
       *
       * @returns the view or a promise to the view.
       */
      render() {
        return;
      }
      create_child_view(child_model, options = {}) {
        options = Object.assign({ parent: this }, options);
        return this.model.widget_manager.create_view(child_model, options).catch(reject("Could not create child view", true));
      }
      /**
       * Create msg callbacks for a comm msg.
       */
      callbacks() {
        return this.model.callbacks(this);
      }
      /**
       * Send a custom msg associated with this view.
       */
      send(content, buffers) {
        this.model.send(content, this.callbacks(), buffers);
      }
      touch() {
        this.model.save_changes(this.callbacks());
      }
      remove() {
        super.remove();
        this.trigger("remove");
        return this;
      }
    };
    JupyterLuminoWidget = class extends Widget {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        super.processMessage(msg);
        this._view.processLuminoMessage(msg);
      }
    };
    JupyterPhosphorWidget = JupyterLuminoWidget;
    JupyterLuminoPanelWidget = class extends Panel {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        super.processMessage(msg);
        this._view.processLuminoMessage(msg);
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        var _a;
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.remove();
        this._view = null;
      }
    };
    JupyterPhosphorPanelWidget = JupyterLuminoPanelWidget;
    DOMWidgetView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:_dom_classes", (model, new_classes) => {
          const old_classes = model.previous("_dom_classes");
          this.update_classes(old_classes, new_classes);
        });
        this.layoutPromise = Promise.resolve();
        this.listenTo(this.model, "change:layout", (model, value) => {
          this.setLayout(value, model.previous("layout"));
        });
        this.stylePromise = Promise.resolve();
        this.listenTo(this.model, "change:style", (model, value) => {
          this.setStyle(value, model.previous("style"));
        });
        this.displayed.then(() => {
          this.update_classes([], this.model.get("_dom_classes"));
          this.setLayout(this.model.get("layout"));
          this.setStyle(this.model.get("style"));
        });
        this._comm_live_update();
        this.listenTo(this.model, "comm_live_update", () => {
          this._comm_live_update();
        });
        this.listenTo(this.model, "change:tooltip", this.updateTooltip);
        this.updateTooltip();
      }
      setLayout(layout, oldLayout) {
        if (layout) {
          this.layoutPromise = this.layoutPromise.then((oldLayoutView) => {
            if (oldLayoutView) {
              oldLayoutView.unlayout();
              this.stopListening(oldLayoutView.model);
              oldLayoutView.remove();
            }
            return this.create_child_view(layout).then((view) => {
              return this.displayed.then(() => {
                view.trigger("displayed");
                this.listenTo(view.model, "change", () => {
                  MessageLoop.postMessage(this.luminoWidget, Widget.ResizeMessage.UnknownSize);
                });
                MessageLoop.postMessage(this.luminoWidget, Widget.ResizeMessage.UnknownSize);
                this.trigger("layout-changed");
                return view;
              });
            }).catch(reject("Could not add LayoutView to DOMWidgetView", true));
          });
        }
      }
      setStyle(style, oldStyle) {
        if (style) {
          this.stylePromise = this.stylePromise.then((oldStyleView) => {
            if (oldStyleView) {
              oldStyleView.unstyle();
              this.stopListening(oldStyleView.model);
              oldStyleView.remove();
            }
            return this.create_child_view(style).then((view) => {
              return this.displayed.then(() => {
                view.trigger("displayed");
                this.trigger("style-changed");
                return view;
              });
            }).catch(reject("Could not add styleView to DOMWidgetView", true));
          });
        }
      }
      updateTooltip() {
        const title = this.model.get("tooltip");
        if (!title) {
          this.el.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.el.setAttribute("title", title);
        }
      }
      /**
       * Update the DOM classes applied to an element, default to this.el.
       */
      update_classes(old_classes, new_classes, el) {
        if (el === void 0) {
          el = this.el;
        }
        difference(old_classes, new_classes).map(function(c6) {
          if (el.classList) {
            el.classList.remove(c6);
          } else {
            el.setAttribute("class", el.getAttribute("class").replace(c6, ""));
          }
        });
        difference(new_classes, old_classes).map(function(c6) {
          if (el.classList) {
            el.classList.add(c6);
          } else {
            el.setAttribute("class", el.getAttribute("class").concat(" ", c6));
          }
        });
      }
      /**
       * Update the DOM classes applied to the widget based on a single
       * trait's value.
       *
       * Given a trait value classes map, this function automatically
       * handles applying the appropriate classes to the widget element
       * and removing classes that are no longer valid.
       *
       * Parameters
       * ----------
       * class_map: dictionary
       *  Dictionary of trait values to class lists.
       *  Example:
       *      {
       *          success: ['alert', 'alert-success'],
       *          info: ['alert', 'alert-info'],
       *          warning: ['alert', 'alert-warning'],
       *          danger: ['alert', 'alert-danger']
       *      };
       * trait_name: string
       *  Name of the trait to check the value of.
       * el: optional DOM element handle, defaults to this.el
       *  Element that the classes are applied to.
       */
      update_mapped_classes(class_map, trait_name, el) {
        let key = this.model.previous(trait_name);
        const old_classes = class_map[key] ? class_map[key] : [];
        key = this.model.get(trait_name);
        const new_classes = class_map[key] ? class_map[key] : [];
        this.update_classes(old_classes, new_classes, el || this.el);
      }
      set_mapped_classes(class_map, trait_name, el) {
        const key = this.model.get(trait_name);
        const new_classes = class_map[key] ? class_map[key] : [];
        this.update_classes([], new_classes, el || this.el);
      }
      _setElement(el) {
        if (this.luminoWidget) {
          this.luminoWidget.dispose();
        }
        this.$el = el instanceof import_jquery.default ? el : (0, import_jquery.default)(el);
        this.el = this.$el[0];
        this.luminoWidget = new JupyterLuminoWidget({
          node: el,
          view: this
        });
      }
      remove() {
        if (this.luminoWidget) {
          this.luminoWidget.dispose();
        }
        return super.remove();
      }
      /**
       * @deprecated Use {@link processLuminoMessage} instead (Since 8.0).
       */
      processPhosphorMessage(msg) {
        this.processLuminoMessage(msg);
      }
      processLuminoMessage(msg) {
        switch (msg.type) {
          case "after-attach":
            this.trigger("displayed");
            break;
          case "show":
            this.trigger("shown");
            break;
        }
      }
      _comm_live_update() {
        if (this.model.comm_live) {
          this.luminoWidget.removeClass("jupyter-widgets-disconnected");
        } else {
          this.luminoWidget.addClass("jupyter-widgets-disconnected");
        }
      }
      updateTabindex() {
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.el.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.el.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.el.removeAttribute("tabIndex");
        }
      }
      /**
       * @deprecated Use {@link luminoWidget} instead (Since 8.0).
       */
      get pWidget() {
        return this.luminoWidget;
      }
      /**
       * @deprecated Use {@link luminoWidget} instead (Since 8.0).
       */
      set pWidget(value) {
        this.luminoWidget = value;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/manager.js
var init_manager = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/manager.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget_layout.js
var css_properties, LayoutModel, LayoutView;
var init_widget_layout = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget_layout.js"() {
    init_utils();
    init_widget2();
    css_properties = {
      align_content: null,
      align_items: null,
      align_self: null,
      border_top: null,
      border_right: null,
      border_bottom: null,
      border_left: null,
      bottom: null,
      display: null,
      flex: null,
      flex_flow: null,
      height: null,
      justify_content: null,
      justify_items: null,
      left: null,
      margin: null,
      max_height: null,
      max_width: null,
      min_height: null,
      min_width: null,
      overflow: null,
      order: null,
      padding: null,
      right: null,
      top: null,
      visibility: null,
      width: null,
      // image-specific
      object_fit: null,
      object_position: null,
      // container
      grid_auto_columns: null,
      grid_auto_flow: null,
      grid_auto_rows: null,
      grid_gap: null,
      grid_template_rows: null,
      grid_template_columns: null,
      grid_template_areas: null,
      // items
      grid_row: null,
      grid_column: null,
      grid_area: null
    };
    LayoutModel = class extends WidgetModel {
      defaults() {
        return assign(super.defaults(), {
          _model_name: "LayoutModel",
          _view_name: "LayoutView"
        }, css_properties);
      }
    };
    LayoutView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        this._traitNames = [];
        super.initialize(parameters);
        for (const key of Object.keys(css_properties)) {
          this.registerTrait(key);
        }
      }
      /**
       * Register a CSS trait that is known by the model
       * @param trait
       */
      registerTrait(trait) {
        this._traitNames.push(trait);
        this.listenTo(this.model, "change:" + trait, (model, value) => {
          this.handleChange(trait, value);
        });
        this.handleChange(trait, this.model.get(trait));
      }
      /**
       * Get the the name of the css property from the trait name
       * @param  model attribute name
       * @return css property name
       */
      css_name(trait) {
        return trait.replace(/_/g, "-");
      }
      /**
       * Handles when a trait value changes
       */
      handleChange(trait, value) {
        const parent = this.options.parent;
        if (parent) {
          if (value === null) {
            parent.el.style.removeProperty(this.css_name(trait));
          } else {
            parent.el.style.setProperty(this.css_name(trait), value);
          }
        } else {
          console.warn("Style not applied because a parent view does not exist");
        }
      }
      /**
       * Remove the styling from the parent view.
       */
      unlayout() {
        const parent = this.options.parent;
        this._traitNames.forEach((trait) => {
          if (parent) {
            parent.el.style.removeProperty(this.css_name(trait));
          } else {
            console.warn("Style not removed because a parent view does not exist");
          }
        }, this);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/widget_style.js
var StyleModel, StyleView;
var init_widget_style = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/widget_style.js"() {
    init_utils();
    init_widget2();
    StyleModel = class extends WidgetModel {
      defaults() {
        const Derived = this.constructor;
        return assign(super.defaults(), {
          _model_name: "StyleModel",
          _view_name: "StyleView"
        }, Object.keys(Derived.styleProperties).reduce((obj, key) => {
          obj[key] = Derived.styleProperties[key].default;
          return obj;
        }, {}));
      }
    };
    StyleModel.styleProperties = {};
    StyleView = class extends WidgetView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        this._traitNames = [];
        super.initialize(parameters);
        const ModelType = this.model.constructor;
        for (const key of Object.keys(ModelType.styleProperties)) {
          this.registerTrait(key);
        }
        this.style();
      }
      /**
       * Register a CSS trait that is known by the model
       * @param trait
       */
      registerTrait(trait) {
        this._traitNames.push(trait);
        this.listenTo(this.model, "change:" + trait, (model, value) => {
          this.handleChange(trait, value);
        });
      }
      /**
       * Handles when a trait value changes
       */
      handleChange(trait, value) {
        const parent = this.options.parent;
        if (parent) {
          const ModelType = this.model.constructor;
          const styleProperties = ModelType.styleProperties;
          const attribute = styleProperties[trait].attribute;
          const selector = styleProperties[trait].selector;
          const elements = selector ? parent.el.querySelectorAll(selector) : [parent.el];
          if (value === null) {
            for (let i6 = 0; i6 !== elements.length; ++i6) {
              elements[i6].style.removeProperty(attribute);
            }
          } else {
            for (let i6 = 0; i6 !== elements.length; ++i6) {
              elements[i6].style.setProperty(attribute, value);
            }
          }
        } else {
          console.warn("Style not applied because a parent view does not exist");
        }
      }
      /**
       * Apply styles for all registered traits
       */
      style() {
        for (const trait of this._traitNames) {
          this.handleChange(trait, this.model.get(trait));
        }
      }
      /**
       * Remove the styling from the parent view.
       */
      unstyle() {
        const parent = this.options.parent;
        const ModelType = this.model.constructor;
        const styleProperties = ModelType.styleProperties;
        this._traitNames.forEach((trait) => {
          if (parent) {
            const attribute = styleProperties[trait].attribute;
            const selector = styleProperties[trait].selector;
            const elements = selector ? parent.el.querySelectorAll(selector) : [parent.el];
            for (let i6 = 0; i6 !== elements.length; ++i6) {
              elements[i6].style.removeProperty(attribute);
            }
          } else {
            console.warn("Style not removed because a parent view does not exist");
          }
        }, this);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/services-shim.js
var shims;
var init_services_shim = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/services-shim.js"() {
    (function(shims2) {
      let services;
      (function(services2) {
        class CommManager {
          constructor(jsServicesKernel) {
            this.targets = /* @__PURE__ */ Object.create(null);
            this.comms = /* @__PURE__ */ Object.create(null);
            this.init_kernel(jsServicesKernel);
          }
          /**
           * Hookup kernel events.
           * @param  {Kernel.IKernel} jsServicesKernel - @jupyterlab/services Kernel.IKernel instance
           */
          init_kernel(jsServicesKernel) {
            this.kernel = jsServicesKernel;
            this.jsServicesKernel = jsServicesKernel;
          }
          /**
           * Creates a new connected comm
           */
          async new_comm(target_name, data, callbacks, metadata, comm_id, buffers) {
            const c6 = this.jsServicesKernel.createComm(target_name, comm_id);
            const comm = new Comm(c6);
            this.register_comm(comm);
            comm.open(data, callbacks, metadata, buffers);
            return comm;
          }
          /**
           * Register a comm target
           * @param  {string} target_name
           * @param  {(Comm, object) => void} f - callback that is called when the
           *                         comm is made.  Signature of f(comm, msg).
           */
          register_target(target_name, f6) {
            const handle = this.jsServicesKernel.registerCommTarget(target_name, (jsServicesComm, msg) => {
              const comm = new Comm(jsServicesComm);
              this.register_comm(comm);
              try {
                return f6(comm, msg);
              } catch (e3) {
                comm.close();
                console.error(e3);
                console.error(new Error("Exception opening new comm"));
              }
            });
            this.targets[target_name] = handle;
          }
          /**
           * Unregisters a comm target
           * @param  {string} target_name
           */
          unregister_target(target_name, f6) {
            const handle = this.targets[target_name];
            handle.dispose();
            delete this.targets[target_name];
          }
          /**
           * Register a comm in the mapping
           */
          register_comm(comm) {
            this.comms[comm.comm_id] = Promise.resolve(comm);
            comm.kernel = this.kernel;
            return comm.comm_id;
          }
        }
        services2.CommManager = CommManager;
        class Comm {
          constructor(jsServicesComm) {
            this.jsServicesComm = jsServicesComm;
          }
          /**
           * Comm id
           * @return {string}
           */
          get comm_id() {
            return this.jsServicesComm.commId;
          }
          /**
           * Target name
           * @return {string}
           */
          get target_name() {
            return this.jsServicesComm.targetName;
          }
          /**
           * Opens a sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @return msg id
           */
          open(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.open(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Sends a message to the sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @param  buffers
           * @return message id
           */
          send(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.send(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Closes the sibling comm in the backend
           * @param  data
           * @param  callbacks
           * @param  metadata
           * @return msg id
           */
          close(data, callbacks, metadata, buffers) {
            const future = this.jsServicesComm.close(data, metadata, buffers);
            this._hookupCallbacks(future, callbacks);
            return future.msg.header.msg_id;
          }
          /**
           * Register a message handler
           * @param  callback, which is given a message
           */
          on_msg(callback) {
            this.jsServicesComm.onMsg = callback.bind(this);
          }
          /**
           * Register a handler for when the comm is closed by the backend
           * @param  callback, which is given a message
           */
          on_close(callback) {
            this.jsServicesComm.onClose = callback.bind(this);
          }
          /**
           * Hooks callback object up with @jupyterlab/services IKernelFuture
           * @param  @jupyterlab/services IKernelFuture instance
           * @param  callbacks
           */
          _hookupCallbacks(future, callbacks) {
            if (callbacks) {
              future.onReply = function(msg) {
                if (callbacks.shell && callbacks.shell.reply) {
                  callbacks.shell.reply(msg);
                }
              };
              future.onStdin = function(msg) {
                if (callbacks.input) {
                  callbacks.input(msg);
                }
              };
              future.onIOPub = function(msg) {
                if (callbacks.iopub) {
                  if (callbacks.iopub.status && msg.header.msg_type === "status") {
                    callbacks.iopub.status(msg);
                  } else if (callbacks.iopub.clear_output && msg.header.msg_type === "clear_output") {
                    callbacks.iopub.clear_output(msg);
                  } else if (callbacks.iopub.output) {
                    switch (msg.header.msg_type) {
                      case "display_data":
                      case "execute_result":
                      case "stream":
                      case "error":
                        callbacks.iopub.output(msg);
                        break;
                      default:
                        break;
                    }
                  }
                }
              };
            }
          }
        }
        services2.Comm = Comm;
      })(services = shims2.services || (shims2.services = {}));
    })(shims || (shims = {}));
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/viewlist.js
var ViewList;
var init_viewlist = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/viewlist.js"() {
    ViewList = class {
      constructor(create_view, remove_view, context) {
        this.initialize(create_view, remove_view, context);
      }
      initialize(create_view, remove_view, context) {
        this._handler_context = context || this;
        this._models = [];
        this.views = [];
        this._create_view = create_view;
        this._remove_view = remove_view || function(view) {
          view.remove();
        };
      }
      /**
       * the create_view, remove_view, and context arguments override the defaults
       * specified when the list is created.
       * after this function, the .views attribute is a list of promises for views
       * if you want to perform some action on the list of views, do something like
       * `Promise.all(myviewlist.views).then(function(views) {...});`
       */
      update(new_models, create_view, remove_view, context) {
        const remove2 = remove_view || this._remove_view;
        const create2 = create_view || this._create_view;
        context = context || this._handler_context;
        let i6 = 0;
        for (; i6 < new_models.length; i6++) {
          if (i6 >= this._models.length || new_models[i6] !== this._models[i6]) {
            break;
          }
        }
        const first_removed = i6;
        const removed = this.views.splice(first_removed, this.views.length - first_removed);
        for (let j2 = 0; j2 < removed.length; j2++) {
          removed[j2].then(function(view) {
            remove2.call(context, view);
          });
        }
        for (; i6 < new_models.length; i6++) {
          this.views.push(Promise.resolve(create2.call(context, new_models[i6], i6)));
        }
        this._models = new_models.slice();
        return Promise.all(this.views);
      }
      /**
       * removes every view in the list; convenience function for `.update([])`
       * that should be faster
       * returns a promise that resolves after this removal is done
       */
      remove() {
        return Promise.all(this.views).then((views) => {
          views.forEach((value) => this._remove_view.call(this._handler_context, value));
          this.views = [];
          this._models = [];
        });
      }
      /**
       * Dispose this viewlist.
       *
       * A synchronous function which just deletes references to child views. This
       * function does not call .remove() on child views because that is
       * asynchronous. Use this in cases where child views will be removed in
       * another way.
       */
      dispose() {
        this.views = null;
        this._models = null;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/registry.js
var import_coreutils16, IJupyterWidgetRegistry;
var init_registry2 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/registry.js"() {
    import_coreutils16 = __toESM(require_dist());
    IJupyterWidgetRegistry = new import_coreutils16.Token("jupyter.extensions.jupyterWidgetRegistry");
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/errorwidget.js
function createErrorWidgetModel(error, msg) {
  class ErrorWidget extends DOMWidgetModel {
    constructor(attributes, options) {
      attributes = Object.assign(Object.assign({}, attributes), { _view_name: "ErrorWidgetView", _view_module: "@jupyter-widgets/base", _model_module_version: JUPYTER_WIDGETS_VERSION, _view_module_version: JUPYTER_WIDGETS_VERSION, msg, error });
      super(attributes, options);
      this.comm_live = true;
    }
  }
  return ErrorWidget;
}
function createErrorWidgetView(error, msg) {
  return class InnerErrorWidgetView extends ErrorWidgetView {
    generateErrorMessage() {
      return {
        msg,
        stack: String(error instanceof Error ? error.stack : error)
      };
    }
  };
}
var ErrorWidgetView;
var init_errorwidget = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/errorwidget.js"() {
    init_widget2();
    init_version();
    init_utils();
    ErrorWidgetView = class extends DOMWidgetView {
      generateErrorMessage() {
        return {
          msg: this.model.get("msg"),
          stack: String(this.model.get("error").stack)
        };
      }
      render() {
        const { msg, stack } = this.generateErrorMessage();
        this.el.classList.add("jupyter-widgets");
        const content = document.createElement("div");
        content.classList.add("jupyter-widgets-error-widget", "icon-error");
        content.innerHTML = BROKEN_FILE_SVG_ICON;
        const text = document.createElement("pre");
        text.style.textAlign = "center";
        text.innerText = "Click to show javascript error.";
        content.append(text);
        this.el.appendChild(content);
        let width;
        let height;
        this.el.onclick = () => {
          if (content.classList.contains("icon-error")) {
            height = height || content.clientHeight;
            width = width || content.clientWidth;
            content.classList.remove("icon-error");
            content.innerHTML = `
        <pre>[Open Browser Console for more detailed log - Double click to close this message]
${msg}
${stack}</pre>
        `;
            content.style.height = `${height}px`;
            content.style.width = `${width}px`;
            content.classList.add("text-error");
          }
        };
        this.el.ondblclick = () => {
          if (content.classList.contains("text-error")) {
            content.classList.remove("text-error");
            content.innerHTML = BROKEN_FILE_SVG_ICON;
            content.append(text);
            content.classList.add("icon-error");
          }
        };
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  BROKEN_FILE_SVG_ICON: () => BROKEN_FILE_SVG_ICON,
  DOMWidgetModel: () => DOMWidgetModel,
  DOMWidgetView: () => DOMWidgetView,
  ErrorWidgetView: () => ErrorWidgetView,
  IJupyterWidgetRegistry: () => IJupyterWidgetRegistry,
  JUPYTER_WIDGETS_VERSION: () => JUPYTER_WIDGETS_VERSION,
  JupyterLuminoPanelWidget: () => JupyterLuminoPanelWidget,
  JupyterLuminoWidget: () => JupyterLuminoWidget,
  JupyterPhosphorPanelWidget: () => JupyterPhosphorPanelWidget,
  JupyterPhosphorWidget: () => JupyterPhosphorWidget,
  LayoutModel: () => LayoutModel,
  LayoutView: () => LayoutView,
  PROTOCOL_VERSION: () => PROTOCOL_VERSION,
  StyleModel: () => StyleModel,
  StyleView: () => StyleView,
  ViewList: () => ViewList,
  WidgetModel: () => WidgetModel,
  WidgetView: () => WidgetView,
  assign: () => assign,
  createErrorWidgetModel: () => createErrorWidgetModel,
  createErrorWidgetView: () => createErrorWidgetView,
  difference: () => difference,
  isEqual: () => isEqual,
  isObject: () => isObject2,
  isSerializable: () => isSerializable,
  pack_models: () => pack_models,
  put_buffers: () => put_buffers,
  reject: () => reject,
  remove_buffers: () => remove_buffers,
  resolvePromisesDict: () => resolvePromisesDict,
  shims: () => shims,
  unpack_models: () => unpack_models,
  uuid: () => uuid
});
var init_lib8 = __esm({
  "../../node_modules/@jupyter-widgets/base/lib/index.js"() {
    init_widget2();
    init_manager();
    init_widget_layout();
    init_widget_style();
    init_services_shim();
    init_viewlist();
    init_version();
    init_utils();
    init_registry2();
    init_errorwidget();
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray2;
    exports.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i6 = 0, len = code3.length; i6 < len; ++i6) {
      lookup[i6] = code3[i6];
      revLookup[code3.charCodeAt(i6)] = i6;
    }
    var i6;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i7;
      for (i7 = 0; i7 < len2; i7 += 4) {
        tmp = revLookup[b64.charCodeAt(i7)] << 18 | revLookup[b64.charCodeAt(i7 + 1)] << 12 | revLookup[b64.charCodeAt(i7 + 2)] << 6 | revLookup[b64.charCodeAt(i7 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i7)] << 2 | revLookup[b64.charCodeAt(i7 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i7)] << 10 | revLookup[b64.charCodeAt(i7 + 1)] << 4 | revLookup[b64.charCodeAt(i7 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i7 = start; i7 < end; i7 += 3) {
        tmp = (uint8[i7] << 16 & 16711680) + (uint8[i7 + 1] << 8 & 65280) + (uint8[i7 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i7 = 0, len22 = len2 - extraBytes; i7 < len22; i7 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i7, i7 + maxChunkLength > len22 ? len22 : i7 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/utils.js
function hexToBuffer(hex) {
  const x2 = new Uint8Array(hex.length / 2);
  for (let i6 = 0; i6 < hex.length; i6 += 2) {
    x2[i6 / 2] = parseInt(hex.slice(i6, i6 + 2), 16);
  }
  return x2.buffer;
}
function bufferToBase64(buffer) {
  return (0, import_base64_js.fromByteArray)(new Uint8Array(buffer));
}
function base64ToBuffer(base64) {
  return (0, import_base64_js.toByteArray)(base64).buffer;
}
var import_base64_js;
var init_utils2 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/utils.js"() {
    import_base64_js = __toESM(require_base64_js());
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/latex.js
function removeMath2(text) {
  const math = [];
  let start = null;
  let end = null;
  let last2 = null;
  let braces = 0;
  let deTilde;
  const hasCodeSpans = /`/.test(text);
  if (hasCodeSpans) {
    text = text.replace(/~/g, "~T").replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, (wholematch) => wholematch.replace(/\$/g, "~D"));
    deTilde = (text2) => {
      return text2.replace(/~([TD])/g, (wholematch, character) => character === "T" ? "~" : inline4);
    };
  } else {
    deTilde = (text2) => {
      return text2;
    };
  }
  let blocks = text.replace(/\r\n?/g, "\n").split(MATHSPLIT2);
  for (let i6 = 1, m5 = blocks.length; i6 < m5; i6 += 2) {
    const block = blocks[i6];
    if (block.charAt(0) === "@") {
      blocks[i6] = "@@" + math.length + "@@";
      math.push(block);
    } else if (start !== null) {
      if (block === end) {
        if (braces) {
          last2 = i6;
        } else {
          blocks = processMath2(start, i6, deTilde, math, blocks);
          start = null;
          end = null;
          last2 = null;
        }
      } else if (block.match(/\n.*\n/)) {
        if (last2 !== null) {
          i6 = last2;
          blocks = processMath2(start, i6, deTilde, math, blocks);
        }
        start = null;
        end = null;
        last2 = null;
        braces = 0;
      } else if (block === "{") {
        braces++;
      } else if (block === "}" && braces) {
        braces--;
      }
    } else {
      if (block === inline4 || block === "$$") {
        start = i6;
        end = block;
        braces = 0;
      } else if (block === "\\\\(" || block === "\\\\[") {
        start = i6;
        end = block.slice(-1) === "(" ? "\\\\)" : "\\\\]";
        braces = 0;
      } else if (block.substr(1, 5) === "begin") {
        start = i6;
        end = "\\end" + block.substr(6);
        braces = 0;
      }
    }
  }
  if (start !== null && last2 !== null) {
    blocks = processMath2(start, last2, deTilde, math, blocks);
    start = null;
    end = null;
    last2 = null;
  }
  return { text: deTilde(blocks.join("")), math };
}
function replaceMath2(text, math) {
  const process2 = (match, n5) => {
    let group2 = math[n5];
    if (group2.substr(0, 3) === "\\\\(" && group2.substr(group2.length - 3) === "\\\\)") {
      group2 = "\\(" + group2.substring(3, group2.length - 3) + "\\)";
    } else if (group2.substr(0, 3) === "\\\\[" && group2.substr(group2.length - 3) === "\\\\]") {
      group2 = "\\[" + group2.substring(3, group2.length - 3) + "\\]";
    }
    return group2;
  };
  return text.replace(/@@(\d+)@@/g, process2);
}
function processMath2(i6, j2, preProcess, math, blocks) {
  let block = blocks.slice(i6, j2 + 1).join("").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  if (navigator && navigator.appName === "Microsoft Internet Explorer") {
    block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
  }
  while (j2 > i6) {
    blocks[j2] = "";
    j2--;
  }
  blocks[i6] = "@@" + math.length + "@@";
  if (preProcess) {
    block = preProcess(block);
  }
  math.push(block);
  return blocks;
}
var inline4, MATHSPLIT2;
var init_latex2 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/latex.js"() {
    inline4 = "$";
    MATHSPLIT2 = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[{}$]|[{}]|(?:\n\s*)+|@@\d+@@|\\\\(?:\(|\)|\[|\]))/i;
  }
});

// ../../node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS({
  "../../node_modules/sanitize-html/index.js"(exports, module) {
    var htmlparser = require_lib3();
    var escapeStringRegexp = require_escape_string_regexp();
    var { isPlainObject } = require_is_plain_object();
    var deepmerge = require_cjs();
    var parseSrcset = require_parse_srcset();
    var { parse: postcssParse } = require_postcss();
    var mediaTags = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ];
    var vulnerableTags = ["script", "style"];
    function each3(obj, cb2) {
      if (obj) {
        Object.keys(obj).forEach(function(key) {
          cb2(obj[key], key);
        });
      }
    }
    function has4(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function filter2(a3, cb2) {
      const n5 = [];
      each3(a3, function(v4) {
        if (cb2(v4)) {
          n5.push(v4);
        }
      });
      return n5;
    }
    function isEmptyObject(obj) {
      for (const key in obj) {
        if (has4(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function stringifySrcset(parsedSrcset) {
      return parsedSrcset.map(function(part) {
        if (!part.url) {
          throw new Error("URL missing");
        }
        return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
      }).join(", ");
    }
    module.exports = sanitizeHtml;
    var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
    function sanitizeHtml(html, options, _recursing) {
      if (html == null) {
        return "";
      }
      if (typeof html === "number") {
        html = html.toString();
      }
      let result2 = "";
      let tempResult = "";
      function Frame(tag, attribs) {
        const that = this;
        this.tag = tag;
        this.attribs = attribs || {};
        this.tagPosition = result2.length;
        this.text = "";
        this.openingTagLength = 0;
        this.mediaChildren = [];
        this.updateParentNodeText = function() {
          if (stack.length) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.text += that.text;
          }
        };
        this.updateParentNodeMediaChildren = function() {
          if (stack.length && mediaTags.includes(this.tag)) {
            const parentFrame = stack[stack.length - 1];
            parentFrame.mediaChildren.push(this.tag);
          }
        };
      }
      options = Object.assign({}, sanitizeHtml.defaults, options);
      options.parser = Object.assign({}, htmlParserDefaults, options.parser);
      const tagAllowed = function(name) {
        return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
      };
      vulnerableTags.forEach(function(tag) {
        if (tagAllowed(tag) && !options.allowVulnerableTags) {
          console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
        }
      });
      const nonTextTagsArray = options.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let allowedAttributesMap;
      let allowedAttributesGlobMap;
      if (options.allowedAttributes) {
        allowedAttributesMap = {};
        allowedAttributesGlobMap = {};
        each3(options.allowedAttributes, function(attributes, tag) {
          allowedAttributesMap[tag] = [];
          const globRegex = [];
          attributes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else {
              allowedAttributesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        });
      }
      const allowedClassesMap = {};
      const allowedClassesGlobMap = {};
      const allowedClassesRegexMap = {};
      each3(options.allowedClasses, function(classes, tag) {
        if (allowedAttributesMap) {
          if (!has4(allowedAttributesMap, tag)) {
            allowedAttributesMap[tag] = [];
          }
          allowedAttributesMap[tag].push("class");
        }
        allowedClassesMap[tag] = classes;
        if (Array.isArray(classes)) {
          const globRegex = [];
          allowedClassesMap[tag] = [];
          allowedClassesRegexMap[tag] = [];
          classes.forEach(function(obj) {
            if (typeof obj === "string" && obj.indexOf("*") >= 0) {
              globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
            } else if (obj instanceof RegExp) {
              allowedClassesRegexMap[tag].push(obj);
            } else {
              allowedClassesMap[tag].push(obj);
            }
          });
          if (globRegex.length) {
            allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
          }
        }
      });
      const transformTagsMap = {};
      let transformTagsAll;
      each3(options.transformTags, function(transform, tag) {
        let transFun;
        if (typeof transform === "function") {
          transFun = transform;
        } else if (typeof transform === "string") {
          transFun = sanitizeHtml.simpleTransform(transform);
        }
        if (tag === "*") {
          transformTagsAll = transFun;
        } else {
          transformTagsMap[tag] = transFun;
        }
      });
      let depth;
      let stack;
      let skipMap;
      let transformMap;
      let skipText;
      let skipTextDepth;
      let addedText = false;
      initializeState();
      const parser = new htmlparser.Parser({
        onopentag: function(name, attribs) {
          if (options.onOpenTag) {
            options.onOpenTag(name, attribs);
          }
          if (options.enforceHtmlBoundary && name === "html") {
            initializeState();
          }
          if (skipText) {
            skipTextDepth++;
            return;
          }
          const frame = new Frame(name, attribs);
          stack.push(frame);
          let skip = false;
          const hasText = !!frame.text;
          let transformedTag;
          if (has4(transformTagsMap, name)) {
            transformedTag = transformTagsMap[name](name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (transformedTag.text !== void 0) {
              frame.innerText = transformedTag.text;
            }
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (transformTagsAll) {
            transformedTag = transformTagsAll(name, attribs);
            frame.attribs = attribs = transformedTag.attribs;
            if (name !== transformedTag.tagName) {
              frame.name = name = transformedTag.tagName;
              transformMap[depth] = transformedTag.tagName;
            }
          }
          if (!tagAllowed(name) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
            skip = true;
            skipMap[depth] = true;
            if (options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") {
              if (nonTextTagsArray.indexOf(name) !== -1) {
                skipText = true;
                skipTextDepth = 1;
              }
            }
          }
          depth++;
          if (skip) {
            if (options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") {
              if (frame.innerText && !hasText) {
                const escaped = escapeHtml(frame.innerText);
                if (options.textFilter) {
                  result2 += options.textFilter(escaped, name);
                } else {
                  result2 += escaped;
                }
                addedText = true;
              }
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          result2 += "<" + name;
          if (name === "script") {
            if (options.allowedScriptHostnames || options.allowedScriptDomains) {
              frame.innerText = "";
            }
          }
          const isBeingEscaped = skip && (options.disallowedTagsMode === "escape" || options.disallowedTagsMode === "recursiveEscape");
          const shouldPreserveEscapedAttributes = isBeingEscaped && options.preserveEscapedAttributes;
          if (shouldPreserveEscapedAttributes) {
            each3(attribs, function(value, a3) {
              result2 += " " + a3 + '="' + escapeHtml(value || "", true) + '"';
            });
          } else if (!allowedAttributesMap || has4(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
            each3(attribs, function(value, a3) {
              if (!VALID_HTML_ATTRIBUTE_NAME.test(a3)) {
                delete frame.attribs[a3];
                return;
              }
              if (value === "" && !options.allowedEmptyAttributes.includes(a3) && (options.nonBooleanAttributes.includes(a3) || options.nonBooleanAttributes.includes("*"))) {
                delete frame.attribs[a3];
                return;
              }
              let passedAllowedAttributesMapCheck = false;
              if (!allowedAttributesMap || has4(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a3) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a3) !== -1 || has4(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a3) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a3)) {
                passedAllowedAttributesMapCheck = true;
              } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                for (const o11 of allowedAttributesMap[name]) {
                  if (isPlainObject(o11) && o11.name && o11.name === a3) {
                    passedAllowedAttributesMapCheck = true;
                    let newValue = "";
                    if (o11.multiple === true) {
                      const splitStrArray = value.split(" ");
                      for (const s8 of splitStrArray) {
                        if (o11.values.indexOf(s8) !== -1) {
                          if (newValue === "") {
                            newValue = s8;
                          } else {
                            newValue += " " + s8;
                          }
                        }
                      }
                    } else if (o11.values.indexOf(value) >= 0) {
                      newValue = value;
                    }
                    value = newValue;
                  }
                }
              }
              if (passedAllowedAttributesMapCheck) {
                if (options.allowedSchemesAppliedToAttributes.indexOf(a3) !== -1) {
                  if (naughtyHref(name, value)) {
                    delete frame.attribs[a3];
                    return;
                  }
                }
                if (name === "script" && a3 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                      const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e3) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a3];
                    return;
                  }
                }
                if (name === "iframe" && a3 === "src") {
                  let allowed = true;
                  try {
                    const parsed = parseUrl(value);
                    if (parsed.isRelativeUrl) {
                      allowed = has4(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                    } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                      const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                        return hostname === parsed.url.hostname;
                      });
                      const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                        return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                      });
                      allowed = allowedHostname || allowedDomain;
                    }
                  } catch (e3) {
                    allowed = false;
                  }
                  if (!allowed) {
                    delete frame.attribs[a3];
                    return;
                  }
                }
                if (a3 === "srcset") {
                  try {
                    let parsed = parseSrcset(value);
                    parsed.forEach(function(value2) {
                      if (naughtyHref("srcset", value2.url)) {
                        value2.evil = true;
                      }
                    });
                    parsed = filter2(parsed, function(v4) {
                      return !v4.evil;
                    });
                    if (!parsed.length) {
                      delete frame.attribs[a3];
                      return;
                    } else {
                      value = stringifySrcset(filter2(parsed, function(v4) {
                        return !v4.evil;
                      }));
                      frame.attribs[a3] = value;
                    }
                  } catch (e3) {
                    delete frame.attribs[a3];
                    return;
                  }
                }
                if (a3 === "class") {
                  const allowedSpecificClasses = allowedClassesMap[name];
                  const allowedWildcardClasses = allowedClassesMap["*"];
                  const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                  const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                  const allowedWildcardClassesRegex = allowedClassesRegexMap["*"];
                  const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                  const allowedClassesGlobs = [
                    allowedSpecificClassesGlob,
                    allowedWildcardClassesGlob
                  ].concat(allowedSpecificClassesRegex, allowedWildcardClassesRegex).filter(function(t11) {
                    return t11;
                  });
                  if (allowedSpecificClasses && allowedWildcardClasses) {
                    value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                  } else {
                    value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                  }
                  if (!value.length) {
                    delete frame.attribs[a3];
                    return;
                  }
                }
                if (a3 === "style") {
                  if (options.parseStyleAttributes) {
                    try {
                      const abstractSyntaxTree = postcssParse(name + " {" + value + "}", { map: false });
                      const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                      value = stringifyStyleAttributes(filteredAST);
                      if (value.length === 0) {
                        delete frame.attribs[a3];
                        return;
                      }
                    } catch (e3) {
                      if (typeof window !== "undefined") {
                        console.warn('Failed to parse "' + name + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                      }
                      delete frame.attribs[a3];
                      return;
                    }
                  } else if (options.allowedStyles) {
                    throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                  }
                }
                result2 += " " + a3;
                if (value && value.length) {
                  result2 += '="' + escapeHtml(value, true) + '"';
                } else if (options.allowedEmptyAttributes.includes(a3)) {
                  result2 += '=""';
                }
              } else {
                delete frame.attribs[a3];
              }
            });
          }
          if (options.selfClosing.indexOf(name) !== -1) {
            result2 += " />";
          } else {
            result2 += ">";
            if (frame.innerText && !hasText && !options.textFilter) {
              result2 += escapeHtml(frame.innerText);
              addedText = true;
            }
          }
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
          frame.openingTagLength = result2.length - frame.tagPosition;
        },
        ontext: function(text) {
          if (skipText) {
            return;
          }
          const lastFrame = stack[stack.length - 1];
          let tag;
          if (lastFrame) {
            tag = lastFrame.tag;
            text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
          }
          if (options.disallowedTagsMode === "completelyDiscard" && !tagAllowed(tag)) {
            text = "";
          } else if ((options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") && (tag === "script" || tag === "style")) {
            result2 += text;
          } else if (!addedText) {
            const escaped = escapeHtml(text, false);
            if (options.textFilter) {
              result2 += options.textFilter(escaped, tag);
            } else {
              result2 += escaped;
            }
          }
          if (stack.length) {
            const frame = stack[stack.length - 1];
            frame.text += text;
          }
        },
        onclosetag: function(name, isImplied) {
          if (options.onCloseTag) {
            options.onCloseTag(name, isImplied);
          }
          if (skipText) {
            skipTextDepth--;
            if (!skipTextDepth) {
              skipText = false;
            } else {
              return;
            }
          }
          const frame = stack.pop();
          if (!frame) {
            return;
          }
          if (frame.tag !== name) {
            stack.push(frame);
            return;
          }
          skipText = options.enforceHtmlBoundary ? name === "html" : false;
          depth--;
          const skip = skipMap[depth];
          if (skip) {
            delete skipMap[depth];
            if (options.disallowedTagsMode === "discard" || options.disallowedTagsMode === "completelyDiscard") {
              frame.updateParentNodeText();
              return;
            }
            tempResult = result2;
            result2 = "";
          }
          if (transformMap[depth]) {
            name = transformMap[depth];
            delete transformMap[depth];
          }
          if (options.exclusiveFilter) {
            const filterResult = options.exclusiveFilter(frame);
            if (filterResult === "excludeTag") {
              if (skip) {
                result2 = tempResult;
                tempResult = "";
              }
              result2 = result2.substring(0, frame.tagPosition) + result2.substring(frame.tagPosition + frame.openingTagLength);
              return;
            } else if (filterResult) {
              result2 = result2.substring(0, frame.tagPosition);
              return;
            }
          }
          frame.updateParentNodeMediaChildren();
          frame.updateParentNodeText();
          if (
            // Already output />
            options.selfClosing.indexOf(name) !== -1 || // Escaped tag, closing tag is implied
            isImplied && !tagAllowed(name) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0
          ) {
            if (skip) {
              result2 = tempResult;
              tempResult = "";
            }
            return;
          }
          result2 += "</" + name + ">";
          if (skip) {
            result2 = tempResult + escapeHtml(result2);
            tempResult = "";
          }
          addedText = false;
        }
      }, options.parser);
      parser.write(html);
      parser.end();
      return result2;
      function initializeState() {
        result2 = "";
        depth = 0;
        stack = [];
        skipMap = {};
        transformMap = {};
        skipText = false;
        skipTextDepth = 0;
      }
      function escapeHtml(s8, quote) {
        if (typeof s8 !== "string") {
          s8 = s8 + "";
        }
        if (options.parser.decodeEntities) {
          s8 = s8.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s8 = s8.replace(/"/g, "&quot;");
          }
        }
        s8 = s8.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (quote) {
          s8 = s8.replace(/"/g, "&quot;");
        }
        return s8;
      }
      function naughtyHref(name, href) {
        href = href.replace(/[\x00-\x20]+/g, "");
        while (true) {
          const firstIndex = href.indexOf("<!--");
          if (firstIndex === -1) {
            break;
          }
          const lastIndex = href.indexOf("-->", firstIndex + 4);
          if (lastIndex === -1) {
            break;
          }
          href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
        }
        const matches2 = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!matches2) {
          if (href.match(/^[/\\]{2}/)) {
            return !options.allowProtocolRelative;
          }
          return false;
        }
        const scheme = matches2[1].toLowerCase();
        if (has4(options.allowedSchemesByTag, name)) {
          return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
        }
        return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
      }
      function parseUrl(value) {
        value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
        if (value.startsWith("relative:")) {
          throw new Error("relative: exploit attempt");
        }
        let base = "relative://relative-site";
        for (let i6 = 0; i6 < 100; i6++) {
          base += `/${i6}`;
        }
        const parsed = new URL(value, base);
        const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
        return {
          isRelativeUrl,
          url: parsed
        };
      }
      function filterCss(abstractSyntaxTree, allowedStyles) {
        if (!allowedStyles) {
          return abstractSyntaxTree;
        }
        const astRules = abstractSyntaxTree.nodes[0];
        let selectedRule;
        if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
          selectedRule = deepmerge(
            allowedStyles[astRules.selector],
            allowedStyles["*"]
          );
        } else {
          selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
        }
        if (selectedRule) {
          abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
        }
        return abstractSyntaxTree;
      }
      function stringifyStyleAttributes(filteredAST) {
        return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
          extractedAttributes.push(
            `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
          );
          return extractedAttributes;
        }, []).join(";");
      }
      function filterDeclarations(selectedRule) {
        return function(allowedDeclarationsList, attributeObject) {
          if (has4(selectedRule, attributeObject.prop)) {
            const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
              return regularExpression.test(attributeObject.value);
            });
            if (matchesRegex) {
              allowedDeclarationsList.push(attributeObject);
            }
          }
          return allowedDeclarationsList;
        };
      }
      function filterClasses(classes, allowed, allowedGlobs) {
        if (!allowed) {
          return classes;
        }
        classes = classes.split(/\s+/);
        return classes.filter(function(clss) {
          return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
            return glob.test(clss);
          });
        }).join(" ");
      }
    }
    var htmlParserDefaults = {
      decodeEntities: true
    };
    sanitizeHtml.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "menu",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      // Tags that cannot be boolean
      nonBooleanAttributes: [
        "abbr",
        "accept",
        "accept-charset",
        "accesskey",
        "action",
        "allow",
        "alt",
        "as",
        "autocapitalize",
        "autocomplete",
        "blocking",
        "charset",
        "cite",
        "class",
        "color",
        "cols",
        "colspan",
        "content",
        "contenteditable",
        "coords",
        "crossorigin",
        "data",
        "datetime",
        "decoding",
        "dir",
        "dirname",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "fetchpriority",
        "for",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formtarget",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "http-equiv",
        "id",
        "imagesizes",
        "imagesrcset",
        "inputmode",
        "integrity",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemtype",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "name",
        "nonce",
        "optimum",
        "pattern",
        "ping",
        "placeholder",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "referrerpolicy",
        "rel",
        "rows",
        "rowspan",
        "sandbox",
        "scope",
        "shape",
        "size",
        "sizes",
        "slot",
        "span",
        "spellcheck",
        "src",
        "srcdoc",
        "srclang",
        "srcset",
        "start",
        "step",
        "style",
        "tabindex",
        "target",
        "title",
        "translate",
        "type",
        "usemap",
        "value",
        "width",
        "wrap",
        // Event handlers
        "onauxclick",
        "onafterprint",
        "onbeforematch",
        "onbeforeprint",
        "onbeforeunload",
        "onbeforetoggle",
        "onblur",
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncopy",
        "oncuechange",
        "oncut",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onpagehide",
        "onpageshow",
        "onpaste",
        "onpause",
        "onplay",
        "onplaying",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onrejectionhandled",
        "onscroll",
        "onscrollend",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwheel"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      allowedEmptyAttributes: [
        "alt"
      ],
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: true,
      enforceHtmlBoundary: false,
      parseStyleAttributes: true,
      preserveEscapedAttributes: false
    };
    sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
      merge = merge === void 0 ? true : merge;
      newAttribs = newAttribs || {};
      return function(tagName, attribs) {
        let attrib;
        if (merge) {
          for (attrib in newAttribs) {
            attribs[attrib] = newAttribs[attrib];
          }
        } else {
          attribs = newAttribs;
        }
        return {
          tagName: newTagName,
          attribs
        };
      };
    };
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/manager-base.js
function default_inline_sanitize(s8) {
  const allowedTags = [
    "a",
    "abbr",
    "b",
    "code",
    "em",
    "i",
    "img",
    "li",
    "ol",
    "span",
    "strong",
    "ul"
  ];
  const allowedAttributes = {
    "*": ["aria-*", "class", "style", "title"],
    a: ["href"],
    img: ["src"],
    style: ["media", "type"]
  };
  return (0, import_sanitize_html.default)(s8, {
    allowedTags,
    allowedAttributes
  });
}
function serialize_state(models, options = {}) {
  const state = {};
  models.forEach((model) => {
    const model_id = model.model_id;
    const split = remove_buffers(model.serialize(model.get_state(options.drop_defaults)));
    const buffers = split.buffers.map((buffer, index2) => {
      return {
        data: bufferToBase64(buffer),
        path: split.buffer_paths[index2],
        encoding: "base64"
      };
    });
    state[model_id] = {
      model_name: model.name,
      model_module: model.module,
      model_module_version: model.get("_model_module_version"),
      state: split.state
    };
    if (buffers.length > 0) {
      state[model_id].buffers = buffers;
    }
  });
  return { version_major: 2, version_minor: 0, state };
}
var import_coreutils17, import_sanitize_html, PROTOCOL_MAJOR_VERSION, CONTROL_COMM_TARGET, CONTROL_COMM_PROTOCOL_VERSION, CONTROL_COMM_TIMEOUT, ManagerBase;
var init_manager_base = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/manager-base.js"() {
    init_lib8();
    import_coreutils17 = __toESM(require_dist());
    init_lib8();
    init_utils2();
    init_latex2();
    import_sanitize_html = __toESM(require_sanitize_html());
    PROTOCOL_MAJOR_VERSION = PROTOCOL_VERSION.split(".", 1)[0];
    CONTROL_COMM_TARGET = "jupyter.widget.control";
    CONTROL_COMM_PROTOCOL_VERSION = "1.0.0";
    CONTROL_COMM_TIMEOUT = 4e3;
    ManagerBase = class {
      constructor() {
        this.comm_target_name = "jupyter.widget";
        this._models = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Modifies view options. Generally overloaded in custom widget manager
       * implementations.
       */
      setViewOptions(options = {}) {
        return options;
      }
      create_view(model, options = {}) {
        const id = uuid();
        const viewPromise = model.state_change = model.state_change.then(async () => {
          const _view_name = model.get("_view_name");
          const _view_module = model.get("_view_module");
          try {
            const ViewType = await this.loadViewClass(_view_name, _view_module, model.get("_view_module_version"));
            const view = new ViewType({
              model,
              options: this.setViewOptions(options)
            });
            view.listenTo(model, "destroy", view.remove);
            await view.render();
            view.once("remove", () => {
              if (model.views) {
                delete model.views[id];
              }
            });
            return view;
          } catch (e3) {
            console.error(`Could not create a view for model id ${model.model_id}`);
            const msg = `Failed to create view for '${_view_name}' from module '${_view_module}' with model '${model.name}' from module '${model.module}'`;
            const ModelCls = createErrorWidgetModel(e3, msg);
            const errorModel = new ModelCls();
            const view = new ErrorWidgetView({
              model: errorModel,
              options: this.setViewOptions(options)
            });
            await view.render();
            return view;
          }
        });
        if (model.views) {
          model.views[id] = viewPromise;
        }
        return viewPromise;
      }
      /**
       * callback handlers specific to a view
       */
      callbacks(view) {
        return {};
      }
      /**
       * Get a promise for a model by model id.
       *
       * #### Notes
       * If the model is not found, the returned Promise object is rejected.
       *
       * If you would like to synchronously test if a model exists, use .has_model().
       */
      async get_model(model_id) {
        const modelPromise = this._models[model_id];
        if (modelPromise === void 0) {
          throw new Error("widget model not found");
        }
        return modelPromise;
      }
      /**
       * Returns true if the given model is registered, otherwise false.
       *
       * #### Notes
       * This is a synchronous way to check if a model is registered.
       */
      has_model(model_id) {
        return this._models[model_id] !== void 0;
      }
      /**
       * Handle when a comm is opened.
       */
      handle_comm_open(comm, msg) {
        const protocolVersion = (msg.metadata || {})["version"] || "";
        if (protocolVersion.split(".", 1)[0] !== PROTOCOL_MAJOR_VERSION) {
          const error = `Wrong widget protocol version: received protocol version '${protocolVersion}', but was expecting major version '${PROTOCOL_MAJOR_VERSION}'`;
          console.error(error);
          return Promise.reject(error);
        }
        const data = msg.content.data;
        const buffer_paths = data.buffer_paths || [];
        const buffers = msg.buffers || [];
        put_buffers(data.state, buffer_paths, buffers);
        return this.new_model({
          model_name: data.state["_model_name"],
          model_module: data.state["_model_module"],
          model_module_version: data.state["_model_module_version"],
          comm
        }, data.state).catch(reject("Could not create a model.", true));
      }
      /**
       * Create a comm and new widget model.
       * @param  options - same options as new_model but comm is not
       *                          required and additional options are available.
       * @param  serialized_state - serialized model attributes.
       */
      new_widget(options, serialized_state = {}) {
        let commPromise;
        if (options.view_name === void 0 || options.view_module === void 0 || options.view_module_version === void 0) {
          return Promise.reject("new_widget(...) must be given view information in the options.");
        }
        if (options.comm) {
          commPromise = Promise.resolve(options.comm);
        } else {
          commPromise = this._create_comm(this.comm_target_name, options.model_id, {
            state: {
              _model_module: options.model_module,
              _model_module_version: options.model_module_version,
              _model_name: options.model_name,
              _view_module: options.view_module,
              _view_module_version: options.view_module_version,
              _view_name: options.view_name
            }
          }, { version: PROTOCOL_VERSION });
        }
        const options_clone = Object.assign({}, options);
        return commPromise.then((comm) => {
          options_clone.comm = comm;
          const widget_model = this.new_model(options_clone, serialized_state);
          return widget_model.then((model) => {
            model.sync("create", model);
            return model;
          });
        }, () => {
          if (!options_clone.model_id) {
            options_clone.model_id = uuid();
          }
          return this.new_model(options_clone, serialized_state);
        });
      }
      register_model(model_id, modelPromise) {
        this._models[model_id] = modelPromise;
        modelPromise.then((model) => {
          model.once("comm:close", () => {
            delete this._models[model_id];
          });
        });
      }
      /**
       * Create and return a promise for a new widget model
       *
       * @param options - the options for creating the model.
       * @param serialized_state - attribute values for the model.
       *
       * @example
       * widget_manager.new_model({
       *      model_name: 'IntSlider',
       *      model_module: '@jupyter-widgets/controls',
       *      model_module_version: '1.0.0',
       *      model_id: 'u-u-i-d'
       * }).then((model) => { console.log('Create success!', model); },
       *  (err) => {console.error(err)});
       *
       */
      async new_model(options, serialized_state = {}) {
        var _a, _b;
        const model_id = (_a = options.model_id) !== null && _a !== void 0 ? _a : (_b = options.comm) === null || _b === void 0 ? void 0 : _b.comm_id;
        if (!model_id) {
          throw new Error("Neither comm nor model_id provided in options object. At least one must exist.");
        }
        options.model_id = model_id;
        const modelPromise = this._make_model(options, serialized_state);
        this.register_model(model_id, modelPromise);
        return await modelPromise;
      }
      /**
       * Fetch all widgets states from the kernel using the control comm channel
       * If this fails (control comm handler not implemented kernel side),
       * it will fall back to `_loadFromKernelModels`.
       *
       * This is a utility function that can be used in subclasses.
       */
      async _loadFromKernel() {
        let data;
        let buffers;
        try {
          const initComm = await this._create_comm(CONTROL_COMM_TARGET, uuid(), {}, { version: CONTROL_COMM_PROTOCOL_VERSION });
          await new Promise((resolve, reject4) => {
            initComm.on_msg((msg) => {
              data = msg["content"]["data"];
              if (data.method !== "update_states") {
                console.warn(`
              Unknown ${data.method} message on the Control channel
            `);
                return;
              }
              buffers = (msg.buffers || []).map((b2) => {
                if (b2 instanceof DataView) {
                  return b2;
                } else {
                  return new DataView(b2 instanceof ArrayBuffer ? b2 : b2.buffer);
                }
              });
              resolve(null);
            });
            initComm.on_close(() => reject4("Control comm was closed too early"));
            initComm.send({ method: "request_states" }, {});
            setTimeout(() => reject4("Control comm did not respond in time"), CONTROL_COMM_TIMEOUT);
          });
          initComm.close();
        } catch (error) {
          return this._loadFromKernelModels();
        }
        const states = data.states;
        const bufferPaths = {};
        const bufferGroups = {};
        for (let i6 = 0; i6 < data.buffer_paths.length; i6++) {
          const [widget_id, ...path] = data.buffer_paths[i6];
          const b2 = buffers[i6];
          if (!bufferPaths[widget_id]) {
            bufferPaths[widget_id] = [];
            bufferGroups[widget_id] = [];
          }
          bufferPaths[widget_id].push(path);
          bufferGroups[widget_id].push(b2);
        }
        const widget_comms = await Promise.all(Object.keys(states).map(async (widget_id) => {
          const comm = this.has_model(widget_id) ? void 0 : await this._create_comm("jupyter.widget", widget_id);
          return { widget_id, comm };
        }));
        await Promise.all(widget_comms.map(async ({ widget_id, comm }) => {
          const state = states[widget_id];
          if (widget_id in bufferPaths) {
            put_buffers(state, bufferPaths[widget_id], bufferGroups[widget_id]);
          }
          try {
            if (comm) {
              await this.new_model({
                model_name: state.model_name,
                model_module: state.model_module,
                model_module_version: state.model_module_version,
                model_id: widget_id,
                comm
              }, state.state);
            } else {
              const model = await this.get_model(widget_id);
              const deserializedState = await model.constructor._deserialize_state(state.state, this);
              model.set_state(deserializedState);
            }
          } catch (error) {
            console.error(error);
          }
        }));
      }
      /**
       * Old implementation of fetching widget models one by one using
       * the request_state message on each comm.
       *
       * This is a utility function that can be used in subclasses.
       */
      async _loadFromKernelModels() {
        const comm_ids = await this._get_comm_info();
        const widgets_info = await Promise.all(Object.keys(comm_ids).map(async (comm_id) => {
          if (this.has_model(comm_id)) {
            return;
          }
          const comm = await this._create_comm(this.comm_target_name, comm_id);
          let msg_id = "";
          const info = new import_coreutils17.PromiseDelegate();
          comm.on_msg((msg) => {
            if (msg.parent_header.msg_id === msg_id && msg.header.msg_type === "comm_msg" && msg.content.data.method === "update") {
              const data = msg.content.data;
              const buffer_paths = data.buffer_paths || [];
              const buffers = msg.buffers || [];
              put_buffers(data.state, buffer_paths, buffers);
              info.resolve({ comm, msg });
            }
          });
          msg_id = comm.send({
            method: "request_state"
          }, this.callbacks(void 0));
          return info.promise;
        }));
        await Promise.all(widgets_info.map(async (widget_info) => {
          if (!widget_info) {
            return;
          }
          const content = widget_info.msg.content;
          await this.new_model({
            model_name: content.data.state._model_name,
            model_module: content.data.state._model_module,
            model_module_version: content.data.state._model_module_version,
            comm: widget_info.comm
          }, content.data.state);
        }));
      }
      async _make_model(options, serialized_state = {}) {
        const model_id = options.model_id;
        const model_promise = this.loadModelClass(options.model_name, options.model_module, options.model_module_version);
        let ModelType;
        const makeErrorModel = (error, msg) => {
          const Cls = createErrorWidgetModel(error, msg);
          const widget_model2 = new Cls();
          return widget_model2;
        };
        try {
          ModelType = await model_promise;
        } catch (error) {
          const msg = "Could not instantiate widget";
          console.error(msg);
          return makeErrorModel(error, msg);
        }
        if (!ModelType) {
          const msg = "Could not instantiate widget";
          console.error(msg);
          const error = new Error(`Cannot find model module ${options.model_module}@${options.model_module_version}, ${options.model_name}`);
          return makeErrorModel(error, msg);
        }
        let widget_model;
        try {
          const attributes = await ModelType._deserialize_state(serialized_state, this);
          const modelOptions = {
            widget_manager: this,
            model_id,
            comm: options.comm
          };
          widget_model = new ModelType(attributes, modelOptions);
        } catch (error) {
          console.error(error);
          const msg = `Model class '${options.model_name}' from module '${options.model_module}' is loaded but can not be instantiated`;
          widget_model = makeErrorModel(error, msg);
        }
        widget_model.name = options.model_name;
        widget_model.module = options.model_module;
        return widget_model;
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      clear_state() {
        return resolvePromisesDict(this._models).then((models) => {
          Object.keys(models).forEach((id) => models[id].close());
          this._models = /* @__PURE__ */ Object.create(null);
        });
      }
      /**
       * Asynchronously get the state of the widget manager.
       *
       * This includes all of the widget models, and follows the format given in
       * the @jupyter-widgets/schema package.
       *
       * @param options - The options for what state to return.
       * @returns Promise for a state dictionary
       */
      get_state(options = {}) {
        const modelPromises = Object.keys(this._models).map((id) => this._models[id]);
        return Promise.all(modelPromises).then((models) => {
          return serialize_state(models, options);
        });
      }
      /**
       * Set the widget manager state.
       *
       * @param state - a Javascript object conforming to the application/vnd.jupyter.widget-state+json spec.
       *
       * Reconstructs all of the widget models in the state, merges that with the
       * current manager state, and then attempts to redisplay the widgets in the
       * state.
       */
      set_state(state) {
        if (!(state.version_major && state.version_major <= 2)) {
          throw "Unsupported widget state format";
        }
        const models = state.state;
        const all_models = this._get_comm_info().then((live_comms) => {
          return Promise.all(Object.keys(models).map((model_id) => {
            const decode = {
              base64: base64ToBuffer,
              hex: hexToBuffer
            };
            const model = models[model_id];
            const modelState = model.state;
            if (model.buffers) {
              const bufferPaths = model.buffers.map((b2) => b2.path);
              const buffers = model.buffers.map((b2) => new DataView(decode[b2.encoding](b2.data)));
              put_buffers(model.state, bufferPaths, buffers);
            }
            if (this.has_model(model_id)) {
              return this.get_model(model_id).then((model2) => {
                return model2.constructor._deserialize_state(modelState || {}, this).then((attributes) => {
                  model2.set_state(attributes);
                  return model2;
                });
              });
            }
            const modelCreate = {
              model_id,
              model_name: model.model_name,
              model_module: model.model_module,
              model_module_version: model.model_module_version
            };
            if (Object.prototype.hasOwnProperty.call(live_comms, "model_id")) {
              return this._create_comm(this.comm_target_name, model_id).then((comm) => {
                modelCreate.comm = comm;
                return this.new_model(modelCreate);
              });
            } else {
              return this.new_model(modelCreate, modelState);
            }
          }));
        });
        return all_models;
      }
      /**
       * Disconnect the widget manager from the kernel, setting each model's comm
       * as dead.
       */
      disconnect() {
        Object.keys(this._models).forEach((i6) => {
          this._models[i6].then((model) => {
            model.comm_live = false;
          });
        });
      }
      /**
       * Resolve a URL relative to the current notebook location.
       *
       * The default implementation just returns the original url.
       */
      resolveUrl(url) {
        return Promise.resolve(url);
      }
      inline_sanitize(source) {
        const parts = removeMath2(source);
        const sanitized = default_inline_sanitize(parts["text"]);
        return replaceMath2(sanitized, parts["math"]);
      }
      async loadModelClass(className, moduleName, moduleVersion) {
        try {
          const promise = this.loadClass(className, moduleName, moduleVersion);
          await promise;
          return promise;
        } catch (error) {
          console.error(error);
          const msg = `Failed to load model class '${className}' from module '${moduleName}'`;
          return createErrorWidgetModel(error, msg);
        }
      }
      async loadViewClass(className, moduleName, moduleVersion) {
        try {
          const promise = this.loadClass(className, moduleName, moduleVersion);
          await promise;
          return promise;
        } catch (error) {
          console.error(error);
          const msg = `Failed to load view class '${className}' from module '${moduleName}'`;
          return createErrorWidgetView(error, msg);
        }
      }
      /**
       * Filter serialized widget state to remove any ID's already present in manager.
       *
       * @param {*} state Serialized state to filter
       *
       * @returns {*} A copy of the state, with its 'state' attribute filtered
       */
      filterExistingModelState(serialized_state) {
        let models = serialized_state.state;
        models = Object.keys(models).filter((model_id) => !this.has_model(model_id)).reduce((res, model_id) => {
          res[model_id] = models[model_id];
          return res;
        }, {});
        return Object.assign(Object.assign({}, serialized_state), { state: models });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/base-manager/lib/index.js
var init_lib9 = __esm({
  "../../node_modules/@jupyter-widgets/base-manager/lib/index.js"() {
    init_manager_base();
    init_utils2();
  }
});

// ../../node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../../node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../../node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// ../../node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re2 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t11 = exports.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max4] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max4}}`).split(`${token}+`).join(`${token}{1,${max4}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R2++;
      debug(name, index2, value);
      t11[name] = index2;
      src[index2] = value;
      safeSrc[index2] = safe;
      re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t11.NUMERICIDENTIFIER]})\\.(${src[t11.NUMERICIDENTIFIER]})\\.(${src[t11.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t11.NUMERICIDENTIFIERLOOSE]})\\.(${src[t11.NUMERICIDENTIFIERLOOSE]})\\.(${src[t11.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t11.NONNUMERICIDENTIFIER]}|${src[t11.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t11.NONNUMERICIDENTIFIER]}|${src[t11.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t11.PRERELEASEIDENTIFIER]}(?:\\.${src[t11.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t11.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t11.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t11.BUILDIDENTIFIER]}(?:\\.${src[t11.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t11.MAINVERSION]}${src[t11.PRERELEASE]}?${src[t11.BUILD]}?`);
    createToken("FULL", `^${src[t11.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t11.MAINVERSIONLOOSE]}${src[t11.PRERELEASELOOSE]}?${src[t11.BUILD]}?`);
    createToken("LOOSE", `^${src[t11.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t11.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t11.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t11.XRANGEIDENTIFIER]})(?:\\.(${src[t11.XRANGEIDENTIFIER]})(?:\\.(${src[t11.XRANGEIDENTIFIER]})(?:${src[t11.PRERELEASE]})?${src[t11.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t11.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t11.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t11.XRANGEIDENTIFIERLOOSE]})(?:${src[t11.PRERELEASELOOSE]})?${src[t11.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t11.GTLT]}\\s*${src[t11.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t11.GTLT]}\\s*${src[t11.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t11.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t11.COERCEPLAIN] + `(?:${src[t11.PRERELEASE]})?(?:${src[t11.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t11.COERCE], true);
    createToken("COERCERTLFULL", src[t11.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t11.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t11.LONETILDE]}${src[t11.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t11.LONETILDE]}${src[t11.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t11.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t11.LONECARET]}${src[t11.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t11.LONECARET]}${src[t11.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t11.GTLT]}\\s*(${src[t11.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t11.GTLT]}\\s*(${src[t11.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t11.GTLT]}\\s*(${src[t11.LOOSEPLAIN]}|${src[t11.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t11.XRANGEPLAIN]})\\s+-\\s+(${src[t11.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t11.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t11.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// ../../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a3, b2) => {
      if (typeof a3 === "number" && typeof b2 === "number") {
        return a3 === b2 ? 0 : a3 < b2 ? -1 : 1;
      }
      const anum = numeric.test(a3);
      const bnum = numeric.test(b2);
      if (anum && bnum) {
        a3 = +a3;
        b2 = +b2;
      }
      return a3 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b2 ? -1 : 1;
    };
    var rcompareIdentifiers = (a3, b2) => compareIdentifiers(b2, a3);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re2, t: t11 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m5 = version3.trim().match(options.loose ? re2[t11.LOOSE] : re2[t11.FULL]);
        if (!m5) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m5[1];
        this.minor = +m5[2];
        this.patch = +m5[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m5[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m5[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m5[5] ? m5[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i6 = 0;
        do {
          const a3 = this.prerelease[i6];
          const b2 = other.prerelease[i6];
          debug("prerelease compare", i6, a3, b2);
          if (a3 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b2) {
            continue;
          } else {
            return compareIdentifiers(a3, b2);
          }
        } while (++i6);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i6 = 0;
        do {
          const a3 = this.build[i6];
          const b2 = other.build[i6];
          debug("build compare", i6, a3, b2);
          if (a3 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a3 === void 0) {
            return -1;
          } else if (a3 === b2) {
            continue;
          } else {
            return compareIdentifiers(a3, b2);
          }
        } while (++i6);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re2[t11.PRERELEASELOOSE] : re2[t11.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i6 = this.prerelease.length;
              while (--i6 >= 0) {
                if (typeof this.prerelease[i6] === "number") {
                  this.prerelease[i6]++;
                  i6 = -2;
                }
              }
              if (i6 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// ../../node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../../node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = (version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse3;
  }
});

// ../../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    var parse3 = require_parse();
    var valid2 = (version3, options) => {
      const v4 = parse3(version3, options);
      return v4 ? v4.version : null;
    };
    module.exports = valid2;
  }
});

// ../../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    var parse3 = require_parse();
    var clean = (version3, options) => {
      const s8 = parse3(version3.trim().replace(/^[=v]+/, ""), options);
      return s8 ? s8.version : null;
    };
    module.exports = clean;
  }
});

// ../../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version3, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// ../../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    var parse3 = require_parse();
    var diff = (version1, version22) => {
      const v1 = parse3(version1, null, true);
      const v22 = parse3(version22, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// ../../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var major = (a3, loose) => new SemVer(a3, loose).major;
    module.exports = major;
  }
});

// ../../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a3, loose) => new SemVer(a3, loose).minor;
    module.exports = minor;
  }
});

// ../../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a3, loose) => new SemVer(a3, loose).patch;
    module.exports = patch;
  }
});

// ../../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    var parse3 = require_parse();
    var prerelease = (version3, options) => {
      const parsed = parse3(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// ../../node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compare2 = (a3, b2, loose) => new SemVer(a3, loose).compare(new SemVer(b2, loose));
    module.exports = compare2;
  }
});

// ../../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var rcompare = (a3, b2, loose) => compare2(b2, a3, loose);
    module.exports = rcompare;
  }
});

// ../../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var compareLoose = (a3, b2) => compare2(a3, b2, true);
    module.exports = compareLoose;
  }
});

// ../../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a3, b2, loose) => {
      const versionA = new SemVer(a3, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// ../../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a3, b2) => compareBuild(a3, b2, loose));
    module.exports = sort;
  }
});

// ../../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a3, b2) => compareBuild(b2, a3, loose));
    module.exports = rsort;
  }
});

// ../../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var gt = (a3, b2, loose) => compare2(a3, b2, loose) > 0;
    module.exports = gt;
  }
});

// ../../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var lt = (a3, b2, loose) => compare2(a3, b2, loose) < 0;
    module.exports = lt;
  }
});

// ../../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var eq2 = (a3, b2, loose) => compare2(a3, b2, loose) === 0;
    module.exports = eq2;
  }
});

// ../../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var neq = (a3, b2, loose) => compare2(a3, b2, loose) !== 0;
    module.exports = neq;
  }
});

// ../../node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var gte = (a3, b2, loose) => compare2(a3, b2, loose) >= 0;
    module.exports = gte;
  }
});

// ../../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare2 = require_compare();
    var lte = (a3, b2, loose) => compare2(a3, b2, loose) <= 0;
    module.exports = lte;
  }
});

// ../../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq2 = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp2 = (a3, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a3 === b2;
        case "!==":
          if (typeof a3 === "object") {
            a3 = a3.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a3 !== b2;
        case "":
        case "=":
        case "==":
          return eq2(a3, b2, loose);
        case "!=":
          return neq(a3, b2, loose);
        case ">":
          return gt(a3, b2, loose);
        case ">=":
          return gte(a3, b2, loose);
        case "<":
          return lt(a3, b2, loose);
        case "<=":
          return lte(a3, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp2;
  }
});

// ../../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re2, t: t11 } = require_re();
    var coerce = (version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(options.includePrerelease ? re2[t11.COERCEFULL] : re2[t11.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t11.COERCERTLFULL] : re2[t11.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// ../../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../../node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// ../../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r4) => this.parseRange(r4.trim())).filter((c6) => c6.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c6) => !isNullSet(c6[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c6 of this.set) {
              if (c6.length === 1 && isAny(c6[0])) {
                this.set = [c6];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i6 = 0; i6 < this.set.length; i6++) {
            if (i6 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i6];
            for (let k2 = 0; k2 < comps.length; k2++) {
              if (k2 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k2].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t11.HYPHENRANGELOOSE] : re2[t11.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re2[t11.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re2[t11.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re2[t11.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t11.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result2 = [...rangeMap.values()];
        cache2.set(memoKey, result2);
        return result2;
      }
      intersects(range2, options) {
        if (!(range2 instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i6 = 0; i6 < this.set.length; i6++) {
          if (testSet(this.set[i6], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t: t11,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c6) => c6.value === "<0.0.0-0";
    var isAny = (c6) => c6.value === "";
    var isSatisfiable = (comparators, options) => {
      let result2 = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result2 && remainingComparators.length) {
        result2 = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result2;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re2[t11.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceTilde(c6, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r4 = options.loose ? re2[t11.TILDELOOSE] : re2[t11.TILDE];
      return comp.replace(r4, (_4, M4, m5, p3, pr) => {
        debug("tilde", comp, _4, M4, m5, p3, pr);
        let ret;
        if (isX(M4)) {
          ret = "";
        } else if (isX(m5)) {
          ret = `>=${M4}.0.0 <${+M4 + 1}.0.0-0`;
        } else if (isX(p3)) {
          ret = `>=${M4}.${m5}.0 <${M4}.${+m5 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M4}.${m5}.${p3}-${pr} <${M4}.${+m5 + 1}.0-0`;
        } else {
          ret = `>=${M4}.${m5}.${p3} <${M4}.${+m5 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c6) => replaceCaret(c6, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r4 = options.loose ? re2[t11.CARETLOOSE] : re2[t11.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r4, (_4, M4, m5, p3, pr) => {
        debug("caret", comp, _4, M4, m5, p3, pr);
        let ret;
        if (isX(M4)) {
          ret = "";
        } else if (isX(m5)) {
          ret = `>=${M4}.0.0${z2} <${+M4 + 1}.0.0-0`;
        } else if (isX(p3)) {
          if (M4 === "0") {
            ret = `>=${M4}.${m5}.0${z2} <${M4}.${+m5 + 1}.0-0`;
          } else {
            ret = `>=${M4}.${m5}.0${z2} <${+M4 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M4 === "0") {
            if (m5 === "0") {
              ret = `>=${M4}.${m5}.${p3}-${pr} <${M4}.${m5}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M4}.${m5}.${p3}-${pr} <${M4}.${+m5 + 1}.0-0`;
            }
          } else {
            ret = `>=${M4}.${m5}.${p3}-${pr} <${+M4 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M4 === "0") {
            if (m5 === "0") {
              ret = `>=${M4}.${m5}.${p3}${z2} <${M4}.${m5}.${+p3 + 1}-0`;
            } else {
              ret = `>=${M4}.${m5}.${p3}${z2} <${M4}.${+m5 + 1}.0-0`;
            }
          } else {
            ret = `>=${M4}.${m5}.${p3} <${+M4 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c6) => replaceXRange(c6, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r4 = options.loose ? re2[t11.XRANGELOOSE] : re2[t11.XRANGE];
      return comp.replace(r4, (ret, gtlt, M4, m5, p3, pr) => {
        debug("xRange", comp, ret, gtlt, M4, m5, p3, pr);
        const xM = isX(M4);
        const xm = xM || isX(m5);
        const xp = xm || isX(p3);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m5 = 0;
          }
          p3 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M4 = +M4 + 1;
              m5 = 0;
              p3 = 0;
            } else {
              m5 = +m5 + 1;
              p3 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M4 = +M4 + 1;
            } else {
              m5 = +m5 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M4}.${m5}.${p3}${pr}`;
        } else if (xm) {
          ret = `>=${M4}.0.0${pr} <${+M4 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M4}.${m5}.0${pr} <${M4}.${+m5 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re2[t11.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t11.GTE0PRE : t11.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version3, options) => {
      for (let i6 = 0; i6 < set2.length; i6++) {
        if (!set2[i6].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i6 = 0; i6 < set2.length; i6++) {
          debug(set2[i6].semver);
          if (set2[i6].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i6].semver.prerelease.length > 0) {
            const allowed = set2[i6].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r4 = this.options.loose ? re2[t11.COMPARATORLOOSE] : re2[t11.COMPARATOR];
        const m5 = comp.match(r4);
        if (!m5) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m5[1] !== void 0 ? m5[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m5[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m5[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp2(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t: t11 } = require_re();
    var cmp2 = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version3, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version3);
    };
    module.exports = satisfies;
  }
});

// ../../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c6) => c6.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// ../../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying2 = (versions, range2, options) => {
      let max4 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v4) => {
        if (rangeObj.test(v4)) {
          if (!max4 || maxSV.compare(v4) === -1) {
            max4 = v4;
            maxSV = new SemVer(max4, options);
          }
        }
      });
      return max4;
    };
    module.exports = maxSatisfying2;
  }
});

// ../../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min3 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v4) => {
        if (rangeObj.test(v4)) {
          if (!min3 || minSV.compare(v4) === 1) {
            min3 = v4;
            minSV = new SemVer(min3, options);
          }
        }
      });
      return min3;
    };
    module.exports = minSatisfying;
  }
});

// ../../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i6 = 0; i6 < range2.set.length; ++i6) {
        const comparators = range2.set[i6];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// ../../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// ../../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version3, range2, hilo, options) => {
      version3 = new SemVer(version3, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range2, options)) {
        return false;
      }
      for (let i6 = 0; i6 < range2.set.length; ++i6) {
        const comparators = range2.set[i6];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// ../../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var gtr = (version3, range2, options) => outside(version3, range2, ">", options);
    module.exports = gtr;
  }
});

// ../../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var ltr = (version3, range2, options) => outside(version3, range2, "<", options);
    module.exports = ltr;
  }
});

// ../../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// ../../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range2, options) => {
      const set2 = [];
      let first2 = null;
      let prev = null;
      const v4 = versions.sort((a3, b2) => compare2(a3, b2, options));
      for (const version3 of v4) {
        const included = satisfies(version3, range2, options);
        if (included) {
          prev = version3;
          if (!first2) {
            first2 = version3;
          }
        } else {
          if (prev) {
            set2.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set2.push([first2, null]);
      }
      const ranges = [];
      for (const [min3, max4] of set2) {
        if (min3 === max4) {
          ranges.push(min3);
        } else if (!max4 && min3 === v4[0]) {
          ranges.push("*");
        } else if (!max4) {
          ranges.push(`>=${min3}`);
        } else if (min3 === v4[0]) {
          ranges.push(`<=${max4}`);
        } else {
          ranges.push(`${min3} - ${max4}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// ../../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c6 of sub) {
        if (c6.operator === ">" || c6.operator === ">=") {
          gt = higherGT(gt, c6, options);
        } else if (c6.operator === "<" || c6.operator === "<=") {
          lt = lowerLT(lt, c6, options);
        } else {
          eqSet.add(c6.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq2 of eqSet) {
        if (gt && !satisfies(eq2, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq2, String(lt), options)) {
          return null;
        }
        for (const c6 of dom) {
          if (!satisfies(eq2, String(c6), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c6 of dom) {
        hasDomGT = hasDomGT || c6.operator === ">" || c6.operator === ">=";
        hasDomLT = hasDomLT || c6.operator === "<" || c6.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomGTPre.major && c6.semver.minor === needDomGTPre.minor && c6.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c6.operator === ">" || c6.operator === ">=") {
            higher = higherGT(gt, c6, options);
            if (higher === c6 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c6), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c6.semver.prerelease && c6.semver.prerelease.length && c6.semver.major === needDomLTPre.major && c6.semver.minor === needDomLTPre.minor && c6.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c6.operator === "<" || c6.operator === "<=") {
            lower = lowerLT(lt, c6, options);
            if (lower === c6 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c6), options)) {
            return false;
          }
        }
        if (!c6.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a3, b2, options) => {
      if (!a3) {
        return b2;
      }
      const comp = compare2(a3.semver, b2.semver, options);
      return comp > 0 ? a3 : comp < 0 ? b2 : b2.operator === ">" && a3.operator === ">=" ? b2 : a3;
    };
    var lowerLT = (a3, b2, options) => {
      if (!a3) {
        return b2;
      }
      const comp = compare2(a3.semver, b2.semver, options);
      return comp < 0 ? a3 : comp > 0 ? b2 : b2.operator === "<" && a3.operator === "<=" ? b2 : a3;
    };
    module.exports = subset;
  }
});

// ../../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/semver/index.js"(exports, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid2 = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq2 = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp2 = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying2 = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse3,
      valid: valid2,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq: eq2,
      neq,
      gte,
      lte,
      cmp: cmp2,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying: maxSatisfying2,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/semvercache.js
var import_semver, SemVerCache;
var init_semvercache = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/semvercache.js"() {
    import_semver = __toESM(require_semver2());
    SemVerCache = class {
      constructor() {
        this._cache = /* @__PURE__ */ Object.create(null);
      }
      set(key, version3, object2) {
        if (!(key in this._cache)) {
          this._cache[key] = /* @__PURE__ */ Object.create(null);
        }
        if (!(version3 in this._cache[key])) {
          this._cache[key][version3] = object2;
        } else {
          throw `Version ${version3} of key ${key} already registered.`;
        }
      }
      get(key, semver) {
        if (key in this._cache) {
          const versions = this._cache[key];
          const best = (0, import_semver.maxSatisfying)(Object.keys(versions), semver);
          if (best !== null) {
            return versions[best];
          }
        }
      }
      getAllVersions(key) {
        if (key in this._cache) {
          return this._cache[key];
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/manager.js
var import_semver2, WIDGET_STATE_MIMETYPE, LabWidgetManager, KernelWidgetManager, WidgetManager;
var init_manager2 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/manager.js"() {
    init_lib8();
    init_lib9();
    init_index_es62();
    import_semver2 = __toESM(require_semver2());
    init_semvercache();
    WIDGET_STATE_MIMETYPE = "application/vnd.jupyter.widget-state+json";
    LabWidgetManager = class extends ManagerBase {
      constructor(rendermime) {
        super();
        this._handleCommOpen = async (comm, msg) => {
          const oldComm = new shims.services.Comm(comm);
          await this.handle_comm_open(oldComm, msg);
        };
        this._restored = new Signal(this);
        this._restoredStatus = false;
        this._kernelRestoreInProgress = false;
        this._isDisposed = false;
        this._registry = new SemVerCache();
        this._modelsSync = /* @__PURE__ */ new Map();
        this._onUnhandledIOPubMessage = new Signal(this);
        this._rendermime = rendermime;
      }
      /**
       * Default callback handler to emit unhandled kernel messages.
       */
      callbacks(view) {
        return {
          iopub: {
            output: (msg) => {
              this._onUnhandledIOPubMessage.emit(msg);
            }
          }
        };
      }
      /**
       * Register a new kernel
       */
      _handleKernelChanged({ oldValue, newValue }) {
        if (oldValue) {
          oldValue.removeCommTarget(this.comm_target_name, this._handleCommOpen);
        }
        if (newValue) {
          newValue.registerCommTarget(this.comm_target_name, this._handleCommOpen);
        }
      }
      /**
       * Disconnect the widget manager from the kernel, setting each model's comm
       * as dead.
       */
      disconnect() {
        super.disconnect();
        this._restoredStatus = false;
      }
      async _loadFromKernel() {
        var _a;
        if (!this.kernel) {
          throw new Error("Kernel not set");
        }
        if (((_a = this.kernel) === null || _a === void 0 ? void 0 : _a.handleComms) === false) {
          return;
        }
        return super._loadFromKernel();
      }
      /**
       * Create a comm.
       */
      async _create_comm(target_name, model_id, data, metadata, buffers) {
        const kernel = this.kernel;
        if (!kernel) {
          throw new Error("No current kernel");
        }
        const comm = kernel.createComm(target_name, model_id);
        if (data || metadata) {
          comm.open(data, metadata, buffers);
        }
        return new shims.services.Comm(comm);
      }
      /**
       * Get the currently-registered comms.
       */
      async _get_comm_info() {
        const kernel = this.kernel;
        if (!kernel) {
          throw new Error("No current kernel");
        }
        const reply = await kernel.requestCommInfo({
          target_name: this.comm_target_name
        });
        if (reply.content.status === "ok") {
          return reply.content.comms;
        } else {
          return {};
        }
      }
      /**
       * Get whether the manager is disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        if (this._commRegistration) {
          this._commRegistration.dispose();
        }
      }
      /**
       * Resolve a URL relative to the current notebook location.
       */
      async resolveUrl(url) {
        return url;
      }
      /**
       * Load a class and return a promise to the loaded object.
       */
      async loadClass(className, moduleName, moduleVersion) {
        if ((moduleName === "@jupyter-widgets/base" || moduleName === "@jupyter-widgets/controls") && (0, import_semver2.valid)(moduleVersion)) {
          moduleVersion = `^${moduleVersion}`;
        }
        const allVersions = this._registry.getAllVersions(moduleName);
        if (!allVersions) {
          throw new Error(`No version of module ${moduleName} is registered`);
        }
        const mod = this._registry.get(moduleName, moduleVersion);
        if (!mod) {
          const registeredVersionList = Object.keys(allVersions);
          throw new Error(`Module ${moduleName}, version ${moduleVersion} is not registered, however,         ${registeredVersionList.join(",")} ${registeredVersionList.length > 1 ? "are" : "is"}`);
        }
        let module;
        if (typeof mod === "function") {
          module = await mod();
        } else {
          module = await mod;
        }
        const cls = module[className];
        if (!cls) {
          throw new Error(`Class ${className} not found in module ${moduleName}`);
        }
        return cls;
      }
      get rendermime() {
        return this._rendermime;
      }
      /**
       * A signal emitted when state is restored to the widget manager.
       *
       * #### Notes
       * This indicates that previously-unavailable widget models might be available now.
       */
      get restored() {
        return this._restored;
      }
      /**
       * Whether the state has been restored yet or not.
       */
      get restoredStatus() {
        return this._restoredStatus;
      }
      /**
       * A signal emitted for unhandled iopub kernel messages.
       *
       */
      get onUnhandledIOPubMessage() {
        return this._onUnhandledIOPubMessage;
      }
      register(data) {
        this._registry.set(data.name, data.version, data.exports);
      }
      /**
       * Register a widget model.
       */
      register_model(model_id, modelPromise) {
        super.register_model(model_id, modelPromise);
        modelPromise.then((model) => {
          this._modelsSync.set(model_id, model);
          model.once("comm:close", () => {
            this._modelsSync.delete(model_id);
          });
        });
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      async clear_state() {
        await super.clear_state();
        this._modelsSync = /* @__PURE__ */ new Map();
      }
      /**
       * Synchronously get the state of the live widgets in the widget manager.
       *
       * This includes all of the live widget models, and follows the format given in
       * the @jupyter-widgets/schema package.
       *
       * @param options - The options for what state to return.
       * @returns A state dictionary
       */
      get_state_sync(options = {}) {
        const models = [];
        for (const model of this._modelsSync.values()) {
          if (model.comm_live) {
            models.push(model);
          }
        }
        return serialize_state(models, options);
      }
    };
    KernelWidgetManager = class extends LabWidgetManager {
      constructor(kernel, rendermime) {
        super(rendermime);
        this._kernel = kernel;
        kernel.statusChanged.connect((sender, args) => {
          this._handleKernelStatusChange(args);
        });
        kernel.connectionStatusChanged.connect((sender, args) => {
          this._handleKernelConnectionStatusChange(args);
        });
        this._handleKernelChanged({
          name: "kernel",
          oldValue: null,
          newValue: kernel
        });
        this.restoreWidgets();
      }
      _handleKernelConnectionStatusChange(status) {
        if (status === "connected") {
          if (!this._kernelRestoreInProgress) {
            this.restoreWidgets();
          }
        }
      }
      _handleKernelStatusChange(status) {
        if (status === "restarting") {
          this.disconnect();
        }
      }
      /**
       * Restore widgets from kernel and saved state.
       */
      async restoreWidgets() {
        try {
          this._kernelRestoreInProgress = true;
          await this._loadFromKernel();
          this._restoredStatus = true;
          this._restored.emit();
        } catch (err) {
        }
        this._kernelRestoreInProgress = false;
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._kernel = null;
        super.dispose();
      }
      get kernel() {
        return this._kernel;
      }
    };
    WidgetManager = class extends LabWidgetManager {
      constructor(context, rendermime, settings) {
        var _a, _b;
        super(rendermime);
        this._context = context;
        context.sessionContext.kernelChanged.connect((sender, args) => {
          this._handleKernelChanged(args);
        });
        context.sessionContext.statusChanged.connect((sender, args) => {
          this._handleKernelStatusChange(args);
        });
        context.sessionContext.connectionStatusChanged.connect((sender, args) => {
          this._handleKernelConnectionStatusChange(args);
        });
        if ((_a = context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) {
          this._handleKernelChanged({
            name: "kernel",
            oldValue: null,
            newValue: (_b = context.sessionContext.session) === null || _b === void 0 ? void 0 : _b.kernel
          });
        }
        this.restoreWidgets(this._context.model);
        this._settings = settings;
        context.saveState.connect((sender, saveState) => {
          if (saveState === "started" && settings.saveState) {
            this._saveState();
          }
        });
      }
      /**
       * Save the widget state to the context model.
       */
      _saveState() {
        const state = this.get_state_sync({ drop_defaults: true });
        if (this._context.model.setMetadata) {
          this._context.model.setMetadata("widgets", {
            "application/vnd.jupyter.widget-state+json": state
          });
        } else {
          this._context.model.metadata.set("widgets", {
            "application/vnd.jupyter.widget-state+json": state
          });
        }
      }
      _handleKernelConnectionStatusChange(status) {
        if (status === "connected") {
          if (!this._kernelRestoreInProgress) {
            this.restoreWidgets(this._context.model, {
              loadKernel: true,
              loadNotebook: false
            });
          }
        }
      }
      _handleKernelStatusChange(status) {
        if (status === "restarting") {
          this.disconnect();
        }
      }
      /**
       * Restore widgets from kernel and saved state.
       */
      async restoreWidgets(notebook, { loadKernel, loadNotebook } = { loadKernel: true, loadNotebook: true }) {
        try {
          await this.context.sessionContext.ready;
          if (loadKernel) {
            try {
              this._kernelRestoreInProgress = true;
              await this._loadFromKernel();
            } finally {
              this._kernelRestoreInProgress = false;
            }
          }
          if (loadNotebook) {
            await this._loadFromNotebook(notebook);
          }
          this._restoredStatus = true;
          this._restored.emit();
        } catch (err) {
        }
      }
      /**
       * Load widget state from notebook metadata
       */
      async _loadFromNotebook(notebook) {
        const widget_md = notebook.getMetadata ? notebook.getMetadata("widgets") : (
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore JupyterLab 3 support
          notebook.metadata.get("widgets")
        );
        if (widget_md && widget_md[WIDGET_STATE_MIMETYPE]) {
          let state = widget_md[WIDGET_STATE_MIMETYPE];
          state = this.filterExistingModelState(state);
          await this.set_state(state);
        }
      }
      /**
       * Dispose the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._context = null;
        super.dispose();
      }
      /**
       * Resolve a URL relative to the current notebook location.
       */
      async resolveUrl(url) {
        const partial2 = await this.context.urlResolver.resolveUrl(url);
        return this.context.urlResolver.getDownloadUrl(partial2);
      }
      get context() {
        return this._context;
      }
      get kernel() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this._context.sessionContext) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.kernel) !== null && _c !== void 0 ? _c : null;
      }
      /**
       * Register a widget model.
       */
      register_model(model_id, modelPromise) {
        super.register_model(model_id, modelPromise);
        this.setDirty();
      }
      /**
       * Close all widgets and empty the widget state.
       * @return Promise that resolves when the widget state is cleared.
       */
      async clear_state() {
        await super.clear_state();
        this.setDirty();
      }
      /**
       * Set the dirty state of the notebook model if applicable.
       *
       * TODO: perhaps should also set dirty when any model changes any data
       */
      setDirty() {
        if (this._settings.saveState) {
          this._context.model.dirty = true;
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/output/lib/output.js
var OUTPUT_WIDGET_VERSION, OutputModel2, OutputView;
var init_output = __esm({
  "../../node_modules/@jupyter-widgets/output/lib/output.js"() {
    init_lib8();
    OUTPUT_WIDGET_VERSION = "1.0.0";
    OutputModel2 = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "OutputModel", _view_name: "OutputView", _model_module: "@jupyter-widgets/output", _view_module: "@jupyter-widgets/output", _model_module_version: OUTPUT_WIDGET_VERSION, _view_module_version: OUTPUT_WIDGET_VERSION });
      }
    };
    OutputView = class extends DOMWidgetView {
    };
  }
});

// ../../node_modules/@jupyter-widgets/output/lib/index.js
var init_lib10 = __esm({
  "../../node_modules/@jupyter-widgets/output/lib/index.js"() {
    init_output();
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/output.js
var output_exports = {};
__export(output_exports, {
  OUTPUT_WIDGET_VERSION: () => OUTPUT_WIDGET_VERSION2,
  OutputModel: () => OutputModel3,
  OutputView: () => OutputView2
});
var import_jquery2, OUTPUT_WIDGET_VERSION2, OutputModel3, OutputView2;
var init_output2 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/output.js"() {
    init_lib10();
    init_lib8();
    init_manager2();
    init_lib7();
    import_jquery2 = __toESM(require_jquery());
    OUTPUT_WIDGET_VERSION2 = OUTPUT_WIDGET_VERSION;
    OutputModel3 = class extends OutputModel2 {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { msg_id: "", outputs: [] });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this._outputs = new OutputAreaModel({ trusted: true });
        this._msgHook = (msg) => {
          this.add(msg);
          return false;
        };
        if (this.widget_manager instanceof WidgetManager) {
          this.widget_manager.context.sessionContext.kernelChanged.connect((sender, args) => {
            this._handleKernelChanged(args);
          });
        }
        this.listenTo(this, "change:msg_id", this.reset_msg_id);
        this.listenTo(this, "change:outputs", this.setOutputs);
        this.setOutputs();
      }
      /**
       * Register a new kernel
       */
      _handleKernelChanged({ oldValue }) {
        const msgId = this.get("msg_id");
        if (msgId && oldValue) {
          oldValue.removeMessageHook(msgId, this._msgHook);
          this.set("msg_id", null);
        }
      }
      /**
       * Reset the message id.
       */
      reset_msg_id() {
        const kernel = this.widget_manager.kernel;
        const msgId = this.get("msg_id");
        const oldMsgId = this.previous("msg_id");
        if (oldMsgId && kernel) {
          kernel.removeMessageHook(oldMsgId, this._msgHook);
        }
        if (msgId && kernel) {
          kernel.registerMessageHook(msgId, this._msgHook);
        }
      }
      add(msg) {
        const msgType = msg.header.msg_type;
        switch (msgType) {
          case "execute_result":
          case "display_data":
          case "stream":
          case "error": {
            const model = msg.content;
            model.output_type = msgType;
            this._outputs.add(model);
            break;
          }
          case "clear_output":
            this.clear_output(msg.content.wait);
            break;
          default:
            break;
        }
        this.set("outputs", this._outputs.toJSON(), { newMessage: true });
        this.save_changes();
      }
      clear_output(wait = false) {
        this._outputs.clear(wait);
      }
      get outputs() {
        return this._outputs;
      }
      setOutputs(model, value, options) {
        if (!(options && options.newMessage)) {
          this.clear_output();
          this._outputs.fromJSON(JSON.parse(JSON.stringify(this.get("outputs"))));
        }
      }
    };
    OutputView2 = class extends OutputView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery2.default)(this.luminoWidget.node);
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this._outputView = new OutputArea({
          rendermime: this.model.widget_manager.rendermime,
          contentFactory: OutputArea.defaultContentFactory,
          model: this.model.outputs
        });
        this.luminoWidget.insertWidget(0, this._outputView);
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-output");
        this.update();
      }
      remove() {
        this._outputView.dispose();
        return super.remove();
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/version.js
var JUPYTER_CONTROLS_VERSION;
var init_version2 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/version.js"() {
    JUPYTER_CONTROLS_VERSION = "2.0.0";
  }
});

// ../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js
var init_lib11 = __esm({
  "../../node_modules/@jupyter-widgets/jupyterlab-manager/lib/index.js"() {
    init_output2();
    init_manager2();
    init_renderer();
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/utils.js
function typeset(element2, text) {
  if (text !== void 0) {
    element2.textContent = text;
  }
  if (window.MathJax !== void 0) {
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, element2]);
  }
}
function escape_html(text) {
  const esc = document.createElement("div");
  esc.textContent = text;
  return esc.innerHTML;
}
function reject3(message, log) {
  return function promiseRejection(error) {
    if (log) {
      console.error(new Error(message));
    }
    throw error;
  };
}
var init_utils3 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/utils.js"() {
    init_lib8();
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_description.js
var DescriptionStyleModel, DescriptionModel, DescriptionView, LabeledDOMWidgetModel, LabeledDOMWidgetView;
var init_widget_description = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_description.js"() {
    init_lib8();
    init_utils3();
    init_version2();
    DescriptionStyleModel = class extends StyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DescriptionStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    DescriptionStyleModel.styleProperties = {
      description_width: {
        selector: ".widget-label",
        attribute: "width",
        default: null
      }
    };
    DescriptionModel = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DescriptionModel", _view_name: "DescriptionView", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION, description: "", description_allow_html: false });
      }
    };
    DescriptionView = class extends DOMWidgetView {
      render() {
        this.label = document.createElement("label");
        this.el.appendChild(this.label);
        this.label.className = "widget-label";
        this.label.style.display = "none";
        this.listenTo(this.model, "change:description", this.updateDescription);
        this.listenTo(this.model, "change:description_allow_html", this.updateDescription);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.updateDescription();
        this.updateTabindex();
        this.updateTooltip();
      }
      typeset(element2, text) {
        this.displayed.then(() => {
          var _a;
          const widget_manager = this.model.widget_manager;
          const latexTypesetter = (_a = widget_manager._rendermime) === null || _a === void 0 ? void 0 : _a.latexTypesetter;
          if (latexTypesetter) {
            if (text !== void 0) {
              element2.textContent = text;
            }
            latexTypesetter.typeset(element2);
          } else {
            return typeset(element2, text);
          }
        });
      }
      updateDescription() {
        const description = this.model.get("description");
        if (description.length === 0) {
          this.label.style.display = "none";
        } else {
          if (this.model.get("description_allow_html")) {
            this.label.innerHTML = this.model.widget_manager.inline_sanitize(description);
          } else {
            this.label.textContent = description;
          }
          this.typeset(this.label);
          this.label.style.display = "";
        }
      }
      updateTooltip() {
        if (!this.label)
          return;
        this.label.title = this.model.get("tooltip");
      }
    };
    LabeledDOMWidgetModel = class extends DescriptionModel {
    };
    LabeledDOMWidgetView = class extends DescriptionView {
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_core.js
var CoreWidgetModel, CoreDOMWidgetModel, CoreDescriptionModel;
var init_widget_core = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_core.js"() {
    init_lib8();
    init_widget_description();
    init_version2();
    CoreWidgetModel = class extends WidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreWidgetModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    CoreDOMWidgetModel = class extends DOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreDOMWidgetModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    CoreDescriptionModel = class extends DescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CoreDescriptionModel", _view_module: "@jupyter-widgets/controls", _model_module: "@jupyter-widgets/controls", _view_module_version: JUPYTER_CONTROLS_VERSION, _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_link.js
var DirectionalLinkModel, LinkModel;
var init_widget_link = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_link.js"() {
    init_lib8();
    init_widget_core();
    DirectionalLinkModel = class extends CoreWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { target: void 0, source: void 0, _model_name: "DirectionalLinkModel" });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change", this.updateBindings, this);
        this.updateBindings();
      }
      updateValue(sourceModel, sourceAttr, targetModel, targetAttr) {
        if (this._updating) {
          return;
        }
        this._updating = true;
        try {
          if (targetModel) {
            targetModel.set(targetAttr, sourceModel.get(sourceAttr));
            targetModel.save_changes();
          }
        } finally {
          this._updating = false;
        }
      }
      updateBindings() {
        this.cleanup();
        [this.sourceModel, this.sourceAttr] = this.get("source") || [null, null];
        [this.targetModel, this.targetAttr] = this.get("target") || [null, null];
        if (this.sourceModel) {
          this.listenTo(this.sourceModel, "change:" + this.sourceAttr, () => {
            this.updateValue(this.sourceModel, this.sourceAttr, this.targetModel, this.targetAttr);
          });
          this.updateValue(this.sourceModel, this.sourceAttr, this.targetModel, this.targetAttr);
          this.listenToOnce(this.sourceModel, "destroy", this.cleanup);
        }
        if (this.targetModel) {
          this.listenToOnce(this.targetModel, "destroy", this.cleanup);
        }
      }
      cleanup() {
        if (this.sourceModel) {
          this.stopListening(this.sourceModel, "change:" + this.sourceAttr, void 0);
          this.stopListening(this.sourceModel, "destroy", void 0);
        }
        if (this.targetModel) {
          this.stopListening(this.targetModel, "destroy", void 0);
        }
      }
    };
    DirectionalLinkModel.serializers = Object.assign(Object.assign({}, CoreWidgetModel.serializers), { target: { deserialize: unpack_models }, source: { deserialize: unpack_models } });
    LinkModel = class extends DirectionalLinkModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "LinkModel" });
      }
      updateBindings() {
        super.updateBindings();
        if (this.targetModel) {
          this.listenTo(this.targetModel, "change:" + this.targetAttr, () => {
            this.updateValue(this.targetModel, this.targetAttr, this.sourceModel, this.sourceAttr);
          });
        }
      }
      cleanup() {
        super.cleanup();
        if (this.targetModel) {
          this.stopListening(this.targetModel, "change:" + this.targetAttr, void 0);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_bool.js
var CheckboxStyleModel, ToggleButtonStyleModel, BoolModel, CheckboxModel, CheckboxView, ToggleButtonModel, ToggleButtonView, ValidModel, ValidView;
var init_widget_bool = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_bool.js"() {
    init_lib8();
    init_widget_core();
    init_widget_description();
    CheckboxStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "CheckboxStyleModel" });
      }
    };
    CheckboxStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: "",
      attribute: "background",
      default: null
    } });
    ToggleButtonStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonStyleModel" });
      }
    };
    ToggleButtonStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { font_family: {
      selector: "",
      attribute: "font-family",
      default: ""
    }, font_size: {
      selector: "",
      attribute: "font-size",
      default: ""
    }, font_style: {
      selector: "",
      attribute: "font-style",
      default: ""
    }, font_variant: {
      selector: "",
      attribute: "font-variant",
      default: ""
    }, font_weight: {
      selector: "",
      attribute: "font-weight",
      default: ""
    }, text_color: {
      selector: "",
      attribute: "color",
      default: ""
    }, text_decoration: {
      selector: "",
      attribute: "text-decoration",
      default: ""
    } });
    BoolModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: false, disabled: false, _model_name: "BoolModel" });
      }
    };
    CheckboxModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { indent: true, style: null, _view_name: "CheckboxView", _model_name: "CheckboxModel" });
      }
    };
    CheckboxView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-checkbox");
        this.label.innerHTML = "&#8203;";
        this.checkboxLabel = document.createElement("label");
        this.checkboxLabel.classList.add("widget-label-basic");
        this.el.appendChild(this.checkboxLabel);
        this.checkbox = document.createElement("input");
        this.checkbox.setAttribute("type", "checkbox");
        this.checkboxLabel.appendChild(this.checkbox);
        this.descriptionSpan = document.createElement("span");
        this.checkboxLabel.appendChild(this.descriptionSpan);
        this.listenTo(this.model, "change:indent", this.updateIndent);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.update();
        this.updateDescription();
        this.updateIndent();
        this.updateTabindex();
        this.updateTooltip();
      }
      /**
       * Overridden from super class
       *
       * Update the description span (rather than the label) since
       * we want the description to the right of the checkbox.
       */
      updateDescription() {
        if (this.checkboxLabel == null) {
          return;
        }
        const description = this.model.get("description");
        if (this.model.get("description_allow_html")) {
          this.descriptionSpan.innerHTML = this.model.widget_manager.inline_sanitize(description);
        } else {
          this.descriptionSpan.textContent = description;
        }
        this.typeset(this.descriptionSpan);
        this.descriptionSpan.title = description;
        this.checkbox.title = description;
      }
      /**
       * Update the visibility of the label in the super class
       * to provide the optional indent.
       */
      updateIndent() {
        const indent = this.model.get("indent");
        this.label.style.display = indent ? "" : "none";
      }
      updateTabindex() {
        if (!this.checkbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.checkbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.checkbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.checkbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.checkbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.checkbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.checkbox.setAttribute("title", title);
        }
      }
      events() {
        return {
          'click input[type="checkbox"]': "_handle_click"
        };
      }
      /**
       * Handles when the checkbox is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click() {
        const value = this.model.get("value");
        this.model.set("value", !value, { updated_view: this });
        this.touch();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        this.checkbox.checked = this.model.get("value");
        if (options === void 0 || options.updated_view != this) {
          this.checkbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       *
       * Used to focus or blur the widget.
       */
      handle_message(content) {
        if (content.do == "focus") {
          this.checkbox.focus();
        } else if (content.do == "blur") {
          this.checkbox.blur();
        }
      }
    };
    ToggleButtonModel = class extends BoolModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "ToggleButtonView", _model_name: "ToggleButtonModel", tooltip: "", icon: "", button_style: "", style: null });
      }
    };
    ToggleButtonView = class extends DOMWidgetView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-button");
        this.el.classList.add("widget-toggle-button");
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.set_button_style();
        this.update();
      }
      update_button_style() {
        this.update_mapped_classes(ToggleButtonView.class_map, "button_style");
      }
      set_button_style() {
        this.set_mapped_classes(ToggleButtonView.class_map, "button_style");
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (this.model.get("value")) {
          this.el.classList.add("mod-active");
        } else {
          this.el.classList.remove("mod-active");
        }
        if (options === void 0 || options.updated_view !== this) {
          this.el.disabled = this.model.get("disabled");
          this.el.setAttribute("tabbable", this.model.get("tabbable"));
          this.el.setAttribute("title", this.model.get("tooltip"));
          const description = this.model.get("description");
          const icon = this.model.get("icon");
          if (description.trim().length === 0 && icon.trim().length === 0) {
            this.el.innerHTML = "&nbsp;";
          } else {
            this.el.textContent = "";
            if (icon.trim().length) {
              const i6 = document.createElement("i");
              this.el.appendChild(i6);
              i6.classList.add("fa");
              i6.classList.add("fa-" + icon);
            }
            this.el.appendChild(document.createTextNode(description));
          }
        }
        this.updateTabindex();
        return super.update();
      }
      events() {
        return {
          // Dictionary of events and their handlers.
          click: "_handle_click"
        };
      }
      /**
       * Handles and validates user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        event.preventDefault();
        const value = this.model.get("value");
        this.model.set("value", !value, { updated_view: this });
        this.touch();
      }
      preinitialize() {
        this.tagName = "button";
      }
    };
    ToggleButtonView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
    ValidModel = class extends BoolModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { readout: "Invalid", _view_name: "ValidView", _model_name: "ValidModel" });
      }
    };
    ValidView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-valid");
        this.el.classList.add("widget-inline-hbox");
        this.icon = document.createElement("i");
        this.icon.classList.add("fa", "fa-fw");
        this.el.appendChild(this.icon);
        this.readout = document.createElement("span");
        this.readout.classList.add("widget-valid-readout");
        this.readout.classList.add("widget-readout");
        this.el.appendChild(this.readout);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.el.classList.remove("mod-valid");
        this.el.classList.remove("mod-invalid");
        this.icon.classList.remove("fa-check");
        this.icon.classList.remove("fa-times");
        this.readout.textContent = this.model.get("readout");
        if (this.model.get("value")) {
          this.el.classList.add("mod-valid");
          this.icon.classList.add("fa-check");
        } else {
          this.el.classList.add("mod-invalid");
          this.icon.classList.add("fa-times");
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_button.js
var ButtonStyleModel, ButtonModel, ButtonView;
var init_widget_button = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_button.js"() {
    init_lib8();
    init_widget_core();
    init_version2();
    ButtonStyleModel = class extends StyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ButtonStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    ButtonStyleModel.styleProperties = {
      button_color: {
        selector: "",
        attribute: "background-color",
        default: null
      },
      font_family: {
        selector: "",
        attribute: "font-family",
        default: ""
      },
      font_size: {
        selector: "",
        attribute: "font-size",
        default: ""
      },
      font_style: {
        selector: "",
        attribute: "font-style",
        default: ""
      },
      font_variant: {
        selector: "",
        attribute: "font-variant",
        default: ""
      },
      font_weight: {
        selector: "",
        attribute: "font-weight",
        default: ""
      },
      text_color: {
        selector: "",
        attribute: "color",
        default: ""
      },
      text_decoration: {
        selector: "",
        attribute: "text-decoration",
        default: ""
      }
    };
    ButtonModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { description: "", tooltip: "", disabled: false, icon: "", button_style: "", _view_name: "ButtonView", _model_name: "ButtonModel", style: null });
      }
    };
    ButtonView = class extends DOMWidgetView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-button");
        this.el.classList.add("widget-button");
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.listenTo(this.model, "change:tabbable", this.updateTabindex);
        this.set_button_style();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.el.disabled = this.model.get("disabled");
        this.updateTabindex();
        const tooltip = this.model.get("tooltip");
        const description = this.model.get("description");
        const icon = this.model.get("icon");
        this.el.setAttribute("title", tooltip !== null && tooltip !== void 0 ? tooltip : description);
        if (description.length || icon.length) {
          this.el.textContent = "";
          if (icon.length) {
            const i6 = document.createElement("i");
            i6.classList.add("fa");
            i6.classList.add(...icon.split(/[\s]+/).filter(Boolean).map((v4) => `fa-${v4}`));
            if (description.length === 0) {
              i6.classList.add("center");
            }
            this.el.appendChild(i6);
          }
          this.el.appendChild(document.createTextNode(description));
        }
        return super.update();
      }
      update_button_style() {
        this.update_mapped_classes(ButtonView.class_map, "button_style");
      }
      set_button_style() {
        this.set_mapped_classes(ButtonView.class_map, "button_style");
      }
      /**
       * Dictionary of events and handlers
       */
      events() {
        return { click: "_handle_click" };
      }
      /**
       * Handles when the button is clicked.
       */
      _handle_click(event) {
        event.preventDefault();
        this.send({ event: "click" });
      }
      preinitialize() {
        this.tagName = "button";
      }
    };
    ButtonView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_box.js
var import_jquery3, BoxModel, HBoxModel, VBoxModel, BoxView, HBoxView, VBoxView, GridBoxView, GridBoxModel;
var init_widget_box = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_box.js"() {
    init_lib8();
    init_widget_core();
    init_index_es6();
    init_index_es69();
    init_index_es610();
    import_jquery3 = __toESM(require_jquery());
    BoxModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "BoxView", _model_name: "BoxModel", children: [], box_style: "" });
      }
    };
    BoxModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { children: { deserialize: unpack_models } });
    HBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HBoxView", _model_name: "HBoxModel" });
      }
    };
    VBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "VBoxView", _model_name: "VBoxModel" });
      }
    };
    BoxView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery3.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.children_views = new ViewList(this.add_child_model, null, this);
        this.listenTo(this.model, "change:children", this.update_children);
        this.listenTo(this.model, "change:box_style", this.update_box_style);
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-container");
        this.luminoWidget.addClass("widget-box");
      }
      render() {
        super.render();
        this.update_children();
        this.set_box_style();
      }
      update_children() {
        var _a;
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children")).then((views) => {
          views.forEach((view) => {
            MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
          });
        });
      }
      update_box_style() {
        this.update_mapped_classes(BoxView.class_map, "box_style");
      }
      set_box_style() {
        this.set_mapped_classes(BoxView.class_map, "box_style");
      }
      add_child_model(model) {
        const dummy = new Widget();
        this.luminoWidget.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i6 = ArrayExt.firstIndexOf(this.luminoWidget.widgets, dummy);
          this.luminoWidget.insertWidget(i6, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      remove() {
        this.children_views = null;
        super.remove();
      }
    };
    BoxView.class_map = {
      success: ["alert", "alert-success"],
      info: ["alert", "alert-info"],
      warning: ["alert", "alert-warning"],
      danger: ["alert", "alert-danger"]
    };
    HBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-hbox");
      }
    };
    VBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-vbox");
      }
    };
    GridBoxView = class extends BoxView {
      /**
       * Public constructor
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.luminoWidget.addClass("widget-gridbox");
        this.luminoWidget.removeClass("widget-box");
      }
    };
    GridBoxModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "GridBoxView", _model_name: "GridBoxModel" });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_image.js
var ImageModel, ImageView;
var init_widget_image = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_image.js"() {
    init_lib8();
    init_widget_core();
    ImageModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ImageModel", _view_name: "ImageView", format: "png", width: "", height: "", value: new DataView(new ArrayBuffer(0)) });
      }
    };
    ImageModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    ImageView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-image");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `image/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        const width = this.model.get("width");
        if (width !== void 0 && width.length > 0) {
          this.el.setAttribute("width", width);
        } else {
          this.el.removeAttribute("width");
        }
        const height = this.model.get("height");
        if (height !== void 0 && height.length > 0) {
          this.el.setAttribute("height", height);
        } else {
          this.el.removeAttribute("height");
        }
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "img";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_video.js
var VideoModel, VideoView;
var init_widget_video = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_video.js"() {
    init_lib8();
    init_widget_core();
    VideoModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "VideoModel", _view_name: "VideoView", format: "mp4", width: "", height: "", autoplay: true, loop: true, controls: true, value: new DataView(new ArrayBuffer(0)) });
      }
    };
    VideoModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    VideoView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.luminoWidget.addClass("widget-image");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `video/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        const width = this.model.get("width");
        if (width !== void 0 && width.length > 0) {
          this.el.setAttribute("width", width);
        } else {
          this.el.removeAttribute("width");
        }
        const height = this.model.get("height");
        if (height !== void 0 && height.length > 0) {
          this.el.setAttribute("height", height);
        } else {
          this.el.removeAttribute("height");
        }
        this.el.loop = this.model.get("loop");
        this.el.autoplay = this.model.get("autoplay");
        this.el.controls = this.model.get("controls");
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "video";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_audio.js
var AudioModel, AudioView;
var init_widget_audio = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_audio.js"() {
    init_lib8();
    init_widget_core();
    AudioModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "AudioModel", _view_name: "AudioView", format: "mp3", autoplay: true, loop: true, controls: true, value: new DataView(new ArrayBuffer(0)) });
      }
    };
    AudioModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { value: {
      serialize: (value) => {
        return new DataView(value.buffer.slice(0));
      }
    } });
    AudioView = class extends DOMWidgetView {
      render() {
        super.render();
        this.luminoWidget.addClass("jupyter-widgets");
        this.update();
      }
      update() {
        let url;
        const format2 = this.model.get("format");
        const value = this.model.get("value");
        if (format2 !== "url") {
          const blob = new Blob([value], {
            type: `audio/${this.model.get("format")}`
          });
          url = URL.createObjectURL(blob);
        } else {
          url = new TextDecoder("utf-8").decode(value.buffer);
        }
        const oldurl = this.el.src;
        this.el.src = url;
        if (oldurl) {
          URL.revokeObjectURL(oldurl);
        }
        this.el.loop = this.model.get("loop");
        this.el.autoplay = this.model.get("autoplay");
        this.el.controls = this.model.get("controls");
        return super.update();
      }
      remove() {
        if (this.el.src) {
          URL.revokeObjectURL(this.el.src);
        }
        super.remove();
      }
      preinitialize() {
        this.tagName = "audio";
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_color.js
function color2hex(color2) {
  return named_colors[color2.toLowerCase()] || rgb3_to_rgb6(color2);
}
function rgb3_to_rgb6(rgb) {
  if (rgb.length === 7) {
    return rgb;
  } else {
    return "#" + rgb.charAt(1) + rgb.charAt(1) + rgb.charAt(2) + rgb.charAt(2) + rgb.charAt(3) + rgb.charAt(3);
  }
}
var named_colors, ColorPickerModel, ColorPickerView;
var init_widget_color = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_color.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    named_colors = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgrey: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgreen: "#90ee90",
      lightgray: "#d3d3d3",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    ColorPickerModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: "black", concise: false, _model_name: "ColorPickerModel", _view_name: "ColorPickerView" });
      }
    };
    ColorPickerView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-colorpicker");
        this._color_container = document.createElement("div");
        this._color_container.className = "widget-inline-hbox widget-colorpicker-input";
        this.el.appendChild(this._color_container);
        this._textbox = document.createElement("input");
        this._textbox.setAttribute("type", "text");
        this._textbox.id = this.label.htmlFor = uuid();
        this._color_container.appendChild(this._textbox);
        this._textbox.value = this.model.get("value");
        this._colorpicker = document.createElement("input");
        this._colorpicker.setAttribute("type", "color");
        this._color_container.appendChild(this._colorpicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change:concise", this._update_concise);
        this._update_concise();
        this._update_value();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view != this) {
          const disabled = this.model.get("disabled");
          this._textbox.disabled = disabled;
          this._colorpicker.disabled = disabled;
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._text_change;
        return {
          'change [type="color"]': "_picker_change",
          'change [type="text"]': "_text_change"
        };
      }
      _update_value() {
        const value = this.model.get("value");
        this._colorpicker.value = color2hex(value);
        this._textbox.value = value;
      }
      _update_concise() {
        const concise = this.model.get("concise");
        if (concise) {
          this.el.classList.add("concise");
          this._textbox.style.display = "none";
        } else {
          this.el.classList.remove("concise");
          this._textbox.style.display = "";
        }
      }
      _picker_change() {
        this.model.set("value", this._colorpicker.value);
        this.touch();
      }
      _text_change() {
        const value = this._validate_color(this._textbox.value, this.model.get("value"));
        this.model.set("value", value);
        this.touch();
      }
      _validate_color(color2, fallback) {
        return color2.match(/#[a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?$/) || named_colors[color2.toLowerCase()] ? color2 : fallback;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_date.js
function serialize_date(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getUTCFullYear(),
      month: value.getUTCMonth(),
      date: value.getUTCDate()
    };
  }
}
function deserialize_date(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setUTCFullYear(value.year, value.month, value.date);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
}
var DatePickerModel, DatePickerView;
var init_widget_date = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_date.js"() {
    init_widget_description();
    init_widget_core();
    init_utils3();
    DatePickerModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: null, _model_name: "DatePickerModel", _view_name: "DatePickerView" });
      }
    };
    DatePickerModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: {
      serialize: serialize_date,
      deserialize: deserialize_date
    } });
    DatePickerView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-datepicker");
        this._datepicker = document.createElement("input");
        this._datepicker.setAttribute("type", "date");
        this._datepicker.id = this.label.htmlFor = uuid();
        this.el.appendChild(this._datepicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this._update_value();
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          this._datepicker.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="date"]': "_picker_change",
          'focusout [type="date"]': "_picker_focusout"
        };
      }
      _update_value() {
        const value = this.model.get("value");
        this._datepicker.valueAsDate = value;
      }
      _picker_change() {
        if (!this._datepicker.validity.badInput) {
          this.model.set("value", this._datepicker.valueAsDate);
          this.touch();
        }
      }
      _picker_focusout() {
        if (this._datepicker.validity.badInput) {
          this.model.set("value", null);
          this.touch();
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_time.js
function serialize_time(value) {
  if (value === null) {
    return null;
  } else {
    const res = PARSER.exec(value);
    if (res === null) {
      return null;
    }
    return {
      hours: Math.min(23, parseInt(res[1], 10)),
      minutes: Math.min(59, parseInt(res[2], 10)),
      seconds: res[4] ? Math.min(59, parseInt(res[4], 10)) : 0,
      milliseconds: res[6] ? parseInt(res[6], 10) : 0
    };
  }
}
function deserialize_time(value) {
  if (value === null) {
    return null;
  } else {
    const parts = [
      `${value.hours.toString().padStart(2, "0")}:${value.minutes.toString().padStart(2, "0")}`
    ];
    if (value.seconds > 0 || value.milliseconds > 0) {
      parts.push(`:${value.seconds.toString().padStart(2, "0")}`);
      if (value.milliseconds > 0) {
        parts.push(`.${value.milliseconds.toString().padStart(3, "0")}`);
      }
    }
    return parts.join("");
  }
}
var PARSER, time_serializers, TimeModel, TimeView;
var init_widget_time = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_time.js"() {
    init_utils3();
    init_widget_description();
    init_widget_core();
    PARSER = /(\d\d):(\d\d)(:(\d\d)(.(\d{1,3})\d*)?)?/;
    time_serializers = {
      serialize: serialize_time,
      deserialize: deserialize_time
    };
    TimeModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: TimeModel.model_name, _view_name: TimeModel.view_name, value: null, disabled: false, min: null, max: null, step: 60 });
      }
    };
    TimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: time_serializers, min: time_serializers, max: time_serializers });
    TimeModel.model_name = "TimeModel";
    TimeModel.view_name = "TimeView";
    TimeView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-timepicker");
        this._timepicker = document.createElement("input");
        this._timepicker.setAttribute("type", "time");
        this._timepicker.id = this.label.htmlFor = uuid();
        this.el.appendChild(this._timepicker);
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change", this.update2);
        this._update_value();
        this.update2();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update2(model, options) {
        if (options === void 0 || options.updated_view !== this) {
          this._timepicker.disabled = this.model.get("disabled");
          this._timepicker.min = this.model.get("min");
          this._timepicker.max = this.model.get("max");
          this._timepicker.step = this.model.get("step");
        }
        return super.update();
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="time"]': "_picker_change",
          'focusout [type="time"]': "_picker_focusout"
        };
      }
      _update_value(model, newValue, options) {
        if (options === void 0 || options.updated_view !== this) {
          this._timepicker.value = this.model.get("value");
        }
      }
      _picker_change() {
        if (!this._timepicker.validity.badInput) {
          this.model.set("value", this._timepicker.value, { updated_view: this });
          this.touch();
        }
      }
      _picker_focusout() {
        if (this._timepicker.validity.badInput) {
          this.model.set("value", null, { updated_view: this });
          this.touch();
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_datetime.js
function serialize_datetime(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getUTCFullYear(),
      month: value.getUTCMonth(),
      date: value.getUTCDate(),
      hours: value.getUTCHours(),
      minutes: value.getUTCMinutes(),
      seconds: value.getUTCSeconds(),
      milliseconds: value.getUTCMilliseconds()
    };
  }
}
function deserialize_datetime(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setUTCFullYear(value.year, value.month, value.date);
    date.setUTCHours(value.hours, value.minutes, value.seconds, value.milliseconds);
    return date;
  }
}
function serialize_naive(value) {
  if (value === null) {
    return null;
  } else {
    return {
      year: value.getFullYear(),
      month: value.getMonth(),
      date: value.getDate(),
      hours: value.getHours(),
      minutes: value.getMinutes(),
      seconds: value.getSeconds(),
      milliseconds: value.getMilliseconds()
    };
  }
}
function deserialize_naive(value) {
  if (value === null) {
    return null;
  } else {
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(value.year, value.month, value.date);
    date.setHours(value.hours, value.minutes, value.seconds, value.milliseconds);
    return date;
  }
}
var datetime_serializers, DatetimeModel, DatetimeView, Private18, naive_serializers, NaiveDatetimeModel;
var init_widget_datetime = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_datetime.js"() {
    init_utils3();
    init_widget_description();
    init_widget_core();
    init_widget_time();
    datetime_serializers = {
      serialize: serialize_datetime,
      deserialize: deserialize_datetime
    };
    DatetimeModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DatetimeModel", _view_name: "DatetimeView", value: null, disabled: false, min: null, max: null });
      }
    };
    DatetimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: datetime_serializers, min: datetime_serializers, max: datetime_serializers });
    DatetimeView = class extends DescriptionView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-datetimepicker");
        const test = document.createElement("input");
        test.type = "datetime-local";
        if (test.type === "text") {
          this._datepicker = document.createElement("input");
          this._datepicker.setAttribute("type", "date");
          this._datepicker.id = this.label.htmlFor = uuid();
          this._timepicker = document.createElement("input");
          this._timepicker.setAttribute("type", "time");
          this._timepicker.id = uuid();
          this.el.appendChild(this._datepicker);
          this.el.appendChild(this._timepicker);
        } else {
          this._datetimepicker = test;
          this._datetimepicker.id = this.label.htmlFor = uuid();
          this.el.appendChild(this._datetimepicker);
        }
        this.listenTo(this.model, "change:value", this._update_value);
        this.listenTo(this.model, "change", this.update2);
        this._update_value();
        this.update2();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update2(model, options) {
        if (options === void 0 || options.updated_view !== this) {
          const min3 = this.model.get("min");
          const max4 = this.model.get("max");
          if (this._datetimepicker) {
            this._datetimepicker.disabled = this.model.get("disabled");
            this._datetimepicker.min = Private18.dt_as_dt_string(min3);
            this._datetimepicker.max = Private18.dt_as_dt_string(max4);
          } else {
            this._datepicker.disabled = this.model.get("disabled");
            this._datepicker.min = Private18.dt_as_date_string(min3);
            this._datepicker.max = Private18.dt_as_date_string(max4);
            this._timepicker.disabled = this.model.get("disabled");
          }
        }
      }
      events() {
        void this._picker_change;
        void this._picker_focusout;
        return {
          'change [type="date"]': "_picker_change",
          'change [type="time"]': "_picker_change",
          'change [type="datetime-local"]': "_picker_change",
          'focusout [type="date"]': "_picker_focusout",
          'focusout [type="datetime-local"]': "_picker_focusout",
          'focusout [type="time"]': "_picker_focusout"
        };
      }
      _update_value(model, newValue, options) {
        if (options === void 0 || options.updated_view !== this) {
          const value = this.model.get("value");
          if (this._datetimepicker) {
            this._datetimepicker.value = Private18.dt_as_dt_string(value);
          } else {
            this._datepicker.valueAsDate = value;
            this._timepicker.value = Private18.dt_as_time_string(value);
          }
        }
      }
      _picker_change() {
        if (this._datetimepicker) {
          if (!this._datetimepicker.validity.badInput) {
            const v4 = this._datetimepicker.value;
            let date = v4 ? new Date(v4) : null;
            if (date && isNaN(date.valueOf())) {
              date = null;
            }
            this.model.set("value", date, { updated_view: this });
            this.touch();
          }
        } else {
          if (!this._datepicker.validity.badInput && !this._timepicker.validity.badInput) {
            const date = this._datepicker.valueAsDate;
            const time = serialize_time(this._timepicker.value);
            if (date !== null && time !== null) {
              date.setHours(time.hours, time.minutes, time.seconds, time.milliseconds);
            }
            this.model.set("value", time !== null && date, { updated_view: this });
            this.touch();
          }
        }
      }
      _picker_focusout() {
        const pickers = [this._datetimepicker, this._datepicker, this._timepicker];
        if (pickers.some((p3) => p3 && p3.validity.badInput)) {
          this.model.set("value", null);
          this.touch();
        }
      }
    };
    (function(Private22) {
      function dt_as_dt_string(value) {
        if (value === null) {
          return "";
        }
        const parts = [];
        parts.push(`${value.getFullYear().toString().padStart(4, "0")}`);
        parts.push(`-${(value.getMonth() + 1).toString().padStart(2, "0")}`);
        parts.push(`-${value.getDate().toString().padStart(2, "0")}`);
        parts.push(`T${value.getHours().toString().padStart(2, "0")}`);
        parts.push(`:${value.getMinutes().toString().padStart(2, "0")}`);
        if (value.getSeconds() > 0 || value.getMilliseconds() > 0) {
          parts.push(`:${value.getSeconds().toString().padStart(2, "0")}`);
          if (value.getMilliseconds() > 0) {
            parts.push(`.${value.getMilliseconds().toString().padStart(3, "0")}`);
          }
        }
        return parts.join("");
      }
      Private22.dt_as_dt_string = dt_as_dt_string;
      function dt_as_date_string(value) {
        return value ? dt_as_dt_string(value).split("T", 2)[0] : "";
      }
      Private22.dt_as_date_string = dt_as_date_string;
      function dt_as_time_string(value) {
        return value ? dt_as_dt_string(value).split("T", 2)[1] : "";
      }
      Private22.dt_as_time_string = dt_as_time_string;
    })(Private18 || (Private18 = {}));
    naive_serializers = {
      serialize: serialize_naive,
      deserialize: deserialize_naive
    };
    NaiveDatetimeModel = class extends DatetimeModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "NaiveDatetimeModel" });
      }
    };
    NaiveDatetimeModel.serializers = Object.assign(Object.assign({}, CoreDescriptionModel.serializers), { value: naive_serializers, min: naive_serializers, max: naive_serializers });
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p3) {
  if ((i6 = (x2 = p3 ? x2.toExponential(p3 - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i6, coefficient = x2.slice(0, i6);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i6 + 1)
  ];
}
var init_formatDecimal = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatDecimal.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
var init_exponent = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/exponent.js"() {
    init_formatDecimal();
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i6 = value.length, t11 = [], j2 = 0, g4 = grouping[0], length = 0;
    while (i6 > 0 && g4 > 0) {
      if (length + g4 + 1 > width)
        g4 = Math.max(1, width - length);
      t11.push(value.substring(i6 -= g4, i6 + g4));
      if ((length += g4 + 1) > width)
        break;
      g4 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t11.reverse().join(thousands);
  };
}
var init_formatGroup = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatGroup.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i6) {
      return numerals[+i6];
    });
  };
}
var init_formatNumerals = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatNumerals.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatSpecifier.js
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
var re;
var init_formatSpecifier = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatSpecifier.js"() {
    re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier.prototype = FormatSpecifier.prototype;
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s8) {
  out:
    for (var n5 = s8.length, i6 = 1, i0 = -1, i1; i6 < n5; ++i6) {
      switch (s8[i6]) {
        case ".":
          i0 = i1 = i6;
          break;
        case "0":
          if (i0 === 0)
            i0 = i6;
          i1 = i6;
          break;
        default:
          if (!+s8[i6])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s8.slice(0, i0) + s8.slice(i1 + 1) : s8;
}
var init_formatTrim = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatTrim.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatPrefixAuto.js
function formatPrefixAuto_default(x2, p3) {
  var d6 = formatDecimalParts(x2, p3);
  if (!d6)
    return x2 + "";
  var coefficient = d6[0], exponent = d6[1], i6 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n5 = coefficient.length;
  return i6 === n5 ? coefficient : i6 > n5 ? coefficient + new Array(i6 - n5 + 1).join("0") : i6 > 0 ? coefficient.slice(0, i6) + "." + coefficient.slice(i6) : "0." + new Array(1 - i6).join("0") + formatDecimalParts(x2, Math.max(0, p3 + i6 - 1))[0];
}
var prefixExponent;
var init_formatPrefixAuto = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatPrefixAuto.js"() {
    init_formatDecimal();
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p3) {
  var d6 = formatDecimalParts(x2, p3);
  if (!d6)
    return x2 + "";
  var coefficient = d6[0], exponent = d6[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var init_formatRounded = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatRounded.js"() {
    init_formatDecimal();
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatTypes.js
var formatTypes_default;
var init_formatTypes = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/formatTypes.js"() {
    init_formatDecimal();
    init_formatPrefixAuto();
    init_formatRounded();
    formatTypes_default = {
      "%": (x2, p3) => (x2 * 100).toFixed(p3),
      "b": (x2) => Math.round(x2).toString(2),
      "c": (x2) => x2 + "",
      "d": formatDecimal_default,
      "e": (x2, p3) => x2.toExponential(p3),
      "f": (x2, p3) => x2.toFixed(p3),
      "g": (x2, p3) => x2.toPrecision(p3),
      "o": (x2) => Math.round(x2).toString(8),
      "p": (x2, p3) => formatRounded_default(x2 * 100, p3),
      "r": formatRounded_default,
      "s": formatPrefixAuto_default,
      "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
      "x": (x2) => Math.round(x2).toString(16)
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/identity.js
function identity_default(x2) {
  return x2;
}
var init_identity2 = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/identity.js"() {
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/locale.js
function locale_default(locale2) {
  var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default : formatGroup_default(map3.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default : formatNumerals_default(map3.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero || fill === "0" && align === "=")
      zero = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i6, n5, c6;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i6 = -1, n5 = value.length;
          while (++i6 < n5) {
            if (c6 = value.charCodeAt(i6), 48 > c6 || c6 > 57) {
              valueSuffix = (c6 === 46 ? decimal + value.slice(i6 + 1) : value.slice(i6)) + valueSuffix;
              value = value.slice(0, i6);
              break;
            }
          }
        }
      }
      if (comma && !zero)
        value = group2(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f6 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f6(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var map3, prefixes;
var init_locale = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/locale.js"() {
    init_exponent();
    init_formatGroup();
    init_formatNumerals();
    init_formatSpecifier();
    init_formatTrim();
    init_formatTypes();
    init_formatPrefixAuto();
    init_identity2();
    map3 = Array.prototype.map;
    prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/defaultLocale.js
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
var locale, format, formatPrefix;
var init_defaultLocale = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/defaultLocale.js"() {
    init_locale();
    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
  }
});

// ../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/index.js
var init_src2 = __esm({
  "../../node_modules/@jupyter-widgets/controls/node_modules/d3-format/src/index.js"() {
    init_defaultLocale();
  }
});

// ../../node_modules/nouislider/dist/nouislider.js
var require_nouislider = __commonJS({
  "../../node_modules/nouislider/dist/nouislider.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.noUiSlider = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.PipsMode = void 0;
      (function(PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
      })(exports2.PipsMode || (exports2.PipsMode = {}));
      exports2.PipsType = void 0;
      (function(PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
      })(exports2.PipsType || (exports2.PipsType = {}));
      function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
      }
      function isValidPartialFormatter(entry) {
        return typeof entry === "object" && typeof entry.to === "function";
      }
      function removeElement(el) {
        el.parentElement.removeChild(el);
      }
      function isSet(value) {
        return value !== null && value !== void 0;
      }
      function preventDefault(e3) {
        e3.preventDefault();
      }
      function unique(array) {
        return array.filter(function(a3) {
          return !this[a3] ? this[a3] = true : false;
        }, {});
      }
      function closest(value, to) {
        return Math.round(value / to) * to;
      }
      function offset4(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
          pageOffset.x = 0;
        }
        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
      }
      function isNumeric(a3) {
        return typeof a3 === "number" && !isNaN(a3) && isFinite(a3);
      }
      function addClassFor(element2, className, duration) {
        if (duration > 0) {
          addClass(element2, className);
          setTimeout(function() {
            removeClass(element2, className);
          }, duration);
        }
      }
      function limit(a3) {
        return Math.max(Math.min(a3, 100), 0);
      }
      function asArray(a3) {
        return Array.isArray(a3) ? a3 : [a3];
      }
      function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
      }
      function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.add(className);
        } else {
          el.className += " " + className;
        }
      }
      function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      }
      function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
      }
      function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== void 0;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x2 = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y4 = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
        return {
          x: x2,
          y: y4
        };
      }
      function getActions() {
        return window.navigator.pointerEnabled ? {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup"
        } : window.navigator.msPointerEnabled ? {
          start: "MSPointerDown",
          move: "MSPointerMove",
          end: "MSPointerUp"
        } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        };
      }
      function getSupportsPassive() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e3) {
        }
        return supportsPassive;
      }
      function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
      }
      function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
      }
      function fromPercentage(range2, value, startRange) {
        return value * 100 / (range2[startRange + 1] - range2[startRange]);
      }
      function toPercentage(range2, value) {
        return fromPercentage(range2, range2[0] < 0 ? value + Math.abs(range2[0]) : value - range2[0], 0);
      }
      function isPercentage(range2, value) {
        return value * (range2[1] - range2[0]) / 100 + range2[0];
      }
      function getJ(value, arr) {
        var j2 = 1;
        while (value >= arr[j2]) {
          j2 += 1;
        }
        return j2;
      }
      function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
          return 100;
        }
        var j2 = getJ(value, xVal);
        var va = xVal[j2 - 1];
        var vb = xVal[j2];
        var pa = xPct[j2 - 1];
        var pb = xPct[j2];
        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
      }
      function fromStepping(xVal, xPct, value) {
        if (value >= 100) {
          return xVal.slice(-1)[0];
        }
        var j2 = getJ(value, xPct);
        var va = xVal[j2 - 1];
        var vb = xVal[j2];
        var pa = xPct[j2 - 1];
        var pb = xPct[j2];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
      }
      function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
          return value;
        }
        var j2 = getJ(value, xPct);
        var a3 = xPct[j2 - 1];
        var b2 = xPct[j2];
        if (snap) {
          if (value - a3 > (b2 - a3) / 2) {
            return b2;
          }
          return a3;
        }
        if (!xSteps[j2 - 1]) {
          return value;
        }
        return xPct[j2 - 1] + closest(value - xPct[j2 - 1], xSteps[j2 - 1]);
      }
      var Spectrum = (
        /** @class */
        function() {
          function Spectrum2(entry, snap, singleStep) {
            this.xPct = [];
            this.xVal = [];
            this.xSteps = [];
            this.xNumSteps = [];
            this.xHighestCompleteStep = [];
            this.xSteps = [singleStep || false];
            this.xNumSteps = [false];
            this.snap = snap;
            var index2;
            var ordered = [];
            Object.keys(entry).forEach(function(index3) {
              ordered.push([asArray(entry[index3]), index3]);
            });
            ordered.sort(function(a3, b2) {
              return a3[0][0] - b2[0][0];
            });
            for (index2 = 0; index2 < ordered.length; index2++) {
              this.handleEntryPoint(ordered[index2][1], ordered[index2][0]);
            }
            this.xNumSteps = this.xSteps.slice(0);
            for (index2 = 0; index2 < this.xNumSteps.length; index2++) {
              this.handleStepPoint(index2, this.xNumSteps[index2]);
            }
          }
          Spectrum2.prototype.getDistance = function(value) {
            var index2;
            var distances = [];
            for (index2 = 0; index2 < this.xNumSteps.length - 1; index2++) {
              var step = this.xNumSteps[index2];
              if (step && value / step % 1 !== 0) {
                throw new Error("noUiSlider: 'limit', 'margin' and 'padding' of " + this.xPct[index2] + "% range must be divisible by step.");
              }
              distances[index2] = fromPercentage(this.xVal, value, index2);
            }
            return distances;
          };
          Spectrum2.prototype.getAbsoluteDistance = function(value, distances, direction) {
            var xPct_index = 0;
            if (value < this.xPct[this.xPct.length - 1]) {
              while (value > this.xPct[xPct_index + 1]) {
                xPct_index++;
              }
            } else if (value === this.xPct[this.xPct.length - 1]) {
              xPct_index = this.xPct.length - 2;
            }
            if (!direction && value === this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
            if (distances === null) {
              distances = [];
            }
            var start_factor;
            var rest_factor = 1;
            var rest_rel_distance = distances[xPct_index];
            var range_pct = 0;
            var rel_range_distance = 0;
            var abs_distance_counter = 0;
            var range_counter = 0;
            if (direction) {
              start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            } else {
              start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
            }
            while (rest_rel_distance > 0) {
              range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
              if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                rel_range_distance = range_pct * start_factor;
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                start_factor = 1;
              } else {
                rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
                rest_factor = 0;
              }
              if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                if (this.xPct.length + range_counter >= 1) {
                  range_counter--;
                }
              } else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                if (this.xPct.length - range_counter >= 1) {
                  range_counter++;
                }
              }
              rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
            }
            return value + abs_distance_counter;
          };
          Spectrum2.prototype.toStepping = function(value) {
            value = toStepping(this.xVal, this.xPct, value);
            return value;
          };
          Spectrum2.prototype.fromStepping = function(value) {
            return fromStepping(this.xVal, this.xPct, value);
          };
          Spectrum2.prototype.getStep = function(value) {
            value = getStep(this.xPct, this.xSteps, this.snap, value);
            return value;
          };
          Spectrum2.prototype.getDefaultStep = function(value, isDown, size5) {
            var j2 = getJ(value, this.xPct);
            if (value === 100 || isDown && value === this.xPct[j2 - 1]) {
              j2 = Math.max(j2 - 1, 1);
            }
            return (this.xVal[j2] - this.xVal[j2 - 1]) / size5;
          };
          Spectrum2.prototype.getNearbySteps = function(value) {
            var j2 = getJ(value, this.xPct);
            return {
              stepBefore: {
                startValue: this.xVal[j2 - 2],
                step: this.xNumSteps[j2 - 2],
                highestStep: this.xHighestCompleteStep[j2 - 2]
              },
              thisStep: {
                startValue: this.xVal[j2 - 1],
                step: this.xNumSteps[j2 - 1],
                highestStep: this.xHighestCompleteStep[j2 - 1]
              },
              stepAfter: {
                startValue: this.xVal[j2],
                step: this.xNumSteps[j2],
                highestStep: this.xHighestCompleteStep[j2]
              }
            };
          };
          Spectrum2.prototype.countStepDecimals = function() {
            var stepDecimals = this.xNumSteps.map(countDecimals);
            return Math.max.apply(null, stepDecimals);
          };
          Spectrum2.prototype.hasNoSize = function() {
            return this.xVal[0] === this.xVal[this.xVal.length - 1];
          };
          Spectrum2.prototype.convert = function(value) {
            return this.getStep(this.toStepping(value));
          };
          Spectrum2.prototype.handleEntryPoint = function(index2, value) {
            var percentage;
            if (index2 === "min") {
              percentage = 0;
            } else if (index2 === "max") {
              percentage = 100;
            } else {
              percentage = parseFloat(index2);
            }
            if (!isNumeric(percentage) || !isNumeric(value[0])) {
              throw new Error("noUiSlider: 'range' value isn't numeric.");
            }
            this.xPct.push(percentage);
            this.xVal.push(value[0]);
            var value1 = Number(value[1]);
            if (!percentage) {
              if (!isNaN(value1)) {
                this.xSteps[0] = value1;
              }
            } else {
              this.xSteps.push(isNaN(value1) ? false : value1);
            }
            this.xHighestCompleteStep.push(0);
          };
          Spectrum2.prototype.handleStepPoint = function(i6, n5) {
            if (!n5) {
              return;
            }
            if (this.xVal[i6] === this.xVal[i6 + 1]) {
              this.xSteps[i6] = this.xHighestCompleteStep[i6] = this.xVal[i6];
              return;
            }
            this.xSteps[i6] = fromPercentage([this.xVal[i6], this.xVal[i6 + 1]], n5, 0) / subRangeRatio(this.xPct[i6], this.xPct[i6 + 1]);
            var totalSteps = (this.xVal[i6 + 1] - this.xVal[i6]) / this.xNumSteps[i6];
            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
            var step = this.xVal[i6] + this.xNumSteps[i6] * highestStep;
            this.xHighestCompleteStep[i6] = step;
          };
          return Spectrum2;
        }()
      );
      var defaultFormatter = {
        to: function(value) {
          return value === void 0 ? "" : value.toFixed(2);
        },
        from: Number
      };
      var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      };
      var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
      };
      function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'step' is not numeric.");
        }
        parsed.singleStep = entry;
      }
      function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }
        parsed.keyboardPageMultiplier = entry;
      }
      function testKeyboardMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
        }
        parsed.keyboardMultiplier = entry;
      }
      function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }
        parsed.keyboardDefaultStep = entry;
      }
      function testRange(parsed, entry) {
        if (typeof entry !== "object" || Array.isArray(entry)) {
          throw new Error("noUiSlider: 'range' is not an object.");
        }
        if (entry.min === void 0 || entry.max === void 0) {
          throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }
        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
      }
      function testStart(parsed, entry) {
        entry = asArray(entry);
        if (!Array.isArray(entry) || !entry.length) {
          throw new Error("noUiSlider: 'start' option is incorrect.");
        }
        parsed.handles = entry.length;
        parsed.start = entry;
      }
      function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'snap' option must be a boolean.");
        }
        parsed.snap = entry;
      }
      function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'animate' option must be a boolean.");
        }
        parsed.animate = entry;
      }
      function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
          throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }
        parsed.animationDuration = entry;
      }
      function testConnect(parsed, entry) {
        var connect = [false];
        var i6;
        if (entry === "lower") {
          entry = [true, false];
        } else if (entry === "upper") {
          entry = [false, true];
        }
        if (entry === true || entry === false) {
          for (i6 = 1; i6 < parsed.handles; i6++) {
            connect.push(entry);
          }
          connect.push(false);
        } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        } else {
          connect = entry;
        }
        parsed.connect = connect;
      }
      function testOrientation(parsed, entry) {
        switch (entry) {
          case "horizontal":
            parsed.ort = 0;
            break;
          case "vertical":
            parsed.ort = 1;
            break;
          default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
      }
      function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'margin' option must be numeric.");
        }
        if (entry === 0) {
          return;
        }
        parsed.margin = parsed.spectrum.getDistance(entry);
      }
      function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'limit' option must be numeric.");
        }
        parsed.limit = parsed.spectrum.getDistance(entry);
        if (!parsed.limit || parsed.handles < 2) {
          throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
      }
      function testPadding(parsed, entry) {
        var index2;
        if (!isNumeric(entry) && !Array.isArray(entry)) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (entry === 0) {
          return;
        }
        if (!Array.isArray(entry)) {
          entry = [entry, entry];
        }
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
        for (index2 = 0; index2 < parsed.spectrum.xNumSteps.length - 1; index2++) {
          if (parsed.padding[0][index2] < 0 || parsed.padding[1][index2] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
          }
        }
        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
        if (totalPadding / (lastValue - firstValue) > 1) {
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
      }
      function testDirection(parsed, entry) {
        switch (entry) {
          case "ltr":
            parsed.dir = 0;
            break;
          case "rtl":
            parsed.dir = 1;
            break;
          default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
      }
      function testBehaviour(parsed, entry) {
        if (typeof entry !== "string") {
          throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        }
        var tap2 = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        var dragAll = entry.indexOf("drag-all") >= 0;
        if (fixed) {
          if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
          }
          testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }
        if (unconstrained && (parsed.margin || parsed.limit)) {
          throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }
        parsed.events = {
          tap: tap2 || snap,
          drag,
          dragAll,
          fixed,
          snap,
          hover,
          unconstrained
        };
      }
      function testTooltips(parsed, entry) {
        if (entry === false) {
          return;
        }
        if (entry === true || isValidPartialFormatter(entry)) {
          parsed.tooltips = [];
          for (var i6 = 0; i6 < parsed.handles; i6++) {
            parsed.tooltips.push(entry);
          }
        } else {
          entry = asArray(entry);
          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          }
          entry.forEach(function(formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
          });
          parsed.tooltips = entry;
        }
      }
      function testHandleAttributes(parsed, entry) {
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a attributes for all handles.");
        }
        parsed.handleAttributes = entry;
      }
      function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
          throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }
        parsed.ariaFormat = entry;
      }
      function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
          throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }
        parsed.format = entry;
      }
      function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }
        parsed.keyboardSupport = entry;
      }
      function testDocumentElement(parsed, entry) {
        parsed.documentElement = entry;
      }
      function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
          throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }
        parsed.cssPrefix = entry;
      }
      function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
          throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }
        if (typeof parsed.cssPrefix === "string") {
          parsed.cssClasses = {};
          Object.keys(entry).forEach(function(key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
          });
        } else {
          parsed.cssClasses = entry;
        }
      }
      function testOptions(options) {
        var parsed = {
          margin: null,
          limit: null,
          padding: null,
          animate: true,
          animationDuration: 300,
          ariaFormat: defaultFormatter,
          format: defaultFormatter
        };
        var tests = {
          step: { r: false, t: testStep },
          keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
          keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
          keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
          start: { r: true, t: testStart },
          connect: { r: true, t: testConnect },
          direction: { r: true, t: testDirection },
          snap: { r: false, t: testSnap },
          animate: { r: false, t: testAnimate },
          animationDuration: { r: false, t: testAnimationDuration },
          range: { r: true, t: testRange },
          orientation: { r: false, t: testOrientation },
          margin: { r: false, t: testMargin },
          limit: { r: false, t: testLimit },
          padding: { r: false, t: testPadding },
          behaviour: { r: true, t: testBehaviour },
          ariaFormat: { r: false, t: testAriaFormat },
          format: { r: false, t: testFormat },
          tooltips: { r: false, t: testTooltips },
          keyboardSupport: { r: true, t: testKeyboardSupport },
          documentElement: { r: false, t: testDocumentElement },
          cssPrefix: { r: true, t: testCssPrefix },
          cssClasses: { r: true, t: testCssClasses },
          handleAttributes: { r: false, t: testHandleAttributes }
        };
        var defaults = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses,
          keyboardPageMultiplier: 5,
          keyboardMultiplier: 1,
          keyboardDefaultStep: 10
        };
        if (options.format && !options.ariaFormat) {
          options.ariaFormat = options.format;
        }
        Object.keys(tests).forEach(function(name) {
          if (!isSet(options[name]) && defaults[name] === void 0) {
            if (tests[name].r) {
              throw new Error("noUiSlider: '" + name + "' is required.");
            }
            return;
          }
          tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        });
        parsed.pips = options.pips;
        var d6 = document.createElement("div");
        var msPrefix = d6.style.msTransform !== void 0;
        var noPrefix = d6.style.transform !== void 0;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
        var styles = [
          ["left", "top"],
          ["right", "bottom"]
        ];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
      }
      function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
        function addNodeTo(addTarget, className) {
          var div = scope_Document.createElement("div");
          if (className) {
            addClass(div, className);
          }
          addTarget.appendChild(div);
          return div;
        }
        function addOrigin(base, handleNumber) {
          var origin = addNodeTo(base, options.cssClasses.origin);
          var handle = addNodeTo(origin, options.cssClasses.handle);
          addNodeTo(handle, options.cssClasses.touchArea);
          handle.setAttribute("data-handle", String(handleNumber));
          if (options.keyboardSupport) {
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function(event) {
              return eventKeydown(event, handleNumber);
            });
          }
          if (options.handleAttributes !== void 0) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function(attribute) {
              handle.setAttribute(attribute, attributes_1[attribute]);
            });
          }
          handle.setAttribute("role", "slider");
          handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
          if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
          } else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
          }
          return origin;
        }
        function addConnect(base, add) {
          if (!add) {
            return false;
          }
          return addNodeTo(base, options.cssClasses.connect);
        }
        function addElements(connectOptions, base) {
          var connectBase = addNodeTo(base, options.cssClasses.connects);
          scope_Handles = [];
          scope_Connects = [];
          scope_Connects.push(addConnect(connectBase, connectOptions[0]));
          for (var i6 = 0; i6 < options.handles; i6++) {
            scope_Handles.push(addOrigin(base, i6));
            scope_HandleNumbers[i6] = i6;
            scope_Connects.push(addConnect(connectBase, connectOptions[i6 + 1]));
          }
        }
        function addSlider(addTarget) {
          addClass(addTarget, options.cssClasses.target);
          if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
          } else {
            addClass(addTarget, options.cssClasses.rtl);
          }
          if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
          } else {
            addClass(addTarget, options.cssClasses.vertical);
          }
          var textDirection = getComputedStyle(addTarget).direction;
          if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
          } else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
          }
          return addNodeTo(addTarget, options.cssClasses.base);
        }
        function addTooltip(handle, handleNumber) {
          if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
          }
          return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }
        function isSliderDisabled() {
          return scope_Target.hasAttribute("disabled");
        }
        function isHandleDisabled(handleNumber) {
          var handleOrigin = scope_Handles[handleNumber];
          return handleOrigin.hasAttribute("disabled");
        }
        function removeTooltips() {
          if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function(tooltip) {
              if (tooltip) {
                removeElement(tooltip);
              }
            });
            scope_Tooltips = null;
          }
        }
        function tooltips() {
          removeTooltips();
          scope_Tooltips = scope_Handles.map(addTooltip);
          bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values2, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
              return;
            }
            if (scope_Tooltips[handleNumber] === false) {
              return;
            }
            var formattedValue = values2[handleNumber];
            if (options.tooltips[handleNumber] !== true) {
              formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }
            scope_Tooltips[handleNumber].innerHTML = formattedValue;
          });
        }
        function aria() {
          removeEvent("update" + INTERNAL_EVENT_NS.aria);
          bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values2, handleNumber, unencoded, tap2, positions) {
            scope_HandleNumbers.forEach(function(index2) {
              var handle = scope_Handles[index2];
              var min3 = checkHandlePosition(scope_Locations, index2, 0, true, true, true);
              var max4 = checkHandlePosition(scope_Locations, index2, 100, true, true, true);
              var now = positions[index2];
              var text = String(options.ariaFormat.to(unencoded[index2]));
              min3 = scope_Spectrum.fromStepping(min3).toFixed(1);
              max4 = scope_Spectrum.fromStepping(max4).toFixed(1);
              now = scope_Spectrum.fromStepping(now).toFixed(1);
              handle.children[0].setAttribute("aria-valuemin", min3);
              handle.children[0].setAttribute("aria-valuemax", max4);
              handle.children[0].setAttribute("aria-valuenow", now);
              handle.children[0].setAttribute("aria-valuetext", text);
            });
          });
        }
        function getGroup(pips2) {
          if (pips2.mode === exports2.PipsMode.Range || pips2.mode === exports2.PipsMode.Steps) {
            return scope_Spectrum.xVal;
          }
          if (pips2.mode === exports2.PipsMode.Count) {
            if (pips2.values < 2) {
              throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            }
            var interval = pips2.values - 1;
            var spread = 100 / interval;
            var values2 = [];
            while (interval--) {
              values2[interval] = interval * spread;
            }
            values2.push(100);
            return mapToRange(values2, pips2.stepped);
          }
          if (pips2.mode === exports2.PipsMode.Positions) {
            return mapToRange(pips2.values, pips2.stepped);
          }
          if (pips2.mode === exports2.PipsMode.Values) {
            if (pips2.stepped) {
              return pips2.values.map(function(value) {
                return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
              });
            }
            return pips2.values;
          }
          return [];
        }
        function mapToRange(values2, stepped) {
          return values2.map(function(value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
          });
        }
        function generateSpread(pips2) {
          function safeIncrement(value, increment) {
            return Number((value + increment).toFixed(7));
          }
          var group2 = getGroup(pips2);
          var indexes = {};
          var firstInRange = scope_Spectrum.xVal[0];
          var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
          var ignoreFirst = false;
          var ignoreLast = false;
          var prevPct = 0;
          group2 = unique(group2.slice().sort(function(a3, b2) {
            return a3 - b2;
          }));
          if (group2[0] !== firstInRange) {
            group2.unshift(firstInRange);
            ignoreFirst = true;
          }
          if (group2[group2.length - 1] !== lastInRange) {
            group2.push(lastInRange);
            ignoreLast = true;
          }
          group2.forEach(function(current, index2) {
            var step;
            var i6;
            var q3;
            var low = current;
            var high = group2[index2 + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips2.mode === exports2.PipsMode.Steps;
            if (isSteps) {
              step = scope_Spectrum.xNumSteps[index2];
            }
            if (!step) {
              step = high - low;
            }
            if (high === void 0) {
              high = low;
            }
            step = Math.max(step, 1e-7);
            for (i6 = low; i6 <= high; i6 = safeIncrement(i6, step)) {
              newPct = scope_Spectrum.toStepping(i6);
              pctDifference = newPct - prevPct;
              steps = pctDifference / (pips2.density || 1);
              realSteps = Math.round(steps);
              stepSize = pctDifference / realSteps;
              for (q3 = 1; q3 <= realSteps; q3 += 1) {
                pctPos = prevPct + q3 * stepSize;
                indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
              }
              type = group2.indexOf(i6) > -1 ? exports2.PipsType.LargeValue : isSteps ? exports2.PipsType.SmallValue : exports2.PipsType.NoValue;
              if (!index2 && ignoreFirst && i6 !== high) {
                type = 0;
              }
              if (!(i6 === high && ignoreLast)) {
                indexes[newPct.toFixed(5)] = [i6, type];
              }
              prevPct = newPct;
            }
          });
          return indexes;
        }
        function addMarking(spread, filterFunc, formatter) {
          var _a, _b;
          var element2 = scope_Document.createElement("div");
          var valueSizeClasses = (_a = {}, _a[exports2.PipsType.None] = "", _a[exports2.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports2.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports2.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
          var markerSizeClasses = (_b = {}, _b[exports2.PipsType.None] = "", _b[exports2.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports2.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports2.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
          var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
          var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
          addClass(element2, options.cssClasses.pips);
          addClass(element2, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
          function getClasses4(type, source) {
            var a3 = source === options.cssClasses.value;
            var orientationClasses = a3 ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a3 ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
          }
          function addSpread(offset5, value, type) {
            type = filterFunc ? filterFunc(value, type) : type;
            if (type === exports2.PipsType.None) {
              return;
            }
            var node = addNodeTo(element2, false);
            node.className = getClasses4(type, options.cssClasses.marker);
            node.style[options.style] = offset5 + "%";
            if (type > exports2.PipsType.NoValue) {
              node = addNodeTo(element2, false);
              node.className = getClasses4(type, options.cssClasses.value);
              node.setAttribute("data-value", String(value));
              node.style[options.style] = offset5 + "%";
              node.innerHTML = String(formatter.to(value));
            }
          }
          Object.keys(spread).forEach(function(offset5) {
            addSpread(offset5, spread[offset5][0], spread[offset5][1]);
          });
          return element2;
        }
        function removePips() {
          if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
          }
        }
        function pips(pips2) {
          removePips();
          var spread = generateSpread(pips2);
          var filter2 = pips2.filter;
          var format2 = pips2.format || {
            to: function(value) {
              return String(Math.round(value));
            }
          };
          scope_Pips = scope_Target.appendChild(addMarking(spread, filter2, format2));
          return scope_Pips;
        }
        function baseSize() {
          var rect = scope_Base.getBoundingClientRect();
          var alt = "offset" + ["Width", "Height"][options.ort];
          return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }
        function attachEvent2(events, element2, callback, data) {
          var method = function(event) {
            var e3 = fixEvent(event, data.pageOffset, data.target || element2);
            if (!e3) {
              return false;
            }
            if (isSliderDisabled() && !data.doNotReject) {
              return false;
            }
            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
              return false;
            }
            if (events === actions.start && e3.buttons !== void 0 && e3.buttons > 1) {
              return false;
            }
            if (data.hover && e3.buttons) {
              return false;
            }
            if (!supportsPassive) {
              e3.preventDefault();
            }
            e3.calcPoint = e3.points[options.ort];
            callback(e3, data);
            return;
          };
          var methods = [];
          events.split(" ").forEach(function(eventName) {
            element2.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
            methods.push([eventName, method]);
          });
          return methods;
        }
        function fixEvent(e3, pageOffset, eventTarget) {
          var touch = e3.type.indexOf("touch") === 0;
          var mouse = e3.type.indexOf("mouse") === 0;
          var pointer = e3.type.indexOf("pointer") === 0;
          var x2 = 0;
          var y4 = 0;
          if (e3.type.indexOf("MSPointer") === 0) {
            pointer = true;
          }
          if (e3.type === "mousedown" && !e3.buttons && !e3.touches) {
            return false;
          }
          if (touch) {
            var isTouchOnTarget = function(checkTouch) {
              var target2 = checkTouch.target;
              return target2 === eventTarget || eventTarget.contains(target2) || e3.composed && e3.composedPath().shift() === eventTarget;
            };
            if (e3.type === "touchstart") {
              var targetTouches = Array.prototype.filter.call(e3.touches, isTouchOnTarget);
              if (targetTouches.length > 1) {
                return false;
              }
              x2 = targetTouches[0].pageX;
              y4 = targetTouches[0].pageY;
            } else {
              var targetTouch = Array.prototype.find.call(e3.changedTouches, isTouchOnTarget);
              if (!targetTouch) {
                return false;
              }
              x2 = targetTouch.pageX;
              y4 = targetTouch.pageY;
            }
          }
          pageOffset = pageOffset || getPageOffset(scope_Document);
          if (mouse || pointer) {
            x2 = e3.clientX + pageOffset.x;
            y4 = e3.clientY + pageOffset.y;
          }
          e3.pageOffset = pageOffset;
          e3.points = [x2, y4];
          e3.cursor = mouse || pointer;
          return e3;
        }
        function calcPointToPercentage(calcPoint) {
          var location2 = calcPoint - offset4(scope_Base, options.ort);
          var proposal = location2 * 100 / baseSize();
          proposal = limit(proposal);
          return options.dir ? 100 - proposal : proposal;
        }
        function getClosestHandle(clickedPosition) {
          var smallestDifference = 100;
          var handleNumber = false;
          scope_Handles.forEach(function(handle, index2) {
            if (isHandleDisabled(index2)) {
              return;
            }
            var handlePosition = scope_Locations[index2];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
            if (isCloser || isCloserAfter || clickAtEdge) {
              handleNumber = index2;
              smallestDifference = differenceWithThisHandle;
            }
          });
          return handleNumber;
        }
        function documentLeave(event, data) {
          if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
            eventEnd(event, data);
          }
        }
        function eventMove(event, data) {
          if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
          }
          var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
          var proposal = movement * 100 / data.baseSize;
          moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        }
        function eventEnd(event, data) {
          if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
          }
          data.listeners.forEach(function(c6) {
            scope_DocumentElement.removeEventListener(c6[0], c6[1]);
          });
          if (scope_ActiveHandlesCount === 0) {
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex();
            if (event.cursor) {
              scope_Body.style.cursor = "";
              scope_Body.removeEventListener("selectstart", preventDefault);
            }
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
          });
        }
        function eventStart(event, data) {
          if (data.handleNumbers.some(isHandleDisabled)) {
            return;
          }
          var handle;
          if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1;
            addClass(handle, options.cssClasses.active);
          }
          event.stopPropagation();
          var listeners = [];
          var moveEvent = attachEvent2(actions.move, scope_DocumentElement, eventMove, {
            // The event target has changed so we need to propagate the original one so that we keep
            // relying on it to extract target touches.
            target: event.target,
            handle,
            connect: data.connect,
            listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice()
          });
          var endEvent = attachEvent2(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          var outEvent = attachEvent2("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
          if (event.cursor) {
            scope_Body.style.cursor = getComputedStyle(event.target).cursor;
            if (scope_Handles.length > 1) {
              addClass(scope_Target, options.cssClasses.drag);
            }
            scope_Body.addEventListener("selectstart", preventDefault, false);
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("start", handleNumber);
          });
        }
        function eventTap(event) {
          event.stopPropagation();
          var proposal = calcPointToPercentage(event.calcPoint);
          var handleNumber = getClosestHandle(proposal);
          if (handleNumber === false) {
            return;
          }
          if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          setHandle(handleNumber, proposal, true, true);
          setZindex();
          fireEvent("slide", handleNumber, true);
          fireEvent("update", handleNumber, true);
          if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
          } else {
            eventStart(event, { handleNumbers: [handleNumber] });
          }
        }
        function eventHover(event) {
          var proposal = calcPointToPercentage(event.calcPoint);
          var to = scope_Spectrum.getStep(proposal);
          var value = scope_Spectrum.fromStepping(to);
          Object.keys(scope_Events).forEach(function(targetEvent) {
            if ("hover" === targetEvent.split(".")[0]) {
              scope_Events[targetEvent].forEach(function(callback) {
                callback.call(scope_Self, value);
              });
            }
          });
        }
        function eventKeydown(event, handleNumber) {
          if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
          }
          var horizontalKeys = ["Left", "Right"];
          var verticalKeys = ["Down", "Up"];
          var largeStepKeys = ["PageDown", "PageUp"];
          var edgeKeys = ["Home", "End"];
          if (options.dir && !options.ort) {
            horizontalKeys.reverse();
          } else if (options.ort && !options.dir) {
            verticalKeys.reverse();
            largeStepKeys.reverse();
          }
          var key = event.key.replace("Arrow", "");
          var isLargeDown = key === largeStepKeys[0];
          var isLargeUp = key === largeStepKeys[1];
          var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
          var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
          var isMin = key === edgeKeys[0];
          var isMax = key === edgeKeys[1];
          if (!isDown && !isUp && !isMin && !isMax) {
            return true;
          }
          event.preventDefault();
          var to;
          if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction];
            if (step === null) {
              return false;
            }
            if (step === false) {
              step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }
            if (isLargeUp || isLargeDown) {
              step *= options.keyboardPageMultiplier;
            } else {
              step *= options.keyboardMultiplier;
            }
            step = Math.max(step, 1e-7);
            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
          } else if (isMax) {
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
          } else {
            to = options.spectrum.xVal[0];
          }
          setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
          fireEvent("slide", handleNumber);
          fireEvent("update", handleNumber);
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          return false;
        }
        function bindSliderEvents(behaviour) {
          if (!behaviour.fixed) {
            scope_Handles.forEach(function(handle, index2) {
              attachEvent2(actions.start, handle.children[0], eventStart, {
                handleNumbers: [index2]
              });
            });
          }
          if (behaviour.tap) {
            attachEvent2(actions.start, scope_Base, eventTap, {});
          }
          if (behaviour.hover) {
            attachEvent2(actions.move, scope_Base, eventHover, {
              hover: true
            });
          }
          if (behaviour.drag) {
            scope_Connects.forEach(function(connect, index2) {
              if (connect === false || index2 === 0 || index2 === scope_Connects.length - 1) {
                return;
              }
              var handleBefore = scope_Handles[index2 - 1];
              var handleAfter = scope_Handles[index2];
              var eventHolders = [connect];
              var handlesToDrag = [handleBefore, handleAfter];
              var handleNumbersToDrag = [index2 - 1, index2];
              addClass(connect, options.cssClasses.draggable);
              if (behaviour.fixed) {
                eventHolders.push(handleBefore.children[0]);
                eventHolders.push(handleAfter.children[0]);
              }
              if (behaviour.dragAll) {
                handlesToDrag = scope_Handles;
                handleNumbersToDrag = scope_HandleNumbers;
              }
              eventHolders.forEach(function(eventHolder) {
                attachEvent2(actions.start, eventHolder, eventStart, {
                  handles: handlesToDrag,
                  handleNumbers: handleNumbersToDrag,
                  connect
                });
              });
            });
          }
        }
        function bindEvent(namespacedEvent, callback) {
          scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
          scope_Events[namespacedEvent].push(callback);
          if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function(a3, index2) {
              fireEvent("update", index2);
            });
          }
        }
        function isInternalNamespace(namespace) {
          return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }
        function removeEvent(namespacedEvent) {
          var event = namespacedEvent && namespacedEvent.split(".")[0];
          var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
          Object.keys(scope_Events).forEach(function(bind) {
            var tEvent = bind.split(".")[0];
            var tNamespace = bind.substring(tEvent.length);
            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
              if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                delete scope_Events[bind];
              }
            }
          });
        }
        function fireEvent(eventName, handleNumber, tap2) {
          Object.keys(scope_Events).forEach(function(targetEvent) {
            var eventType = targetEvent.split(".")[0];
            if (eventName === eventType) {
              scope_Events[targetEvent].forEach(function(callback) {
                callback.call(
                  // Use the slider public API as the scope ('this')
                  scope_Self,
                  // Return values as array, so arg_1[arg_2] is always valid.
                  scope_Values.map(options.format.to),
                  // Handle index, 0 or 1
                  handleNumber,
                  // Un-formatted slider values
                  scope_Values.slice(),
                  // Event is fired by tap, true or false
                  tap2 || false,
                  // Left offset of the handle, in relation to the slider
                  scope_Locations.slice(),
                  // add the slider public API to an accessible parameter when this is unavailable
                  scope_Self
                );
              });
            }
          });
        }
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
          var distance;
          if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
              to = Math.max(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
              to = Math.min(to, distance);
            }
          }
          if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
              to = Math.min(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
              to = Math.max(to, distance);
            }
          }
          if (options.padding) {
            if (handleNumber === 0) {
              distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
              to = Math.max(to, distance);
            }
            if (handleNumber === scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
              to = Math.min(to, distance);
            }
          }
          to = scope_Spectrum.getStep(to);
          to = limit(to);
          if (to === reference[handleNumber] && !getValue) {
            return false;
          }
          return to;
        }
        function inRuleOrder(v4, a3) {
          var o11 = options.ort;
          return (o11 ? a3 : v4) + ", " + (o11 ? v4 : a3);
        }
        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
          var proposals = locations.slice();
          var firstHandle = handleNumbers[0];
          var b2 = [!upward, upward];
          var f6 = [upward, !upward];
          handleNumbers = handleNumbers.slice();
          if (upward) {
            handleNumbers.reverse();
          }
          if (handleNumbers.length > 1) {
            handleNumbers.forEach(function(handleNumber, o11) {
              var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b2[o11], f6[o11], false);
              if (to === false) {
                proposal = 0;
              } else {
                proposal = to - proposals[handleNumber];
                proposals[handleNumber] = to;
              }
            });
          } else {
            b2 = f6 = [true];
          }
          var state = false;
          handleNumbers.forEach(function(handleNumber, o11) {
            state = setHandle(handleNumber, locations[handleNumber] + proposal, b2[o11], f6[o11]) || state;
          });
          if (state) {
            handleNumbers.forEach(function(handleNumber) {
              fireEvent("update", handleNumber);
              fireEvent("slide", handleNumber);
            });
            if (connect != void 0) {
              fireEvent("drag", firstHandle);
            }
          }
        }
        function transformDirection(a3, b2) {
          return options.dir ? 100 - a3 - b2 : a3;
        }
        function updateHandlePosition(handleNumber, to) {
          scope_Locations[handleNumber] = to;
          scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
          var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
          var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
          scope_Handles[handleNumber].style[options.transformRule] = translateRule;
          updateConnect(handleNumber);
          updateConnect(handleNumber + 1);
        }
        function setZindex() {
          scope_HandleNumbers.forEach(function(handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
          });
        }
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
          if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
          }
          if (to === false) {
            return false;
          }
          updateHandlePosition(handleNumber, to);
          return true;
        }
        function updateConnect(index2) {
          if (!scope_Connects[index2]) {
            return;
          }
          var l7 = 0;
          var h4 = 100;
          if (index2 !== 0) {
            l7 = scope_Locations[index2 - 1];
          }
          if (index2 !== scope_Connects.length - 1) {
            h4 = scope_Locations[index2];
          }
          var connectWidth = h4 - l7;
          var translateRule = "translate(" + inRuleOrder(transformDirection(l7, connectWidth) + "%", "0") + ")";
          var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
          scope_Connects[index2].style[options.transformRule] = translateRule + " " + scaleRule;
        }
        function resolveToValue(to, handleNumber) {
          if (to === null || to === false || to === void 0) {
            return scope_Locations[handleNumber];
          }
          if (typeof to === "number") {
            to = String(to);
          }
          to = options.format.from(to);
          if (to !== false) {
            to = scope_Spectrum.toStepping(to);
          }
          if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
          }
          return to;
        }
        function valueSet(input, fireSetEvent, exactInput) {
          var values2 = asArray(input);
          var isInit = scope_Locations[0] === void 0;
          fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
          if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          scope_HandleNumbers.forEach(function(handleNumber) {
            setHandle(handleNumber, resolveToValue(values2[handleNumber], handleNumber), true, false, exactInput);
          });
          var i6 = scope_HandleNumbers.length === 1 ? 0 : 1;
          if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;
            if (scope_HandleNumbers.length > 1) {
              var space_1 = 100 / (scope_HandleNumbers.length - 1);
              scope_HandleNumbers.forEach(function(handleNumber) {
                scope_Locations[handleNumber] = handleNumber * space_1;
              });
            }
          }
          for (; i6 < scope_HandleNumbers.length; ++i6) {
            scope_HandleNumbers.forEach(function(handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
          }
          setZindex();
          scope_HandleNumbers.forEach(function(handleNumber) {
            fireEvent("update", handleNumber);
            if (values2[handleNumber] !== null && fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          });
        }
        function valueReset(fireSetEvent) {
          valueSet(options.start, fireSetEvent);
        }
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
          handleNumber = Number(handleNumber);
          if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
          }
          setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
          fireEvent("update", handleNumber);
          if (fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        }
        function valueGet(unencoded) {
          if (unencoded === void 0) {
            unencoded = false;
          }
          if (unencoded) {
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
          }
          var values2 = scope_Values.map(options.format.to);
          if (values2.length === 1) {
            return values2[0];
          }
          return values2;
        }
        function destroy() {
          removeEvent(INTERNAL_EVENT_NS.aria);
          removeEvent(INTERNAL_EVENT_NS.tooltips);
          Object.keys(options.cssClasses).forEach(function(key) {
            removeClass(scope_Target, options.cssClasses[key]);
          });
          while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
          }
          delete scope_Target.noUiSlider;
        }
        function getNextStepsForHandle(handleNumber) {
          var location2 = scope_Locations[handleNumber];
          var nearbySteps = scope_Spectrum.getNearbySteps(location2);
          var value = scope_Values[handleNumber];
          var increment = nearbySteps.thisStep.step;
          var decrement = null;
          if (options.snap) {
            return [
              value - nearbySteps.stepBefore.startValue || null,
              nearbySteps.stepAfter.startValue - value || null
            ];
          }
          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          }
          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          } else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          }
          if (location2 === 100) {
            increment = null;
          } else if (location2 === 0) {
            decrement = null;
          }
          var stepDecimals = scope_Spectrum.countStepDecimals();
          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }
          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }
          return [decrement, increment];
        }
        function getNextSteps() {
          return scope_HandleNumbers.map(getNextStepsForHandle);
        }
        function updateOptions(optionsToUpdate, fireSetEvent) {
          var v4 = valueGet();
          var updateAble = [
            "margin",
            "limit",
            "padding",
            "range",
            "animate",
            "snap",
            "step",
            "format",
            "pips",
            "tooltips"
          ];
          updateAble.forEach(function(name) {
            if (optionsToUpdate[name] !== void 0) {
              originalOptions[name] = optionsToUpdate[name];
            }
          });
          var newOptions = testOptions(originalOptions);
          updateAble.forEach(function(name) {
            if (optionsToUpdate[name] !== void 0) {
              options[name] = newOptions[name];
            }
          });
          scope_Spectrum = newOptions.spectrum;
          options.margin = newOptions.margin;
          options.limit = newOptions.limit;
          options.padding = newOptions.padding;
          if (options.pips) {
            pips(options.pips);
          } else {
            removePips();
          }
          if (options.tooltips) {
            tooltips();
          } else {
            removeTooltips();
          }
          scope_Locations = [];
          valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v4, fireSetEvent);
        }
        function setupSlider() {
          scope_Base = addSlider(scope_Target);
          addElements(options.connect, scope_Base);
          bindSliderEvents(options.events);
          valueSet(options.start);
          if (options.pips) {
            pips(options.pips);
          }
          if (options.tooltips) {
            tooltips();
          }
          aria();
        }
        setupSlider();
        var scope_Self = {
          destroy,
          steps: getNextSteps,
          on: bindEvent,
          off: removeEvent,
          get: valueGet,
          set: valueSet,
          setHandle: valueSetHandle,
          reset: valueReset,
          // Exposed for unit testing, don't use this in your application.
          __moveHandles: function(upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
          },
          options: originalOptions,
          updateOptions,
          target: scope_Target,
          removePips,
          removeTooltips,
          getPositions: function() {
            return scope_Locations.slice();
          },
          getTooltips: function() {
            return scope_Tooltips;
          },
          getOrigins: function() {
            return scope_Handles;
          },
          pips
          // Issue #594
        };
        return scope_Self;
      }
      function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
          throw new Error("noUiSlider: create requires a single element, got: " + target);
        }
        if (target.noUiSlider) {
          throw new Error("noUiSlider: Slider was already initialized.");
        }
        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
      }
      var nouislider = {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses,
        create: initialize
      };
      exports2.create = initialize;
      exports2.cssClasses = cssClasses;
      exports2["default"] = nouislider;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_int.js
var import_nouislider, IntModel, BoundedIntModel, SliderStyleModel, IntSliderModel, IntRangeSliderModel, BaseIntSliderView, IntRangeSliderView, IntSliderView, IntTextModel, BoundedIntTextModel, IntTextView, ProgressStyleModel, IntProgressModel, ProgressView, PlayModel, PlayView;
var init_widget_int = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_int.js"() {
    init_widget_core();
    init_widget_description();
    init_lib8();
    init_utils3();
    init_src2();
    import_nouislider = __toESM(require_nouislider());
    IntModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntModel", value: 0 });
      }
    };
    BoundedIntModel = class extends IntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedIntModel", max: 100, min: 0 });
      }
    };
    SliderStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SliderStyleModel" });
      }
    };
    SliderStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { handle_color: {
      selector: ".noUi-handle",
      attribute: "background-color",
      default: null
    } });
    IntSliderModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntSliderModel", _view_name: "IntSliderView", step: 1, orientation: "horizontal", readout: true, readout_format: "d", continuous_update: true, style: null, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    IntRangeSliderModel = class extends IntSliderModel {
    };
    BaseIntSliderView = class extends DescriptionView {
      constructor() {
        super(...arguments);
        this._parse_value = parseInt;
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-slider");
        this.el.classList.add("widget-hslider");
        this.$slider = document.createElement("div");
        this.$slider.classList.add("slider");
        this.slider_container = document.createElement("div");
        this.slider_container.classList.add("slider-container");
        this.slider_container.appendChild(this.$slider);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement("div");
        this.el.appendChild(this.readout);
        this.readout.classList.add("widget-readout");
        this.readout.contentEditable = "true";
        this.readout.style.display = "none";
        this.createSlider();
        this.model.on("change:orientation", this.regenSlider, this);
        this.model.on("change:max", this.updateSliderOptions, this);
        this.model.on("change:min", this.updateSliderOptions, this);
        this.model.on("change:step", this.updateSliderOptions, this);
        this.model.on("change:value", this.updateSliderValue, this);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          if (this.model.get("disabled")) {
            this.readout.contentEditable = "false";
            this.$slider.setAttribute("disabled", true);
          } else {
            this.readout.contentEditable = "true";
            this.$slider.removeAttribute("disabled");
          }
          const orientation = this.model.get("orientation");
          if (orientation === "vertical") {
            this.el.classList.remove("widget-hslider");
            this.el.classList.add("widget-vslider");
            this.el.classList.remove("widget-inline-hbox");
            this.el.classList.add("widget-inline-vbox");
          } else {
            this.el.classList.remove("widget-vslider");
            this.el.classList.add("widget-hslider");
            this.el.classList.remove("widget-inline-vbox");
            this.el.classList.add("widget-inline-hbox");
          }
          const readout = this.model.get("readout");
          if (readout) {
            this.readout.style.display = "";
            this.displayed.then(() => {
              if (this.readout_overflow()) {
                this.readout.classList.add("overflow");
              } else {
                this.readout.classList.remove("overflow");
              }
            });
          } else {
            this.readout.style.display = "none";
          }
        }
        return super.update();
      }
      /**
       * Returns true if the readout box content overflows.
       */
      readout_overflow() {
        return this.readout.scrollWidth > this.readout.clientWidth;
      }
      events() {
        return {
          // Dictionary of events and their handlers.
          "blur [contentEditable=true]": "handleTextChange",
          "keydown [contentEditable=true]": "handleKeyDown"
        };
      }
      handleKeyDown(e3) {
        if (e3.keyCode === 13) {
          e3.preventDefault();
          this.handleTextChange();
        }
      }
      /**
       * Create a new noUiSlider object
       */
      createSlider() {
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider.default.create(this.$slider, {
          start: this.model.get("value"),
          connect: true,
          behaviour: behavior,
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step"),
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => this._validate_slide_value(value)
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      /**
       * Recreate/Regenerate a slider object
       * noUiSlider does not support in-place mutation of the orientation
       * state. We therefore need to destroy the current instance
       * and create a new one with the new properties. This is
       * handled in a separate function and has a dedicated event
       * handler.
       */
      regenSlider(e3) {
        this.$slider.noUiSlider.destroy();
        this.createSlider();
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x2) {
        return Math.round(x2);
      }
    };
    IntRangeSliderView = class extends BaseIntSliderView {
      constructor() {
        super(...arguments);
        this._range_regex = /^\s*([+-]?\d+)\s*[-:]\s*([+-]?\d+)/;
      }
      update(options) {
        super.update(options);
        const value = this.model.get("value");
        this.readout.textContent = this.valueToString(value);
        if (this.model.get("value") !== value) {
          this.model.set("value", value, { updated_view: this });
          this.touch();
        }
      }
      /**
       * Write value to a string
       */
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return value.map(function(v4) {
          return format2(v4);
        }).join(" \u2013 ");
      }
      /**
       * Parse value from a string
       */
      stringToValue(text) {
        if (text === null) {
          return null;
        }
        const match = this._range_regex.exec(text);
        if (match) {
          return [this._parse_value(match[1]), this._parse_value(match[2])];
        } else {
          return null;
        }
      }
      handleTextChange() {
        let value = this.stringToValue(this.readout.textContent);
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        if (value === null || isNaN(value[0]) || isNaN(value[1]) || value[0] > value[1]) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = [
            Math.max(Math.min(value[0], vmax), vmin),
            Math.max(Math.min(value[1], vmax), vmin)
          ];
          if (value[0] !== this.model.get("value")[0] || value[1] !== this.model.get("value")[1]) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      handleSliderChanged(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.model.set("value", actual_value, { updated_view: this });
        this.touch();
      }
      updateSliderOptions(e3) {
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("value"),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      updateSliderValue(model, _4, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_value = this.$slider.noUiSlider.get();
        const value = this.model.get("value");
        if (prev_value[0] !== value[0] || prev_value[1] !== value[1]) {
          this.$slider.noUiSlider.set(value);
        }
      }
    };
    IntSliderView = class extends BaseIntSliderView {
      update(options) {
        super.update(options);
        const min3 = this.model.get("min");
        const max4 = this.model.get("max");
        let value = this.model.get("value");
        if (value > max4) {
          value = max4;
        } else if (value < min3) {
          value = min3;
        }
        this.readout.textContent = this.valueToString(value);
        if (this.model.get("value") !== value) {
          this.model.set("value", value, { updated_view: this });
          this.touch();
        }
      }
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return format2(value);
      }
      stringToValue(text) {
        return this._parse_value(text);
      }
      handleTextChange() {
        var _a;
        let value = this.stringToValue((_a = this.readout.textContent) !== null && _a !== void 0 ? _a : "");
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        if (isNaN(value)) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = Math.max(Math.min(value, vmax), vmin);
          if (value !== this.model.get("value")) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      handleSliderChangeEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      handleSliderUpdateEvent(values2, handle) {
        const actual_value = values2.map(this._validate_slide_value);
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      handleSliderChanged(values2, handle) {
        const actual_value = this._validate_slide_value(values2[handle]);
        const model_value = this.model.get("value");
        if (parseFloat(model_value) !== actual_value) {
          this.model.set("value", actual_value, { updated_view: this });
          this.touch();
        }
      }
      updateSliderOptions(e3) {
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("value"),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      updateSliderValue(model, _4, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_value = this.$slider.noUiSlider.get();
        const value = this.model.get("value");
        if (prev_value !== value) {
          this.$slider.noUiSlider.set(value);
        }
      }
    };
    IntTextModel = class extends IntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntTextModel", _view_name: "IntTextView", disabled: false, continuous_update: false });
      }
    };
    BoundedIntTextModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedIntTextModel", _view_name: "IntTextView", disabled: false, continuous_update: false, step: 1 });
      }
    };
    IntTextView = class extends DescriptionView {
      constructor() {
        super(...arguments);
        this._parse_value = parseInt;
        this._default_step = "1";
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-text");
        this.textbox = document.createElement("input");
        this.textbox.type = "number";
        this.textbox.required = true;
        this.textbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.textbox);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          const value = this.model.get("value");
          if (this._parse_value(this.textbox.value) !== value) {
            this.textbox.value = value.toString();
          }
          if (this.model.get("min") !== void 0) {
            this.textbox.min = this.model.get("min");
          }
          if (this.model.get("max") !== void 0) {
            this.textbox.max = this.model.get("max");
          }
          if (this.model.get("step") !== void 0 && this.model.get("step") !== null) {
            this.textbox.step = this.model.get("step");
          } else {
            this.textbox.step = this._default_step;
          }
          this.textbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "keyup input": "handleKeyUp",
          "input input": "handleChanging",
          "change input": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the event isn't sent to the application.
       */
      handleKeyDown(e3) {
        e3.stopPropagation();
      }
      /**
       * Handles key press
       */
      handleKeypress(e3) {
        if (/[e,. ]/.test(String.fromCharCode(e3.keyCode))) {
          e3.preventDefault();
        }
      }
      /**
       * Handle key up
       */
      handleKeyUp(e3) {
        if (e3.altKey || e3.ctrlKey) {
          return;
        }
        const target = e3.target;
        let value = target.value;
        value = value.replace(/[e,.\s]/g, "");
        if (value.length >= 1) {
          const subvalue = value.substr(1);
          value = value[0] + subvalue.replace(/[+-]/g, "");
        }
        if (target.value !== value) {
          e3.preventDefault();
          target.value = value;
        }
      }
      /**
       * Call the submit handler if continuous update is true and we are not
       * obviously incomplete.
       */
      handleChanging(e3) {
        const target = e3.target;
        const trimmed = target.value.trim();
        if (trimmed === "" || ["-", "-.", ".", "+.", "+"].indexOf(trimmed) >= 0) {
          return;
        }
        if (this.model.get("continuous_update")) {
          this.handleChanged(e3);
        }
      }
      /**
       * Applies validated input.
       */
      handleChanged(e3) {
        const target = e3.target;
        let numericalValue = this._parse_value(target.value);
        if (isNaN(numericalValue)) {
          target.value = this.model.get("value");
        } else {
          let boundedValue = numericalValue;
          if (this.model.get("max") !== void 0) {
            boundedValue = Math.min(this.model.get("max"), boundedValue);
          }
          if (this.model.get("min") !== void 0) {
            boundedValue = Math.max(this.model.get("min"), boundedValue);
          }
          if (boundedValue !== numericalValue) {
            target.value = boundedValue;
            numericalValue = boundedValue;
          }
          if (numericalValue !== this.model.get("value")) {
            this.model.set("value", numericalValue, { updated_view: this });
            this.touch();
          }
        }
      }
    };
    ProgressStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ProgressStyleModel" });
      }
    };
    ProgressStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { bar_color: {
      selector: ".progress-bar",
      attribute: "background-color",
      default: null
    } });
    IntProgressModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "IntProgressModel", _view_name: "ProgressView", orientation: "horizontal", bar_style: "", style: null });
      }
    };
    ProgressView = class extends DescriptionView {
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:bar_style", this.update_bar_style);
        this.luminoWidget.addClass("jupyter-widgets");
      }
      render() {
        super.render();
        const orientation = this.model.get("orientation");
        const className = orientation === "horizontal" ? "widget-hprogress" : "widget-vprogress";
        this.el.classList.add(className);
        this.progress = document.createElement("div");
        this.progress.classList.add("progress");
        this.progress.style.position = "relative";
        this.el.appendChild(this.progress);
        this.bar = document.createElement("div");
        this.bar.classList.add("progress-bar");
        this.bar.style.position = "absolute";
        this.bar.style.bottom = "0px";
        this.bar.style.left = "0px";
        this.progress.appendChild(this.bar);
        this.update();
        this.set_bar_style();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        const value = this.model.get("value");
        const max4 = this.model.get("max");
        const min3 = this.model.get("min");
        const orientation = this.model.get("orientation");
        const percent = 100 * (value - min3) / (max4 - min3);
        if (orientation === "horizontal") {
          this.el.classList.remove("widget-inline-vbox");
          this.el.classList.remove("widget-vprogress");
          this.el.classList.add("widget-inline-hbox");
          this.el.classList.add("widget-hprogress");
          this.bar.style.width = percent + "%";
          this.bar.style.height = "100%";
        } else {
          this.el.classList.remove("widget-inline-hbox");
          this.el.classList.remove("widget-hprogress");
          this.el.classList.add("widget-inline-vbox");
          this.el.classList.add("widget-vprogress");
          this.bar.style.width = "100%";
          this.bar.style.height = percent + "%";
        }
        return super.update();
      }
      update_bar_style() {
        this.update_mapped_classes(ProgressView.class_map, "bar_style", this.bar);
      }
      set_bar_style() {
        this.set_mapped_classes(ProgressView.class_map, "bar_style", this.bar);
      }
    };
    ProgressView.class_map = {
      success: ["progress-bar-success"],
      info: ["progress-bar-info"],
      warning: ["progress-bar-warning"],
      danger: ["progress-bar-danger"]
    };
    PlayModel = class extends BoundedIntModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "PlayModel", _view_name: "PlayView", repeat: false, playing: false, show_repeat: true, interval: 100, step: 1, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
      }
      loop() {
        if (!this.get("playing")) {
          return;
        }
        const next_value = this.get("value") + this.get("step");
        if (next_value <= this.get("max")) {
          this.set("value", next_value);
          this.schedule_next();
        } else {
          if (this.get("repeat")) {
            this.set("value", this.get("min"));
            this.schedule_next();
          } else {
            this.pause();
          }
        }
        this.save_changes();
      }
      schedule_next() {
        this._timerId = window.setTimeout(this.loop.bind(this), this.get("interval"));
      }
      stop() {
        this.pause();
        this.set("value", this.get("min"));
        this.save_changes();
      }
      pause() {
        window.clearTimeout(this._timerId);
        this._timerId = void 0;
        this.set("playing", false);
        this.save_changes();
      }
      animate() {
        if (this._timerId !== void 0) {
          return;
        }
        if (this.get("value") === this.get("max")) {
          this.set("value", this.get("min"));
          this.schedule_next();
          this.save_changes();
        } else {
          this.loop();
        }
        this.save_changes();
      }
      play() {
        this.set("playing", !this.get("playing"));
        this.save_changes();
      }
      repeat() {
        this.set("repeat", !this.get("repeat"));
        this.save_changes();
      }
    };
    PlayView = class extends DOMWidgetView {
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
        this.el.classList.add("widget-play");
        this.playPauseButton = document.createElement("button");
        this.stopButton = document.createElement("button");
        this.repeatButton = document.createElement("button");
        this.playPauseButton.className = "jupyter-button";
        this.stopButton.className = "jupyter-button";
        this.repeatButton.className = "jupyter-button";
        this.el.appendChild(this.playPauseButton);
        this.el.appendChild(this.stopButton);
        this.el.appendChild(this.repeatButton);
        const playIcon = document.createElement("i");
        playIcon.className = "fa fa-play";
        this.playPauseButton.appendChild(playIcon);
        const stopIcon = document.createElement("i");
        stopIcon.className = "fa fa-stop";
        this.stopButton.appendChild(stopIcon);
        const repeatIcon = document.createElement("i");
        repeatIcon.className = "fa fa-retweet";
        this.repeatButton.appendChild(repeatIcon);
        this.playPauseButton.onclick = this.model.play.bind(this.model);
        this.stopButton.onclick = this.model.stop.bind(this.model);
        this.repeatButton.onclick = this.model.repeat.bind(this.model);
        this.listenTo(this.model, "change:playing", this.onPlayingChanged);
        this.listenTo(this.model, "change:repeat", this.updateRepeat);
        this.listenTo(this.model, "change:show_repeat", this.updateRepeat);
        this.updatePlaying();
        this.updateRepeat();
        this.update();
      }
      update() {
        const disabled = this.model.get("disabled");
        this.playPauseButton.disabled = disabled;
        this.stopButton.disabled = disabled;
        this.repeatButton.disabled = disabled;
        this.updatePlaying();
      }
      onPlayingChanged() {
        this.updatePlaying();
        const previous = this.model.previous("playing");
        const current = this.model.get("playing");
        if (!previous && current) {
          this.model.animate();
        } else {
          this.model.pause();
        }
      }
      updatePlaying() {
        const playing = this.model.get("playing");
        const icon = this.playPauseButton.getElementsByTagName("i")[0];
        if (playing) {
          icon.className = "fa fa-pause";
        } else {
          icon.className = "fa fa-play";
        }
      }
      updateRepeat() {
        const repeat = this.model.get("repeat");
        this.repeatButton.style.display = this.model.get("show_repeat") ? this.playPauseButton.style.display : "none";
        if (repeat) {
          this.repeatButton.classList.add("mod-active");
        } else {
          this.repeatButton.classList.remove("mod-active");
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_float.js
var import_nouislider2, FloatModel, BoundedFloatModel, FloatSliderModel, FloatLogSliderModel, FloatRangeSliderModel, FloatSliderView, FloatLogSliderView, FloatRangeSliderView, FloatTextModel, BoundedFloatTextModel, FloatTextView, FloatProgressModel;
var init_widget_float = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_float.js"() {
    init_widget_core();
    init_widget_int();
    init_src2();
    import_nouislider2 = __toESM(require_nouislider());
    FloatModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatModel", value: 0 });
      }
    };
    BoundedFloatModel = class extends FloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedFloatModel", max: 100, min: 0 });
      }
    };
    FloatSliderModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatSliderModel", _view_name: "FloatSliderView", step: 1, orientation: "horizontal", _range: false, readout: true, readout_format: ".2f", slider_color: null, continuous_update: true, disabled: false });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    FloatLogSliderModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatLogSliderModel", _view_name: "FloatLogSliderView", step: 0.1, orientation: "horizontal", _range: false, readout: true, readout_format: ".3g", slider_color: null, continuous_update: true, disabled: false, base: 10, value: 1, min: 0, max: 4 });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        this.on("change:readout_format", this.update_readout_format, this);
        this.update_readout_format();
      }
      update_readout_format() {
        this.readout_formatter = format(this.get("readout_format"));
      }
    };
    FloatRangeSliderModel = class extends FloatSliderModel {
    };
    FloatSliderView = class extends IntSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x2) {
        return x2;
      }
    };
    FloatLogSliderView = class extends BaseIntSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
      }
      update(options) {
        super.update(options);
        const value = this.model.get("value");
        this.readout.textContent = this.valueToString(value);
      }
      /**
       * Convert from value to exponent
       *
       * @param value the widget value
       * @returns the log-value between the min/max exponents
       */
      logCalc(value) {
        const min3 = this.model.get("min");
        const max4 = this.model.get("max");
        const base = this.model.get("base");
        let log_value = Math.log(value) / Math.log(base);
        if (log_value > max4) {
          log_value = max4;
        } else if (log_value < min3) {
          log_value = min3;
        }
        return log_value;
      }
      createSlider() {
        var _a;
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider2.default.create(this.$slider, {
          start: this.logCalc(this.model.get("value")),
          behaviour: behavior,
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: (_a = this.model.get("step")) !== null && _a !== void 0 ? _a : void 0,
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => value
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      /**
       * Write value to a string
       */
      valueToString(value) {
        const format2 = this.model.readout_formatter;
        return format2(value);
      }
      /**
       * Parse value from a string
       */
      stringToValue(text) {
        return text === null ? NaN : this._parse_value(text);
      }
      /**
       * this handles the entry of text into the contentEditable label first, the
       * value is checked if it contains a parseable value then it is clamped
       * within the min-max range of the slider finally, the model is updated if
       * the value is to be changed
       *
       * if any of these conditions are not met, the text is reset
       */
      handleTextChange() {
        let value = this.stringToValue(this.readout.textContent);
        const vmin = this.model.get("min");
        const vmax = this.model.get("max");
        const base = this.model.get("base");
        if (isNaN(value)) {
          this.readout.textContent = this.valueToString(this.model.get("value"));
        } else {
          value = Math.max(Math.min(value, Math.pow(base, vmax)), Math.pow(base, vmin));
          if (value !== this.model.get("value")) {
            this.readout.textContent = this.valueToString(value);
            this.model.set("value", value);
            this.touch();
          } else {
            this.readout.textContent = this.valueToString(this.model.get("value"));
          }
        }
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.readout.textContent = this.valueToString(actual_value);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.readout.textContent = this.valueToString(actual_value);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        if (this._updating_slider) {
          return;
        }
        const base = this.model.get("base");
        const actual_value = Math.pow(base, this._validate_slide_value(values2[0]));
        this.model.set("value", actual_value, { updated_view: this });
        this.touch();
      }
      updateSliderValue(model, value, options) {
        if (options.updated_view === this) {
          return;
        }
        const log_value = this.logCalc(this.model.get("value"));
        this.$slider.noUiSlider.set(log_value);
      }
      updateSliderOptions(e3) {
        this.$slider.noUiSlider.updateOptions({
          start: this.logCalc(this.model.get("value")),
          range: {
            min: this.model.get("min"),
            max: this.model.get("max")
          },
          step: this.model.get("step")
        });
      }
      _validate_slide_value(x2) {
        return x2;
      }
    };
    FloatRangeSliderView = class extends IntRangeSliderView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
        this._range_regex = /^\s*([+-]?(?:\d*\.?\d+|\d+\.)(?:[eE][-:]?\d+)?)\s*[-:]\s*([+-]?(?:\d*\.?\d+|\d+\.)(?:[eE][+-]?\d+)?)/;
      }
      /**
       * Validate the value of the slider before sending it to the back-end
       * and applying it to the other views on the page.
       */
      _validate_slide_value(x2) {
        return x2;
      }
    };
    FloatTextModel = class extends FloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatTextModel", _view_name: "FloatTextView", disabled: false, continuous_update: false });
      }
    };
    BoundedFloatTextModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "BoundedFloatTextModel", _view_name: "FloatTextView", disabled: false, continuous_update: false, step: 0.1 });
      }
    };
    FloatTextView = class extends IntTextView {
      constructor() {
        super(...arguments);
        this._parse_value = parseFloat;
        this._default_step = "any";
      }
      /**
       * Handle key press
       */
      handleKeypress(e3) {
        e3.stopPropagation();
      }
      /**
       * Handle key up
       */
      handleKeyUp(e3) {
      }
    };
    FloatProgressModel = class extends BoundedFloatModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FloatProgressModel", _view_name: "ProgressView", orientation: "horizontal", bar_style: "", style: null });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_controller.js
var import_jquery4, ControllerButtonModel, ControllerButtonView, ControllerAxisModel, ControllerAxisView, ControllerModel, ControllerView;
var init_widget_controller = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_controller.js"() {
    init_widget_core();
    init_lib8();
    init_index_es610();
    init_index_es6();
    init_utils3();
    import_jquery4 = __toESM(require_jquery());
    ControllerButtonModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerButtonModel", _view_name: "ControllerButtonView", value: 0, pressed: false });
      }
    };
    ControllerButtonView = class extends DOMWidgetView {
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller-button");
        this.el.style.width = "fit-content";
        this.support = document.createElement("div");
        this.support.style.position = "relative";
        this.support.style.margin = "1px";
        this.support.style.width = "16px";
        this.support.style.height = "16px";
        this.support.style.border = "1px solid black";
        this.support.style.background = "lightgray";
        this.el.appendChild(this.support);
        this.bar = document.createElement("div");
        this.bar.style.position = "absolute";
        this.bar.style.width = "100%";
        this.bar.style.bottom = "0px";
        this.bar.style.background = "gray";
        this.support.appendChild(this.bar);
        this.update();
        this.label = document.createElement("div");
        this.label.textContent = this.model.get("description");
        this.label.style.textAlign = "center";
        this.el.appendChild(this.label);
      }
      update() {
        this.bar.style.height = 100 * this.model.get("value") + "%";
      }
    };
    ControllerAxisModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerAxisModel", _view_name: "ControllerAxisView", value: 0 });
      }
    };
    ControllerAxisView = class extends DOMWidgetView {
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller-axis");
        this.el.style.width = "16px";
        this.el.style.padding = "4px";
        this.support = document.createElement("div");
        this.support.style.position = "relative";
        this.support.style.margin = "1px";
        this.support.style.width = "4px";
        this.support.style.height = "64px";
        this.support.style.border = "1px solid black";
        this.support.style.background = "lightgray";
        this.bullet = document.createElement("div");
        this.bullet.style.position = "absolute";
        this.bullet.style.margin = "-3px";
        this.bullet.style.boxSizing = "unset";
        this.bullet.style.width = "10px";
        this.bullet.style.height = "10px";
        this.bullet.style.background = "gray";
        this.label = document.createElement("div");
        this.label.textContent = this.model.get("description");
        this.label.style.textAlign = "center";
        this.support.appendChild(this.bullet);
        this.el.appendChild(this.support);
        this.el.appendChild(this.label);
        this.update();
      }
      update() {
        this.bullet.style.top = 50 * (this.model.get("value") + 1) + "%";
      }
    };
    ControllerModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ControllerModel", _view_name: "ControllerView", index: 0, name: "", mapping: "", connected: false, timestamp: 0, buttons: [], axes: [] });
      }
      initialize(attributes, options) {
        super.initialize(attributes, options);
        if (navigator.getGamepads === void 0) {
          this.readout = "This browser does not support gamepads.";
          console.error(this.readout);
        } else {
          this.readout = "Connect gamepad and press any button.";
          if (this.get("connected")) {
            this.update_loop();
          } else {
            this.wait_loop();
          }
        }
      }
      /**
       * Waits for a gamepad to be connected at the provided index.
       * Once one is connected, it will start the update loop, which
       * populates the update of axes and button values.
       */
      wait_loop() {
        const index2 = this.get("index");
        const pad = navigator.getGamepads()[index2];
        if (pad) {
          this.setup(pad).then((controls) => {
            this.set(controls);
            this.save_changes();
            window.requestAnimationFrame(this.update_loop.bind(this));
          });
        } else {
          window.requestAnimationFrame(this.wait_loop.bind(this));
        }
      }
      /**
       * Given a native gamepad object, returns a promise for a dictionary of
       * controls, of the form
       * {
       *     buttons: list of Button models,
       *     axes: list of Axis models,
       * }
       */
      setup(pad) {
        this.set({
          name: pad.id,
          mapping: pad.mapping,
          connected: pad.connected,
          timestamp: pad.timestamp
        });
        return resolvePromisesDict({
          buttons: Promise.all(pad.buttons.map((btn, index2) => {
            return this._create_button_model(index2);
          })),
          axes: Promise.all(pad.axes.map((axis, index2) => {
            return this._create_axis_model(index2);
          }))
        });
      }
      /**
       * Update axes and buttons values, until the gamepad is disconnected.
       * When the gamepad is disconnected, this.reset_gamepad is called.
       */
      update_loop() {
        const index2 = this.get("index");
        const id = this.get("name");
        const pad = navigator.getGamepads()[index2];
        if (pad && index2 === pad.index && id === pad.id) {
          this.set({
            timestamp: pad.timestamp,
            connected: pad.connected
          });
          this.save_changes();
          this.get("buttons").forEach(function(model, index3) {
            model.set({
              value: pad.buttons[index3].value,
              pressed: pad.buttons[index3].pressed
            });
            model.save_changes();
          });
          this.get("axes").forEach(function(model, index3) {
            model.set("value", pad.axes[index3]);
            model.save_changes();
          });
          window.requestAnimationFrame(this.update_loop.bind(this));
        } else {
          this.reset_gamepad();
        }
      }
      /**
       * Resets the gamepad attributes, and start the wait_loop.
       */
      reset_gamepad() {
        this.get("buttons").forEach(function(button) {
          button.close();
        });
        this.get("axes").forEach(function(axis) {
          axis.close();
        });
        this.set({
          name: "",
          mapping: "",
          connected: false,
          timestamp: 0,
          buttons: [],
          axes: []
        });
        this.save_changes();
        window.requestAnimationFrame(this.wait_loop.bind(this));
      }
      /**
       * Creates a gamepad button widget.
       */
      _create_button_model(index2) {
        return this.widget_manager.new_widget({
          model_name: "ControllerButtonModel",
          model_module: "@jupyter-widgets/controls",
          model_module_version: this.get("_model_module_version"),
          view_name: "ControllerButtonView",
          view_module: "@jupyter-widgets/controls",
          view_module_version: this.get("_view_module_version")
        }).then(function(model) {
          model.set("description", index2);
          return model;
        });
      }
      /**
       * Creates a gamepad axis widget.
       */
      _create_axis_model(index2) {
        return this.widget_manager.new_widget({
          model_name: "ControllerAxisModel",
          model_module: "@jupyter-widgets/controls",
          model_module_version: this.get("_model_module_version"),
          view_name: "ControllerAxisView",
          view_module: "@jupyter-widgets/controls",
          view_module_version: this.get("_view_module_version")
        }).then(function(model) {
          model.set("description", index2);
          return model;
        });
      }
    };
    ControllerModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), { buttons: { deserialize: unpack_models }, axes: { deserialize: unpack_models } });
    ControllerView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoPanelWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery4.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.button_views = new ViewList(this.add_button, null, this);
        this.listenTo(this.model, "change:buttons", (model, value) => {
          this.button_views.update(value);
        });
        this.axis_views = new ViewList(this.add_axis, null, this);
        this.listenTo(this.model, "change:axes", (model, value) => {
          this.axis_views.update(value);
        });
        this.listenTo(this.model, "change:name", this.update_label);
      }
      render() {
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-controller");
        this.label = document.createElement("div");
        this.el.appendChild(this.label);
        this.axis_box = new Panel();
        this.axis_box.node.style.display = "flex";
        this.luminoWidget.addWidget(this.axis_box);
        this.button_box = new Panel();
        this.button_box.node.style.display = "flex";
        this.luminoWidget.addWidget(this.button_box);
        this.button_views.update(this.model.get("buttons"));
        this.axis_views.update(this.model.get("axes"));
        this.update_label();
      }
      update_label() {
        this.label.textContent = this.model.get("name") || this.model.readout;
      }
      add_button(model) {
        const dummy = new Widget();
        this.button_box.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i6 = ArrayExt.firstIndexOf(this.button_box.widgets, dummy);
          this.button_box.insertWidget(i6, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child button view to controller", true));
      }
      add_axis(model) {
        const dummy = new Widget();
        this.axis_box.addWidget(dummy);
        return this.create_child_view(model).then((view) => {
          const i6 = ArrayExt.firstIndexOf(this.axis_box.widgets, dummy);
          this.axis_box.insertWidget(i6, view.luminoWidget);
          dummy.dispose();
          return view;
        }).catch(reject("Could not add child axis view to controller", true));
      }
      remove() {
        super.remove();
        this.button_views.remove();
        this.axis_views.remove();
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_selection.js
var import_nouislider3, SelectionModel, SelectionView, DropdownModel, DropdownView, SelectModel, SelectView, RadioButtonsModel, RadioButtonsView, ToggleButtonsStyleModel, ToggleButtonsModel, ToggleButtonsView, SelectionSliderModel, SelectionSliderView, MultipleSelectionModel, SelectMultipleModel, SelectMultipleView, SelectionRangeSliderModel, SelectionRangeSliderView;
var init_widget_selection = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_selection.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    import_nouislider3 = __toESM(require_nouislider());
    init_utils3();
    SelectionModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionModel", index: "", _options_labels: [], disabled: false });
      }
    };
    SelectionView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        super.update();
        if (this.listbox) {
          this.listbox.disabled = this.model.get("disabled");
        }
        this.updateTabindex();
        this.updateTooltip();
      }
      updateTabindex() {
        if (!this.listbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.listbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.listbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.listbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.listbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.listbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.listbox.setAttribute("title", title);
        }
      }
    };
    DropdownModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "DropdownModel", _view_name: "DropdownView", button_style: "" });
      }
    };
    DropdownView = class extends SelectionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-dropdown");
        this.listbox = document.createElement("select");
        this.listbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
      }
      /**
       * Update the contents of this view
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          const optsChanged = this.model.hasChanged("_options_labels");
          if (optsChanged) {
            this._updateOptions();
          }
        }
        const index2 = this.model.get("index");
        this.listbox.selectedIndex = index2 === null ? -1 : index2;
        return super.update();
      }
      _updateOptions() {
        this.listbox.textContent = "";
        const items = this.model.get("_options_labels");
        for (let i6 = 0; i6 < items.length; i6++) {
          const item = items[i6];
          const option = document.createElement("option");
          option.textContent = item.replace(/ /g, "\xA0");
          option.setAttribute("data-value", encodeURIComponent(item));
          option.value = item;
          this.listbox.appendChild(option);
        }
      }
      events() {
        return {
          "change select": "_handle_change"
        };
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        this.model.set("index", this.listbox.selectedIndex === -1 ? null : this.listbox.selectedIndex, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.listbox.focus();
        } else if (content.do === "blur") {
          this.listbox.blur();
        }
      }
    };
    SelectModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectModel", _view_name: "SelectView", rows: 5 });
      }
    };
    SelectView = class extends SelectionView {
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listbox = document.createElement("select");
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-select");
        this.listbox.id = this.label.htmlFor = uuid();
        this.el.appendChild(this.listbox);
        this._updateOptions();
        this.update();
        this.updateSelection();
      }
      /**
       * Update the contents of this view
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          const optsChange = this.model.hasChanged("_options_labels");
          const idxChange = this.model.hasChanged("index");
          if (optsChange || idxChange) {
            const idx = this.model.get("index");
            if (optsChange) {
              this._updateOptions();
            }
            this.updateSelection(idx);
          }
        }
        super.update();
        let rows = this.model.get("rows");
        if (rows === null) {
          rows = "";
        }
        this.listbox.setAttribute("size", rows);
      }
      updateSelection(index2) {
        index2 = index2 || this.model.get("index");
        this.listbox.selectedIndex = index2 === null ? -1 : index2;
      }
      _updateOptions() {
        this.listbox.textContent = "";
        const items = this.model.get("_options_labels");
        for (let i6 = 0; i6 < items.length; i6++) {
          const item = items[i6];
          const option = document.createElement("option");
          option.textContent = item.replace(/ /g, "\xA0");
          option.setAttribute("data-value", encodeURIComponent(item));
          option.value = item;
          this.listbox.appendChild(option);
        }
      }
      events() {
        return {
          "change select": "_handle_change"
        };
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        this.model.set("index", this.listbox.selectedIndex, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do == "focus") {
          this.listbox.focus();
        } else if (content.do == "blur") {
          this.listbox.blur();
        }
      }
    };
    RadioButtonsModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "RadioButtonsModel", _view_name: "RadioButtonsView", tooltips: [], icons: [], button_style: "", orientation: "vertical" });
      }
    };
    RadioButtonsView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-radio");
        this.container = document.createElement("div");
        this.el.appendChild(this.container);
        this.container.classList.add("widget-radio-box");
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (this.model.get("orientation") === "vertical") {
          this.container.classList.remove("widget-radio-box-horizontal");
          this.container.classList.add("widget-radio-box-vertical");
        } else {
          this.container.classList.remove("widget-radio-box-vertical");
          this.container.classList.add("widget-radio-box-horizontal");
        }
        const items = this.model.get("_options_labels");
        const radios = Array.from(this.container.querySelectorAll('input[type="radio"]')).map((x2) => x2.value);
        let stale = items.length !== radios.length;
        if (!stale) {
          for (let i6 = 0, len = items.length; i6 < len; ++i6) {
            if (radios[i6] !== items[i6]) {
              stale = true;
              break;
            }
          }
        }
        if (stale && (options === void 0 || options.updated_view !== this)) {
          this.container.textContent = "";
          items.forEach((item, index2) => {
            const label = document.createElement("label");
            label.textContent = item;
            this.container.appendChild(label);
            const radio = document.createElement("input");
            radio.setAttribute("type", "radio");
            radio.value = index2.toString();
            radio.setAttribute("data-value", encodeURIComponent(item));
            label.appendChild(radio);
          });
        }
        items.forEach((item, index2) => {
          const item_query = 'input[data-value="' + encodeURIComponent(item) + '"]';
          const radio = this.container.querySelectorAll(item_query);
          if (radio.length > 0) {
            const radio_el = radio[0];
            radio_el.checked = this.model.get("index") === index2;
            radio_el.disabled = this.model.get("disabled");
          }
        });
        setTimeout(this.adjustPadding, 0, this);
        return super.update(options);
      }
      /**
       * Adjust Padding to Multiple of Line Height
       *
       * Adjust margins so that the overall height
       * is a multiple of a single line height.
       *
       * This widget needs it because radio options
       * are spaced tighter than individual widgets
       * yet we would like the full widget line up properly
       * when displayed side-by-side with other widgets.
       */
      adjustPadding(e3) {
        const elStyles = window.getComputedStyle(e3.el);
        const margins = parseInt(elStyles.marginTop, 10) + parseInt(elStyles.marginBottom, 10);
        const lineHeight = e3.label.offsetHeight + margins;
        const cStyles = window.getComputedStyle(e3.container);
        const containerMargin = parseInt(cStyles.marginBottom, 10);
        const diff = (e3.el.offsetHeight + margins - containerMargin) % lineHeight;
        const extraMargin = diff === 0 ? 0 : lineHeight - diff;
        e3.container.style.marginBottom = extraMargin + "px";
      }
      events() {
        return {
          'click input[type="radio"]': "_handle_click"
        };
      }
      /**
       * Handle when a value is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        const target = event.target;
        this.model.set("index", parseInt(target.value, 10), { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do == "focus") {
          const firstItem = this.container.firstElementChild;
          firstItem.focus();
        } else if (content.do == "blur") {
          for (let i6 = 0; i6 < this.container.children.length; i6++) {
            const item = this.container.children[i6];
            item.blur();
          }
        }
      }
    };
    ToggleButtonsStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonsStyleModel" });
      }
    };
    ToggleButtonsStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { button_width: {
      selector: ".widget-toggle-button",
      attribute: "width",
      default: null
    }, font_weight: {
      selector: ".widget-toggle-button",
      attribute: "font-weight",
      default: ""
    } });
    ToggleButtonsModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ToggleButtonsModel", _view_name: "ToggleButtonsView" });
      }
    };
    ToggleButtonsView = class extends DescriptionView {
      initialize(options) {
        this._css_state = {};
        super.initialize(options);
        this.listenTo(this.model, "change:button_style", this.update_button_style);
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-toggle-buttons");
        this.buttongroup = document.createElement("div");
        this.el.appendChild(this.buttongroup);
        this.update();
        this.set_button_style();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        const items = this.model.get("_options_labels");
        const icons = this.model.get("icons") || [];
        const previous_icons = this.model.previous("icons") || [];
        const previous_bstyle = ToggleButtonsView.classMap[this.model.previous("button_style")] || "";
        const tooltips = this.model.get("tooltips") || [];
        const disabled = this.model.get("disabled");
        const buttons = this.buttongroup.querySelectorAll("button");
        const values2 = Array.from(buttons).map((x2) => x2.value);
        let stale = false;
        for (let i6 = 0, len = items.length; i6 < len; ++i6) {
          if (values2[i6] !== items[i6] || icons[i6] !== previous_icons[i6]) {
            stale = true;
            break;
          }
        }
        if (stale && (options === void 0 || options.updated_view !== this)) {
          this.buttongroup.textContent = "";
          items.forEach((item, index2) => {
            let item_html;
            const empty2 = item.trim().length === 0 && (!icons[index2] || icons[index2].trim().length === 0);
            if (empty2) {
              item_html = "&nbsp;";
            } else {
              item_html = escape_html(item);
            }
            const icon = document.createElement("i");
            const button = document.createElement("button");
            if (icons[index2]) {
              icon.className = "fa fa-" + icons[index2];
            }
            button.setAttribute("type", "button");
            button.className = "widget-toggle-button jupyter-button";
            if (previous_bstyle) {
              button.classList.add(previous_bstyle);
            }
            button.innerHTML = item_html;
            button.setAttribute("data-value", encodeURIComponent(item));
            button.setAttribute("value", index2.toString());
            button.appendChild(icon);
            button.disabled = disabled;
            if (tooltips[index2]) {
              button.setAttribute("title", tooltips[index2]);
            }
            this.update_style_traits(button);
            this.buttongroup.appendChild(button);
          });
        }
        items.forEach((item, index2) => {
          const item_query = '[data-value="' + encodeURIComponent(item) + '"]';
          const button = this.buttongroup.querySelector(item_query);
          if (this.model.get("index") === index2) {
            button.classList.add("mod-active");
          } else {
            button.classList.remove("mod-active");
          }
        });
        this.stylePromise.then(function(style) {
          if (style) {
            style.style();
          }
        });
        return super.update(options);
      }
      update_style_traits(button) {
        for (const name in this._css_state) {
          if (Object.prototype.hasOwnProperty.call(this._css_state, "name")) {
            if (name === "margin") {
              this.buttongroup.style[name] = this._css_state[name];
            } else if (name !== "width") {
              if (button) {
                button.style[name] = this._css_state[name];
              } else {
                const buttons = this.buttongroup.querySelectorAll("button");
                if (buttons.length) {
                  buttons[0].style[name] = this._css_state[name];
                }
              }
            }
          }
        }
      }
      update_button_style() {
        const buttons = this.buttongroup.querySelectorAll("button");
        for (let i6 = 0; i6 < buttons.length; i6++) {
          this.update_mapped_classes(ToggleButtonsView.classMap, "button_style", buttons[i6]);
        }
      }
      set_button_style() {
        const buttons = this.buttongroup.querySelectorAll("button");
        for (let i6 = 0; i6 < buttons.length; i6++) {
          this.set_mapped_classes(ToggleButtonsView.classMap, "button_style", buttons[i6]);
        }
      }
      events() {
        return {
          "click button": "_handle_click"
        };
      }
      /**
       * Handle when a value is clicked.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      _handle_click(event) {
        const target = event.target;
        this.model.set("index", parseInt(target.value, 10), { updated_view: this });
        this.touch();
        this.send({ event: "click" });
      }
    };
    (function(ToggleButtonsView2) {
      ToggleButtonsView2.classMap = {
        primary: ["mod-primary"],
        success: ["mod-success"],
        info: ["mod-info"],
        warning: ["mod-warning"],
        danger: ["mod-danger"]
      };
    })(ToggleButtonsView || (ToggleButtonsView = {}));
    SelectionSliderModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionSliderModel", _view_name: "SelectionSliderView", orientation: "horizontal", readout: true, continuous_update: true });
      }
    };
    SelectionSliderView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-hslider");
        this.el.classList.add("widget-slider");
        this.$slider = document.createElement("div");
        this.$slider.classList.add("slider");
        this.slider_container = document.createElement("div");
        this.slider_container.classList.add("slider-container");
        this.slider_container.appendChild(this.$slider);
        this.el.appendChild(this.slider_container);
        this.readout = document.createElement("div");
        this.el.appendChild(this.readout);
        this.readout.classList.add("widget-readout");
        this.readout.style.display = "none";
        this.createSlider();
        this.model.on("change:orientation", this.regenSlider, this);
        this.model.on("change:index", this.updateSliderValue, this);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if ((options === null || options === void 0 ? void 0 : options.updated_view) !== this) {
          this.updateSliderOptions(this.model);
          const orientation = this.model.get("orientation");
          const disabled = this.model.get("disabled");
          if (disabled) {
            this.readout.contentEditable = "false";
            this.$slider.setAttribute("disabled", true);
          } else {
            this.readout.contentEditable = "true";
            this.$slider.removeAttribute("disabled");
          }
          if (orientation === "vertical") {
            this.el.classList.remove("widget-hslider");
            this.el.classList.remove("widget-inline-hbox");
            this.el.classList.add("widget-vslider");
            this.el.classList.add("widget-inline-vbox");
          } else {
            this.el.classList.remove("widget-vslider");
            this.el.classList.remove("widget-inline-vbox");
            this.el.classList.add("widget-hslider");
            this.el.classList.add("widget-inline-hbox");
          }
          const readout = this.model.get("readout");
          if (readout) {
            this.readout.style.display = "";
          } else {
            this.readout.style.display = "none";
          }
          this.updateSelection();
        }
        return super.update(options);
      }
      regenSlider(e3) {
        this.$slider.noUiSlider.destroy();
        this.createSlider();
      }
      createSlider() {
        const labels = this.model.get("_options_labels");
        const min3 = 0;
        const max4 = labels.length - 1;
        const orientation = this.model.get("orientation");
        const behavior = this.model.get("behavior");
        import_nouislider3.default.create(this.$slider, {
          start: this.model.get("index"),
          connect: true,
          behaviour: behavior,
          range: {
            min: min3,
            max: max4
          },
          step: 1,
          animate: false,
          orientation,
          direction: orientation === "horizontal" ? "ltr" : "rtl",
          format: {
            from: (value) => Number(value),
            to: (value) => Math.round(value)
          }
        });
        this.$slider.noUiSlider.on("update", (values2, handle) => {
          this.handleSliderUpdateEvent(values2, handle);
        });
        this.$slider.noUiSlider.on("change", (values2, handle) => {
          this.handleSliderChangeEvent(values2, handle);
        });
      }
      events() {
        return {
          slide: "handleSliderChange",
          slidestop: "handleSliderChanged"
        };
      }
      updateSelection() {
        const index2 = this.model.get("index");
        this.updateReadout(index2);
      }
      updateReadout(index2) {
        const value = this.model.get("_options_labels")[index2];
        this.readout.textContent = value;
      }
      /**
       * Called whilst the slider is dragged, tapped or moved by the arrow keys.
       */
      handleSliderUpdateEvent(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider handle is released after dragging,
       * or by tapping or moving by the arrow keys.
       */
      handleSliderChangeEvent(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        this.handleSliderChanged(values2, handle);
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        const index2 = values2[0];
        this.updateReadout(index2);
        this.model.set("index", index2, { updated_view: this });
        this.touch();
      }
      updateSliderOptions(e3) {
        const labels = this.model.get("_options_labels");
        const min3 = 0;
        const max4 = labels.length - 1;
        this.$slider.noUiSlider.updateOptions({
          start: this.model.get("index"),
          range: {
            min: min3,
            max: max4
          },
          step: 1
        });
      }
      updateSliderValue(model, _4, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_index = this.$slider.noUiSlider.get();
        const index2 = this.model.get("index");
        if (prev_index !== index2) {
          this.$slider.noUiSlider.set(index2);
        }
      }
    };
    MultipleSelectionModel = class extends SelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "MultipleSelectionModel" });
      }
    };
    SelectMultipleModel = class extends MultipleSelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectMultipleModel", _view_name: "SelectMultipleView", rows: null });
      }
    };
    SelectMultipleView = class extends SelectView {
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.listbox.multiple = true;
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-select-multiple");
      }
      updateSelection() {
        const selected = this.model.get("index") || [];
        const listboxOptions = this.listbox.options;
        this.listbox.selectedIndex = -1;
        selected.forEach((i6) => {
          listboxOptions[i6].selected = true;
        });
      }
      /**
       * Handle when a new value is selected.
       */
      _handle_change() {
        const index2 = Array.prototype.map.call(this.listbox.selectedOptions || [], function(option) {
          return option.index;
        });
        this.model.set("index", index2, { updated_view: this });
        this.touch();
      }
    };
    SelectionRangeSliderModel = class extends MultipleSelectionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionSliderModel", _view_name: "SelectionSliderView", orientation: "horizontal", readout: true, continuous_update: true });
      }
    };
    SelectionRangeSliderView = class extends SelectionSliderView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
      }
      updateSelection(index2) {
        index2 = index2 || this.model.get("index");
        this.updateReadout(index2);
      }
      updateReadout(index2) {
        const labels = this.model.get("_options_labels");
        const minValue = labels[index2[0]];
        const maxValue = labels[index2[1]];
        this.readout.textContent = `${minValue}-${maxValue}`;
      }
      /**
       * Called when the slider value is changing.
       */
      handleSliderUpdateEvent(values2, handle) {
        const intValues = values2.map(Math.trunc);
        this.updateReadout(intValues);
        if (this.model.get("continuous_update")) {
          this.handleSliderChanged(values2, handle);
        }
      }
      /**
       * Called when the slider value has changed.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleSliderChanged(values2, handle) {
        const intValues = values2.map(Math.round);
        this.updateReadout(intValues);
        this.model.set("index", intValues.slice(), { updated_view: this });
        this.touch();
      }
      updateSliderValue(model, _4, options) {
        if (options.updated_view === this) {
          return;
        }
        const prev_index = this.$slider.noUiSlider.get().map(Math.round);
        const index2 = this.model.get("index").map(Math.round);
        if (prev_index[0] !== index2[0] || prev_index[1] !== index2[1]) {
          this.$slider.noUiSlider.set(index2);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/tabpanel.js
var EventedPanel, TabPanel;
var init_tabpanel = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/tabpanel.js"() {
    init_index_es69();
    init_index_es62();
    init_index_es65();
    init_index_es610();
    EventedPanel = class extends Panel {
      constructor() {
        super(...arguments);
        this._widgetRemoved = new Signal(this);
      }
      /**
       * A signal emitted when a widget is removed from the panel.
       */
      get widgetRemoved() {
        return this._widgetRemoved;
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        this._widgetRemoved.emit(msg.child);
      }
    };
    TabPanel = class extends Widget {
      /**
       * Construct a new tab panel.
       *
       * @param options - The options for initializing the tab panel.
       */
      constructor(options = {}) {
        super();
        this._currentChanged = new Signal(this);
        this.addClass("jupyter-widget-TabPanel");
        this.tabBar = new TabBar(options);
        this.tabBar.addClass("jupyter-widget-TabPanel-tabBar");
        this.tabContents = new EventedPanel();
        this.tabContents.addClass("jupyter-widget-TabPanel-tabContents");
        this.tabBar.tabMoved.connect(this._onTabMoved, this);
        this.tabBar.currentChanged.connect(this._onCurrentChanged, this);
        this.tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        this.tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        this.tabContents.widgetRemoved.connect(this._onWidgetRemoved, this);
        const layout = new PanelLayout();
        layout.addWidget(this.tabBar);
        layout.addWidget(this.tabContents);
        this.layout = layout;
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentIndex() {
        const currentIndex = this.tabBar.currentIndex;
        return currentIndex === -1 ? null : currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the index is out of range, it will be set to `null`.
       */
      set currentIndex(value) {
        this.tabBar.currentIndex = value === null ? -1 : value;
      }
      /**
       * Get the currently selected widget.
       *
       * #### Notes
       * This will be `null` if there is no selected tab.
       */
      get currentWidget() {
        const title = this.tabBar.currentTitle;
        return title ? title.owner : null;
      }
      /**
       * Set the currently selected widget.
       *
       * #### Notes
       * If the widget is not in the panel, it will be set to `null`.
       */
      set currentWidget(value) {
        this.tabBar.currentTitle = value ? value.title : null;
      }
      /**
       * Get the whether the tabs are movable by the user.
       *
       * #### Notes
       * Tabs can always be moved programmatically.
       */
      get tabsMovable() {
        return this.tabBar.tabsMovable;
      }
      /**
       * Set the whether the tabs are movable by the user.
       *
       * #### Notes
       * Tabs can always be moved programmatically.
       */
      set tabsMovable(value) {
        this.tabBar.tabsMovable = value;
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.tabContents.widgets;
      }
      /**
       * Add a widget to the end of the tab panel.
       *
       * @param widget - The widget to add to the tab panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       *
       * The widget's `title` is used to populate the tab.
       */
      addWidget(widget) {
        this.insertWidget(this.widgets.length, widget);
      }
      /**
       * Insert a widget into the tab panel at a specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the tab panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       *
       * The widget's `title` is used to populate the tab.
       */
      insertWidget(index2, widget) {
        if (widget !== this.currentWidget) {
          widget.hide();
        }
        this.tabContents.insertWidget(index2, widget);
        this.tabBar.insertTab(index2, widget.title);
      }
      /**
       * Handle the `currentChanged` signal from the tab bar.
       */
      _onCurrentChanged(sender, args) {
        const { previousIndex, previousTitle, currentIndex, currentTitle } = args;
        const previousWidget = previousTitle ? previousTitle.owner : null;
        const currentWidget = currentTitle ? currentTitle.owner : null;
        if (previousWidget) {
          previousWidget.hide();
        }
        if (currentWidget) {
          currentWidget.show();
        }
        this._currentChanged.emit({
          previousIndex,
          previousWidget,
          currentIndex,
          currentWidget
        });
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop.flush();
        }
      }
      /**
       * Handle the `tabActivateRequested` signal from the tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from the tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabMoved` signal from the tab bar.
       */
      _onTabMoved(sender, args) {
        this.tabContents.insertWidget(args.toIndex, args.title.owner);
      }
      /**
       * Handle the `widgetRemoved` signal from the stacked panel.
       */
      _onWidgetRemoved(sender, widget) {
        this.tabBar.removeTab(widget.title);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/currentselection.js
var Selection;
var init_currentselection = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/currentselection.js"() {
    init_index_es6();
    init_index_es62();
    Selection = class {
      constructor(sequence, options = {}) {
        this._array = null;
        this._value = null;
        this._previousValue = null;
        this._selectionChanged = new Signal(this);
        this._array = sequence;
        this._insertBehavior = options.insertBehavior || "select-item-if-needed";
        this._removeBehavior = options.removeBehavior || "select-item-after";
      }
      /**
       * A signal emitted when the current item is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected item is changed either
       * through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current item
       * changes due to other items being inserted, removed, or moved, but the
       * current item remains the same. It is only emitted when the actual current
       * item is changed.
       */
      get selectionChanged() {
        return this._selectionChanged;
      }
      /**
       * Adjust for setting an item.
       *
       * This should be called *after* the set.
       *
       * @param index - The index set.
       * @param oldValue - The old value at the index.
       */
      adjustSelectionForSet(index2) {
        const pi = this.index;
        const pv = this.value;
        if (index2 !== pi) {
          return;
        }
        this._updateSelectedValue();
        const cv = this.value;
        this._previousValue = null;
        if (pv !== cv) {
          this._selectionChanged.emit({
            previousIndex: pi,
            previousValue: pv,
            currentIndex: pi,
            currentValue: cv
          });
        }
      }
      /**
       * Get the currently selected item.
       *
       * #### Notes
       * This will be `null` if no item is selected.
       */
      get value() {
        return this._value;
      }
      /**
       * Set the currently selected item.
       *
       * #### Notes
       * If the item does not exist in the vector, the currentValue will be set to
       * `null`. This selects the first entry equal to the desired item.
       */
      set value(value) {
        if (value === null || this._array === null) {
          this.index = null;
        } else {
          this.index = ArrayExt.firstIndexOf(this._array, value);
        }
      }
      /**
       * Get the index of the currently selected item.
       *
       * #### Notes
       * This will be `null` if no item is selected.
       */
      get index() {
        return this._index;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * @param index - The index to select.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `null`, which
       * indicates no item is selected.
       */
      set index(index2) {
        let i6;
        if (index2 !== null && this._array !== null) {
          i6 = Math.floor(index2);
          if (i6 < 0 || i6 >= this._array.length) {
            i6 = null;
          }
        } else {
          i6 = null;
        }
        if (this._index === i6) {
          return;
        }
        const pi = this._index;
        const pv = this._value;
        this._index = i6;
        this._updateSelectedValue();
        this._previousValue = pv;
        this._selectionChanged.emit({
          previousIndex: pi,
          previousValue: pv,
          currentIndex: i6,
          currentValue: this._value
        });
      }
      /**
       * Get the selection behavior when inserting a tab.
       */
      get insertBehavior() {
        return this._insertBehavior;
      }
      /**
       * Set the selection behavior when inserting a tab.
       */
      set insertBehavior(value) {
        this._insertBehavior = value;
      }
      /**
       * Get the selection behavior when removing a tab.
       */
      get removeBehavior() {
        return this._removeBehavior;
      }
      /**
       * Set the selection behavior when removing a tab.
       */
      set removeBehavior(value) {
        this._removeBehavior = value;
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * @param i - The new index of the inserted item.
       * @param j - The inserted item.
       *
       * #### Notes
       * This method accounts for the tab bar's insertion behavior when adjusting
       * the current index and emitting the changed signal. This should be called
       * after the insertion.
       */
      adjustSelectionForInsert(i6, item) {
        const cv = this._value;
        const ci = this._index;
        const bh = this._insertBehavior;
        if (bh === "select-item" || bh === "select-item-if-needed" && ci === null) {
          this._index = i6;
          this._value = item;
          this._previousValue = cv;
          this._selectionChanged.emit({
            previousIndex: ci,
            previousValue: cv,
            currentIndex: i6,
            currentValue: item
          });
          return;
        }
        if (ci !== null && ci >= i6) {
          this._index++;
        }
      }
      /**
       * Clear the selection and history.
       */
      clearSelection() {
        const pi = this._index;
        const pv = this._value;
        this._index = null;
        this._value = null;
        this._previousValue = null;
        if (pi === null) {
          return;
        }
        this._selectionChanged.emit({
          previousIndex: pi,
          previousValue: pv,
          currentIndex: this._index,
          currentValue: this._value
        });
      }
      /**
       * Adjust the current index for an item remove operation.
       *
       * @param i - The former index of the removed item.
       * @param item - The removed item.
       *
       * #### Notes
       * This method accounts for the remove behavior when adjusting the current
       * index and emitting the changed signal. It should be called after the item
       * is removed.
       */
      adjustSelectionForRemove(i6, item) {
        if (this._index === null) {
          return;
        }
        const ci = this._index;
        const bh = this._removeBehavior;
        if (ci !== i6) {
          if (ci > i6) {
            this._index--;
          }
          return;
        }
        if (!this._array || this._array.length === 0) {
          this._index = null;
          this._value = null;
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i6,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-item-after") {
          this._index = Math.min(i6, this._array.length - 1);
          this._updateSelectedValue();
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i6,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-item-before") {
          this._index = Math.max(0, i6 - 1);
          this._updateSelectedValue();
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i6,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this._value
          });
          return;
        }
        if (bh === "select-previous-item") {
          if (this._previousValue) {
            this.value = this._previousValue;
          } else {
            this._index = Math.min(i6, this._array.length - 1);
            this._updateSelectedValue();
          }
          this._previousValue = null;
          this._selectionChanged.emit({
            previousIndex: i6,
            previousValue: item,
            currentIndex: this._index,
            currentValue: this.value
          });
          return;
        }
        this._index = null;
        this._value = null;
        this._previousValue = null;
        this._selectionChanged.emit({
          previousIndex: i6,
          previousValue: item,
          currentIndex: this._index,
          currentValue: this._value
        });
      }
      /**
       * Set the current value based on the current index.
       */
      _updateSelectedValue() {
        const i6 = this._index;
        this._value = i6 !== null && this._array ? this._array[i6] : null;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/lumino/accordion.js
var COLLAPSE_CLASS, COLLAPSE_HEADER_CLASS, COLLAPSE_CONTENTS_CLASS, COLLAPSE_CLASS_OPEN, Collapse, ACCORDION_CLASS, ACCORDION_CHILD_CLASS, ACCORDION_CHILD_ACTIVE_CLASS, Accordion;
var init_accordion = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/lumino/accordion.js"() {
    init_index_es6();
    init_index_es62();
    init_index_es610();
    init_currentselection();
    COLLAPSE_CLASS = "jupyter-widget-Collapse";
    COLLAPSE_HEADER_CLASS = "jupyter-widget-Collapse-header";
    COLLAPSE_CONTENTS_CLASS = "jupyter-widget-Collapse-contents";
    COLLAPSE_CLASS_OPEN = "jupyter-widget-Collapse-open";
    Collapse = class extends Widget {
      constructor(options) {
        super(options);
        this._collapseChanged = new Signal(this);
        this.addClass(COLLAPSE_CLASS);
        this._header = new Widget();
        this._header.addClass(COLLAPSE_HEADER_CLASS);
        this._header.node.addEventListener("click", this);
        const icon = document.createElement("i");
        icon.classList.add("fa", "fa-fw", "fa-caret-right");
        this._header.node.appendChild(icon);
        this._header.node.appendChild(document.createElement("span"));
        this._content = new Panel();
        this._content.addClass(COLLAPSE_CONTENTS_CLASS);
        const layout = new PanelLayout();
        this.layout = layout;
        layout.addWidget(this._header);
        layout.addWidget(this._content);
        if (options.widget) {
          this.widget = options.widget;
        }
        this.collapsed = false;
      }
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._header = null;
        this._widget = null;
        this._content = null;
      }
      get widget() {
        return this._widget;
      }
      set widget(widget) {
        const oldWidget = this._widget;
        if (oldWidget) {
          oldWidget.disposed.disconnect(this._onChildDisposed, this);
          oldWidget.title.changed.disconnect(this._onTitleChanged, this);
          oldWidget.parent = null;
        }
        this._widget = widget;
        widget.disposed.connect(this._onChildDisposed, this);
        widget.title.changed.connect(this._onTitleChanged, this);
        this._onTitleChanged(widget.title);
        this._content.addWidget(widget);
      }
      get collapsed() {
        return this._collapsed;
      }
      set collapsed(value) {
        if (value === this._collapsed) {
          return;
        }
        if (value) {
          this._collapse();
        } else {
          this._uncollapse();
        }
      }
      toggle() {
        this.collapsed = !this.collapsed;
      }
      get collapseChanged() {
        return this._collapseChanged;
      }
      _collapse() {
        this._collapsed = true;
        if (this._content) {
          this._content.hide();
        }
        this.removeClass(COLLAPSE_CLASS_OPEN);
        this._header.node.children[0].classList.add("fa-caret-right");
        this._header.node.children[0].classList.remove("fa-caret-down");
        this._collapseChanged.emit(void 0);
      }
      _uncollapse() {
        this._collapsed = false;
        if (this._content) {
          this._content.show();
        }
        this.addClass(COLLAPSE_CLASS_OPEN);
        this._header.node.children[0].classList.add("fa-caret-down");
        this._header.node.children[0].classList.remove("fa-caret-right");
        this._collapseChanged.emit(void 0);
      }
      /**
       * Handle the DOM events for the Collapse widget.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          default:
            break;
        }
      }
      _evtClick(event) {
        this.toggle();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this._header.node.children[1].textContent = this._widget.title.label;
      }
      _onChildDisposed(sender) {
        this.dispose();
      }
    };
    ACCORDION_CLASS = "jupyter-widget-Accordion";
    ACCORDION_CHILD_CLASS = "jupyter-widget-Accordion-child";
    ACCORDION_CHILD_ACTIVE_CLASS = "jupyter-widget-Accordion-child-active";
    Accordion = class extends Panel {
      constructor(options) {
        super(options);
        this._selection = new Selection(this.widgets);
        this._selection.selectionChanged.connect(this._onSelectionChanged, this);
        this.addClass(ACCORDION_CLASS);
      }
      /**
       * A read-only sequence of the widgets in the panel.
       *
       * #### Notes
       * This is a read-only property.
       */
      /*  get widgets(): ISequence<Widget> {
          return new ArraySequence(toArray(map((this.layout as PanelLayout).widgets, (w: Collapse) => w.widget)));
        }
      */
      get collapseWidgets() {
        return this.layout.widgets;
      }
      get selection() {
        return this._selection;
      }
      indexOf(widget) {
        return ArrayExt.findFirstIndex(this.collapseWidgets, (w3) => w3.widget === widget);
      }
      /**
       * Add a widget to the end of the accordion.
       *
       * @param widget - The widget to add to the accordion.
       *
       * @returns The Collapse widget wrapping the added widget.
       *
       * #### Notes
       * The widget will be wrapped in a CollapsedWidget.
       */
      addWidget(widget) {
        const collapse = this._wrapWidget(widget);
        collapse.collapsed = true;
        super.addWidget(collapse);
        this._selection.adjustSelectionForInsert(this.widgets.length - 1, collapse);
        return collapse;
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the accordion.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        const collapse = this._wrapWidget(widget);
        collapse.collapsed = true;
        super.insertWidget(index2, collapse);
        this._selection.adjustSelectionForInsert(index2, collapse);
      }
      removeWidget(widget) {
        const index2 = this.indexOf(widget);
        if (index2 >= 0) {
          const collapse = this.collapseWidgets[index2];
          widget.parent = null;
          collapse.dispose();
          this._selection.adjustSelectionForRemove(index2, null);
        }
      }
      _wrapWidget(widget) {
        const collapse = new Collapse({ widget });
        collapse.addClass(ACCORDION_CHILD_CLASS);
        collapse.collapseChanged.connect(this._onCollapseChange, this);
        return collapse;
      }
      _onCollapseChange(sender) {
        if (!sender.collapsed) {
          this._selection.value = sender;
        } else if (this._selection.value === sender && sender.collapsed) {
          this._selection.value = null;
        }
      }
      _onSelectionChanged(sender, change) {
        const pv = change.previousValue;
        const cv = change.currentValue;
        if (pv) {
          pv.collapsed = true;
          pv.removeClass(ACCORDION_CHILD_ACTIVE_CLASS);
        }
        if (cv) {
          cv.collapsed = false;
          cv.addClass(ACCORDION_CHILD_ACTIVE_CLASS);
        }
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_selectioncontainer.js
var import_jquery5, SelectionContainerModel, AccordionModel, JupyterLuminoAccordionWidget, AccordionView, TabModel, JupyterLuminoTabPanelWidget, TabView, StackModel, StackView;
var init_widget_selectioncontainer = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_selectioncontainer.js"() {
    init_lib8();
    init_widget_box();
    init_tabpanel();
    init_accordion();
    init_index_es610();
    init_index_es6();
    init_index_es69();
    import_jquery5 = __toESM(require_jquery());
    SelectionContainerModel = class extends BoxModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "SelectionContainerModel", selected_index: null, titles: [] });
      }
    };
    AccordionModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "AccordionModel", _view_name: "AccordionView" });
      }
    };
    JupyterLuminoAccordionWidget = class extends Accordion {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
      }
      /**
       * Process the Lumino message.
       *
       * Any custom Lumino widget used inside a Jupyter widget should override
       * the processMessage function like this.
       */
      processMessage(msg) {
        var _a;
        super.processMessage(msg);
        (_a = this._view) === null || _a === void 0 ? void 0 : _a.processLuminoMessage(msg);
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
    };
    AccordionView = class extends DOMWidgetView {
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoAccordionWidget({ view: this });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery5.default)(this.luminoWidget.node);
      }
      initialize(parameters) {
        super.initialize(parameters);
        this.children_views = new ViewList(this.add_child_view, this.remove_child_view, this);
        this.listenTo(this.model, "change:children", () => this.updateChildren());
        this.listenTo(this.model, "change:selected_index", () => this.update_selected_index());
        this.listenTo(this.model, "change:titles", () => this.update_titles());
      }
      /**
       * Called when view is rendered.
       */
      render() {
        var _a;
        super.render();
        const accordion = this.luminoWidget;
        accordion.addClass("jupyter-widgets");
        accordion.addClass("widget-accordion");
        accordion.addClass("widget-container");
        accordion.selection.selectionChanged.connect((sender) => {
          if (!this.updatingChildren) {
            this.model.set("selected_index", accordion.selection.index);
            this.touch();
          }
        });
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.update_titles();
        this.update_selected_index();
      }
      /**
       * Update children
       */
      updateChildren() {
        var _a;
        this.updatingChildren = true;
        this.luminoWidget.selection.index = null;
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.update_selected_index();
        this.updatingChildren = false;
      }
      /**
       * Set header titles
       */
      update_titles() {
        const collapsed = this.luminoWidget.collapseWidgets;
        const titles = this.model.get("titles");
        for (let i6 = 0; i6 < collapsed.length; i6++) {
          if (titles[i6] !== void 0) {
            collapsed[i6].widget.title.label = titles[i6];
          }
        }
      }
      /**
       * Make the rendering and selected index consistent.
       */
      update_selected_index() {
        this.luminoWidget.selection.index = this.model.get("selected_index");
      }
      /**
       * Called when a child is removed from children list.
       */
      remove_child_view(view) {
        this.luminoWidget.removeWidget(view.luminoWidget);
        view.remove();
      }
      /**
       * Called when a child is added to children list.
       */
      add_child_view(model, index2) {
        const accordion = this.luminoWidget;
        const placeholder2 = new Widget();
        placeholder2.title.label = this.model.get("titles")[index2] || "";
        accordion.addWidget(placeholder2);
        return this.create_child_view(model).then((view) => {
          const widget = view.luminoWidget;
          widget.title.label = placeholder2.title.label;
          const collapse = accordion.collapseWidgets[accordion.indexOf(placeholder2)];
          collapse.widget = widget;
          placeholder2.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      remove() {
        this.children_views = null;
        super.remove();
      }
    };
    TabModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "TabModel", _view_name: "TabView" });
      }
    };
    JupyterLuminoTabPanelWidget = class extends TabPanel {
      constructor(options) {
        const view = options.view;
        delete options.view;
        super(options);
        this._view = view;
        MessageLoop.installMessageHook(this.tabContents, (handler, msg) => {
          this._view.processLuminoMessage(msg);
          return true;
        });
      }
      /**
       * Dispose the widget.
       *
       * This causes the view to be destroyed as well with 'remove'
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        super.dispose();
        this._view.remove();
        this._view = null;
      }
    };
    TabView = class extends DOMWidgetView {
      constructor() {
        super(...arguments);
        this.updatingTabs = false;
      }
      _createElement(tagName) {
        this.luminoWidget = new JupyterLuminoTabPanelWidget({
          view: this
        });
        return this.luminoWidget.node;
      }
      _setElement(el) {
        if (this.el || el !== this.luminoWidget.node) {
          throw new Error("Cannot reset the DOM element.");
        }
        this.el = this.luminoWidget.node;
        this.$el = (0, import_jquery5.default)(this.luminoWidget.node);
      }
      /**
       * Public constructor.
       */
      initialize(parameters) {
        super.initialize(parameters);
        this.childrenViews = new ViewList(this.addChildView, (view) => {
          view.remove();
        }, this);
        this.listenTo(this.model, "change:children", () => this.updateTabs());
        this.listenTo(this.model, "change:titles", () => this.updateTitles());
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        const tabs = this.luminoWidget;
        tabs.addClass("jupyter-widgets");
        tabs.addClass("widget-container");
        tabs.addClass("jupyter-widget-tab");
        tabs.addClass("widget-tab");
        tabs.tabsMovable = true;
        tabs.tabBar.insertBehavior = "none";
        tabs.tabBar.currentChanged.connect(this._onTabChanged, this);
        tabs.tabBar.tabMoved.connect(this._onTabMoved, this);
        tabs.tabBar.addClass("widget-tab-bar");
        tabs.tabContents.addClass("widget-tab-contents");
        tabs.tabBar.tabsMovable = false;
        this.updateTabs();
        this.update();
      }
      /**
       * Render tab views based on the current model's children.
       */
      updateTabs() {
        var _a;
        this.updatingTabs = true;
        this.luminoWidget.currentIndex = null;
        (_a = this.childrenViews) === null || _a === void 0 ? void 0 : _a.update(this.model.get("children"));
        this.luminoWidget.currentIndex = this.model.get("selected_index");
        this.updatingTabs = false;
      }
      /**
       * Called when a child is added to children list.
       */
      addChildView(model, index2) {
        const label = this.model.get("titles")[index2] || "";
        const tabs = this.luminoWidget;
        const placeholder2 = new Widget();
        placeholder2.title.label = label;
        tabs.addWidget(placeholder2);
        return this.create_child_view(model).then((view) => {
          const widget = view.luminoWidget;
          widget.title.label = placeholder2.title.label;
          widget.title.closable = false;
          const i6 = ArrayExt.firstIndexOf(tabs.widgets, placeholder2);
          tabs.insertWidget(i6 + 1, widget);
          placeholder2.dispose();
          return view;
        }).catch(reject("Could not add child view to box", true));
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.updateSelectedIndex();
        return super.update();
      }
      /**
       * Updates the tab page titles.
       */
      updateTitles() {
        const titles = this.model.get("titles") || [];
        each(this.luminoWidget.widgets, (widget, i6) => {
          widget.title.label = titles[i6] || "";
        });
      }
      /**
       * Updates the selected index.
       */
      updateSelectedIndex() {
        this.luminoWidget.currentIndex = this.model.get("selected_index");
      }
      remove() {
        this.childrenViews = null;
        super.remove();
      }
      _onTabChanged(sender, args) {
        if (!this.updatingTabs) {
          const i6 = args.currentIndex;
          this.model.set("selected_index", i6 === -1 ? null : i6);
          this.touch();
        }
      }
      /**
       * Handle the `tabMoved` signal from the tab bar.
       */
      _onTabMoved(sender, args) {
        const children = this.model.get("children").slice();
        ArrayExt.move(children, args.fromIndex, args.toIndex);
        this.model.set("children", children);
        this.touch();
      }
    };
    StackModel = class extends SelectionContainerModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "StackModel", _view_name: "StackView" });
      }
    };
    StackView = class extends BoxView {
      initialize(parameters) {
        super.initialize(parameters);
        this.listenTo(this.model, "change:selected_index", this.update_children);
      }
      update_children() {
        var _a;
        let child;
        if (this.model.get("selected_index") === null) {
          child = [];
        } else {
          child = [this.model.get("children")[this.model.get("selected_index")]];
        }
        (_a = this.children_views) === null || _a === void 0 ? void 0 : _a.update(child).then((views) => {
          views.forEach((view) => {
            MessageLoop.postMessage(view.luminoWidget, Widget.ResizeMessage.UnknownSize);
          });
        });
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_tagsinput.js
function trim(value) {
  return value.replace(/^\s+|\s+$/g, "");
}
function clamp2(value, min3, max4) {
  return Math.min(Math.max(value, min3), max4);
}
function removeChildren(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var Selection2, TagsInputBaseModel, TagsInputBaseView, TagsInputModel, TagsInputView, ColorsInputModel, ColorsInputView, NumbersInputModel, NumbersInputView, FloatsInputModel, FloatsInputView, IntsInputModel, IntsInputView;
var init_widget_tagsinput = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_tagsinput.js"() {
    init_src();
    init_src2();
    init_widget_core();
    init_lib8();
    Selection2 = class {
      constructor(start, dx, max4) {
        this.start = start;
        this.dx = dx;
        this.max = max4;
      }
      /**
       * Check if a given index is currently selected.
       */
      isSelected(index2) {
        let min3;
        let max4;
        if (this.dx >= 0) {
          min3 = this.start;
          max4 = this.start + this.dx;
        } else {
          min3 = this.start + this.dx;
          max4 = this.start;
        }
        return min3 <= index2 && index2 < max4;
      }
      /**
       * Update selection
       */
      updateSelection(dx) {
        this.dx += dx;
        if (this.start + this.dx > this.max) {
          this.dx = this.max - this.start;
        }
        if (this.start + this.dx < 0) {
          this.dx = -this.start;
        }
      }
    };
    TagsInputBaseModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], placeholder: "\u200B", allowed_tags: null, allow_duplicates: true });
      }
    };
    TagsInputBaseView = class extends DOMWidgetView {
      constructor() {
        super(...arguments);
        this.hoveredTag = null;
        this.hoveredTagIndex = null;
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("jupyter-widget-tagsinput");
        this.taginputWrapper = document.createElement("div");
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        } else {
          this.taginputWrapper.style.display = "inline-block";
        }
        this.datalistID = uuid();
        this.taginput = document.createElement("input");
        this.taginput.classList.add("jupyter-widget-tag");
        this.taginput.classList.add("jupyter-widget-taginput");
        this.taginput.setAttribute("list", this.datalistID);
        this.taginput.setAttribute("type", "text");
        this.autocompleteList = document.createElement("datalist");
        this.autocompleteList.id = this.datalistID;
        this.updateAutocomplete();
        this.model.on("change:allowed_tags", this.updateAutocomplete.bind(this));
        this.updatePlaceholder();
        this.model.on("change:placeholder", this.updatePlaceholder.bind(this));
        this.taginputWrapper.classList.add("widget-text");
        this.taginputWrapper.appendChild(this.taginput);
        this.taginputWrapper.appendChild(this.autocompleteList);
        this.el.onclick = this.focus.bind(this);
        this.el.ondrop = (event) => {
          const index2 = this.hoveredTagIndex == null ? this.tags.length : this.hoveredTagIndex;
          return this.ondrop(event, index2);
        };
        this.el.ondragover = this.ondragover.bind(this);
        this.taginput.onchange = this.handleValueAdded.bind(this);
        this.taginput.oninput = this.resizeInput.bind(this);
        this.taginput.onkeydown = this.handleKeyEvent.bind(this);
        this.taginput.onblur = this.loseFocus.bind(this);
        this.resizeInput();
        this.inputIndex = this.model.get("value").length;
        this.selection = null;
        this.preventLoosingFocus = false;
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed. The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.preventLoosingFocus = true;
        removeChildren(this.el);
        this.tags = [];
        const value = this.model.get("value");
        this.inputIndex = value.length;
        for (const idx in value) {
          const index2 = parseInt(idx);
          const tag = this.createTag(value[index2], index2, this.selection != null && this.selection.isSelected(index2));
          tag.draggable = true;
          tag.ondragstart = ((index3, value2) => {
            return (event) => {
              this.ondragstart(event, index3, value2, this.model.model_id);
            };
          })(index2, value[index2]);
          tag.ondrop = ((index3) => {
            return (event) => {
              this.ondrop(event, index3);
            };
          })(index2);
          tag.ondragover = this.ondragover.bind(this);
          tag.ondragenter = ((index3) => {
            return (event) => {
              this.ondragenter(event, index3);
            };
          })(index2);
          tag.ondragend = this.ondragend.bind(this);
          this.tags.push(tag);
          this.el.appendChild(tag);
        }
        this.el.insertBefore(this.taginputWrapper, this.el.children[this.inputIndex]);
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        } else {
          this.taginputWrapper.style.display = "inline-block";
        }
        this.preventLoosingFocus = false;
        return super.update();
      }
      /**
       * Update the auto-completion list
       */
      updateAutocomplete() {
        removeChildren(this.autocompleteList);
        const allowedTags = this.model.get("allowed_tags");
        for (const tag of allowedTags) {
          const option = document.createElement("option");
          option.value = tag;
          this.autocompleteList.appendChild(option);
        }
      }
      /**
       * Update the auto-completion list
       */
      updatePlaceholder() {
        this.taginput.placeholder = this.model.get("placeholder");
        this.resizeInput();
      }
      /**
       * Update the tags, called when the selection has changed and we need to update the tags CSS
       */
      updateTags() {
        const value = this.model.get("value");
        for (const idx in this.tags) {
          const index2 = parseInt(idx);
          this.updateTag(this.tags[index2], value[index2], index2, this.selection != null && this.selection.isSelected(index2));
        }
      }
      /**
       * Handle a new value is added from the input element
       */
      handleValueAdded(event) {
        const newTagValue = trim(this.taginput.value);
        const tagIndex = this.inputIndex;
        if (newTagValue == "") {
          return;
        }
        this.inputIndex++;
        const tagAdded = this.addTag(tagIndex, newTagValue);
        if (tagAdded) {
          this.taginput.value = "";
          this.resizeInput();
          this.focus();
        }
      }
      /**
       * Add a new tag with a value of `tagValue` at the `index` position
       * Return true if the tag was correctly added, false otherwise
       */
      addTag(index2, tagValue) {
        const value = this.model.get("value");
        let newTagValue;
        try {
          newTagValue = this.validateValue(tagValue);
        } catch (error) {
          return false;
        }
        const allowedTagValues = this.model.get("allowed_tags");
        if (allowedTagValues.length && !allowedTagValues.includes(newTagValue)) {
          return false;
        }
        if (!this.model.get("allow_duplicates") && value.includes(newTagValue)) {
          return false;
        }
        this.selection = null;
        const newValue = [...value];
        newValue.splice(index2, 0, newTagValue);
        this.model.set("value", newValue);
        this.model.save_changes();
        return true;
      }
      /**
       * Resize the input element
       */
      resizeInput() {
        let content;
        if (this.taginput.value.length != 0) {
          content = this.taginput.value;
        } else {
          content = this.model.get("placeholder");
        }
        const size5 = content.length + 1;
        this.taginput.setAttribute("size", String(size5));
      }
      /**
       * Handle key events on the input element
       */
      handleKeyEvent(event) {
        const valueLength = this.model.get("value").length;
        if (this.taginput.value.length) {
          return;
        }
        const currentElement = this.inputIndex;
        switch (event.key) {
          case "ArrowLeft":
            if (event.ctrlKey && event.shiftKey) {
              this.select(currentElement, -currentElement);
            }
            if (!event.ctrlKey && event.shiftKey) {
              this.select(currentElement, -1);
            }
            if (event.ctrlKey) {
              this.inputIndex = 0;
            } else {
              this.inputIndex--;
            }
            break;
          case "ArrowRight":
            if (event.ctrlKey && event.shiftKey) {
              this.select(currentElement, valueLength - currentElement);
            }
            if (!event.ctrlKey && event.shiftKey) {
              this.select(currentElement, 1);
            }
            if (event.ctrlKey) {
              this.inputIndex = valueLength;
            } else {
              this.inputIndex++;
            }
            break;
          case "Backspace":
            if (this.selection) {
              this.removeSelectedTags();
            } else {
              this.removeTag(this.inputIndex - 1);
            }
            break;
          case "Delete":
            if (this.selection) {
              this.removeSelectedTags();
            } else {
              this.removeTag(this.inputIndex);
            }
            break;
          default:
            return;
            break;
        }
        if (!event.shiftKey) {
          this.selection = null;
        }
        this.inputIndex = clamp2(this.inputIndex, 0, valueLength);
        this.update();
        this.focus();
      }
      /**
       * Function that gets called when a tag with a given `value` is being dragged.
       */
      ondragstart(event, index2, tagValue, origin) {
        if (event.dataTransfer == null) {
          return;
        }
        event.dataTransfer.setData("index", String(index2));
        event.dataTransfer.setData("tagValue", String(tagValue));
        event.dataTransfer.setData("origin", origin);
      }
      /**
       * Function that gets called when a tag has been dragged on the tag at the `index` position.
       */
      ondrop(event, index2) {
        if (event.dataTransfer == null) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        const draggedTagValue = event.dataTransfer.getData("tagValue");
        const draggedTagindex = parseInt(event.dataTransfer.getData("index"));
        const sameOrigin = event.dataTransfer.getData("origin") == this.model.model_id;
        if (isNaN(draggedTagindex)) {
          return;
        }
        if (sameOrigin) {
          const value = this.model.get("value");
          const newValue = [...value];
          if (draggedTagindex < index2) {
            index2--;
          }
          newValue.splice(draggedTagindex, 1);
          newValue.splice(index2, 0, draggedTagValue);
          this.model.set("value", newValue);
          this.model.save_changes();
          return;
        }
        this.addTag(index2, draggedTagValue);
      }
      ondragover(event) {
        event.preventDefault();
      }
      ondragenter(event, index2) {
        if (this.hoveredTag != null && this.hoveredTag != this.tags[index2]) {
          this.hoveredTag.style.marginLeft = "1px";
        }
        this.hoveredTag = this.tags[index2];
        this.hoveredTagIndex = index2;
        this.hoveredTag.style.marginLeft = "30px";
      }
      ondragend() {
        if (this.hoveredTag != null) {
          this.hoveredTag.style.marginLeft = "1px";
        }
        this.hoveredTag = null;
        this.hoveredTagIndex = null;
      }
      /**
       * Select tags from `start` to `start + dx` not included.
       */
      select(start, dx) {
        const valueLength = this.model.get("value").length;
        if (!this.selection) {
          this.selection = new Selection2(start, dx, valueLength);
        } else {
          this.selection.updateSelection(dx);
        }
      }
      /**
       * Remove all the selected tags.
       */
      removeSelectedTags() {
        const value = [...this.model.get("value")];
        const valueLength = value.length;
        for (let idx = valueLength - 1; idx >= 0; idx--) {
          if (this.selection != null && this.selection.isSelected(idx)) {
            value.splice(idx, 1);
            if (idx < this.inputIndex) {
              this.inputIndex--;
            }
          }
        }
        this.model.set("value", value);
        this.model.save_changes();
      }
      /**
       * Remove a tag given its index in the list
       */
      removeTag(tagIndex) {
        const value = [...this.model.get("value")];
        value.splice(tagIndex, 1);
        if (tagIndex < this.inputIndex) {
          this.inputIndex--;
        }
        this.model.set("value", value);
        this.model.save_changes();
      }
      /**
       * Focus on the input element
       */
      focus() {
        this.taginputWrapper.style.display = "inline-block";
        this.taginput.focus();
      }
      /**
       * Lose focus on the input element
       */
      loseFocus() {
        if (this.preventLoosingFocus) {
          return;
        }
        if (this.model.get("value").length) {
          this.taginputWrapper.style.display = "none";
        }
        this.selection = null;
        this.updateTags();
      }
      preinitialize() {
        this.tagName = "div";
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        return value;
      }
    };
    TagsInputModel = class extends TagsInputBaseModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], tag_style: "", _view_name: "TagsInputView", _model_name: "TagsInputModel" });
      }
    };
    TagsInputView = class extends TagsInputBaseView {
      /**
       * Create the string tag
       */
      createTag(value, index2, selected) {
        const tag = document.createElement("div");
        const style = this.model.get("tag_style");
        tag.classList.add("jupyter-widget-tag");
        tag.classList.add(TagsInputView.class_map[style]);
        if (selected) {
          tag.classList.add("mod-active");
        }
        tag.appendChild(document.createTextNode(this.getTagText(value)));
        const i6 = document.createElement("i");
        i6.classList.add("fa");
        i6.classList.add("fa-times");
        i6.classList.add("jupyter-widget-tag-close");
        tag.appendChild(i6);
        i6.onmousedown = ((index3) => {
          return () => {
            this.removeTag(index3);
            this.loseFocus();
          };
        })(index2);
        return tag;
      }
      /**
       * Returns the text that should be displayed in the tag element
       */
      getTagText(value) {
        return value;
      }
      /**
       * Update a given tag
       */
      updateTag(tag, value, index2, selected) {
        if (selected) {
          tag.classList.add("mod-active");
        } else {
          tag.classList.remove("mod-active");
        }
      }
    };
    TagsInputView.class_map = {
      primary: "mod-primary",
      success: "mod-success",
      info: "mod-info",
      warning: "mod-warning",
      danger: "mod-danger"
    };
    ColorsInputModel = class extends TagsInputBaseModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: [], _view_name: "ColorsInputView", _model_name: "ColorsInputModel" });
      }
    };
    ColorsInputView = class extends TagsInputBaseView {
      /**
       * Create the Color tag
       */
      createTag(value, index2, selected) {
        const tag = document.createElement("div");
        const color2 = value;
        const darkerColor = color(value).darker().toString();
        tag.classList.add("jupyter-widget-tag");
        tag.classList.add("jupyter-widget-colortag");
        if (!selected) {
          tag.style.backgroundColor = color2;
        } else {
          tag.classList.add("mod-active");
          tag.style.backgroundColor = darkerColor;
        }
        const i6 = document.createElement("i");
        i6.classList.add("fa");
        i6.classList.add("fa-times");
        i6.classList.add("jupyter-widget-tag-close");
        tag.appendChild(i6);
        i6.onmousedown = ((index3) => {
          return () => {
            this.removeTag(index3);
            this.loseFocus();
          };
        })(index2);
        return tag;
      }
      /**
       * Update a given tag
       */
      updateTag(tag, value, index2, selected) {
        const color2 = value;
        const darkerColor = color(value).darker().toString();
        if (!selected) {
          tag.classList.remove("mod-active");
          tag.style.backgroundColor = color2;
        } else {
          tag.classList.add("mod-active");
          tag.style.backgroundColor = darkerColor;
        }
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        if (color(value) == null) {
          throw value + " is not a valid Color";
        }
        return value;
      }
    };
    NumbersInputModel = class extends TagsInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { min: null, max: null });
      }
    };
    NumbersInputView = class extends TagsInputView {
      render() {
        this.model.on("change:format", () => {
          this.formatter = format(this.model.get("format"));
          this.update();
        });
        this.formatter = format(this.model.get("format"));
        super.render();
      }
      /**
       * Returns the text that should be displayed in the tag element
       */
      getTagText(value) {
        return this.formatter(this.parseNumber(value));
      }
      /**
       * Validate an input tag typed by the user, returning the correct tag type. This should be overridden in subclasses.
       */
      validateValue(value) {
        const parsed = this.parseNumber(value);
        const min3 = this.model.get("min");
        const max4 = this.model.get("max");
        if (isNaN(parsed) || min3 != null && parsed < min3 || max4 != null && parsed > max4) {
          throw value + " is not a valid number, it should be in the range [" + min3 + ", " + max4 + "]";
        }
        return parsed;
      }
    };
    FloatsInputModel = class extends NumbersInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "FloatsInputView", _model_name: "FloatsInputModel", format: ".1f" });
      }
    };
    FloatsInputView = class extends NumbersInputView {
      parseNumber(value) {
        return parseFloat(value);
      }
    };
    IntsInputModel = class extends NumbersInputModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "IntsInputView", _model_name: "IntsInputModel", format: "d" });
      }
    };
    IntsInputView = class extends NumbersInputView {
      parseNumber(value) {
        const int = parseInt(value);
        if (int != parseFloat(value)) {
          throw value + " should be an integer";
        }
        return int;
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_string.js
var INVALID_VALUE_CLASS, StringStyleModel, HTMLStyleModel, HTMLMathStyleModel, LabelStyleModel, TextStyleModel, StringModel, StringView, HTMLModel, HTMLView, HTMLMathModel, HTMLMathView, LabelModel, LabelView, TextareaModel, TextareaView, TextModel, TextView, PasswordModel, PasswordView, ComboboxModel, ComboboxView;
var init_widget_string = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_string.js"() {
    init_widget_core();
    init_widget_description();
    init_utils3();
    init_version2();
    INVALID_VALUE_CLASS = "jpwidgets-invalidComboValue";
    StringStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "StringStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    StringStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: "",
      attribute: "background",
      default: null
    }, font_size: {
      selector: "",
      attribute: "font-size",
      default: ""
    }, text_color: {
      selector: "",
      attribute: "color",
      default: ""
    } });
    HTMLStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "HTMLStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    HTMLStyleModel.styleProperties = Object.assign({}, StringStyleModel.styleProperties);
    HTMLMathStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "HTMLMathStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    HTMLMathStyleModel.styleProperties = Object.assign({}, StringStyleModel.styleProperties);
    LabelStyleModel = class extends StringStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "LabelStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    LabelStyleModel.styleProperties = Object.assign(Object.assign({}, StringStyleModel.styleProperties), { font_family: {
      selector: "",
      attribute: "font-family",
      default: ""
    }, font_style: {
      selector: "",
      attribute: "font-style",
      default: ""
    }, font_variant: {
      selector: "",
      attribute: "font-variant",
      default: ""
    }, font_weight: {
      selector: "",
      attribute: "font-weight",
      default: ""
    }, text_decoration: {
      selector: "",
      attribute: "text-decoration",
      default: ""
    } });
    TextStyleModel = class extends DescriptionStyleModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "TextStyleModel", _model_module: "@jupyter-widgets/controls", _model_module_version: JUPYTER_CONTROLS_VERSION });
      }
    };
    TextStyleModel.styleProperties = Object.assign(Object.assign({}, DescriptionStyleModel.styleProperties), { background: {
      selector: ".widget-input",
      attribute: "background",
      default: null
    }, font_size: {
      selector: ".widget-input",
      attribute: "font-size",
      default: ""
    }, text_color: {
      selector: ".widget-input",
      attribute: "color",
      default: ""
    } });
    StringModel = class extends CoreDescriptionModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { value: "", disabled: false, placeholder: "\u200B", _model_name: "StringModel" });
      }
    };
    StringView = class extends DescriptionView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-inline-hbox");
      }
    };
    HTMLModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HTMLView", _model_name: "HTMLModel" });
      }
    };
    HTMLView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-html");
        this.content = document.createElement("div");
        this.content.classList.add("widget-html-content");
        this.el.appendChild(this.content);
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.content.innerHTML = this.model.get("value");
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.content.focus();
        } else if (content.do === "blur") {
          this.content.blur();
        }
      }
    };
    HTMLMathModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "HTMLMathView", _model_name: "HTMLMathModel" });
      }
    };
    HTMLMathView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-htmlmath");
        this.content = document.createElement("div");
        this.content.classList.add("widget-htmlmath-content");
        this.el.appendChild(this.content);
        this.update();
      }
      /**
       * Update the contents of this view
       */
      update() {
        this.content.innerHTML = this.model.get("value");
        this.typeset(this.content);
        return super.update();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.content.focus();
        } else if (content.do === "blur") {
          this.content.blur();
        }
      }
    };
    LabelModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "LabelView", _model_name: "LabelModel" });
      }
    };
    LabelView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-label");
        this.update();
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update() {
        this.typeset(this.el, this.model.get("value"));
        return super.update();
      }
    };
    TextareaModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "TextareaView", _model_name: "TextareaModel", rows: null, continuous_update: true });
      }
    };
    TextareaView = class extends StringView {
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-textarea");
        this.textbox = document.createElement("textarea");
        this.textbox.setAttribute("rows", "5");
        this.textbox.id = this.label.htmlFor = uuid();
        this.textbox.classList.add("widget-input");
        this.el.appendChild(this.textbox);
        this.update();
        this.listenTo(this.model, "change:placeholder", (model, value, options) => {
          this.update_placeholder(value);
        });
        this.update_placeholder();
        this.updateTooltip();
      }
      update_placeholder(value) {
        const v4 = value || this.model.get("placeholder");
        this.textbox.setAttribute("placeholder", v4.toString());
      }
      /**
       * Update the contents of this view
       *
       * Called when the model is changed.  The model may have been
       * changed by another view or by a state update from the back-end.
       */
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          this.textbox.value = this.model.get("value");
          let rows = this.model.get("rows");
          if (rows === null) {
            rows = "";
          }
          this.textbox.setAttribute("rows", rows);
          this.textbox.disabled = this.model.get("disabled");
        }
        this.updateTabindex();
        this.updateTooltip();
        return super.update();
      }
      updateTabindex() {
        if (!this.textbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.textbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.textbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.textbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.textbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.textbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.textbox.setAttribute("title", title);
        }
      }
      events() {
        return {
          "keydown textarea": "handleKeyDown",
          "keypress textarea": "handleKeypress",
          "input textarea": "handleChanging",
          "change textarea": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the event isn't sent to the application.
       */
      handleKeyDown(e3) {
        e3.stopPropagation();
      }
      /**
       * Handles key press
       *
       * Stop propagation so the keypress isn't sent to the application.
       */
      handleKeypress(e3) {
        e3.stopPropagation();
      }
      /**
       * Triggered on input change
       */
      handleChanging(e3) {
        if (this.model.get("continuous_update")) {
          this.handleChanged(e3);
        }
      }
      /**
       * Sync the value with the kernel.
       *
       * @param e Event
       */
      handleChanged(e3) {
        const target = e3.target;
        this.model.set("value", target.value, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
    };
    TextModel = class extends StringModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "TextView", _model_name: "TextModel", continuous_update: true });
      }
    };
    TextView = class extends StringView {
      constructor() {
        super(...arguments);
        this.inputType = "text";
      }
      /**
       * Called when view is rendered.
       */
      render() {
        super.render();
        this.el.classList.add("widget-text");
        this.textbox = document.createElement("input");
        this.textbox.setAttribute("type", this.inputType);
        this.textbox.id = this.label.htmlFor = uuid();
        this.textbox.classList.add("widget-input");
        this.el.appendChild(this.textbox);
        this.update();
        this.listenTo(this.model, "change:placeholder", (model, value, options) => {
          this.update_placeholder(value);
        });
        this.update_placeholder();
        this.updateTabindex();
        this.updateTooltip();
      }
      update_placeholder(value) {
        this.textbox.setAttribute("placeholder", value || this.model.get("placeholder"));
      }
      updateTabindex() {
        if (!this.textbox) {
          return;
        }
        const tabbable = this.model.get("tabbable");
        if (tabbable === true) {
          this.textbox.setAttribute("tabIndex", "0");
        } else if (tabbable === false) {
          this.textbox.setAttribute("tabIndex", "-1");
        } else if (tabbable === null) {
          this.textbox.removeAttribute("tabIndex");
        }
      }
      updateTooltip() {
        if (!this.textbox)
          return;
        const title = this.model.get("tooltip");
        if (!title) {
          this.textbox.removeAttribute("title");
        } else if (this.model.get("description").length === 0) {
          this.textbox.setAttribute("title", title);
        }
      }
      update(options) {
        if (options === void 0 || options.updated_view !== this) {
          if (this.textbox.value !== this.model.get("value")) {
            this.textbox.value = this.model.get("value");
          }
          this.textbox.disabled = this.model.get("disabled");
        }
        return super.update();
      }
      events() {
        return {
          "keydown input": "handleKeyDown",
          "keypress input": "handleKeypress",
          "input input": "handleChanging",
          "change input": "handleChanged"
        };
      }
      /**
       * Handle key down
       *
       * Stop propagation so the keypress isn't sent to the application.
       */
      handleKeyDown(e3) {
        e3.stopPropagation();
      }
      /**
       * Handles text submission
       */
      handleKeypress(e3) {
        e3.stopPropagation();
        if (e3.keyCode === 13) {
          this.send({ event: "submit" });
        }
      }
      /**
       * Handles user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleChanging(e3) {
        if (this.model.get("continuous_update")) {
          this.handleChanged(e3);
        }
      }
      /**
       * Handles user input.
       *
       * Calling model.set will trigger all of the other views of the
       * model to update.
       */
      handleChanged(e3) {
        const target = e3.target;
        this.model.set("value", target.value, { updated_view: this });
        this.touch();
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
    };
    PasswordModel = class extends TextModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _view_name: "PasswordView", _model_name: "PasswordModel" });
      }
    };
    PasswordView = class extends TextView {
      constructor() {
        super(...arguments);
        this.inputType = "password";
      }
    };
    ComboboxModel = class extends TextModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "ComboboxModel", _view_name: "ComboboxView", options: [], ensure_options: false });
      }
    };
    ComboboxView = class extends TextView {
      constructor() {
        super(...arguments);
        this.isInitialRender = true;
      }
      render() {
        this.datalist = document.createElement("datalist");
        this.datalist.id = uuid();
        super.render();
        this.textbox.setAttribute("list", this.datalist.id);
        this.el.appendChild(this.datalist);
        this.updateTooltip();
      }
      update(options) {
        super.update(options);
        if (!this.datalist) {
          return;
        }
        const valid2 = this.isValid(this.model.get("value"));
        this.highlightValidState(valid2);
        if (options !== void 0 && options.updated_view || !this.model.hasChanged("options") && !this.isInitialRender) {
          return;
        }
        this.isInitialRender = false;
        const opts = this.model.get("options");
        const optionFragment = document.createDocumentFragment();
        for (const v4 of opts) {
          const o11 = document.createElement("option");
          o11.value = v4;
          optionFragment.appendChild(o11);
        }
        this.datalist.replaceChildren(...optionFragment.children);
      }
      isValid(value) {
        if (true === this.model.get("ensure_option")) {
          const options = this.model.get("options");
          if (options.indexOf(value) === -1) {
            return false;
          }
        }
        return true;
      }
      handleChanging(e3) {
        const target = e3.target;
        const valid2 = this.isValid(target.value);
        this.highlightValidState(valid2);
        if (valid2) {
          super.handleChanging(e3);
        }
      }
      handleChanged(e3) {
        const target = e3.target;
        const valid2 = this.isValid(target.value);
        this.highlightValidState(valid2);
        if (valid2) {
          super.handleChanged(e3);
        }
      }
      /**
       * Handle message sent to the front end.
       */
      handle_message(content) {
        if (content.do === "focus") {
          this.textbox.focus();
        } else if (content.do === "blur") {
          this.textbox.blur();
        }
      }
      highlightValidState(valid2) {
        this.textbox.classList.toggle(INVALID_VALUE_CLASS, !valid2);
      }
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/widget_upload.js
var FileUploadModel, FileUploadView;
var init_widget_upload = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/widget_upload.js"() {
    init_widget_core();
    init_lib8();
    FileUploadModel = class extends CoreDOMWidgetModel {
      defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: "FileUploadModel", _view_name: "FileUploadView", accept: "", description: "Upload", disabled: false, icon: "upload", button_style: "", multiple: false, value: [], error: "", style: null });
      }
    };
    FileUploadModel.serializers = Object.assign(Object.assign({}, CoreDOMWidgetModel.serializers), {
      // use a dummy serializer for value to circumvent the default serializer.
      value: { serialize: (x2) => x2 }
    });
    FileUploadView = class extends DOMWidgetView {
      preinitialize() {
        this.tagName = "button";
      }
      render() {
        super.render();
        this.el.classList.add("jupyter-widgets");
        this.el.classList.add("widget-upload");
        this.el.classList.add("jupyter-button");
        this.fileInput = document.createElement("input");
        this.fileInput.type = "file";
        this.fileInput.style.display = "none";
        this.el.addEventListener("click", () => {
          this.fileInput.click();
        });
        this.fileInput.addEventListener("click", () => {
          this.fileInput.value = "";
        });
        this.fileInput.addEventListener("change", () => {
          var _a;
          const promisesFile = [];
          Array.from((_a = this.fileInput.files) !== null && _a !== void 0 ? _a : []).forEach((file) => {
            promisesFile.push(new Promise((resolve, reject4) => {
              const fileReader = new FileReader();
              fileReader.onload = () => {
                const content = fileReader.result;
                resolve({
                  content,
                  name: file.name,
                  type: file.type,
                  size: file.size,
                  last_modified: file.lastModified
                });
              };
              fileReader.onerror = () => {
                reject4();
              };
              fileReader.onabort = fileReader.onerror;
              fileReader.readAsArrayBuffer(file);
            }));
          });
          Promise.all(promisesFile).then((files) => {
            this.model.set({
              value: files,
              error: ""
            });
            this.touch();
          }).catch((err) => {
            console.error("error in file upload: %o", err);
            this.model.set({
              error: err
            });
            this.touch();
          });
        });
        this.listenTo(this.model, "change:button_style", this.update_button_style);
        this.set_button_style();
        this.update();
      }
      update() {
        this.el.disabled = this.model.get("disabled");
        this.el.setAttribute("title", this.model.get("tooltip"));
        const value = this.model.get("value");
        const description = `${this.model.get("description")} (${value.length})`;
        const icon = this.model.get("icon");
        if (description.length || icon.length) {
          this.el.textContent = "";
          if (icon.length) {
            const i6 = document.createElement("i");
            i6.classList.add("fa");
            i6.classList.add("fa-" + icon);
            if (description.length === 0) {
              i6.classList.add("center");
            }
            this.el.appendChild(i6);
          }
          this.el.appendChild(document.createTextNode(description));
        }
        this.fileInput.accept = this.model.get("accept");
        this.fileInput.multiple = this.model.get("multiple");
        return super.update();
      }
      update_button_style() {
        this.update_mapped_classes(FileUploadView.class_map, "button_style", this.el);
      }
      set_button_style() {
        this.set_mapped_classes(FileUploadView.class_map, "button_style", this.el);
      }
    };
    FileUploadView.class_map = {
      primary: ["mod-primary"],
      success: ["mod-success"],
      info: ["mod-info"],
      warning: ["mod-warning"],
      danger: ["mod-danger"]
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/package.json
var require_package = __commonJS({
  "../../node_modules/@jupyter-widgets/controls/package.json"(exports, module) {
    module.exports = {
      name: "@jupyter-widgets/controls",
      version: "5.0.12",
      description: "Jupyter interactive widgets",
      repository: {
        type: "git",
        url: "https://github.com/jupyter-widgets/ipywidgets.git"
      },
      license: "BSD-3-Clause",
      author: "Project Jupyter",
      main: "lib/index.js",
      typings: "lib/index.d.ts",
      files: [
        "lib/**/*.map",
        "lib/**/*.d.ts",
        "lib/**/*.js",
        "css/*.css",
        "dist/",
        "src"
      ],
      scripts: {
        build: "npm run build:src && npm run build:css",
        "build:css": "lessc css/nouislider.less css/nouislider.css && postcss --use postcss-import --use postcss-cssnext -o css/widgets.built.css css/widgets.css",
        "build:src": "tsc --build",
        "build:test": "tsc --build test && webpack --config test/webpack.conf.js",
        clean: "npm run clean:src",
        "clean:src": "rimraf lib && rimraf tsconfig.tsbuildinfo",
        prepublish: "npm run clean && npm run build",
        test: "npm run test:unit",
        "test:coverage": "npm run build:test && webpack --config test/webpack-cov.conf.js && karma start test/karma-cov.conf.js",
        "test:unit": "npm run test:unit:firefox && npm run test:unit:chrome",
        "test:unit:chrome": "npm run test:unit:default -- --browsers=Chrome",
        "test:unit:default": "npm run build:test && karma start test/karma.conf.js --log-level debug",
        "test:unit:firefox": "npm run test:unit:default -- --browsers=Firefox",
        "test:unit:firefox:headless": "npm run test:unit:default -- --browsers=FirefoxHeadless",
        "test:unit:ie": "npm run test:unit:default -- --browsers=IE"
      },
      dependencies: {
        "@jupyter-widgets/base": "^6.0.11",
        "@lumino/algorithm": "^1 || ^2",
        "@lumino/domutils": "^1 || ^2",
        "@lumino/messaging": "^1 || ^2",
        "@lumino/signaling": "^1 || ^2",
        "@lumino/widgets": "^1 || ^2",
        "d3-color": "^3.0.1",
        "d3-format": "^3.0.1",
        jquery: "^3.1.1",
        nouislider: "15.4.0"
      },
      devDependencies: {
        "@jupyterlab/services": "^6.0.0 || ^7.0.0",
        "@types/d3-color": "^3.0.2",
        "@types/d3-format": "^3.0.1",
        "@types/expect.js": "^0.3.29",
        "@types/jquery": "^3.5.16",
        "@types/mathjax": "^0.0.37",
        "@types/mocha": "^9.0.0",
        "@types/node": "^17.0.2",
        chai: "^4.0.0",
        "css-loader": "^6.5.1",
        "expect.js": "^0.3.1",
        "istanbul-instrumenter-loader": "^3.0.1",
        karma: "^6.3.3",
        "karma-chrome-launcher": "^3.1.0",
        "karma-coverage": "^2.0.3",
        "karma-firefox-launcher": "^2.1.1",
        "karma-ie-launcher": "^1.0.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-webpack": "^5.0.0",
        less: "^4.1.2",
        mocha: "^9.0.0",
        "npm-run-all": "^4.1.5",
        postcss: "^8.3.2",
        "postcss-cli": "^9.1.0",
        "postcss-cssnext": "^3.1.0",
        "postcss-import": "^14.0.2",
        "postcss-loader": "^6.1.0",
        rimraf: "^3.0.2",
        sinon: "^12.0.1",
        "sinon-chai": "^3.3.0",
        "style-loader": "^3.3.1",
        typescript: "~4.9.4",
        webpack: "^5.65.0"
      },
      gitHead: "ace1a8fe516699b06914ff59d8a26f33a6911239"
    };
  }
});

// ../../node_modules/@jupyter-widgets/controls/lib/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AccordionModel: () => AccordionModel,
  AccordionView: () => AccordionView,
  AudioModel: () => AudioModel,
  AudioView: () => AudioView,
  BaseIntSliderView: () => BaseIntSliderView,
  BoolModel: () => BoolModel,
  BoundedFloatModel: () => BoundedFloatModel,
  BoundedFloatTextModel: () => BoundedFloatTextModel,
  BoundedIntModel: () => BoundedIntModel,
  BoundedIntTextModel: () => BoundedIntTextModel,
  BoxModel: () => BoxModel,
  BoxView: () => BoxView,
  ButtonModel: () => ButtonModel,
  ButtonStyleModel: () => ButtonStyleModel,
  ButtonView: () => ButtonView,
  CheckboxModel: () => CheckboxModel,
  CheckboxStyleModel: () => CheckboxStyleModel,
  CheckboxView: () => CheckboxView,
  ColorPickerModel: () => ColorPickerModel,
  ColorPickerView: () => ColorPickerView,
  ColorsInputModel: () => ColorsInputModel,
  ColorsInputView: () => ColorsInputView,
  ComboboxModel: () => ComboboxModel,
  ComboboxView: () => ComboboxView,
  ControllerAxisModel: () => ControllerAxisModel,
  ControllerAxisView: () => ControllerAxisView,
  ControllerButtonModel: () => ControllerButtonModel,
  ControllerButtonView: () => ControllerButtonView,
  ControllerModel: () => ControllerModel,
  ControllerView: () => ControllerView,
  DatePickerModel: () => DatePickerModel,
  DatePickerView: () => DatePickerView,
  DatetimeModel: () => DatetimeModel,
  DatetimeView: () => DatetimeView,
  DescriptionModel: () => DescriptionModel,
  DescriptionStyleModel: () => DescriptionStyleModel,
  DescriptionView: () => DescriptionView,
  DirectionalLinkModel: () => DirectionalLinkModel,
  DropdownModel: () => DropdownModel,
  DropdownView: () => DropdownView,
  FileUploadModel: () => FileUploadModel,
  FileUploadView: () => FileUploadView,
  FloatLogSliderModel: () => FloatLogSliderModel,
  FloatLogSliderView: () => FloatLogSliderView,
  FloatModel: () => FloatModel,
  FloatProgressModel: () => FloatProgressModel,
  FloatRangeSliderModel: () => FloatRangeSliderModel,
  FloatRangeSliderView: () => FloatRangeSliderView,
  FloatSliderModel: () => FloatSliderModel,
  FloatSliderView: () => FloatSliderView,
  FloatTextModel: () => FloatTextModel,
  FloatTextView: () => FloatTextView,
  FloatsInputModel: () => FloatsInputModel,
  FloatsInputView: () => FloatsInputView,
  GridBoxModel: () => GridBoxModel,
  GridBoxView: () => GridBoxView,
  HBoxModel: () => HBoxModel,
  HBoxView: () => HBoxView,
  HTMLMathModel: () => HTMLMathModel,
  HTMLMathStyleModel: () => HTMLMathStyleModel,
  HTMLMathView: () => HTMLMathView,
  HTMLModel: () => HTMLModel,
  HTMLStyleModel: () => HTMLStyleModel,
  HTMLView: () => HTMLView,
  ImageModel: () => ImageModel,
  ImageView: () => ImageView,
  IntModel: () => IntModel,
  IntProgressModel: () => IntProgressModel,
  IntRangeSliderModel: () => IntRangeSliderModel,
  IntRangeSliderView: () => IntRangeSliderView,
  IntSliderModel: () => IntSliderModel,
  IntSliderView: () => IntSliderView,
  IntTextModel: () => IntTextModel,
  IntTextView: () => IntTextView,
  IntsInputModel: () => IntsInputModel,
  IntsInputView: () => IntsInputView,
  JUPYTER_CONTROLS_VERSION: () => JUPYTER_CONTROLS_VERSION,
  JupyterLuminoAccordionWidget: () => JupyterLuminoAccordionWidget,
  JupyterLuminoTabPanelWidget: () => JupyterLuminoTabPanelWidget,
  LabelModel: () => LabelModel,
  LabelStyleModel: () => LabelStyleModel,
  LabelView: () => LabelView,
  LabeledDOMWidgetModel: () => LabeledDOMWidgetModel,
  LabeledDOMWidgetView: () => LabeledDOMWidgetView,
  LinkModel: () => LinkModel,
  MultipleSelectionModel: () => MultipleSelectionModel,
  NaiveDatetimeModel: () => NaiveDatetimeModel,
  PasswordModel: () => PasswordModel,
  PasswordView: () => PasswordView,
  PlayModel: () => PlayModel,
  PlayView: () => PlayView,
  ProgressStyleModel: () => ProgressStyleModel,
  ProgressView: () => ProgressView,
  RadioButtonsModel: () => RadioButtonsModel,
  RadioButtonsView: () => RadioButtonsView,
  SelectModel: () => SelectModel,
  SelectMultipleModel: () => SelectMultipleModel,
  SelectMultipleView: () => SelectMultipleView,
  SelectView: () => SelectView,
  SelectionContainerModel: () => SelectionContainerModel,
  SelectionModel: () => SelectionModel,
  SelectionRangeSliderModel: () => SelectionRangeSliderModel,
  SelectionRangeSliderView: () => SelectionRangeSliderView,
  SelectionSliderModel: () => SelectionSliderModel,
  SelectionSliderView: () => SelectionSliderView,
  SelectionView: () => SelectionView,
  SliderStyleModel: () => SliderStyleModel,
  StackModel: () => StackModel,
  StackView: () => StackView,
  StringModel: () => StringModel,
  StringView: () => StringView,
  TabModel: () => TabModel,
  TabView: () => TabView,
  TagsInputModel: () => TagsInputModel,
  TagsInputView: () => TagsInputView,
  TextModel: () => TextModel,
  TextStyleModel: () => TextStyleModel,
  TextView: () => TextView,
  TextareaModel: () => TextareaModel,
  TextareaView: () => TextareaView,
  TimeModel: () => TimeModel,
  TimeView: () => TimeView,
  ToggleButtonModel: () => ToggleButtonModel,
  ToggleButtonStyleModel: () => ToggleButtonStyleModel,
  ToggleButtonView: () => ToggleButtonView,
  ToggleButtonsModel: () => ToggleButtonsModel,
  ToggleButtonsStyleModel: () => ToggleButtonsStyleModel,
  ToggleButtonsView: () => ToggleButtonsView,
  VBoxModel: () => VBoxModel,
  VBoxView: () => VBoxView,
  ValidModel: () => ValidModel,
  ValidView: () => ValidView,
  VideoModel: () => VideoModel,
  VideoView: () => VideoView,
  datetime_serializers: () => datetime_serializers,
  deserialize_date: () => deserialize_date,
  deserialize_datetime: () => deserialize_datetime,
  deserialize_naive: () => deserialize_naive,
  deserialize_time: () => deserialize_time,
  escape_html: () => escape_html,
  naive_serializers: () => naive_serializers,
  reject: () => reject3,
  resolvePromisesDict: () => resolvePromisesDict,
  serialize_date: () => serialize_date,
  serialize_datetime: () => serialize_datetime,
  serialize_naive: () => serialize_naive,
  serialize_time: () => serialize_time,
  time_serializers: () => time_serializers,
  typeset: () => typeset,
  uuid: () => uuid,
  version: () => version
});
var version;
var init_lib12 = __esm({
  "../../node_modules/@jupyter-widgets/controls/lib/index.js"() {
    init_utils3();
    init_version2();
    init_widget_link();
    init_widget_bool();
    init_widget_button();
    init_widget_box();
    init_widget_image();
    init_widget_video();
    init_widget_audio();
    init_widget_color();
    init_widget_date();
    init_widget_datetime();
    init_widget_time();
    init_widget_int();
    init_widget_float();
    init_widget_controller();
    init_widget_selection();
    init_widget_selectioncontainer();
    init_widget_tagsinput();
    init_widget_string();
    init_widget_description();
    init_widget_upload();
    version = require_package().version;
  }
});

// ../../node_modules/thebe-core/node_modules/nanoid/url-alphabet/index.js
var init_url_alphabet = __esm({
  "../../node_modules/thebe-core/node_modules/nanoid/url-alphabet/index.js"() {
  }
});

// ../../node_modules/thebe-core/node_modules/nanoid/index.browser.js
var random2, customRandom, customAlphabet;
var init_index_browser = __esm({
  "../../node_modules/thebe-core/node_modules/nanoid/index.browser.js"() {
    init_url_alphabet();
    random2 = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size5 = defaultSize) => {
        let id = "";
        while (true) {
          let bytes = getRandom(step);
          let j2 = step | 0;
          while (j2--) {
            id += alphabet[bytes[j2] & mask] || "";
            if (id.length === size5)
              return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size5 = 21) => customRandom(alphabet, size5, random2);
  }
});

// ../../node_modules/thebe-core/dist/esm/utils.js
function shortId() {
  return nanoid();
}
function ensureString2(maybeString) {
  if (Array.isArray(maybeString))
    return maybeString.join("\n");
  return maybeString;
}
function isMimeBundle({ output_type }) {
  return output_type === "display_data" || output_type === "execute_result";
}
function placeholder(plainText) {
  return `
<div class="thebe-ipywidgets-placeholder">
  <div class="thebe-ipywidgets-placeholder-image"></div>
  <div class="thebe-ipywidgets-placeholder-message"><code>ipywidgets</code> - a Jupyter kernel connection is required to fully display this output.</div>
  ${plainText && `<pre>${plainText}</pre>`}
</div>
`;
}
function stripWidgets(outputs, hideWidgets = true, placeholderFn = placeholder) {
  return outputs.map((output) => {
    if (!isMimeBundle(output))
      return output;
    const _a = output.data, _b = WIDGET_MIMETYPE, widgets = _a[_b], others = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    if (!widgets)
      return output;
    let data = output.data;
    if (hideWidgets)
      data = Object.assign({}, others);
    if (placeholderFn && !("text/html" in data))
      data["text/html"] = placeholderFn(ensureString2(data["text/plain"]));
    const stripped = Object.assign(Object.assign({}, output), { data });
    return stripped;
  });
}
var nanoid;
var init_utils4 = __esm({
  "../../node_modules/thebe-core/dist/esm/utils.js"() {
    init_tslib_es6();
    init_index_browser();
    init_manager3();
    nanoid = customAlphabet("1234567890abcdef", 8);
  }
});

// ../../node_modules/thebe-core/dist/esm/requireJsLoader.js
function fetchAndLoadInFrame(baseUrl) {
  return __awaiter(this, void 0, void 0, function* () {
    if (typeof document === "undefined")
      throw new Error("Cannot load requirejs outside of the browser");
    const res = yield fetch(REQUIREJS_URL);
    if (!res.ok) {
      throw new Error(`Could not fetch requirejs ${res.status} ${res.statusText}`);
    }
    const requireJsSource = yield res.text();
    return new Promise((resolve, reject4) => {
      const iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.onload = () => {
        const contentWindow = iframe.contentWindow;
        if (!contentWindow)
          return reject4("Cannot load in isolated: no contentWindow, origin error?");
        contentWindow.window.eval(requireJsSource);
        const requirejs = {
          require: contentWindow.window.require,
          define: contentWindow.window.define
        };
        if (!requirejs.require || !requirejs.define)
          return reject4("Require.js loading did not result in `require` and `define` objects attachment to window");
        requirejs.require.config({ baseUrl });
        resolve(requirejs);
        iframe.onload = null;
      };
      document.body.appendChild(iframe);
    });
  });
}
var REQUIREJS_CDN_URL, REQUIREJS_URL, RequireJsLoader;
var init_requireJsLoader = __esm({
  "../../node_modules/thebe-core/dist/esm/requireJsLoader.js"() {
    init_tslib_es6();
    REQUIREJS_CDN_URL = "https://cdn.jsdelivr.net/npm/";
    REQUIREJS_URL = "https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js";
    RequireJsLoader = class {
      constructor(baseUrl) {
        this.baseUrl = baseUrl !== null && baseUrl !== void 0 ? baseUrl : REQUIREJS_CDN_URL;
        this.requested = false;
        this.resolveFn = () => ({});
        this.ready = new Promise((resolve) => this.resolveFn = resolve);
      }
      load(postLoadFn) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.requested) {
            this.requested = true;
            this.requirejs = yield fetchAndLoadInFrame(this.baseUrl);
            yield postLoadFn === null || postLoadFn === void 0 ? void 0 : postLoadFn(this.requirejs.require, this.requirejs.define);
            this.resolveFn(this.requirejs);
          }
          return this.ready;
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/loader.js
function requirePromise(requirejs, moduleName) {
  return new Promise((resolve, reject4) => requirejs.require([`${moduleName}`], resolve, reject4));
}
function moduleNameToCDNUrl(moduleName, moduleVersion) {
  let packageName = moduleName;
  let fileName = "index";
  let index2 = moduleName.indexOf("/");
  if (index2 !== -1 && moduleName[0] === "@") {
    index2 = moduleName.indexOf("/", index2 + 1);
  }
  if (index2 !== -1) {
    fileName = moduleName.substr(index2 + 1);
    packageName = moduleName.substr(0, index2);
  }
  return `${cdn}${packageName}@${moduleVersion}/dist/${fileName}`;
}
function requireFromCDN(requirejs, moduleName, moduleVersion) {
  return __awaiter(this, void 0, void 0, function* () {
    const url = moduleNameToCDNUrl(moduleName, moduleVersion);
    const conf = { paths: {} };
    conf.paths[moduleName] = url;
    requirejs.require.config(conf);
    try {
      const module = yield requirePromise(requirejs, moduleName);
      return module;
    } catch (err) {
      console.error(`thebe:loader requirejs error on cdn require`, err);
      throw err;
    }
  });
}
function requireLoader(requirejs, moduleName, moduleVersion, useCDNOnly = false) {
  return __awaiter(this, void 0, void 0, function* () {
    console.debug(`thebe:loader loading ${moduleName}@${moduleVersion}`);
    if (useCDNOnly) {
      return requireFromCDN(requirejs, moduleName, moduleVersion);
    } else {
      if (requirejs.require.defined(moduleName)) {
        return requirePromise(requirejs, moduleName);
      }
      console.debug(`thebe:loader falling back to ${cdn} for ${moduleName}@${moduleVersion}`);
      return requireFromCDN(requirejs, moduleName, moduleVersion);
    }
  });
}
var cdn;
var init_loader = __esm({
  "../../node_modules/thebe-core/dist/esm/loader.js"() {
    init_tslib_es6();
    cdn = "https://cdn.jsdelivr.net/npm/";
  }
});

// ../../node_modules/thebe-core/dist/esm/manager.js
var WIDGET_MIMETYPE, ThebeManager;
var init_manager3 = __esm({
  "../../node_modules/thebe-core/dist/esm/manager.js"() {
    init_tslib_es6();
    init_index_es614();
    init_index_es612();
    init_lib11();
    init_lib8();
    init_lib12();
    init_utils4();
    init_requireJsLoader();
    init_loader();
    WIDGET_MIMETYPE = "application/vnd.jupyter.widget-view+json";
    ThebeManager = class extends KernelWidgetManager {
      constructor(kernel, rendermime) {
        super(kernel, rendermime);
        this.id = shortId();
        this.addWidgetFactories();
        this._registerWidgets();
        this._loader = new RequireJsLoader();
      }
      addWidgetFactories() {
        this.rendermime.addFactory({
          safe: false,
          mimeTypes: [WIDGET_MIMETYPE],
          createRenderer: (options) => new WidgetRenderer(options, this)
        }, 1);
      }
      removeWidgetFactories() {
        this.rendermime.removeMimeType(WIDGET_MIMETYPE);
      }
      /**
       * TODO implement a reasonable method for thebe-core that can load serialized widget state
       * see: https://github.dev/voila-dashboards/voila/blob/7090eb3e30c0c4aa25c2b7d5d2d45e8de1333b3b/packages/voila/src/manager.ts#L52
       *
       */
      build_widgets() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("ThebeManager:build_widgets not implmented");
        });
      }
      display_view(msg, view, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (options.el) {
            Widget2.attach(view.luminoWidget, options.el);
          }
          if (view.el) {
            view.el.setAttribute("data-thebe-jupyter-widget", "");
            view.el.addEventListener("jupyterWidgetResize", () => {
              MessageLoop2.postMessage(view.luminoWidget, Widget2.ResizeMessage.UnknownSize);
            });
          }
          return view.luminoWidget;
        });
      }
      loadClass(className, moduleName, moduleVersion) {
        const _super = Object.create(null, {
          loadClass: { get: () => super.loadClass }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._loader.requested) {
            console.debug(`thebe:manager:loadClass initial requirejs load ${this.id}`);
            this._loader.load((require2, define2) => {
              define2("@jupyter-widgets/base", lib_exports2);
              define2("@jupyter-widgets/controls", lib_exports4);
              define2("@jupyter-widgets/output", output_exports);
            });
          }
          console.debug(`thebe:manager:loadClass ${moduleName}@${moduleVersion}`);
          const rjs = yield this._loader.ready;
          if (moduleName === "@jupyter-widgets/base" || moduleName === "@jupyter-widgets/controls" || moduleName === "@jupyter-widgets/output") {
            return _super.loadClass.call(this, className, moduleName, moduleVersion);
          } else {
            let mod;
            try {
              mod = yield requireLoader(rjs, moduleName, moduleVersion);
            } catch (err) {
              console.error(`thebe:manager:loadClass loader error`, err);
              throw err;
            }
            if (mod[className]) {
              return mod[className];
            } else {
              console.error(`thebe:manager:loadClass ${className} not found in module ${moduleName}@${moduleVersion}`);
              throw new Error(`Class ${className} not found in module ${moduleName}@${moduleVersion}`);
            }
          }
        });
      }
      _registerWidgets() {
        this.register({
          name: "@jupyter-widgets/base",
          version: JUPYTER_WIDGETS_VERSION,
          exports: lib_exports2
          // TODO improve typing
        });
        this.register({
          name: "@jupyter-widgets/controls",
          version: JUPYTER_CONTROLS_VERSION,
          exports: lib_exports4
          // TODO improve typing
        });
        this.register({
          name: "@jupyter-widgets/output",
          version: output_exports.OUTPUT_WIDGET_VERSION,
          exports: output_exports
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/emitter.js
var EventEmitter;
var init_emitter = __esm({
  "../../node_modules/thebe-core/dist/esm/emitter.js"() {
    init_events();
    EventEmitter = class {
      constructor(id, config, subject, object2) {
        this._id = id;
        this._config = config;
        this._subject = subject;
        this._object = object2;
      }
      triggerStatus({ status, message }) {
        console.debug(`${status} ${message}`);
        this._config.events.trigger(ThebeEventType.status, {
          subject: this._subject,
          id: this._id,
          object: this._object,
          status,
          message
        });
      }
      triggerError({ status, message }) {
        console.debug(`Error [${this._subject}][${this._id}] ${message}`);
        this._config.events.trigger(ThebeEventType.error, {
          subject: this._subject,
          id: this._id,
          object: this._object,
          status,
          message
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/session.js
var ThebeSession, session_default;
var init_session = __esm({
  "../../node_modules/thebe-core/dist/esm/session.js"() {
    init_tslib_es6();
    init_events();
    init_manager3();
    init_emitter();
    ThebeSession = class {
      constructor(server, connection, rendermime) {
        var _a;
        this.server = server;
        this.connection = connection;
        this.events = new EventEmitter(this.connection.id, server.config, EventSubject.session, this);
        if (this.connection.kernel == null)
          throw Error("ThebeSession - kernel is null");
        this.manager = new ThebeManager(this.connection.kernel, rendermime);
        this.connection.statusChanged.connect((_4, s8) => {
          let status;
          switch (s8) {
            case "starting":
            case "restarting":
            case "autorestarting":
              status = SessionStatusEvent.starting;
              break;
            case "idle":
            case "busy":
              status = SessionStatusEvent.ready;
              break;
            case "terminating":
            case "dead":
            default:
              status = SessionStatusEvent.shutdown;
              break;
          }
          this.events.triggerStatus({
            status,
            message: `kernel ${this.connection.name} status changed to ${status}[${s8}]`
          });
          if (s8 === "dead") {
            this.events.triggerError({
              status: ErrorStatusEvent.session,
              message: `kernel ${this.connection.name} is dead`
            });
            this.dispose();
          }
        });
        this.connection.disposed.connect(() => {
          this.events.triggerStatus({
            status: SessionStatusEvent.shutdown,
            message: `kernel ${this.connection.name} disposed`
          });
        });
        this.events.triggerStatus({
          status: SessionStatusEvent.ready,
          message: `ThebeSession created, kernel '${(_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.name}' available`
        });
      }
      get id() {
        return this.connection.id;
      }
      get kernel() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.kernel;
      }
      get path() {
        return this.connection.path;
      }
      get name() {
        return this.connection.name;
      }
      restart() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          console.debug(`requesting restart for kernel ${this.id}`);
          const p3 = (_a = this.connection.kernel) === null || _a === void 0 ? void 0 : _a.restart();
          this.events.triggerStatus({
            status: SessionStatusEvent.starting,
            message: `Kernel restart requested`
          });
          yield p3;
          this.events.triggerStatus({
            status: SessionStatusEvent.ready,
            message: `session restarted, kernel '${(_b = this.connection.kernel) === null || _b === void 0 ? void 0 : _b.name}' available`
          });
        });
      }
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.connection.isDisposed)
            return;
          yield this.connection.shutdown();
          this.events.triggerStatus({
            status: SessionStatusEvent.shutdown,
            message: `session ${this.name}`
          });
          this.dispose();
        });
      }
      dispose() {
        if (!this.connection.isDisposed)
          this.connection.dispose();
      }
    };
    session_default = ThebeSession;
  }
});

// ../../node_modules/thebe-core/dist/esm/server.js
function responseToJson(res) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!res.ok)
      throw Error(`${res.status} - ${res.statusText}`);
    const json = yield res.json();
    return json;
  });
}
function errorAsString(errorLike) {
  if (typeof errorLike === "string")
    return errorLike;
  if (errorLike.message)
    return errorLike.message;
  if (errorLike.status && errorLike.statusText)
    return `${errorLike.status} - ${errorLike.statusText}`;
  return JSON.stringify(errorLike);
}
var import_services3, ThebeServer, server_default;
var init_server = __esm({
  "../../node_modules/thebe-core/dist/esm/server.js"() {
    init_tslib_es6();
    init_url();
    init_sessions();
    import_services3 = __toESM(require_lib2());
    init_session();
    init_utils4();
    init_events();
    init_emitter();
    ThebeServer = class {
      constructor(config) {
        this.id = shortId();
        this.config = config;
        this.events = new EventEmitter(this.id, config, EventSubject.server, this);
        this.ready = new Promise((resolve, reject4) => {
          this.resolveReadyFn = resolve;
          this.rejectReadyFn = reject4;
        });
        this._isDisposed = false;
      }
      get isBinder() {
        return !!this.binderUrls;
      }
      get isReady() {
        var _a, _b;
        return (_b = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.isReady) !== null && _b !== void 0 ? _b : false;
      }
      get isDisposed() {
        return this._isDisposed;
      }
      get settings() {
        var _a;
        return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings;
      }
      shutdownSession(id) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.shutdown(id);
        });
      }
      shutdownAllSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.shutdownAll();
        });
      }
      check() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const resp = yield ThebeServer.status((_b = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings) !== null && _b !== void 0 ? _b : this.config.serverSettings);
          return resp.ok;
        });
      }
      dispose() {
        var _a, _b, _c, _d;
        if (this._isDisposed)
          return;
        if (!((_a = this.serviceManager) === null || _a === void 0 ? void 0 : _a.isDisposed))
          (_b = this.serviceManager) === null || _b === void 0 ? void 0 : _b.dispose();
        if (!((_c = this.sessionManager) === null || _c === void 0 ? void 0 : _c.isDisposed))
          (_d = this.sessionManager) === null || _d === void 0 ? void 0 : _d.dispose();
        this._isDisposed = true;
      }
      startNewSession(rendermime, kernelOptions) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          if (!this.sessionManager) {
            throw Error("Requesting session from a server, with no SessionManager available");
          }
          yield this.sessionManager.ready;
          let path = (_a = kernelOptions === null || kernelOptions === void 0 ? void 0 : kernelOptions.path) !== null && _a !== void 0 ? _a : this.config.kernels.path;
          let name = "thebe.ipynb";
          const match = path.match(/\/*([a-zA-Z0-9-]+.ipynb)$/);
          if (match) {
            name = match[1];
          }
          const kernelName = (_b = kernelOptions === null || kernelOptions === void 0 ? void 0 : kernelOptions.kernelName) !== null && _b !== void 0 ? _b : this.config.kernels.kernelName;
          console.debug("thebe:api:startNewSession server", this);
          console.debug("thebe:api:startNewSession", { name, path, kernelName });
          if (this.serviceManager) {
            path = path.slice(1).replace(/\//g, "-");
          }
          const connection = yield (_c = this.sessionManager) === null || _c === void 0 ? void 0 : _c.startNew({
            name,
            path,
            type: "notebook",
            kernel: {
              name: kernelName
            }
          });
          return new session_default(this, connection, rendermime);
        });
      }
      listRunningSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          const iter = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.running();
          const models = [];
          let result2 = iter === null || iter === void 0 ? void 0 : iter.next();
          while (result2 && !result2.done) {
            models.push(result2.value);
            result2 = iter === null || iter === void 0 ? void 0 : iter.next();
          }
          return models;
        });
      }
      refreshRunningSessions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          yield (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.refreshRunning();
          return this.listRunningSessions();
        });
      }
      connectToExistingSession(model, rendermime) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.ready;
          if (!this.sessionManager) {
            throw Error("Requesting session from a server, with no SessionManager available");
          }
          yield this.sessionManager.ready;
          const connection = (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.connectTo({ model });
          return new session_default(this, connection, rendermime);
        });
      }
      clearSavedBinderSessions() {
        return __awaiter(this, void 0, void 0, function* () {
          const urls = this.makeBinderUrls();
          window.localStorage.removeItem(urls.storageKey);
        });
      }
      /**
       * Connect to a Jupyter server directly
       *
       */
      connectToJupyterServer() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          console.debug("thebe:api:connectToJupyterServer:serverSettings:", this.config.serverSettings);
          const serverSettings = import_services3.ServerConnection.makeSettings(this.config.serverSettings);
          try {
            this.events.triggerStatus({
              status: ServerStatusEvent.launching,
              message: `Checking server url`
            });
            yield ThebeServer.status(serverSettings);
            this.events.triggerStatus({
              status: ServerStatusEvent.launching,
              message: `Server reachable`
            });
          } catch (err) {
            const message = `Server not reachable (${serverSettings.baseUrl}) - ${err}`;
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message
            });
            (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, message);
            return;
          }
          const kernelManager = new import_services3.KernelManager({ serverSettings });
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Created KernelManager`
          });
          this.sessionManager = new import_services3.SessionManager({
            kernelManager,
            serverSettings
          });
          this.sessionManager.connectionFailure.connect((_4, err) => {
            this.events.triggerError({
              status: ErrorStatusEvent.server,
              message: `connection failure: ${err}`
            });
          });
          this.sessionManager.runningChanged.connect((_4, models) => {
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `${models.length} running sessions changed: ${models.map((m5) => m5.name).join(",")}`
            });
          });
          this.events.triggerStatus({
            status: ServerStatusEvent.ready,
            message: `Created SessionManager`
          });
          return this.sessionManager.ready.then(() => {
            var _a2;
            this.userServerUrl = `${serverSettings.baseUrl}?token=${serverSettings.token}`;
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `Server connection ready`
            });
            (_a2 = this.resolveReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
          }, (err) => {
            var _a2;
            return (_a2 = this.rejectReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, errorAsString(err));
          });
        });
      }
      /**
       * Connect to Jupyterlite Server
       */
      connectToJupyterLiteServer(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Connecting to JupyterLite`
          });
          if (!window.thebeLite)
            throw new Error(`thebe-lite is not available at window.thebeLite - load this onto your page before loading thebe or thebe-core.`);
          this.serviceManager = yield window.thebeLite.startJupyterLiteServer(config);
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Started JupyterLite server`
          });
          console.debug("thebe:api:connectToJupyterLiteServer:serverSettings:", this.serviceManager.serverSettings);
          this.sessionManager = this.serviceManager.sessions;
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Received SessionMananger from JupyterLite`
          });
          return (_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.ready.then(() => {
            var _a2;
            this.userServerUrl = "/";
            this.events.triggerStatus({
              status: ServerStatusEvent.ready,
              message: `Server connection established`
            });
            (_a2 = this.resolveReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, this);
          }, (err) => {
            var _a2;
            return (_a2 = this.rejectReadyFn) === null || _a2 === void 0 ? void 0 : _a2.call(this, errorAsString(err));
          });
        });
      }
      makeBinderUrls() {
        var _a;
        return makeBinderUrls(this.config, (_a = this.repoProviders) !== null && _a !== void 0 ? _a : WELL_KNOWN_REPO_PROVIDERS);
      }
      checkForSavedBinderSession() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const { storageKey } = makeBinderUrls(this.config, (_a = this.repoProviders) !== null && _a !== void 0 ? _a : WELL_KNOWN_REPO_PROVIDERS);
            return getExistingServer(this.config.savedSessions, storageKey);
          } catch (err) {
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message: `${err} - Failed to check for saved session.`
            });
            return null;
          }
        });
      }
      /**
       * Connect to a Binder instance in order to
       * access a Jupyter server that can provide kernels
       *
       * @param ctx
       * @param opts
       * @returns
       */
      connectToServerViaBinder(customProviders) {
        return __awaiter(this, void 0, void 0, function* () {
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Connecting to binderhub at ${this.config.binder.binderUrl}`
          });
          this.repoProviders = [...WELL_KNOWN_REPO_PROVIDERS, ...customProviders !== null && customProviders !== void 0 ? customProviders : []];
          try {
            this.binderUrls = makeBinderUrls(this.config, this.repoProviders);
          } catch (err) {
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message: `${err} - Failed to connect to binderhub at ${this.config.binder.binderUrl}`
            });
            return;
          }
          const urls = this.binderUrls;
          this.events.triggerStatus({
            status: ServerStatusEvent.launching,
            message: `Binder build url is ${urls.build}`
          });
          if (this.config.savedSessions.enabled) {
            console.debug("thebe:server:connectToServerViaBinder Checking for saved session...");
            const existingSettings = yield this.checkForSavedBinderSession();
            if (existingSettings) {
              const serverSettings = import_services3.ServerConnection.makeSettings(existingSettings);
              const kernelManager = new import_services3.KernelManager({ serverSettings });
              this.events.triggerStatus({
                status: ServerStatusEvent.launching,
                message: `Created KernelManager`
              });
              this.sessionManager = new import_services3.SessionManager({
                kernelManager,
                serverSettings
              });
              this.events.triggerStatus({
                status: ServerStatusEvent.launching,
                message: `Created KernelManager`
              });
              return this.sessionManager.ready.then(() => {
                var _a;
                this.userServerUrl = `${serverSettings.baseUrl}?token=${serverSettings.token}`;
                this.events.triggerStatus({
                  status: ServerStatusEvent.ready,
                  message: `Re-connected to binder server`
                });
                (_a = this.resolveReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, this);
              }, (err) => {
                var _a;
                return (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, errorAsString(err));
              });
            }
          }
          const state = {
            status: ServerStatusEvent.launching
          };
          const es = new EventSource(urls.build);
          this.events.triggerStatus({
            status: state.status,
            message: `Opened connection to binder: ${urls.build}`
          });
          es.onerror = (evt) => {
            var _a;
            console.error(`Lost connection to binder: ${urls.build}`, evt);
            es === null || es === void 0 ? void 0 : es.close();
            state.status = ErrorStatusEvent.error;
            const data = evt === null || evt === void 0 ? void 0 : evt.data;
            const phase = data ? data.phase : "unknown";
            const message = `Lost connection to binder: ${urls.build}
phase: ${phase} - ${data ? data.message : "no message"}`;
            this.events.triggerError({
              status: ErrorStatusEvent.error,
              message
            });
            (_a = this.rejectReadyFn) === null || _a === void 0 ? void 0 : _a.call(this, message);
          };
          es.onmessage = (evt) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const msg = JSON.parse(evt.data);
            const phase = (_b = (_a = msg.phase) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
            switch (phase) {
              case "failed":
                es === null || es === void 0 ? void 0 : es.close();
                state.status = ErrorStatusEvent.error;
                this.events.triggerError({
                  status: ErrorStatusEvent.error,
                  message: `Binder: failed to build - ${urls.build} - ${msg.message}`
                });
                (_c = this.rejectReadyFn) === null || _c === void 0 ? void 0 : _c.call(this, msg.message);
                break;
              case "ready":
                {
                  es === null || es === void 0 ? void 0 : es.close();
                  const settings = {
                    baseUrl: msg.url,
                    wsUrl: "ws" + msg.url.slice(4),
                    token: msg.token,
                    appendToken: true
                  };
                  const serverSettings = import_services3.ServerConnection.makeSettings(settings);
                  const kernelManager = new import_services3.KernelManager({ serverSettings });
                  this.sessionManager = new import_services3.SessionManager({
                    kernelManager,
                    serverSettings
                  });
                  if (this.config.savedSessions.enabled) {
                    saveServerInfo(urls.storageKey, this.id, serverSettings);
                    console.debug(`thebe:server:connectToServerViaBinder Saved session for ${this.id} at ${urls.build}`);
                  }
                  yield this.sessionManager.ready;
                  this.userServerUrl = `${msg.url}?token=${msg.token}`;
                  state.status = ServerStatusEvent.ready;
                  this.events.triggerStatus({
                    status: state.status,
                    message: `Binder server is ready: ${msg.message}`
                  });
                  (_d = this.resolveReadyFn) === null || _d === void 0 ? void 0 : _d.call(this, this);
                }
                break;
              default:
                this.events.triggerStatus({
                  status: state.status,
                  message: `Binder is: ${phase} - ${msg.message}`
                });
            }
          });
        });
      }
      //
      // ServerRestAPI Implementation
      //
      getFetchUrl(relativeUrl) {
        var _a, _b;
        if (!this.sessionManager)
          throw new Error("Must connect to a server before requesting KernelSpecs");
        if (!((_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings))
          throw new Error("No server settings available in session manager");
        const settings = (_b = this.sessionManager) === null || _b === void 0 ? void 0 : _b.serverSettings;
        const baseUrl = new URL(settings.baseUrl);
        const url = new URL(`${baseUrl.pathname}${relativeUrl}`.replace("//", "/"), baseUrl.origin);
        url.searchParams.append("token", settings.token);
        return url;
      }
      static status(serverSettings) {
        return import_services3.ServerConnection.makeRequest(`${serverSettings.baseUrl}api/status`, {}, import_services3.ServerConnection.makeSettings(serverSettings));
      }
      getKernelSpecs() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.sessionManager)
            throw new Error("Must connect to a server before requesting KernelSpecs");
          return import_services3.KernelSpecAPI.getSpecs(import_services3.ServerConnection.makeSettings((_a = this.sessionManager) === null || _a === void 0 ? void 0 : _a.serverSettings));
        });
      }
      getContents(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          if (opts.type)
            url.searchParams.append("type", opts.type);
          if (opts.format)
            url.searchParams.append("format", opts.format);
          url.searchParams.append("content", opts.returnContent ? "1" : "0");
          return responseToJson(yield fetch(url));
        });
      }
      duplicateFile(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          const { copy_from, ext, type } = opts;
          return responseToJson(yield fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ copy_from, ext, type })
          }));
        });
      }
      createDirectory(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const url = this.getFetchUrl(`/api/contents/${opts.path}`);
          return responseToJson(yield fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "directory" })
          }));
        });
      }
      renameContents(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { path, newPath } = opts;
          const url = this.getFetchUrl(`/api/contents/${path}`);
          return responseToJson(yield fetch(url, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ path: newPath })
          }));
        });
      }
      uploadFile(opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { path, content, format: format2, type } = opts;
          const url = this.getFetchUrl(`/api/contents/${path}`);
          console.debug("thebe:api:server:uploadFile", url);
          return responseToJson(yield fetch(url, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              path,
              content,
              format: format2 !== null && format2 !== void 0 ? format2 : "json",
              type: type !== null && type !== void 0 ? type : "notebook"
            })
          }));
        });
      }
    };
    server_default = ThebeServer;
  }
});

// ../../node_modules/@jupyterlab/mathjax2/node_modules/@lumino/coreutils/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@jupyterlab/mathjax2/node_modules/@lumino/coreutils/dist/index.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_coreutils = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.JSONExt = void 0;
      (function(JSONExt12) {
        JSONExt12.emptyObject = Object.freeze({});
        JSONExt12.emptyArray = Object.freeze([]);
        function isPrimitive(value) {
          return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
        }
        JSONExt12.isPrimitive = isPrimitive;
        function isArray(value) {
          return Array.isArray(value);
        }
        JSONExt12.isArray = isArray;
        function isObject4(value) {
          return !isPrimitive(value) && !isArray(value);
        }
        JSONExt12.isObject = isObject4;
        function deepEqual2(first2, second) {
          if (first2 === second) {
            return true;
          }
          if (isPrimitive(first2) || isPrimitive(second)) {
            return false;
          }
          var a1 = isArray(first2);
          var a22 = isArray(second);
          if (a1 !== a22) {
            return false;
          }
          if (a1 && a22) {
            return deepArrayEqual(first2, second);
          }
          return deepObjectEqual(first2, second);
        }
        JSONExt12.deepEqual = deepEqual2;
        function deepCopy(value) {
          if (isPrimitive(value)) {
            return value;
          }
          if (isArray(value)) {
            return deepArrayCopy(value);
          }
          return deepObjectCopy(value);
        }
        JSONExt12.deepCopy = deepCopy;
        function deepArrayEqual(first2, second) {
          if (first2 === second) {
            return true;
          }
          if (first2.length !== second.length) {
            return false;
          }
          for (var i6 = 0, n5 = first2.length; i6 < n5; ++i6) {
            if (!deepEqual2(first2[i6], second[i6])) {
              return false;
            }
          }
          return true;
        }
        function deepObjectEqual(first2, second) {
          if (first2 === second) {
            return true;
          }
          for (var key in first2) {
            if (first2[key] !== void 0 && !(key in second)) {
              return false;
            }
          }
          for (var key in second) {
            if (second[key] !== void 0 && !(key in first2)) {
              return false;
            }
          }
          for (var key in first2) {
            var firstValue = first2[key];
            var secondValue = second[key];
            if (firstValue === void 0 && secondValue === void 0) {
              continue;
            }
            if (firstValue === void 0 || secondValue === void 0) {
              return false;
            }
            if (!deepEqual2(firstValue, secondValue)) {
              return false;
            }
          }
          return true;
        }
        function deepArrayCopy(value) {
          var result2 = new Array(value.length);
          for (var i6 = 0, n5 = value.length; i6 < n5; ++i6) {
            result2[i6] = deepCopy(value[i6]);
          }
          return result2;
        }
        function deepObjectCopy(value) {
          var result2 = {};
          for (var key in value) {
            var subvalue = value[key];
            if (subvalue === void 0) {
              continue;
            }
            result2[key] = deepCopy(subvalue);
          }
          return result2;
        }
      })(exports2.JSONExt || (exports2.JSONExt = {}));
      var MimeData5 = (
        /** @class */
        function() {
          function MimeData6() {
            this._types = [];
            this._values = [];
          }
          MimeData6.prototype.types = function() {
            return this._types.slice();
          };
          MimeData6.prototype.hasData = function(mime) {
            return this._types.indexOf(mime) !== -1;
          };
          MimeData6.prototype.getData = function(mime) {
            var i6 = this._types.indexOf(mime);
            return i6 !== -1 ? this._values[i6] : void 0;
          };
          MimeData6.prototype.setData = function(mime, data) {
            this.clearData(mime);
            this._types.push(mime);
            this._values.push(data);
          };
          MimeData6.prototype.clearData = function(mime) {
            var i6 = this._types.indexOf(mime);
            if (i6 !== -1) {
              this._types.splice(i6, 1);
              this._values.splice(i6, 1);
            }
          };
          MimeData6.prototype.clear = function() {
            this._types.length = 0;
            this._values.length = 0;
          };
          return MimeData6;
        }()
      );
      var PromiseDelegate5 = (
        /** @class */
        function() {
          function PromiseDelegate6() {
            var _this = this;
            this.promise = new Promise(function(resolve, reject4) {
              _this._resolve = resolve;
              _this._reject = reject4;
            });
          }
          PromiseDelegate6.prototype.resolve = function(value) {
            var resolve = this._resolve;
            resolve(value);
          };
          PromiseDelegate6.prototype.reject = function(reason) {
            var reject4 = this._reject;
            reject4(reason);
          };
          return PromiseDelegate6;
        }()
      );
      var Token3 = (
        /** @class */
        function() {
          function Token4(name) {
            this.name = name;
            this._tokenStructuralPropertyT = null;
          }
          return Token4;
        }()
      );
      function fallbackRandomValues(buffer) {
        var value = 0;
        for (var i6 = 0, n5 = buffer.length; i6 < n5; ++i6) {
          if (i6 % 4 === 0) {
            value = Math.random() * 4294967295 >>> 0;
          }
          buffer[i6] = value & 255;
          value >>>= 8;
        }
      }
      exports2.Random = void 0;
      (function(Random) {
        Random.getRandomValues = function() {
          var crypto2 = typeof window !== "undefined" && (window.crypto || window.msCrypto) || null;
          if (crypto2 && typeof crypto2.getRandomValues === "function") {
            return function getRandomValues(buffer) {
              return crypto2.getRandomValues(buffer);
            };
          }
          return fallbackRandomValues;
        }();
      })(exports2.Random || (exports2.Random = {}));
      function uuid4Factory(getRandomValues) {
        var bytes = new Uint8Array(16);
        var lut = new Array(256);
        for (var i6 = 0; i6 < 16; ++i6) {
          lut[i6] = "0" + i6.toString(16);
        }
        for (var i6 = 16; i6 < 256; ++i6) {
          lut[i6] = i6.toString(16);
        }
        return function uuid4() {
          getRandomValues(bytes);
          bytes[6] = 64 | bytes[6] & 15;
          bytes[8] = 128 | bytes[8] & 63;
          return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
        };
      }
      exports2.UUID = void 0;
      (function(UUID7) {
        UUID7.uuid4 = uuid4Factory(exports2.Random.getRandomValues);
      })(exports2.UUID || (exports2.UUID = {}));
      exports2.MimeData = MimeData5;
      exports2.PromiseDelegate = PromiseDelegate5;
      exports2.Token = Token3;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jupyterlab/mathjax2/lib/index.js
var import_coreutils18, MathJaxTypesetter;
var init_lib13 = __esm({
  "../../node_modules/@jupyterlab/mathjax2/lib/index.js"() {
    import_coreutils18 = __toESM(require_dist2());
    MathJaxTypesetter = class {
      /**
       * Create a new MathJax typesetter.
       */
      constructor(options) {
        this._initPromise = new import_coreutils18.PromiseDelegate();
        this._initialized = false;
        this._url = options.url;
        this._config = options.config;
      }
      /**
       * Typeset the math in a node.
       *
       * #### Notes
       * MathJax schedules the typesetting asynchronously,
       * but there are not currently any callbacks or Promises
       * firing when it is done.
       */
      typeset(node) {
        if (!this._initialized) {
          this._init();
        }
        void this._initPromise.promise.then(() => {
          MathJax.Hub.Queue(["Typeset", MathJax.Hub, node]);
          try {
            MathJax.Hub.Queue(["Require", MathJax.Ajax, "[MathJax]/extensions/TeX/AMSmath.js"], () => {
              MathJax.InputJax.TeX.resetEquationNumbers();
            });
          } catch (e3) {
            console.error("Error queueing resetEquationNumbers:", e3);
          }
        });
      }
      /**
       * Initialize MathJax.
       */
      _init() {
        const head = document.getElementsByTagName("head")[0];
        const script = document.createElement("script");
        script.type = "text/javascript";
        script.src = `${this._url}?config=${this._config}&amp;delayStartupUntil=configured`;
        script.charset = "utf-8";
        head.appendChild(script);
        script.addEventListener("load", () => {
          this._onLoad();
        });
        this._initialized = true;
      }
      /**
       * Handle MathJax loading.
       */
      _onLoad() {
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [
              ["$", "$"],
              ["\\(", "\\)"]
            ],
            displayMath: [
              ["$$", "$$"],
              ["\\[", "\\]"]
            ],
            processEscapes: true,
            processEnvironments: true
          },
          // Center justify equations in code and markdown cells. Elsewhere
          // we use CSS to left justify single line equations in code cells.
          displayAlign: "center",
          CommonHTML: {
            linebreaks: { automatic: true }
          },
          "HTML-CSS": {
            availableFonts: [],
            imageFont: null,
            preferredFont: null,
            webFont: "STIX-Web",
            styles: { ".MathJax_Display": { margin: 0 } },
            linebreaks: { automatic: true }
          },
          skipStartupTypeset: true,
          messageStyle: "none"
        });
        MathJax.Hub.Register.StartupHook("End Config", () => {
          var _a, _b, _c, _d, _e2, _f;
          (_c = (_b = (_a = MathJax.Hub) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.MathEvents) === null || _c === void 0 ? true : delete _c.styles[".MathJax_Hover_Arrow:hover span"];
          (_f = (_e2 = (_d = MathJax.Hub) === null || _d === void 0 ? void 0 : _d.config) === null || _e2 === void 0 ? void 0 : _e2.MathMenu) === null || _f === void 0 ? true : delete _f.styles[".MathJax_MenuClose:hover span"];
        });
        MathJax.Hub.Configured();
        this._initPromise.resolve(void 0);
      }
    };
  }
});

// ../../node_modules/@jupyterlab/javascript-extension/lib/index.js
function evalInContext(code, element, document, window) {
  return eval(code);
}
var TEXT_JAVASCRIPT_MIMETYPE, APPLICATION_JAVASCRIPT_MIMETYPE, ExperimentalRenderedJavascript, rendererFactory, extension, lib_default;
var init_lib14 = __esm({
  "../../node_modules/@jupyterlab/javascript-extension/lib/index.js"() {
    init_lib6();
    TEXT_JAVASCRIPT_MIMETYPE = "text/javascript";
    APPLICATION_JAVASCRIPT_MIMETYPE = "application/javascript";
    ExperimentalRenderedJavascript = class extends RenderedJavaScript {
      render(model) {
        const trans = this.translator.load("jupyterlab");
        const renderJavascript = () => {
          try {
            const data = model.data[this.mimeType];
            if (data) {
              evalInContext(data, this.node, document, window);
            }
            return Promise.resolve();
          } catch (error) {
            return Promise.reject(error);
          }
        };
        if (!model.trusted) {
          const pre = document.createElement("pre");
          pre.textContent = trans.__("Are you sure that you want to run arbitrary Javascript within your JupyterLab session?");
          const button = document.createElement("button");
          button.textContent = trans.__("Run");
          this.node.appendChild(pre);
          this.node.appendChild(button);
          button.onclick = (event) => {
            this.node.textContent = "";
            void renderJavascript();
          };
          return Promise.resolve();
        }
        return renderJavascript();
      }
    };
    rendererFactory = {
      safe: false,
      mimeTypes: [TEXT_JAVASCRIPT_MIMETYPE, APPLICATION_JAVASCRIPT_MIMETYPE],
      createRenderer: (options) => new ExperimentalRenderedJavascript(options)
    };
    extension = {
      id: "@jupyterlab/javascript-extension:factory",
      description: "Adds renderer for JavaScript content.",
      rendererFactory,
      rank: 0,
      dataType: "string"
    };
    lib_default = extension;
  }
});

// ../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/collections/dist/index.es6.js
var LinkedList4, Private19;
var init_index_es623 = __esm({
  "../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/collections/dist/index.es6.js"() {
    LinkedList4 = class {
      constructor() {
        this._first = null;
        this._last = null;
        this._size = 0;
      }
      /**
       * Whether the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get isEmpty() {
        return this._size === 0;
      }
      /**
       * The size of the list.
       *
       * #### Complexity
       * `O(1)`
       *
       * #### Notes
       * This is equivalent to `length`.
       */
      get size() {
        return this._size;
      }
      /**
       * The length of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `size`.
       *
       * This property is deprecated.
       */
      get length() {
        return this._size;
      }
      /**
       * The first value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get first() {
        return this._first ? this._first.value : void 0;
      }
      /**
       * The last value in the list.
       *
       * This is `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get last() {
        return this._last ? this._last.value : void 0;
      }
      /**
       * The first node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get firstNode() {
        return this._first;
      }
      /**
       * The last node in the list.
       *
       * This is `null` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      get lastNode() {
        return this._last;
      }
      /**
       * Create an iterator over the values in the list.
       *
       * @returns A new iterator starting with the first value.
       *
       * #### Complexity
       * Constant.
       */
      *[Symbol.iterator]() {
        let node = this._first;
        while (node) {
          yield node.value;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the values in the list.
       *
       * @returns A new iterator starting with the last value.
       *
       * #### Complexity
       * Constant.
       */
      *retro() {
        let node = this._last;
        while (node) {
          yield node.value;
          node = node.prev;
        }
      }
      /**
       * Create an iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the first node.
       *
       * #### Complexity
       * Constant.
       */
      *nodes() {
        let node = this._first;
        while (node) {
          yield node;
          node = node.next;
        }
      }
      /**
       * Create a reverse iterator over the nodes in the list.
       *
       * @returns A new iterator starting with the last node.
       *
       * #### Complexity
       * Constant.
       */
      *retroNodes() {
        let node = this._last;
        while (node) {
          yield node;
          node = node.prev;
        }
      }
      /**
       * Assign new values to the list, replacing all current values.
       *
       * @param values - The values to assign to the list.
       *
       * #### Complexity
       * Linear.
       */
      assign(values2) {
        this.clear();
        for (const value of values2) {
          this.addLast(value);
        }
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addLast`.
       */
      push(value) {
        this.addLast(value);
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeLast`.
       */
      pop() {
        return this.removeLast();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `addFirst`.
       */
      shift(value) {
        this.addFirst(value);
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * This is equivalent to `removeFirst`.
       */
      unshift() {
        return this.removeFirst();
      }
      /**
       * Add a value to the beginning of the list.
       *
       * @param value - The value to add to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addFirst(value) {
        let node = new Private19.LinkedListNode(this, value);
        if (!this._first) {
          this._first = node;
          this._last = node;
        } else {
          node.next = this._first;
          this._first.prev = node;
          this._first = node;
        }
        this._size++;
        return node;
      }
      /**
       * Add a value to the end of the list.
       *
       * @param value - The value to add to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Complexity
       * Constant.
       */
      addLast(value) {
        let node = new Private19.LinkedListNode(this, value);
        if (!this._last) {
          this._first = node;
          this._last = node;
        } else {
          node.prev = this._last;
          this._last.next = node;
          this._last = node;
        }
        this._size++;
        return node;
      }
      /**
       * Insert a value before a specific node in the list.
       *
       * @param value - The value to insert before the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the beginning of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertBefore(value, ref) {
        if (!ref || ref === this._first) {
          return this.addFirst(value);
        }
        if (!(ref instanceof Private19.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private19.LinkedListNode(this, value);
        let _ref = ref;
        let prev = _ref.prev;
        node.next = _ref;
        node.prev = prev;
        _ref.prev = node;
        prev.next = node;
        this._size++;
        return node;
      }
      /**
       * Insert a value after a specific node in the list.
       *
       * @param value - The value to insert after the reference node.
       *
       * @param ref - The reference node of interest. If this is `null`,
       *   the value will be added to the end of the list.
       *
       * @returns The list node which holds the value.
       *
       * #### Notes
       * The reference node must be owned by the list.
       *
       * #### Complexity
       * Constant.
       */
      insertAfter(value, ref) {
        if (!ref || ref === this._last) {
          return this.addLast(value);
        }
        if (!(ref instanceof Private19.LinkedListNode) || ref.list !== this) {
          throw new Error("Reference node is not owned by the list.");
        }
        let node = new Private19.LinkedListNode(this, value);
        let _ref = ref;
        let next = _ref.next;
        node.next = next;
        node.prev = _ref;
        _ref.next = node;
        next.prev = node;
        this._size++;
        return node;
      }
      /**
       * Remove and return the value at the beginning of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeFirst() {
        let node = this._first;
        if (!node) {
          return void 0;
        }
        if (node === this._last) {
          this._first = null;
          this._last = null;
        } else {
          this._first = node.next;
          this._first.prev = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove and return the value at the end of the list.
       *
       * @returns The removed value, or `undefined` if the list is empty.
       *
       * #### Complexity
       * Constant.
       */
      removeLast() {
        let node = this._last;
        if (!node) {
          return void 0;
        }
        if (node === this._first) {
          this._first = null;
          this._last = null;
        } else {
          this._last = node.prev;
          this._last.next = null;
        }
        node.list = null;
        node.next = null;
        node.prev = null;
        this._size--;
        return node.value;
      }
      /**
       * Remove a specific node from the list.
       *
       * @param node - The node to remove from the list.
       *
       * #### Complexity
       * Constant.
       *
       * #### Notes
       * The node must be owned by the list.
       */
      removeNode(node) {
        if (!(node instanceof Private19.LinkedListNode) || node.list !== this) {
          throw new Error("Node is not owned by the list.");
        }
        let _node = node;
        if (_node === this._first && _node === this._last) {
          this._first = null;
          this._last = null;
        } else if (_node === this._first) {
          this._first = _node.next;
          this._first.prev = null;
        } else if (_node === this._last) {
          this._last = _node.prev;
          this._last.next = null;
        } else {
          _node.next.prev = _node.prev;
          _node.prev.next = _node.next;
        }
        _node.list = null;
        _node.next = null;
        _node.prev = null;
        this._size--;
      }
      /**
       * Remove all values from the list.
       *
       * #### Complexity
       * Linear.
       */
      clear() {
        let node = this._first;
        while (node) {
          let next = node.next;
          node.list = null;
          node.prev = null;
          node.next = null;
          node = next;
        }
        this._first = null;
        this._last = null;
        this._size = 0;
      }
    };
    (function(LinkedList5) {
      function from(values2) {
        let list = new LinkedList5();
        list.assign(values2);
        return list;
      }
      LinkedList5.from = from;
    })(LinkedList4 || (LinkedList4 = {}));
    (function(Private22) {
      class LinkedListNode {
        /**
         * Construct a new linked list node.
         *
         * @param list - The list which owns the node.
         *
         * @param value - The value for the link.
         */
        constructor(list, value) {
          this.list = null;
          this.next = null;
          this.prev = null;
          this.list = list;
          this.value = value;
        }
      }
      Private22.LinkedListNode = LinkedListNode;
    })(Private19 || (Private19 = {}));
  }
});

// ../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/messaging/dist/index.es6.js
var Message4, ConflatableMessage4, MessageLoop5;
var init_index_es624 = __esm({
  "../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/messaging/dist/index.es6.js"() {
    init_index_es6();
    init_index_es623();
    Message4 = class {
      /**
       * Construct a new message.
       *
       * @param type - The type of the message.
       */
      constructor(type) {
        this.type = type;
      }
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * If a conflatable message is posted to a handler while another
       * conflatable message of the same `type` has already been posted
       * to the handler, the `conflate()` method of the existing message
       * will be invoked. If that method returns `true`, the new message
       * will not be enqueued. This allows messages to be compressed, so
       * that only a single instance of the message type is processed per
       * cycle, no matter how many times messages of that type are posted.
       *
       * Custom message types may reimplement this property.
       *
       * The default implementation is always `false`.
       */
      get isConflatable() {
        return false;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * @param other - A conflatable message of the same `type`.
       *
       * @returns `true` if the message was successfully conflated, or
       *   `false` otherwise.
       *
       * #### Notes
       * Message conflation is an advanced topic. Most message types will
       * not make use of this feature.
       *
       * This method is called automatically by the message loop when the
       * given message is posted to the handler paired with this message.
       * This message will already be enqueued and conflatable, and the
       * given message will have the same `type` and also be conflatable.
       *
       * This method should merge the state of the other message into this
       * message as needed so that when this message is finally delivered
       * to the handler, it receives the most up-to-date information.
       *
       * If this method returns `true`, it signals that the other message
       * was successfully conflated and that message will not be enqueued.
       *
       * If this method returns `false`, the other message will be enqueued
       * for normal delivery.
       *
       * Custom message types may reimplement this method.
       *
       * The default implementation always returns `false`.
       */
      conflate(other) {
        return false;
      }
    };
    ConflatableMessage4 = class extends Message4 {
      /**
       * Test whether the message is conflatable.
       *
       * #### Notes
       * This property is always `true`.
       */
      get isConflatable() {
        return true;
      }
      /**
       * Conflate this message with another message of the same `type`.
       *
       * #### Notes
       * This method always returns `true`.
       */
      conflate(other) {
        return true;
      }
    };
    (function(MessageLoop6) {
      let pending = null;
      const schedule = ((resolved) => (fn) => {
        let rejected = false;
        resolved.then(() => !rejected && fn());
        return () => {
          rejected = true;
        };
      })(Promise.resolve());
      function sendMessage(handler, msg) {
        let hooks = messageHooks.get(handler);
        if (!hooks || hooks.length === 0) {
          invokeHandler(handler, msg);
          return;
        }
        let passed = every(retro(hooks), (hook) => {
          return hook ? invokeHook(hook, handler, msg) : true;
        });
        if (passed) {
          invokeHandler(handler, msg);
        }
      }
      MessageLoop6.sendMessage = sendMessage;
      function postMessage(handler, msg) {
        if (!msg.isConflatable) {
          enqueueMessage(handler, msg);
          return;
        }
        let conflated = some(messageQueue, (posted) => {
          if (posted.handler !== handler) {
            return false;
          }
          if (!posted.msg) {
            return false;
          }
          if (posted.msg.type !== msg.type) {
            return false;
          }
          if (!posted.msg.isConflatable) {
            return false;
          }
          return posted.msg.conflate(msg);
        });
        if (!conflated) {
          enqueueMessage(handler, msg);
        }
      }
      MessageLoop6.postMessage = postMessage;
      function installMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.indexOf(hook) !== -1) {
          return;
        }
        if (!hooks) {
          messageHooks.set(handler, [hook]);
        } else {
          hooks.push(hook);
        }
      }
      MessageLoop6.installMessageHook = installMessageHook;
      function removeMessageHook(handler, hook) {
        let hooks = messageHooks.get(handler);
        if (!hooks) {
          return;
        }
        let i6 = hooks.indexOf(hook);
        if (i6 === -1) {
          return;
        }
        hooks[i6] = null;
        scheduleCleanup(hooks);
      }
      MessageLoop6.removeMessageHook = removeMessageHook;
      function clearData(handler) {
        let hooks = messageHooks.get(handler);
        if (hooks && hooks.length > 0) {
          ArrayExt.fill(hooks, null);
          scheduleCleanup(hooks);
        }
        for (const posted of messageQueue) {
          if (posted.handler === handler) {
            posted.handler = null;
            posted.msg = null;
          }
        }
      }
      MessageLoop6.clearData = clearData;
      function flush() {
        if (flushGuard || pending === null) {
          return;
        }
        pending();
        pending = null;
        flushGuard = true;
        runMessageLoop();
        flushGuard = false;
      }
      MessageLoop6.flush = flush;
      function getExceptionHandler() {
        return exceptionHandler;
      }
      MessageLoop6.getExceptionHandler = getExceptionHandler;
      function setExceptionHandler(handler) {
        let old = exceptionHandler;
        exceptionHandler = handler;
        return old;
      }
      MessageLoop6.setExceptionHandler = setExceptionHandler;
      const messageQueue = new LinkedList4();
      const messageHooks = /* @__PURE__ */ new WeakMap();
      const dirtySet = /* @__PURE__ */ new Set();
      let exceptionHandler = (err) => {
        console.error(err);
      };
      let flushGuard = false;
      function invokeHook(hook, handler, msg) {
        let result2 = true;
        try {
          if (typeof hook === "function") {
            result2 = hook(handler, msg);
          } else {
            result2 = hook.messageHook(handler, msg);
          }
        } catch (err) {
          exceptionHandler(err);
        }
        return result2;
      }
      function invokeHandler(handler, msg) {
        try {
          handler.processMessage(msg);
        } catch (err) {
          exceptionHandler(err);
        }
      }
      function enqueueMessage(handler, msg) {
        messageQueue.addLast({ handler, msg });
        if (pending !== null) {
          return;
        }
        pending = schedule(runMessageLoop);
      }
      function runMessageLoop() {
        pending = null;
        if (messageQueue.isEmpty) {
          return;
        }
        let sentinel = { handler: null, msg: null };
        messageQueue.addLast(sentinel);
        while (true) {
          let posted = messageQueue.removeFirst();
          if (posted === sentinel) {
            return;
          }
          if (posted.handler && posted.msg) {
            sendMessage(posted.handler, posted.msg);
          }
        }
      }
      function scheduleCleanup(hooks) {
        if (dirtySet.size === 0) {
          schedule(cleanupDirtySet);
        }
        dirtySet.add(hooks);
      }
      function cleanupDirtySet() {
        dirtySet.forEach(cleanupHooks);
        dirtySet.clear();
      }
      function cleanupHooks(hooks) {
        ArrayExt.removeAllWhere(hooks, isNull2);
      }
      function isNull2(value) {
        return value === null;
      }
    })(MessageLoop5 || (MessageLoop5 = {}));
  }
});

// ../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/dragdrop/dist/index.es6.js
var Drag4, Private20;
var init_index_es625 = __esm({
  "../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/dragdrop/dist/index.es6.js"() {
    init_index_es63();
    Drag4 = class {
      /**
       * Construct a new drag object.
       *
       * @param options - The options for initializing the drag.
       */
      constructor(options) {
        this._onScrollFrame = () => {
          if (!this._scrollTarget) {
            return;
          }
          let { element: element2, edge, distance } = this._scrollTarget;
          let d6 = Private20.SCROLL_EDGE_SIZE - distance;
          let f6 = Math.pow(d6 / Private20.SCROLL_EDGE_SIZE, 2);
          let s8 = Math.max(1, Math.round(f6 * Private20.SCROLL_EDGE_SIZE));
          switch (edge) {
            case "top":
              element2.scrollTop -= s8;
              break;
            case "left":
              element2.scrollLeft -= s8;
              break;
            case "right":
              element2.scrollLeft += s8;
              break;
            case "bottom":
              element2.scrollTop += s8;
              break;
          }
          requestAnimationFrame(this._onScrollFrame);
        };
        this._disposed = false;
        this._dropAction = "none";
        this._override = null;
        this._currentTarget = null;
        this._currentElement = null;
        this._promise = null;
        this._scrollTarget = null;
        this._resolve = null;
        this.document = options.document || document;
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || "copy";
        this.supportedActions = options.supportedActions || "all";
        this.source = options.source || null;
      }
      /**
       * Dispose of the resources held by the drag object.
       *
       * #### Notes
       * This will cancel the drag operation if it is active.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        if (this._currentTarget) {
          let event = new PointerEvent("pointerup", {
            bubbles: true,
            cancelable: true,
            clientX: -1,
            clientY: -1
          });
          Private20.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        this._finalize("none");
      }
      /**
       * Test whether the drag object is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Start the drag operation at the specified client position.
       *
       * @param clientX - The client X position for the drag start.
       *
       * @param clientY - The client Y position for the drag start.
       *
       * @returns A promise which resolves to the result of the drag.
       *
       * #### Notes
       * If the drag has already been started, the promise created by the
       * first call to `start` is returned.
       *
       * If the drag operation has ended, or if the drag object has been
       * disposed, the returned promise will resolve to `'none'`.
       *
       * The drag object will be automatically disposed when drag operation
       * completes. This means `Drag` objects are for single-use only.
       *
       * This method assumes the left mouse button is already held down.
       */
      start(clientX, clientY) {
        if (this._disposed) {
          return Promise.resolve("none");
        }
        if (this._promise) {
          return this._promise;
        }
        this._addListeners();
        this._attachDragImage(clientX, clientY);
        this._promise = new Promise((resolve) => {
          this._resolve = resolve;
        });
        let event = new PointerEvent("pointermove", {
          bubbles: true,
          cancelable: true,
          clientX,
          clientY
        });
        document.dispatchEvent(event);
        return this._promise;
      }
      /**
       * Handle the DOM events for the drag operation.
       *
       * @param event - The DOM event sent to the drag object.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the document. It should not be
       * called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          default:
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * Move the drag image element to the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        let style = this.dragImage.style;
        style.transform = `translate(${clientX}px, ${clientY}px)`;
      }
      /**
       * Handle the `'pointermove'` event for the drag object.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        this._updateCurrentTarget(event);
        this._updateDragScroll(event);
        this.moveDragImage(event.clientX, event.clientY);
      }
      /**
       * Handle the `'pointerup'` event for the drag object.
       */
      _evtPointerUp(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.button !== 0) {
          return;
        }
        this._updateCurrentTarget(event);
        if (!this._currentTarget) {
          this._finalize("none");
          return;
        }
        if (this._dropAction === "none") {
          Private20.dispatchDragLeave(this, this._currentTarget, null, event);
          this._finalize("none");
          return;
        }
        let action = Private20.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
      }
      /**
       * Handle the `'keydown'` event for the drag object.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this.dispose();
        }
      }
      /**
       * Add the document event listeners for the drag object.
       */
      _addListeners() {
        document.addEventListener("pointerdown", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointerenter", this, true);
        document.addEventListener("pointerleave", this, true);
        document.addEventListener("pointerover", this, true);
        document.addEventListener("pointerout", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("keyup", this, true);
        document.addEventListener("keypress", this, true);
        document.addEventListener("contextmenu", this, true);
      }
      /**
       * Remove the document event listeners for the drag object.
       */
      _removeListeners() {
        document.removeEventListener("pointerdown", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointerenter", this, true);
        document.removeEventListener("pointerleave", this, true);
        document.removeEventListener("pointerover", this, true);
        document.removeEventListener("pointerout", this, true);
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("keyup", this, true);
        document.removeEventListener("keypress", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Update the drag scroll element under the mouse.
       */
      _updateDragScroll(event) {
        let target = Private20.findScrollTarget(event);
        if (!this._scrollTarget && !target) {
          return;
        }
        if (!this._scrollTarget) {
          setTimeout(this._onScrollFrame, 500);
        }
        this._scrollTarget = target;
      }
      /**
       * Update the current target node using the given mouse event.
       */
      _updateCurrentTarget(event) {
        let prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        let prevElem = this._currentElement;
        let currElem = Private20.findElementBehindBackdrop(event, this.document);
        this._currentElement = currElem;
        if (currElem !== prevElem && currElem !== currTarget) {
          Private20.dispatchDragExit(this, currTarget, currElem, event);
        }
        if (currElem !== prevElem && currElem !== currTarget) {
          currTarget = Private20.dispatchDragEnter(this, currElem, currTarget, event);
        }
        if (currTarget !== prevTarget) {
          this._currentTarget = currTarget;
          Private20.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        let action = Private20.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
      }
      /**
       * Attach the drag image element at the specified location.
       *
       * This is a no-op if there is no drag image element.
       */
      _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
          return;
        }
        this.dragImage.classList.add("lm-mod-drag-image");
        let style = this.dragImage.style;
        style.pointerEvents = "none";
        style.position = "fixed";
        style.transform = `translate(${clientX}px, ${clientY}px)`;
        const body = this.document instanceof Document ? this.document.body : this.document.firstElementChild;
        body.appendChild(this.dragImage);
      }
      /**
       * Detach the drag image element from the DOM.
       *
       * This is a no-op if there is no drag image element.
       */
      _detachDragImage() {
        if (!this.dragImage) {
          return;
        }
        let parent = this.dragImage.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(this.dragImage);
      }
      /**
       * Set the internal drop action state and update the drag cursor.
       */
      _setDropAction(action) {
        action = Private20.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
          return;
        }
        switch (action) {
          case "none":
            this._dropAction = action;
            this._override = Drag4.overrideCursor("no-drop", this.document);
            break;
          case "copy":
            this._dropAction = action;
            this._override = Drag4.overrideCursor("copy", this.document);
            break;
          case "link":
            this._dropAction = action;
            this._override = Drag4.overrideCursor("alias", this.document);
            break;
          case "move":
            this._dropAction = action;
            this._override = Drag4.overrideCursor("move", this.document);
            break;
        }
      }
      /**
       * Finalize the drag operation and resolve the drag promise.
       */
      _finalize(action) {
        let resolve = this._resolve;
        this._removeListeners();
        this._detachDragImage();
        if (this._override) {
          this._override.dispose();
          this._override = null;
        }
        this.mimeData.clear();
        this._disposed = true;
        this._dropAction = "none";
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        if (resolve) {
          resolve(action);
        }
      }
    };
    (function(Drag5) {
      class Event2 extends DragEvent {
        constructor(event, options) {
          super(options.type, {
            bubbles: true,
            cancelable: true,
            altKey: event.altKey,
            button: event.button,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            detail: 0,
            metaKey: event.metaKey,
            relatedTarget: options.related,
            screenX: event.screenX,
            screenY: event.screenY,
            shiftKey: event.shiftKey,
            view: window
          });
          const { drag } = options;
          this.dropAction = "none";
          this.mimeData = drag.mimeData;
          this.proposedAction = drag.proposedAction;
          this.supportedActions = drag.supportedActions;
          this.source = drag.source;
        }
      }
      Drag5.Event = Event2;
      function overrideCursor(cursor, doc = document) {
        return Private20.overrideCursor(cursor, doc);
      }
      Drag5.overrideCursor = overrideCursor;
    })(Drag4 || (Drag4 = {}));
    (function(Private22) {
      Private22.SCROLL_EDGE_SIZE = 20;
      function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : "none";
      }
      Private22.validateAction = validateAction;
      function findElementBehindBackdrop(event, root2 = document) {
        if (event) {
          if (lastElementEventSearch && event == lastElementEventSearch.event) {
            return lastElementEventSearch.element;
          }
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(event.clientX, event.clientY);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementEventSearch = { event, element: element2 };
          return element2;
        } else {
          const transform = Private22.cursorBackdrop.style.transform;
          if (lastElementSearch && transform === lastElementSearch.transform) {
            return lastElementSearch.element;
          }
          const bbox = Private22.cursorBackdrop.getBoundingClientRect();
          Private22.cursorBackdrop.style.zIndex = "-1000";
          const element2 = root2.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);
          Private22.cursorBackdrop.style.zIndex = "";
          lastElementSearch = { transform, element: element2 };
          return element2;
        }
      }
      Private22.findElementBehindBackdrop = findElementBehindBackdrop;
      let lastElementEventSearch = null;
      let lastElementSearch = null;
      function findScrollTarget(event) {
        let x2 = event.clientX;
        let y4 = event.clientY;
        let element2 = findElementBehindBackdrop(event);
        for (; element2; element2 = element2.parentElement) {
          if (!element2.hasAttribute("data-lm-dragscroll")) {
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (element2 === document.body) {
            offsetX = window.pageXOffset;
            offsetY = window.pageYOffset;
          }
          let r4 = element2.getBoundingClientRect();
          let top = r4.top + offsetY;
          let left = r4.left + offsetX;
          let right = left + r4.width;
          let bottom = top + r4.height;
          if (x2 < left || x2 >= right || y4 < top || y4 >= bottom) {
            continue;
          }
          let dl = x2 - left + 1;
          let dt = y4 - top + 1;
          let dr = right - x2;
          let db = bottom - y4;
          let distance = Math.min(dl, dt, dr, db);
          if (distance > Private22.SCROLL_EDGE_SIZE) {
            continue;
          }
          let edge;
          switch (distance) {
            case db:
              edge = "bottom";
              break;
            case dt:
              edge = "top";
              break;
            case dr:
              edge = "right";
              break;
            case dl:
              edge = "left";
              break;
            default:
              throw "unreachable";
          }
          let dsw = element2.scrollWidth - element2.clientWidth;
          let dsh = element2.scrollHeight - element2.clientHeight;
          let shouldScroll;
          switch (edge) {
            case "top":
              shouldScroll = dsh > 0 && element2.scrollTop > 0;
              break;
            case "left":
              shouldScroll = dsw > 0 && element2.scrollLeft > 0;
              break;
            case "right":
              shouldScroll = dsw > 0 && element2.scrollLeft < dsw;
              break;
            case "bottom":
              shouldScroll = dsh > 0 && element2.scrollTop < dsh;
              break;
            default:
              throw "unreachable";
          }
          if (!shouldScroll) {
            continue;
          }
          return { element: element2, edge, distance };
        }
        return null;
      }
      Private22.findScrollTarget = findScrollTarget;
      function dispatchDragEnter(drag, currElem, currTarget, event) {
        if (!currElem) {
          return null;
        }
        let dragEvent = new Drag4.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        let canceled = !currElem.dispatchEvent(dragEvent);
        if (canceled) {
          return currElem;
        }
        const body = drag.document instanceof Document ? drag.document.body : drag.document.firstElementChild;
        if (currElem === body) {
          return currTarget;
        }
        dragEvent = new Drag4.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragenter"
        });
        body.dispatchEvent(dragEvent);
        return body;
      }
      Private22.dispatchDragEnter = dispatchDragEnter;
      function dispatchDragExit(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag4.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragexit"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragExit = dispatchDragExit;
      function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        if (!prevTarget) {
          return;
        }
        let dragEvent = new Drag4.Event(event, {
          drag,
          related: currTarget,
          type: "lm-dragleave"
        });
        prevTarget.dispatchEvent(dragEvent);
      }
      Private22.dispatchDragLeave = dispatchDragLeave;
      function dispatchDragOver(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag4.Event(event, {
          drag,
          related: null,
          type: "lm-dragover"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDragOver = dispatchDragOver;
      function dispatchDrop(drag, currTarget, event) {
        if (!currTarget) {
          return "none";
        }
        let dragEvent = new Drag4.Event(event, {
          drag,
          related: null,
          type: "lm-drop"
        });
        let canceled = !currTarget.dispatchEvent(dragEvent);
        if (canceled) {
          return dragEvent.dropAction;
        }
        return "none";
      }
      Private22.dispatchDrop = dispatchDrop;
      const actionTable = {
        none: 0,
        copy: 1,
        link: 2,
        move: 4
      };
      const supportedTable = {
        none: actionTable["none"],
        copy: actionTable["copy"],
        link: actionTable["link"],
        move: actionTable["move"],
        "copy-link": actionTable["copy"] | actionTable["link"],
        "copy-move": actionTable["copy"] | actionTable["move"],
        "link-move": actionTable["link"] | actionTable["move"],
        all: actionTable["copy"] | actionTable["link"] | actionTable["move"]
      };
      function overrideCursor(cursor, doc = document) {
        let id = ++overrideCursorID;
        const body = doc instanceof Document ? doc.body : doc.firstElementChild;
        if (!Private22.cursorBackdrop.isConnected) {
          Private22.cursorBackdrop.style.transform = "scale(0)";
          body.appendChild(Private22.cursorBackdrop);
          resetBackdropScroll();
          document.addEventListener("pointermove", alignBackdrop, {
            capture: true,
            passive: true
          });
          Private22.cursorBackdrop.addEventListener("scroll", propagateBackdropScroll, {
            capture: true,
            passive: true
          });
        }
        Private22.cursorBackdrop.style.cursor = cursor;
        return new DisposableDelegate(() => {
          if (id === overrideCursorID && Private22.cursorBackdrop.isConnected) {
            document.removeEventListener("pointermove", alignBackdrop, true);
            Private22.cursorBackdrop.removeEventListener("scroll", propagateBackdropScroll, true);
            body.removeChild(Private22.cursorBackdrop);
          }
        });
      }
      Private22.overrideCursor = overrideCursor;
      function alignBackdrop(event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        Private22.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;
      }
      function propagateBackdropScroll(_event) {
        if (!Private22.cursorBackdrop) {
          return;
        }
        let element2 = findElementBehindBackdrop();
        if (!element2) {
          return;
        }
        const scrollTarget = element2.closest("[data-lm-dragscroll]");
        if (!scrollTarget) {
          return;
        }
        scrollTarget.scrollTop += Private22.cursorBackdrop.scrollTop - backdropScrollOrigin;
        scrollTarget.scrollLeft += Private22.cursorBackdrop.scrollLeft - backdropScrollOrigin;
        resetBackdropScroll();
      }
      function resetBackdropScroll() {
        Private22.cursorBackdrop.scrollTop = backdropScrollOrigin;
        Private22.cursorBackdrop.scrollLeft = backdropScrollOrigin;
      }
      const backdropScrollOrigin = 500;
      function createCursorBackdrop() {
        const backdrop = document.createElement("div");
        backdrop.classList.add("lm-cursor-backdrop");
        return backdrop;
      }
      let overrideCursorID = 0;
      Private22.cursorBackdrop = createCursorBackdrop();
    })(Private20 || (Private20 = {}));
  }
});

// ../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/widgets/dist/index.es6.js
var import_coreutils19, BoxSizer4, BoxEngine4, Title5, Widget5, Private$j4, Layout4, LayoutItem4, Private$i4, PanelLayout5, Utils4, Utils$14, SplitLayout4, Private$h4, AccordionLayout4, Private$g4, Panel5, Private$f4, SplitPanel4, Private$e4, AccordionPanel4, Private$d4, BoxLayout4, Private$c4, BoxPanel4, Private$b4, CommandPalette4, Private$a4, Menu4, Private$94, Private$84, ARROW_KEYS4, TabBar5, Private$74, DockLayout4, Private$64, DockPanel4, Private$54, GridLayout4, Private$44, MenuBar4, Private$34, Private$24, SingletonLayout4, StackedLayout4, Private$14, Private21;
var init_index_es626 = __esm({
  "../../node_modules/@jupyterlab/json-extension/node_modules/@lumino/widgets/dist/index.es6.js"() {
    init_index_es6();
    import_coreutils19 = __toESM(require_dist());
    init_index_es65();
    init_index_es624();
    init_index_es64();
    init_index_es62();
    init_index_es625();
    init_index_es67();
    init_index_es68();
    init_index_es63();
    init_index_es66();
    BoxSizer4 = class {
      constructor() {
        this.sizeHint = 0;
        this.minSize = 0;
        this.maxSize = Infinity;
        this.stretch = 1;
        this.size = 0;
        this.done = false;
      }
    };
    (function(BoxEngine5) {
      function calc(sizers, space) {
        let count3 = sizers.length;
        if (count3 === 0) {
          return space;
        }
        let totalMin = 0;
        let totalMax = 0;
        let totalSize = 0;
        let totalStretch = 0;
        let stretchCount = 0;
        for (let i6 = 0; i6 < count3; ++i6) {
          let sizer = sizers[i6];
          let min3 = sizer.minSize;
          let max4 = sizer.maxSize;
          let hint = sizer.sizeHint;
          sizer.done = false;
          sizer.size = Math.max(min3, Math.min(hint, max4));
          totalSize += sizer.size;
          totalMin += min3;
          totalMax += max4;
          if (sizer.stretch > 0) {
            totalStretch += sizer.stretch;
            stretchCount++;
          }
        }
        if (space === totalSize) {
          return 0;
        }
        if (space <= totalMin) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.minSize;
          }
          return space - totalMin;
        }
        if (space >= totalMax) {
          for (let i6 = 0; i6 < count3; ++i6) {
            let sizer = sizers[i6];
            sizer.size = sizer.maxSize;
          }
          return space - totalMax;
        }
        let nearZero = 0.01;
        let notDoneCount = count3;
        if (space < totalSize) {
          let freeSpace = totalSize - space;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size - amt <= sizer.minSize) {
                freeSpace -= sizer.size - sizer.minSize;
                sizer.size = sizer.minSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size -= amt;
              }
            }
          }
        } else {
          let freeSpace = space - totalSize;
          while (stretchCount > 0 && freeSpace > nearZero) {
            let distSpace = freeSpace;
            let distStretch = totalStretch;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done || sizer.stretch === 0) {
                continue;
              }
              let amt = sizer.stretch * distSpace / distStretch;
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                totalStretch -= sizer.stretch;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
                stretchCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
          while (notDoneCount > 0 && freeSpace > nearZero) {
            let amt = freeSpace / notDoneCount;
            for (let i6 = 0; i6 < count3; ++i6) {
              let sizer = sizers[i6];
              if (sizer.done) {
                continue;
              }
              if (sizer.size + amt >= sizer.maxSize) {
                freeSpace -= sizer.maxSize - sizer.size;
                sizer.size = sizer.maxSize;
                sizer.done = true;
                notDoneCount--;
              } else {
                freeSpace -= amt;
                sizer.size += amt;
              }
            }
          }
        }
        return 0;
      }
      BoxEngine5.calc = calc;
      function adjust(sizers, index2, delta) {
        if (sizers.length === 0 || delta === 0) {
          return;
        }
        if (delta > 0) {
          growSizer(sizers, index2, delta);
        } else {
          shrinkSizer(sizers, index2, -delta);
        }
      }
      BoxEngine5.adjust = adjust;
      function growSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2; i6 >= 0 && grow > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && shrink > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
      function shrinkSizer(sizers, index2, delta) {
        let growLimit = 0;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5; ++i6) {
          let sizer = sizers[i6];
          growLimit += sizer.maxSize - sizer.size;
        }
        let shrinkLimit = 0;
        for (let i6 = 0; i6 <= index2; ++i6) {
          let sizer = sizers[i6];
          shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        let grow = delta;
        for (let i6 = index2 + 1, n5 = sizers.length; i6 < n5 && grow > 0; ++i6) {
          let sizer = sizers[i6];
          let limit = sizer.maxSize - sizer.size;
          if (limit >= grow) {
            sizer.sizeHint = sizer.size + grow;
            grow = 0;
          } else {
            sizer.sizeHint = sizer.size + limit;
            grow -= limit;
          }
        }
        let shrink = delta;
        for (let i6 = index2; i6 >= 0 && shrink > 0; --i6) {
          let sizer = sizers[i6];
          let limit = sizer.size - sizer.minSize;
          if (limit >= shrink) {
            sizer.sizeHint = sizer.size - shrink;
            shrink = 0;
          } else {
            sizer.sizeHint = sizer.size - limit;
            shrink -= limit;
          }
        }
      }
    })(BoxEngine4 || (BoxEngine4 = {}));
    Title5 = class {
      /**
       * Construct a new title.
       *
       * @param options - The options for initializing the title.
       */
      constructor(options) {
        this._label = "";
        this._caption = "";
        this._mnemonic = -1;
        this._icon = void 0;
        this._iconClass = "";
        this._iconLabel = "";
        this._className = "";
        this._closable = false;
        this._changed = new Signal(this);
        this._isDisposed = false;
        this.owner = options.owner;
        if (options.label !== void 0) {
          this._label = options.label;
        }
        if (options.mnemonic !== void 0) {
          this._mnemonic = options.mnemonic;
        }
        if (options.icon !== void 0) {
          this._icon = options.icon;
        }
        if (options.iconClass !== void 0) {
          this._iconClass = options.iconClass;
        }
        if (options.iconLabel !== void 0) {
          this._iconLabel = options.iconLabel;
        }
        if (options.caption !== void 0) {
          this._caption = options.caption;
        }
        if (options.className !== void 0) {
          this._className = options.className;
        }
        if (options.closable !== void 0) {
          this._closable = options.closable;
        }
        this._dataset = options.dataset || {};
      }
      /**
       * A signal emitted when the state of the title changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Get the label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get label() {
        return this._label;
      }
      /**
       * Set the label for the title.
       */
      set label(value) {
        if (this._label === value) {
          return;
        }
        this._label = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the mnemonic index for the title.
       *
       * #### Notes
       * The default value is `-1`.
       */
      get mnemonic() {
        return this._mnemonic;
      }
      /**
       * Set the mnemonic index for the title.
       */
      set mnemonic(value) {
        if (this._mnemonic === value) {
          return;
        }
        this._mnemonic = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon renderer for the title.
       *
       * #### Notes
       * The default value is undefined.
       */
      get icon() {
        return this._icon;
      }
      /**
       * Set the icon renderer for the title.
       *
       * #### Notes
       * A renderer is an object that supplies a render and unrender function.
       */
      set icon(value) {
        if (this._icon === value) {
          return;
        }
        this._icon = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconClass() {
        return this._iconClass;
      }
      /**
       * Set the icon class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconClass(value) {
        if (this._iconClass === value) {
          return;
        }
        this._iconClass = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the icon label for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get iconLabel() {
        return this._iconLabel;
      }
      /**
       * Set the icon label for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set iconLabel(value) {
        if (this._iconLabel === value) {
          return;
        }
        this._iconLabel = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the caption for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get caption() {
        return this._caption;
      }
      /**
       * Set the caption for the title.
       */
      set caption(value) {
        if (this._caption === value) {
          return;
        }
        this._caption = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the extra class name for the title.
       *
       * #### Notes
       * The default value is an empty string.
       */
      get className() {
        return this._className;
      }
      /**
       * Set the extra class name for the title.
       *
       * #### Notes
       * Multiple class names can be separated with whitespace.
       */
      set className(value) {
        if (this._className === value) {
          return;
        }
        this._className = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the closable state for the title.
       *
       * #### Notes
       * The default value is `false`.
       */
      get closable() {
        return this._closable;
      }
      /**
       * Set the closable state for the title.
       *
       * #### Notes
       * This controls the presence of a close icon when applicable.
       */
      set closable(value) {
        if (this._closable === value) {
          return;
        }
        this._closable = value;
        this._changed.emit(void 0);
      }
      /**
       * Get the dataset for the title.
       *
       * #### Notes
       * The default value is an empty dataset.
       */
      get dataset() {
        return this._dataset;
      }
      /**
       * Set the dataset for the title.
       *
       * #### Notes
       * This controls the data attributes when applicable.
       */
      set dataset(value) {
        if (this._dataset === value) {
          return;
        }
        this._dataset = value;
        this._changed.emit(void 0);
      }
      /**
       * Test whether the title has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the title.
       *
       * #### Notes
       * It is the responsibility of the owner to call the title disposal.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
      }
    };
    Widget5 = class {
      /**
       * Construct a new widget.
       *
       * @param options - The options for initializing the widget.
       */
      constructor(options = {}) {
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this._disposed = new Signal(this);
        this._hiddenMode = Widget5.HiddenMode.Display;
        this.node = Private$j4.createNode(options);
        this.addClass("lm-Widget");
      }
      /**
       * Dispose of the widget and its descendant widgets.
       *
       * #### Notes
       * It is unsafe to use the widget after it has been disposed.
       *
       * All calls made to this method after the first are a no-op.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.setFlag(Widget5.Flag.IsDisposed);
        this._disposed.emit(void 0);
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget5.detach(this);
        }
        if (this._layout) {
          this._layout.dispose();
          this._layout = null;
        }
        this.title.dispose();
        Signal.clearData(this);
        MessageLoop5.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * A signal emitted when the widget is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the widget has been disposed.
       */
      get isDisposed() {
        return this.testFlag(Widget5.Flag.IsDisposed);
      }
      /**
       * Test whether the widget's node is attached to the DOM.
       */
      get isAttached() {
        return this.testFlag(Widget5.Flag.IsAttached);
      }
      /**
       * Test whether the widget is explicitly hidden.
       *
       * #### Notes
       * You should prefer `!{@link isVisible}` over `{@link isHidden}` if you want to know if the
       * widget is hidden as this does not test if the widget is hidden because one of its ancestors is hidden.
       */
      get isHidden() {
        return this.testFlag(Widget5.Flag.IsHidden);
      }
      /**
       * Test whether the widget is visible.
       *
       * #### Notes
       * A widget is visible when it is attached to the DOM, is not
       * explicitly hidden, and has no explicitly hidden ancestors.
       *
       * Since 2.7.0, this does not rely on the {@link Widget.Flag.IsVisible} flag.
       * It recursively checks the visibility of all parent widgets.
       */
      get isVisible() {
        let parent = this;
        do {
          if (parent.isHidden || !parent.isAttached) {
            return false;
          }
          parent = parent.parent;
        } while (parent != null);
        return true;
      }
      /**
       * The title object for the widget.
       *
       * #### Notes
       * The title object is used by some container widgets when displaying
       * the widget alongside some title, such as a tab panel or side bar.
       *
       * Since not all widgets will use the title, it is created on demand.
       *
       * The `owner` property of the title is set to this widget.
       */
      get title() {
        return Private$j4.titleProperty.get(this);
      }
      /**
       * Get the id of the widget's DOM node.
       */
      get id() {
        return this.node.id;
      }
      /**
       * Set the id of the widget's DOM node.
       */
      set id(value) {
        this.node.id = value;
      }
      /**
       * The dataset for the widget's DOM node.
       */
      get dataset() {
        return this.node.dataset;
      }
      /**
       * Get the method for hiding the widget.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding the widget.
       */
      set hiddenMode(value) {
        if (this._hiddenMode === value) {
          return;
        }
        if (this.isHidden) {
          this._toggleHidden(false);
        }
        if (value == Widget5.HiddenMode.Scale) {
          this.node.style.willChange = "transform";
        } else {
          this.node.style.willChange = "auto";
        }
        this._hiddenMode = value;
        if (this.isHidden) {
          this._toggleHidden(true);
        }
      }
      /**
       * Get the parent of the widget.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent of the widget.
       *
       * #### Notes
       * Children are typically added to a widget by using a layout, which
       * means user code will not normally set the parent widget directly.
       *
       * The widget will be automatically removed from its old parent.
       *
       * This is a no-op if there is no effective parent change.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (value && this.contains(value)) {
          throw new Error("Invalid parent widget.");
        }
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget5.ChildMessage("child-removed", this);
          MessageLoop5.sendMessage(this._parent, msg);
        }
        this._parent = value;
        if (this._parent && !this._parent.isDisposed) {
          let msg = new Widget5.ChildMessage("child-added", this);
          MessageLoop5.sendMessage(this._parent, msg);
        }
        if (!this.isDisposed) {
          MessageLoop5.sendMessage(this, Widget5.Msg.ParentChanged);
        }
      }
      /**
       * Get the layout for the widget.
       */
      get layout() {
        return this._layout;
      }
      /**
       * Set the layout for the widget.
       *
       * #### Notes
       * The layout is single-use only. It cannot be changed after the
       * first assignment.
       *
       * The layout is disposed automatically when the widget is disposed.
       */
      set layout(value) {
        if (this._layout === value) {
          return;
        }
        if (this.testFlag(Widget5.Flag.DisallowLayout)) {
          throw new Error("Cannot set widget layout.");
        }
        if (this._layout) {
          throw new Error("Cannot change widget layout.");
        }
        if (value.parent) {
          throw new Error("Cannot change layout parent.");
        }
        this._layout = value;
        value.parent = this;
      }
      /**
       * Create an iterator over the widget's children.
       *
       * @returns A new iterator over the children of the widget.
       *
       * #### Notes
       * The widget must have a populated layout in order to have children.
       *
       * If a layout is not installed, the returned iterator will be empty.
       */
      *children() {
        if (this._layout) {
          yield* this._layout;
        }
      }
      /**
       * Test whether a widget is a descendant of this widget.
       *
       * @param widget - The descendant widget of interest.
       *
       * @returns `true` if the widget is a descendant, `false` otherwise.
       */
      contains(widget) {
        for (let value = widget; value; value = value._parent) {
          if (value === this) {
            return true;
          }
        }
        return false;
      }
      /**
       * Test whether the widget's DOM node has the given class name.
       *
       * @param name - The class name of interest.
       *
       * @returns `true` if the node has the class, `false` otherwise.
       */
      hasClass(name) {
        return this.node.classList.contains(name);
      }
      /**
       * Add a class name to the widget's DOM node.
       *
       * @param name - The class name to add to the node.
       *
       * #### Notes
       * If the class name is already added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      addClass(name) {
        this.node.classList.add(name);
      }
      /**
       * Remove a class name from the widget's DOM node.
       *
       * @param name - The class name to remove from the node.
       *
       * #### Notes
       * If the class name is not yet added to the node, this is a no-op.
       *
       * The class name must not contain whitespace.
       */
      removeClass(name) {
        this.node.classList.remove(name);
      }
      /**
       * Toggle a class name on the widget's DOM node.
       *
       * @param name - The class name to toggle on the node.
       *
       * @param force - Whether to force add the class (`true`) or force
       *   remove the class (`false`). If not provided, the presence of
       *   the class will be toggled from its current state.
       *
       * @returns `true` if the class is now present, `false` otherwise.
       *
       * #### Notes
       * The class name must not contain whitespace.
       */
      toggleClass(name, force) {
        if (force === true) {
          this.node.classList.add(name);
          return true;
        }
        if (force === false) {
          this.node.classList.remove(name);
          return false;
        }
        return this.node.classList.toggle(name);
      }
      /**
       * Post an `'update-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      update() {
        MessageLoop5.postMessage(this, Widget5.Msg.UpdateRequest);
      }
      /**
       * Post a `'fit-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      fit() {
        MessageLoop5.postMessage(this, Widget5.Msg.FitRequest);
      }
      /**
       * Post an `'activate-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for posting the message.
       */
      activate() {
        MessageLoop5.postMessage(this, Widget5.Msg.ActivateRequest);
      }
      /**
       * Send a `'close-request'` message to the widget.
       *
       * #### Notes
       * This is a simple convenience method for sending the message.
       */
      close() {
        MessageLoop5.sendMessage(this, Widget5.Msg.CloseRequest);
      }
      /**
       * Show the widget and make it visible to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `false`.
       *
       * If the widget is not explicitly hidden, this is a no-op.
       */
      show() {
        if (!this.testFlag(Widget5.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop5.sendMessage(this, Widget5.Msg.BeforeShow);
        }
        this.clearFlag(Widget5.Flag.IsHidden);
        this._toggleHidden(false);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop5.sendMessage(this, Widget5.Msg.AfterShow);
        }
        if (this.parent) {
          let msg = new Widget5.ChildMessage("child-shown", this);
          MessageLoop5.sendMessage(this.parent, msg);
        }
      }
      /**
       * Hide the widget and make it hidden to its parent widget.
       *
       * #### Notes
       * This causes the {@link isHidden} property to be `true`.
       *
       * If the widget is explicitly hidden, this is a no-op.
       */
      hide() {
        if (this.testFlag(Widget5.Flag.IsHidden)) {
          return;
        }
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop5.sendMessage(this, Widget5.Msg.BeforeHide);
        }
        this.setFlag(Widget5.Flag.IsHidden);
        this._toggleHidden(true);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
          MessageLoop5.sendMessage(this, Widget5.Msg.AfterHide);
        }
        if (this.parent) {
          let msg = new Widget5.ChildMessage("child-hidden", this);
          MessageLoop5.sendMessage(this.parent, msg);
        }
      }
      /**
       * Show or hide the widget according to a boolean value.
       *
       * @param hidden - `true` to hide the widget, or `false` to show it.
       *
       * #### Notes
       * This is a convenience method for `hide()` and `show()`.
       */
      setHidden(hidden) {
        if (hidden) {
          this.hide();
        } else {
          this.show();
        }
      }
      /**
       * Test whether the given widget flag is set.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      testFlag(flag) {
        return (this._flags & flag) !== 0;
      }
      /**
       * Set the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      setFlag(flag) {
        this._flags |= flag;
      }
      /**
       * Clear the given widget flag.
       *
       * #### Notes
       * This will not typically be called directly by user code.
       *
       * Since 2.7.0, {@link Widget.Flag.IsVisible} is deprecated.
       * It will be removed in a future version.
       */
      clearFlag(flag) {
        this._flags &= ~flag;
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       *
       * #### Notes
       * Subclasses may reimplement this method as needed.
       */
      processMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.notifyLayout(msg);
            this.onResize(msg);
            break;
          case "update-request":
            this.notifyLayout(msg);
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.notifyLayout(msg);
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.notifyLayout(msg);
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.setFlag(Widget5.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.notifyLayout(msg);
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.clearFlag(Widget5.Flag.IsVisible);
            this.notifyLayout(msg);
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.notifyLayout(msg);
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            if (!this.isHidden && (!this.parent || this.parent.isVisible)) {
              this.setFlag(Widget5.Flag.IsVisible);
            }
            this.setFlag(Widget5.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.notifyLayout(msg);
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.clearFlag(Widget5.Flag.IsVisible);
            this.clearFlag(Widget5.Flag.IsAttached);
            this.notifyLayout(msg);
            this.onAfterDetach(msg);
            break;
          case "activate-request":
            this.notifyLayout(msg);
            this.onActivateRequest(msg);
            break;
          case "close-request":
            this.notifyLayout(msg);
            this.onCloseRequest(msg);
            break;
          case "child-added":
            this.notifyLayout(msg);
            this.onChildAdded(msg);
            break;
          case "child-removed":
            this.notifyLayout(msg);
            this.onChildRemoved(msg);
            break;
          default:
            this.notifyLayout(msg);
            break;
        }
      }
      /**
       * Invoke the message processing routine of the widget's layout.
       *
       * @param msg - The message to dispatch to the layout.
       *
       * #### Notes
       * This is a no-op if the widget does not have a layout.
       *
       * This will not typically be called directly by user code.
       */
      notifyLayout(msg) {
        if (this._layout) {
          this._layout.processParentMessage(msg);
        }
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       *
       * #### Notes
       * The default implementation unparents or detaches the widget.
       */
      onCloseRequest(msg) {
        if (this.parent) {
          this.parent = null;
        } else if (this.isAttached) {
          Widget5.detach(this);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onResize(msg) {
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onUpdateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onActivateRequest(msg) {
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeShow(msg) {
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterShow(msg) {
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeHide(msg) {
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterHide(msg) {
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeAttach(msg) {
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterAttach(msg) {
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onBeforeDetach(msg) {
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onAfterDetach(msg) {
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildAdded(msg) {
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildRemoved(msg) {
      }
      _toggleHidden(hidden) {
        if (hidden) {
          switch (this._hiddenMode) {
            case Widget5.HiddenMode.Display:
              this.addClass("lm-mod-hidden");
              break;
            case Widget5.HiddenMode.Scale:
              this.node.style.transform = "scale(0)";
              this.node.setAttribute("aria-hidden", "true");
              break;
            case Widget5.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "hidden";
              this.node.style.zIndex = "-1";
              break;
          }
        } else {
          switch (this._hiddenMode) {
            case Widget5.HiddenMode.Display:
              this.removeClass("lm-mod-hidden");
              break;
            case Widget5.HiddenMode.Scale:
              this.node.style.transform = "";
              this.node.removeAttribute("aria-hidden");
              break;
            case Widget5.HiddenMode.ContentVisibility:
              this.node.style.contentVisibility = "";
              this.node.style.zIndex = "";
              break;
          }
        }
      }
    };
    (function(Widget6) {
      (function(HiddenMode) {
        HiddenMode[HiddenMode["Display"] = 0] = "Display";
        HiddenMode[HiddenMode["Scale"] = 1] = "Scale";
        HiddenMode[HiddenMode["ContentVisibility"] = 2] = "ContentVisibility";
      })(Widget6.HiddenMode || (Widget6.HiddenMode = {}));
      (function(Flag) {
        Flag[Flag["IsDisposed"] = 1] = "IsDisposed";
        Flag[Flag["IsAttached"] = 2] = "IsAttached";
        Flag[Flag["IsHidden"] = 4] = "IsHidden";
        Flag[Flag["IsVisible"] = 8] = "IsVisible";
        Flag[Flag["DisallowLayout"] = 16] = "DisallowLayout";
      })(Widget6.Flag || (Widget6.Flag = {}));
      (function(Msg) {
        Msg.BeforeShow = new Message4("before-show");
        Msg.AfterShow = new Message4("after-show");
        Msg.BeforeHide = new Message4("before-hide");
        Msg.AfterHide = new Message4("after-hide");
        Msg.BeforeAttach = new Message4("before-attach");
        Msg.AfterAttach = new Message4("after-attach");
        Msg.BeforeDetach = new Message4("before-detach");
        Msg.AfterDetach = new Message4("after-detach");
        Msg.ParentChanged = new Message4("parent-changed");
        Msg.UpdateRequest = new ConflatableMessage4("update-request");
        Msg.FitRequest = new ConflatableMessage4("fit-request");
        Msg.ActivateRequest = new ConflatableMessage4("activate-request");
        Msg.CloseRequest = new ConflatableMessage4("close-request");
      })(Widget6.Msg || (Widget6.Msg = {}));
      class ChildMessage extends Message4 {
        /**
         * Construct a new child message.
         *
         * @param type - The message type.
         *
         * @param child - The child widget for the message.
         */
        constructor(type, child) {
          super(type);
          this.child = child;
        }
      }
      Widget6.ChildMessage = ChildMessage;
      class ResizeMessage extends Message4 {
        /**
         * Construct a new resize message.
         *
         * @param width - The **offset width** of the widget, or `-1` if
         *   the width is not known.
         *
         * @param height - The **offset height** of the widget, or `-1` if
         *   the height is not known.
         */
        constructor(width, height) {
          super("resize");
          this.width = width;
          this.height = height;
        }
      }
      Widget6.ResizeMessage = ResizeMessage;
      (function(ResizeMessage2) {
        ResizeMessage2.UnknownSize = new ResizeMessage2(-1, -1);
      })(ResizeMessage = Widget6.ResizeMessage || (Widget6.ResizeMessage = {}));
      function attach(widget, host, ref = null) {
        if (widget.parent) {
          throw new Error("Cannot attach a child widget.");
        }
        if (widget.isAttached || widget.node.isConnected) {
          throw new Error("Widget is already attached.");
        }
        if (!host.isConnected) {
          throw new Error("Host is not attached.");
        }
        MessageLoop5.sendMessage(widget, Widget6.Msg.BeforeAttach);
        host.insertBefore(widget.node, ref);
        MessageLoop5.sendMessage(widget, Widget6.Msg.AfterAttach);
      }
      Widget6.attach = attach;
      function detach(widget) {
        if (widget.parent) {
          throw new Error("Cannot detach a child widget.");
        }
        if (!widget.isAttached || !widget.node.isConnected) {
          throw new Error("Widget is not attached.");
        }
        MessageLoop5.sendMessage(widget, Widget6.Msg.BeforeDetach);
        widget.node.parentNode.removeChild(widget.node);
        MessageLoop5.sendMessage(widget, Widget6.Msg.AfterDetach);
      }
      Widget6.detach = detach;
    })(Widget5 || (Widget5 = {}));
    (function(Private22) {
      Private22.titleProperty = new AttachedProperty({
        name: "title",
        create: (owner) => new Title5({ owner })
      });
      function createNode(options) {
        return options.node || document.createElement(options.tag || "div");
      }
      Private22.createNode = createNode;
    })(Private$j4 || (Private$j4 = {}));
    Layout4 = class {
      /**
       * Construct a new layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        this._disposed = false;
        this._parent = null;
        this._fitPolicy = options.fitPolicy || "set-min-size";
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This should be reimplemented to clear and dispose of the widgets.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        this._parent = null;
        this._disposed = true;
        Signal.clearData(this);
        AttachedProperty.clearData(this);
      }
      /**
       * Test whether the layout is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Get the parent widget of the layout.
       */
      get parent() {
        return this._parent;
      }
      /**
       * Set the parent widget of the layout.
       *
       * #### Notes
       * This is set automatically when installing the layout on the parent
       * widget. The parent widget should not be set directly by user code.
       */
      set parent(value) {
        if (this._parent === value) {
          return;
        }
        if (this._parent) {
          throw new Error("Cannot change parent widget.");
        }
        if (value.layout !== this) {
          throw new Error("Invalid parent widget.");
        }
        this._parent = value;
        this.init();
      }
      /**
       * Get the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       */
      get fitPolicy() {
        return this._fitPolicy;
      }
      /**
       * Set the fit policy for the layout.
       *
       * #### Notes
       * The fit policy controls the computed size constraints which are
       * applied to the parent widget by the layout.
       *
       * Some layout implementations may ignore the fit policy.
       *
       * Changing the fit policy will clear the current size constraint
       * for the parent widget and then re-fit the parent.
       */
      set fitPolicy(value) {
        if (this._fitPolicy === value) {
          return;
        }
        this._fitPolicy = value;
        if (this._parent) {
          let style = this._parent.node.style;
          style.minWidth = "";
          style.minHeight = "";
          style.maxWidth = "";
          style.maxHeight = "";
          this._parent.fit();
        }
      }
      /**
       * Process a message sent to the parent widget.
       *
       * @param msg - The message sent to the parent widget.
       *
       * #### Notes
       * This method is called by the parent widget to process a message.
       *
       * Subclasses may reimplement this method as needed.
       */
      processParentMessage(msg) {
        switch (msg.type) {
          case "resize":
            this.onResize(msg);
            break;
          case "update-request":
            this.onUpdateRequest(msg);
            break;
          case "fit-request":
            this.onFitRequest(msg);
            break;
          case "before-show":
            this.onBeforeShow(msg);
            break;
          case "after-show":
            this.onAfterShow(msg);
            break;
          case "before-hide":
            this.onBeforeHide(msg);
            break;
          case "after-hide":
            this.onAfterHide(msg);
            break;
          case "before-attach":
            this.onBeforeAttach(msg);
            break;
          case "after-attach":
            this.onAfterAttach(msg);
            break;
          case "before-detach":
            this.onBeforeDetach(msg);
            break;
          case "after-detach":
            this.onAfterDetach(msg);
            break;
          case "child-removed":
            this.onChildRemoved(msg);
            break;
          case "child-shown":
            this.onChildShown(msg);
            break;
          case "child-hidden":
            this.onChildHidden(msg);
            break;
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       *
       * #### Notes
       * This method is invoked immediately after the layout is installed
       * on the parent widget.
       *
       * The default implementation reparents all of the widgets to the
       * layout parent widget.
       *
       * Subclasses should reimplement this method and attach the child
       * widget nodes to the parent widget's node.
       */
      init() {
        for (const widget of this) {
          widget.parent = this.parent;
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the specified layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onResize(msg) {
        for (const widget of this) {
          MessageLoop5.sendMessage(widget, Widget5.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       *
       * #### Notes
       * The layout should ensure that its widgets are resized according
       * to the available layout space, and that they are sent a `'resize'`
       * message if appropriate.
       *
       * The default implementation of this method sends an `UnknownSize`
       * resize message to all widgets.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onUpdateRequest(msg) {
        for (const widget of this) {
          MessageLoop5.sendMessage(widget, Widget5.ResizeMessage.UnknownSize);
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeAttach(msg) {
        for (const widget of this) {
          MessageLoop5.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-attach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterAttach(msg) {
        for (const widget of this) {
          MessageLoop5.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeDetach(msg) {
        for (const widget of this) {
          MessageLoop5.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message
       * to all widgets. It assumes all widget nodes are attached to the
       * parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterDetach(msg) {
        for (const widget of this) {
          MessageLoop5.sendMessage(widget, msg);
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop5.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterShow(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop5.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'before-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onBeforeHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop5.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on an `'after-hide'` message.
       *
       * #### Notes
       * The default implementation of this method forwards the message to
       * all non-hidden widgets. It assumes all widget nodes are attached
       * to the parent widget node.
       *
       * This may be reimplemented by subclasses as needed.
       */
      onAfterHide(msg) {
        for (const widget of this) {
          if (!widget.isHidden) {
            MessageLoop5.sendMessage(widget, msg);
          }
        }
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       *
       * #### Notes
       * This will remove the child widget from the layout.
       *
       * Subclasses should **not** typically reimplement this method.
       */
      onChildRemoved(msg) {
        this.removeWidget(msg.child);
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onFitRequest(msg) {
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildShown(msg) {
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       *
       * #### Notes
       * The default implementation of this handler is a no-op.
       */
      onChildHidden(msg) {
      }
    };
    (function(Layout5) {
      function getHorizontalAlignment(widget) {
        return Private$i4.horizontalAlignmentProperty.get(widget);
      }
      Layout5.getHorizontalAlignment = getHorizontalAlignment;
      function setHorizontalAlignment(widget, value) {
        Private$i4.horizontalAlignmentProperty.set(widget, value);
      }
      Layout5.setHorizontalAlignment = setHorizontalAlignment;
      function getVerticalAlignment(widget) {
        return Private$i4.verticalAlignmentProperty.get(widget);
      }
      Layout5.getVerticalAlignment = getVerticalAlignment;
      function setVerticalAlignment(widget, value) {
        Private$i4.verticalAlignmentProperty.set(widget, value);
      }
      Layout5.setVerticalAlignment = setVerticalAlignment;
    })(Layout4 || (Layout4 = {}));
    LayoutItem4 = class {
      /**
       * Construct a new layout item.
       *
       * @param widget - The widget to be managed by the item.
       *
       * #### Notes
       * The widget will be set to absolute positioning.
       * The widget will use strict CSS containment.
       */
      constructor(widget) {
        this._top = NaN;
        this._left = NaN;
        this._width = NaN;
        this._height = NaN;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = Infinity;
        this._maxHeight = Infinity;
        this._disposed = false;
        this.widget = widget;
        this.widget.node.style.position = "absolute";
        this.widget.node.style.contain = "strict";
      }
      /**
       * Dispose of the the layout item.
       *
       * #### Notes
       * This will reset the positioning of the widget.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this._disposed = true;
        let style = this.widget.node.style;
        style.position = "";
        style.top = "";
        style.left = "";
        style.width = "";
        style.height = "";
        style.contain = "";
      }
      /**
       * The computed minimum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minWidth() {
        return this._minWidth;
      }
      /**
       * The computed minimum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get minHeight() {
        return this._minHeight;
      }
      /**
       * The computed maximum width of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxWidth() {
        return this._maxWidth;
      }
      /**
       * The computed maximum height of the widget.
       *
       * #### Notes
       * This value can be updated by calling the `fit` method.
       */
      get maxHeight() {
        return this._maxHeight;
      }
      /**
       * Whether the layout item is disposed.
       */
      get isDisposed() {
        return this._disposed;
      }
      /**
       * Whether the managed widget is hidden.
       */
      get isHidden() {
        return this.widget.isHidden;
      }
      /**
       * Whether the managed widget is visible.
       */
      get isVisible() {
        return this.widget.isVisible;
      }
      /**
       * Whether the managed widget is attached.
       */
      get isAttached() {
        return this.widget.isAttached;
      }
      /**
       * Update the computed size limits of the managed widget.
       */
      fit() {
        let limits = ElementExt.sizeLimits(this.widget.node);
        this._minWidth = limits.minWidth;
        this._minHeight = limits.minHeight;
        this._maxWidth = limits.maxWidth;
        this._maxHeight = limits.maxHeight;
      }
      /**
       * Update the position and size of the managed widget.
       *
       * @param left - The left edge position of the layout box.
       *
       * @param top - The top edge position of the layout box.
       *
       * @param width - The width of the layout box.
       *
       * @param height - The height of the layout box.
       */
      update(left, top, width, height) {
        let clampW = Math.max(this._minWidth, Math.min(width, this._maxWidth));
        let clampH = Math.max(this._minHeight, Math.min(height, this._maxHeight));
        if (clampW < width) {
          switch (Layout4.getHorizontalAlignment(this.widget)) {
            case "left":
              break;
            case "center":
              left += (width - clampW) / 2;
              break;
            case "right":
              left += width - clampW;
              break;
            default:
              throw "unreachable";
          }
        }
        if (clampH < height) {
          switch (Layout4.getVerticalAlignment(this.widget)) {
            case "top":
              break;
            case "center":
              top += (height - clampH) / 2;
              break;
            case "bottom":
              top += height - clampH;
              break;
            default:
              throw "unreachable";
          }
        }
        let resized = false;
        let style = this.widget.node.style;
        if (this._top !== top) {
          this._top = top;
          style.top = `${top}px`;
        }
        if (this._left !== left) {
          this._left = left;
          style.left = `${left}px`;
        }
        if (this._width !== clampW) {
          resized = true;
          this._width = clampW;
          style.width = `${clampW}px`;
        }
        if (this._height !== clampH) {
          resized = true;
          this._height = clampH;
          style.height = `${clampH}px`;
        }
        if (resized) {
          let msg = new Widget5.ResizeMessage(clampW, clampH);
          MessageLoop5.sendMessage(this.widget, msg);
        }
      }
    };
    (function(Private22) {
      Private22.horizontalAlignmentProperty = new AttachedProperty({
        name: "horizontalAlignment",
        create: () => "center",
        changed: onAlignmentChanged
      });
      Private22.verticalAlignmentProperty = new AttachedProperty({
        name: "verticalAlignment",
        create: () => "top",
        changed: onAlignmentChanged
      });
      function onAlignmentChanged(child) {
        if (child.parent && child.parent.layout) {
          child.parent.update();
        }
      }
    })(Private$i4 || (Private$i4 = {}));
    PanelLayout5 = class extends Layout4 {
      constructor() {
        super(...arguments);
        this._widgets = [];
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       *
       * All reimplementations should call the superclass method.
       *
       * This method is called automatically when the parent is disposed.
       */
      dispose() {
        while (this._widgets.length > 0) {
          this._widgets.pop().dispose();
        }
        super.dispose();
      }
      /**
       * A read-only array of the widgets in the layout.
       */
      get widgets() {
        return this._widgets;
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        yield* this._widgets;
      }
      /**
       * Add a widget to the end of the layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, it will be moved.
       */
      addWidget(widget) {
        this.insertWidget(this._widgets.length, widget);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        widget.parent = this.parent;
        let i6 = this._widgets.indexOf(widget);
        let j2 = Math.max(0, Math.min(index2, this._widgets.length));
        if (i6 === -1) {
          ArrayExt.insert(this._widgets, j2, widget);
          if (this.parent) {
            this.attachWidget(j2, widget);
          }
          return;
        }
        if (j2 === this._widgets.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._widgets, i6, j2);
        if (this.parent) {
          this.moveWidget(i6, j2, widget);
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this.removeWidgetAt(this._widgets.indexOf(widget));
      }
      /**
       * Remove the widget at a given index from the layout.
       *
       * @param index - The index of the widget to remove.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      removeWidgetAt(index2) {
        let widget = ArrayExt.removeAt(this._widgets, index2);
        if (widget && this.parent) {
          this.detachWidget(index2, widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        let index2 = 0;
        for (const widget of this) {
          this.attachWidget(index2++, widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(index2, widget) {
        let ref = this.parent.node.children[index2];
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation moves the widget's node to the proper
       * location in the parent's node and sends the appropriate attach and
       * detach messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is moved in the parent's node.
       */
      moveWidget(fromIndex, toIndex, widget) {
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
        let ref = this.parent.node.children[toIndex];
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.insertBefore(widget.node, ref);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the panel layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(index2, widget) {
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
      }
    };
    (function(Utils5) {
      function clampDimension(value) {
        return Math.max(0, Math.floor(value));
      }
      Utils5.clampDimension = clampDimension;
    })(Utils4 || (Utils4 = {}));
    Utils$14 = Utils4;
    SplitLayout4 = class extends PanelLayout5 {
      /**
       * Construct a new split layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this.widgetOffset = 0;
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._hasNormedSizes = false;
        this._sizers = [];
        this._items = [];
        this._handles = [];
        this._box = null;
        this._alignment = "start";
        this._orientation = "horizontal";
        this.renderer = options.renderer;
        if (options.orientation !== void 0) {
          this._orientation = options.orientation;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils4.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        this._handles.length = 0;
        super.dispose();
      }
      /**
       * Get the layout orientation for the split layout.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the layout orientation for the split layout.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._orientation = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["orientation"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the split layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand  to fill the
       * entire split layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the split layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the split layout.
       */
      set spacing(value) {
        value = Utils4.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the split handles in the layout.
       */
      get handles() {
        return this._handles;
      }
      /**
       * Get the absolute sizes of the widgets in the layout.
       *
       * @returns A new array of the absolute sizes of the widgets.
       *
       * This method **does not** measure the DOM nodes.
       */
      absoluteSizes() {
        return this._sizers.map((sizer) => sizer.size);
      }
      /**
       * Get the relative sizes of the widgets in the layout.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return Private$h4.normalize(this._sizers.map((sizer) => sizer.size));
      }
      /**
       * Set the relative sizes for the widgets in the layout.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        let n5 = this._sizers.length;
        let temp = sizes.slice(0, n5);
        while (temp.length < n5) {
          temp.push(0);
        }
        let normed = Private$h4.normalize(temp);
        for (let i6 = 0; i6 < n5; ++i6) {
          let sizer = this._sizers[i6];
          sizer.sizeHint = normed[i6];
          sizer.size = normed[i6];
        }
        this._hasNormedSizes = true;
        if (update && this.parent) {
          this.parent.update();
        }
      }
      /**
       * Move the offset position of a split handle.
       *
       * @param index - The index of the handle of the interest.
       *
       * @param position - The desired offset position of the handle.
       *
       * #### Notes
       * The position is relative to the offset parent.
       *
       * This will move the handle as close as possible to the desired
       * position. The sibling widgets will be adjusted as necessary.
       */
      moveHandle(index2, position) {
        let handle = this._handles[index2];
        if (!handle || handle.classList.contains("lm-mod-hidden")) {
          return;
        }
        let delta;
        if (this._orientation === "horizontal") {
          delta = position - handle.offsetLeft;
        } else {
          delta = position - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        for (let sizer of this._sizers) {
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
        }
        BoxEngine4.adjust(this._sizers, index2, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["orientation"] = this.orientation;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        let item = new LayoutItem4(widget);
        let handle = Private$h4.createHandle(this.renderer);
        let average = Private$h4.averageSize(this._sizers);
        let sizer = Private$h4.createSizer(average);
        ArrayExt.insert(this._items, index2, item);
        ArrayExt.insert(this._sizers, index2, sizer);
        ArrayExt.insert(this._handles, index2, handle);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        this.parent.node.appendChild(handle);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        ArrayExt.move(this._handles, fromIndex, toIndex);
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        let handle = ArrayExt.removeAt(this._handles, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        this.parent.node.removeChild(handle);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const item = this._items[i6];
        if (item.isHidden) {
          return;
        }
        let handleStyle = this._handles[i6].style;
        if (isHorizontal) {
          left += this.widgetOffset;
          item.update(left, top, size5, height);
          left += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${this._spacing}px`;
          handleStyle.height = `${height}px`;
        } else {
          top += this.widgetOffset;
          item.update(left, top, width, size5);
          top += size5;
          handleStyle.top = `${top}px`;
          handleStyle.left = `${left}px`;
          handleStyle.width = `${width}px`;
          handleStyle.height = `${this._spacing}px`;
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        let lastHandleIndex = -1;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          if (this._items[i6].isHidden) {
            this._handles[i6].classList.add("lm-mod-hidden");
          } else {
            this._handles[i6].classList.remove("lm-mod-hidden");
            lastHandleIndex = i6;
            nVisible++;
          }
        }
        if (lastHandleIndex !== -1) {
          this._handles[lastHandleIndex].classList.add("lm-mod-hidden");
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1) + this.widgetOffset * this._items.length;
        let horz = this._orientation === "horizontal";
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (sizer.size > 0) {
            sizer.sizeHint = sizer.size;
          }
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.stretch = SplitLayout4.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop5.sendMessage(this.parent.parent, Widget5.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop5.sendMessage(this.parent, Widget5.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0 && this.widgetOffset === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let extra = 0;
        let offset4 = 0;
        let horz = this._orientation === "horizontal";
        if (nVisible > 0) {
          let space;
          if (horz) {
            space = Math.max(0, width - this._fixed);
          } else {
            space = Math.max(0, height - this._fixed);
          }
          if (this._hasNormedSizes) {
            for (let sizer of this._sizers) {
              sizer.sizeHint *= space;
            }
            this._hasNormedSizes = false;
          }
          let delta = BoxEngine4.calc(this._sizers, space);
          if (delta > 0) {
            switch (this._alignment) {
              case "start":
                break;
              case "center":
                extra = 0;
                offset4 = delta / 2;
                break;
              case "end":
                extra = 0;
                offset4 = delta;
                break;
              case "justify":
                extra = delta / nVisible;
                offset4 = 0;
                break;
              default:
                throw "unreachable";
            }
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          const item = this._items[i6];
          const size5 = item.isHidden ? 0 : this._sizers[i6].size + extra;
          this.updateItemPosition(i6, horz, horz ? left + offset4 : left, horz ? top : top + offset4, height, width, size5);
          const fullOffset = this.widgetOffset + (this._handles[i6].classList.contains("lm-mod-hidden") ? 0 : this._spacing);
          if (horz) {
            left += size5 + fullOffset;
          } else {
            top += size5 + fullOffset;
          }
        }
      }
    };
    (function(SplitLayout5) {
      function getStretch(widget) {
        return Private$h4.stretchProperty.get(widget);
      }
      SplitLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$h4.stretchProperty.set(widget, value);
      }
      SplitLayout5.setStretch = setStretch;
    })(SplitLayout4 || (SplitLayout4 = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function createSizer(size5) {
        let sizer = new BoxSizer4();
        sizer.sizeHint = Math.floor(size5);
        return sizer;
      }
      Private22.createSizer = createSizer;
      function createHandle(renderer) {
        let handle = renderer.createHandle();
        handle.style.position = "absolute";
        handle.style.contain = "style";
        return handle;
      }
      Private22.createHandle = createHandle;
      function averageSize(sizers) {
        return sizers.reduce((v4, s8) => v4 + s8.size, 0) / sizers.length || 0;
      }
      Private22.averageSize = averageSize;
      function normalize2(values2) {
        let n5 = values2.length;
        if (n5 === 0) {
          return [];
        }
        let sum = values2.reduce((a3, b2) => a3 + Math.abs(b2), 0);
        return sum === 0 ? values2.map((v4) => 1 / n5) : values2.map((v4) => v4 / sum);
      }
      Private22.normalize = normalize2;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof SplitLayout4) {
          child.parent.fit();
        }
      }
    })(Private$h4 || (Private$h4 = {}));
    AccordionLayout4 = class extends SplitLayout4 {
      /**
       * Construct a new accordion layout.
       *
       * @param options - The options for initializing the layout.
       *
       * #### Notes
       * The default orientation will be vertical.
       *
       * Titles must be rotated for horizontal accordion panel using CSS: see accordionpanel.css
       */
      constructor(options) {
        super({ ...options, orientation: options.orientation || "vertical" });
        this._titles = [];
        this.titleSpace = options.titleSpace || 22;
      }
      /**
       * The section title height or width depending on the orientation.
       */
      get titleSpace() {
        return this.widgetOffset;
      }
      set titleSpace(value) {
        value = Utils$14.clampDimension(value);
        if (this.widgetOffset === value) {
          return;
        }
        this.widgetOffset = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this._titles;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._titles.length = 0;
        super.dispose();
      }
      updateTitle(index2, widget) {
        const oldTitle = this._titles[index2];
        const expanded = oldTitle.classList.contains("lm-mod-expanded");
        const newTitle = Private$g4.createTitle(this.renderer, widget.title, expanded);
        this._titles[index2] = newTitle;
        this.parent.node.replaceChild(newTitle, oldTitle);
      }
      /**
       * Insert a widget into the layout at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into the layout.
       *
       * #### Notes
       * The index will be clamped to the bounds of the widgets.
       *
       * If the widget is already added to the layout, it will be moved.
       *
       * #### Undefined Behavior
       * An `index` which is non-integral.
       */
      insertWidget(index2, widget) {
        if (!widget.id) {
          widget.id = `id-${import_coreutils19.UUID.uuid4()}`;
        }
        super.insertWidget(index2, widget);
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(index2, widget) {
        const title = Private$g4.createTitle(this.renderer, widget.title);
        ArrayExt.insert(this._titles, index2, title);
        this.parent.node.appendChild(title);
        widget.node.setAttribute("role", "region");
        widget.node.setAttribute("aria-labelledby", title.id);
        super.attachWidget(index2, widget);
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._titles, fromIndex, toIndex);
        super.moveWidget(fromIndex, toIndex, widget);
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        const title = ArrayExt.removeAt(this._titles, index2);
        this.parent.node.removeChild(title);
        super.detachWidget(index2, widget);
      }
      /**
       * Update the item position.
       *
       * @param i Item index
       * @param isHorizontal Whether the layout is horizontal or not
       * @param left Left position in pixels
       * @param top Top position in pixels
       * @param height Item height
       * @param width Item width
       * @param size Item size
       */
      updateItemPosition(i6, isHorizontal, left, top, height, width, size5) {
        const titleStyle = this._titles[i6].style;
        titleStyle.top = `${top}px`;
        titleStyle.left = `${left}px`;
        titleStyle.height = `${this.widgetOffset}px`;
        if (isHorizontal) {
          titleStyle.width = `${height}px`;
        } else {
          titleStyle.width = `${width}px`;
        }
        super.updateItemPosition(i6, isHorizontal, left, top, height, width, size5);
      }
    };
    (function(Private22) {
      function createTitle(renderer, data, expanded = true) {
        const title = renderer.createSectionTitle(data);
        title.style.position = "absolute";
        title.style.contain = "strict";
        title.setAttribute("aria-label", `${data.label} Section`);
        title.setAttribute("aria-expanded", expanded ? "true" : "false");
        title.setAttribute("aria-controls", data.owner.id);
        if (expanded) {
          title.classList.add("lm-mod-expanded");
        }
        return title;
      }
      Private22.createTitle = createTitle;
    })(Private$g4 || (Private$g4 = {}));
    Panel5 = class extends Widget5 {
      /**
       * Construct a new panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this.addClass("lm-Panel");
        this.layout = Private$f4.createLayout(options);
      }
      /**
       * A read-only array of the widgets in the panel.
       */
      get widgets() {
        return this.layout.widgets;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        this.layout.addWidget(widget);
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        this.layout.insertWidget(index2, widget);
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new PanelLayout5();
      }
      Private22.createLayout = createLayout;
    })(Private$f4 || (Private$f4 = {}));
    SplitPanel4 = class extends Panel5 {
      /**
       * Construct a new split panel.
       *
       * @param options - The options for initializing the split panel.
       */
      constructor(options = {}) {
        super({ layout: Private$e4.createLayout(options) });
        this._handleMoved = new Signal(this);
        this._pressData = null;
        this.addClass("lm-SplitPanel");
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        super.dispose();
      }
      /**
       * Get the layout orientation for the split panel.
       */
      get orientation() {
        return this.layout.orientation;
      }
      /**
       * Set the layout orientation for the split panel.
       */
      set orientation(value) {
        this.layout.orientation = value;
      }
      /**
       * Get the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the split panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire split panel.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the split panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the split panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * The renderer used by the split panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * A signal emitted when a split handle has moved.
       */
      get handleMoved() {
        return this._handleMoved;
      }
      /**
       * A read-only array of the split handles in the panel.
       */
      get handles() {
        return this.layout.handles;
      }
      /**
       * Get the relative sizes of the widgets in the panel.
       *
       * @returns A new array of the relative sizes of the widgets.
       *
       * #### Notes
       * The returned sizes reflect the sizes of the widgets normalized
       * relative to their siblings.
       *
       * This method **does not** measure the DOM nodes.
       */
      relativeSizes() {
        return this.layout.relativeSizes();
      }
      /**
       * Set the relative sizes for the widgets in the panel.
       *
       * @param sizes - The relative sizes for the widgets in the panel.
       * @param update - Update the layout after setting relative sizes.
       * Default is True.
       *
       * #### Notes
       * Extra values are ignored, too few will yield an undefined layout.
       *
       * The actual geometry of the DOM nodes is updated asynchronously.
       */
      setRelativeSizes(sizes, update = true) {
        this.layout.setRelativeSizes(sizes, update);
      }
      /**
       * Handle the DOM events for the split panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-SplitPanel-child");
        this._releaseMouse();
      }
      /**
       * Handle the `'keydown'` event for the split panel.
       */
      _evtKeyDown(event) {
        if (this._pressData) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (event.keyCode === 27) {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'pointerdown'` event for the split panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let index2 = ArrayExt.findFirstIndex(layout.handles, (handle2) => {
          return handle2.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        document.addEventListener("pointerup", this, true);
        document.addEventListener("pointermove", this, true);
        document.addEventListener("keydown", this, true);
        document.addEventListener("contextmenu", this, true);
        let delta;
        let handle = layout.handles[index2];
        let rect = handle.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          delta = event.clientX - rect.left;
        } else {
          delta = event.clientY - rect.top;
        }
        let style = window.getComputedStyle(handle);
        let override = Drag4.overrideCursor(style.cursor);
        this._pressData = { index: index2, delta, override };
      }
      /**
       * Handle the `'pointermove'` event for the split panel.
       */
      _evtPointerMove(event) {
        event.preventDefault();
        event.stopPropagation();
        let pos;
        let layout = this.layout;
        let rect = this.node.getBoundingClientRect();
        if (layout.orientation === "horizontal") {
          pos = event.clientX - rect.left - this._pressData.delta;
        } else {
          pos = event.clientY - rect.top - this._pressData.delta;
        }
        layout.moveHandle(this._pressData.index, pos);
      }
      /**
       * Handle the `'pointerup'` event for the split panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
      }
      /**
       * Release the mouse grab for the split panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._handleMoved.emit();
        document.removeEventListener("keydown", this, true);
        document.removeEventListener("pointerup", this, true);
        document.removeEventListener("pointermove", this, true);
        document.removeEventListener("contextmenu", this, true);
      }
    };
    (function(SplitPanel5) {
      class Renderer {
        /**
         * Create a new handle for use with a split panel.
         *
         * @returns A new handle element for a split panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-SplitPanel-handle";
          return handle;
        }
      }
      SplitPanel5.Renderer = Renderer;
      SplitPanel5.defaultRenderer = new Renderer();
      function getStretch(widget) {
        return SplitLayout4.getStretch(widget);
      }
      SplitPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        SplitLayout4.setStretch(widget, value);
      }
      SplitPanel5.setStretch = setStretch;
    })(SplitPanel4 || (SplitPanel4 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new SplitLayout4({
          renderer: options.renderer || SplitPanel4.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing
        });
      }
      Private22.createLayout = createLayout;
    })(Private$e4 || (Private$e4 = {}));
    AccordionPanel4 = class extends SplitPanel4 {
      /**
       * Construct a new accordion panel.
       *
       * @param options - The options for initializing the accordion panel.
       *
       */
      constructor(options = {}) {
        super({ ...options, layout: Private$d4.createLayout(options) });
        this._widgetSizesCache = /* @__PURE__ */ new WeakMap();
        this._expansionToggled = new Signal(this);
        this.addClass("lm-AccordionPanel");
      }
      /**
       * The renderer used by the accordion panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * The section title space.
       *
       * This is the height if the panel is vertical and the width if it is
       * horizontal.
       */
      get titleSpace() {
        return this.layout.titleSpace;
      }
      set titleSpace(value) {
        this.layout.titleSpace = value;
      }
      /**
       * A read-only array of the section titles in the panel.
       */
      get titles() {
        return this.layout.titles;
      }
      /**
       * A signal emitted when a widget of the AccordionPanel is collapsed or expanded.
       */
      get expansionToggled() {
        return this._expansionToggled;
      }
      /**
       * Add a widget to the end of the panel.
       *
       * @param widget - The widget to add to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      addWidget(widget) {
        super.addWidget(widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Collapse the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      collapse(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && !widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Expand the widget at position `index`.
       *
       * #### Notes
       * If no widget is found for `index`, this will bail.
       *
       * @param index Widget index
       */
      expand(index2) {
        const widget = this.layout.widgets[index2];
        if (widget && widget.isHidden) {
          this._toggleExpansion(index2);
        }
      }
      /**
       * Insert a widget at the specified index.
       *
       * @param index - The index at which to insert the widget.
       *
       * @param widget - The widget to insert into to the panel.
       *
       * #### Notes
       * If the widget is already contained in the panel, it will be moved.
       */
      insertWidget(index2, widget) {
        super.insertWidget(index2, widget);
        widget.title.changed.connect(this._onTitleChanged, this);
      }
      /**
       * Handle the DOM events for the accordion panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        super.handleEvent(event);
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._eventKeyDown(event);
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        super.onBeforeAttach(msg);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        super.onAfterDetach(msg);
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        const index2 = ArrayExt.findFirstIndex(this.widgets, (widget) => {
          return widget.contains(sender.owner);
        });
        if (index2 >= 0) {
          this.layout.updateTitle(index2, sender.owner);
          this.update();
        }
      }
      /**
       * Compute the size of widgets in this panel on the title click event.
       * On closing, the size of the widget is cached and we will try to expand
       * the last opened widget.
       * On opening, we will use the cached size if it is available to restore the
       * widget.
       * In both cases, if we can not compute the size of widgets, we will let
       * `SplitLayout` decide.
       *
       * @param index - The index of widget to be opened of closed
       *
       * @returns Relative size of widgets in this panel, if this size can
       * not be computed, return `undefined`
       */
      _computeWidgetSize(index2) {
        const layout = this.layout;
        const widget = layout.widgets[index2];
        if (!widget) {
          return void 0;
        }
        const isHidden2 = widget.isHidden;
        const widgetSizes = layout.absoluteSizes();
        const delta = (isHidden2 ? -1 : 1) * this.spacing;
        const totalSize = widgetSizes.reduce((prev, curr) => prev + curr);
        let newSize = [...widgetSizes];
        if (!isHidden2) {
          const currentSize = widgetSizes[index2];
          this._widgetSizesCache.set(widget, currentSize);
          newSize[index2] = 0;
          const widgetToCollapse = newSize.map((sz) => sz > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            return void 0;
          }
          newSize[widgetToCollapse] = widgetSizes[widgetToCollapse] + currentSize + delta;
        } else {
          const previousSize = this._widgetSizesCache.get(widget);
          if (!previousSize) {
            return void 0;
          }
          newSize[index2] += previousSize;
          const widgetToCollapse = newSize.map((sz) => sz - previousSize > 0).lastIndexOf(true);
          if (widgetToCollapse === -1) {
            newSize.forEach((_4, idx) => {
              if (idx !== index2) {
                newSize[idx] -= widgetSizes[idx] / totalSize * (previousSize - delta);
              }
            });
          } else {
            newSize[widgetToCollapse] -= previousSize - delta;
          }
        }
        return newSize.map((sz) => sz / (totalSize + delta));
      }
      /**
       * Handle the `'click'` event for the accordion panel
       */
      _evtClick(event) {
        const target = event.target;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            event.preventDefault();
            event.stopPropagation();
            this._toggleExpansion(index2);
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the accordion panel.
       */
      _eventKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        const target = event.target;
        let handled = false;
        if (target) {
          const index2 = ArrayExt.findFirstIndex(this.titles, (title) => {
            return title.contains(target);
          });
          if (index2 >= 0) {
            const keyCode = event.keyCode.toString();
            if (event.key.match(/Space|Enter/) || keyCode.match(/13|32/)) {
              target.click();
              handled = true;
            } else if (this.orientation === "horizontal" ? event.key.match(/ArrowLeft|ArrowRight/) || keyCode.match(/37|39/) : event.key.match(/ArrowUp|ArrowDown/) || keyCode.match(/38|40/)) {
              const direction = event.key.match(/ArrowLeft|ArrowUp/) || keyCode.match(/37|38/) ? -1 : 1;
              const length = this.titles.length;
              const newIndex = (index2 + length + direction) % length;
              this.titles[newIndex].focus();
              handled = true;
            } else if (event.key === "End" || keyCode === "35") {
              this.titles[this.titles.length - 1].focus();
              handled = true;
            } else if (event.key === "Home" || keyCode === "36") {
              this.titles[0].focus();
              handled = true;
            }
          }
          if (handled) {
            event.preventDefault();
          }
        }
      }
      _toggleExpansion(index2) {
        const title = this.titles[index2];
        const widget = this.layout.widgets[index2];
        const newSize = this._computeWidgetSize(index2);
        if (newSize) {
          this.setRelativeSizes(newSize, false);
        }
        if (widget.isHidden) {
          title.classList.add("lm-mod-expanded");
          title.setAttribute("aria-expanded", "true");
          widget.show();
        } else {
          title.classList.remove("lm-mod-expanded");
          title.setAttribute("aria-expanded", "false");
          widget.hide();
        }
        this._expansionToggled.emit(index2);
      }
    };
    (function(AccordionPanel5) {
      class Renderer extends SplitPanel4.Renderer {
        constructor() {
          super();
          this.titleClassName = "lm-AccordionPanel-title";
          this._titleID = 0;
          this._titleKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the collapse indicator for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the collapse indicator.
         */
        createCollapseIcon(data) {
          return document.createElement("span");
        }
        /**
         * Render the element for a section title.
         *
         * @param data - The data to use for rendering the section title.
         *
         * @returns A element representing the section title.
         */
        createSectionTitle(data) {
          const handle = document.createElement("h3");
          handle.setAttribute("tabindex", "0");
          handle.id = this.createTitleKey(data);
          handle.className = this.titleClassName;
          for (const aData in data.dataset) {
            handle.dataset[aData] = data.dataset[aData];
          }
          const collapser = handle.appendChild(this.createCollapseIcon(data));
          collapser.className = "lm-AccordionPanel-titleCollapser";
          const label = handle.appendChild(document.createElement("span"));
          label.className = "lm-AccordionPanel-titleLabel";
          label.textContent = data.label;
          label.title = data.caption || data.label;
          return handle;
        }
        /**
         * Create a unique render key for the title.
         *
         * @param data - The data to use for the title.
         *
         * @returns The unique render key for the title.
         *
         * #### Notes
         * This method caches the key against the section title the first time
         * the key is generated.
         */
        createTitleKey(data) {
          let key = this._titleKeys.get(data);
          if (key === void 0) {
            key = `title-key-${this._uuid}-${this._titleID++}`;
            this._titleKeys.set(data, key);
          }
          return key;
        }
      }
      Renderer._nInstance = 0;
      AccordionPanel5.Renderer = Renderer;
      AccordionPanel5.defaultRenderer = new Renderer();
    })(AccordionPanel4 || (AccordionPanel4 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new AccordionLayout4({
          renderer: options.renderer || AccordionPanel4.defaultRenderer,
          orientation: options.orientation,
          alignment: options.alignment,
          spacing: options.spacing,
          titleSpace: options.titleSpace
        });
      }
      Private22.createLayout = createLayout;
    })(Private$d4 || (Private$d4 = {}));
    BoxLayout4 = class extends PanelLayout5 {
      /**
       * Construct a new box layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super();
        this._fixed = 0;
        this._spacing = 4;
        this._dirty = false;
        this._sizers = [];
        this._items = [];
        this._box = null;
        this._alignment = "start";
        this._direction = "top-to-bottom";
        if (options.direction !== void 0) {
          this._direction = options.direction;
        }
        if (options.alignment !== void 0) {
          this._alignment = options.alignment;
        }
        if (options.spacing !== void 0) {
          this._spacing = Utils$14.clampDimension(options.spacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._sizers.length = 0;
        super.dispose();
      }
      /**
       * Get the layout direction for the box layout.
       */
      get direction() {
        return this._direction;
      }
      /**
       * Set the layout direction for the box layout.
       */
      set direction(value) {
        if (this._direction === value) {
          return;
        }
        this._direction = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["direction"] = value;
        this.parent.fit();
      }
      /**
       * Get the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this._alignment;
      }
      /**
       * Set the content alignment for the box layout.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        if (this._alignment === value) {
          return;
        }
        this._alignment = value;
        if (!this.parent) {
          return;
        }
        this.parent.dataset["alignment"] = value;
        this.parent.update();
      }
      /**
       * Get the inter-element spacing for the box layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the box layout.
       */
      set spacing(value) {
        value = Utils$14.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        this.parent.dataset["direction"] = this.direction;
        this.parent.dataset["alignment"] = this.alignment;
        super.init();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        ArrayExt.insert(this._items, index2, new LayoutItem4(widget));
        ArrayExt.insert(this._sizers, index2, new BoxSizer4());
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        ArrayExt.move(this._sizers, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        ArrayExt.removeAt(this._sizers, index2);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        this._fixed = this._spacing * Math.max(0, nVisible - 1);
        let horz = Private$c4.isHorizontal(this._direction);
        let minW = horz ? this._fixed : 0;
        let minH = horz ? 0 : this._fixed;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          let sizer = this._sizers[i6];
          if (item.isHidden) {
            sizer.minSize = 0;
            sizer.maxSize = 0;
            continue;
          }
          item.fit();
          sizer.sizeHint = BoxLayout4.getSizeBasis(item.widget);
          sizer.stretch = BoxLayout4.getStretch(item.widget);
          if (horz) {
            sizer.minSize = item.minWidth;
            sizer.maxSize = item.maxWidth;
            minW += item.minWidth;
            minH = Math.max(minH, item.minHeight);
          } else {
            sizer.minSize = item.minHeight;
            sizer.maxSize = item.maxHeight;
            minH += item.minHeight;
            minW = Math.max(minW, item.minWidth);
          }
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop5.sendMessage(this.parent.parent, Widget5.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop5.sendMessage(this.parent, Widget5.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let delta;
        switch (this._direction) {
          case "left-to-right":
            delta = BoxEngine4.calc(this._sizers, Math.max(0, width - this._fixed));
            break;
          case "top-to-bottom":
            delta = BoxEngine4.calc(this._sizers, Math.max(0, height - this._fixed));
            break;
          case "right-to-left":
            delta = BoxEngine4.calc(this._sizers, Math.max(0, width - this._fixed));
            left += width;
            break;
          case "bottom-to-top":
            delta = BoxEngine4.calc(this._sizers, Math.max(0, height - this._fixed));
            top += height;
            break;
          default:
            throw "unreachable";
        }
        let extra = 0;
        let offset4 = 0;
        if (delta > 0) {
          switch (this._alignment) {
            case "start":
              break;
            case "center":
              extra = 0;
              offset4 = delta / 2;
              break;
            case "end":
              extra = 0;
              offset4 = delta;
              break;
            case "justify":
              extra = delta / nVisible;
              offset4 = 0;
              break;
            default:
              throw "unreachable";
          }
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let size5 = this._sizers[i6].size;
          switch (this._direction) {
            case "left-to-right":
              item.update(left + offset4, top, size5 + extra, height);
              left += size5 + extra + this._spacing;
              break;
            case "top-to-bottom":
              item.update(left, top + offset4, width, size5 + extra);
              top += size5 + extra + this._spacing;
              break;
            case "right-to-left":
              item.update(left - offset4 - size5 - extra, top, size5 + extra, height);
              left -= size5 + extra + this._spacing;
              break;
            case "bottom-to-top":
              item.update(left, top - offset4 - size5 - extra, width, size5 + extra);
              top -= size5 + extra + this._spacing;
              break;
            default:
              throw "unreachable";
          }
        }
      }
    };
    (function(BoxLayout5) {
      function getStretch(widget) {
        return Private$c4.stretchProperty.get(widget);
      }
      BoxLayout5.getStretch = getStretch;
      function setStretch(widget, value) {
        Private$c4.stretchProperty.set(widget, value);
      }
      BoxLayout5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return Private$c4.sizeBasisProperty.get(widget);
      }
      BoxLayout5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        Private$c4.sizeBasisProperty.set(widget, value);
      }
      BoxLayout5.setSizeBasis = setSizeBasis;
    })(BoxLayout4 || (BoxLayout4 = {}));
    (function(Private22) {
      Private22.stretchProperty = new AttachedProperty({
        name: "stretch",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      Private22.sizeBasisProperty = new AttachedProperty({
        name: "sizeBasis",
        create: () => 0,
        coerce: (owner, value) => Math.max(0, Math.floor(value)),
        changed: onChildSizingChanged
      });
      function isHorizontal(dir) {
        return dir === "left-to-right" || dir === "right-to-left";
      }
      Private22.isHorizontal = isHorizontal;
      function clampSpacing(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampSpacing = clampSpacing;
      function onChildSizingChanged(child) {
        if (child.parent && child.parent.layout instanceof BoxLayout4) {
          child.parent.fit();
        }
      }
    })(Private$c4 || (Private$c4 = {}));
    BoxPanel4 = class extends Panel5 {
      /**
       * Construct a new box panel.
       *
       * @param options - The options for initializing the box panel.
       */
      constructor(options = {}) {
        super({ layout: Private$b4.createLayout(options) });
        this.addClass("lm-BoxPanel");
      }
      /**
       * Get the layout direction for the box panel.
       */
      get direction() {
        return this.layout.direction;
      }
      /**
       * Set the layout direction for the box panel.
       */
      set direction(value) {
        this.layout.direction = value;
      }
      /**
       * Get the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      get alignment() {
        return this.layout.alignment;
      }
      /**
       * Set the content alignment for the box panel.
       *
       * #### Notes
       * This is the alignment of the widgets in the layout direction.
       *
       * The alignment has no effect if the widgets can expand to fill the
       * entire box layout.
       */
      set alignment(value) {
        this.layout.alignment = value;
      }
      /**
       * Get the inter-element spacing for the box panel.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the inter-element spacing for the box panel.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        msg.child.addClass("lm-BoxPanel-child");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        msg.child.removeClass("lm-BoxPanel-child");
      }
    };
    (function(BoxPanel5) {
      function getStretch(widget) {
        return BoxLayout4.getStretch(widget);
      }
      BoxPanel5.getStretch = getStretch;
      function setStretch(widget, value) {
        BoxLayout4.setStretch(widget, value);
      }
      BoxPanel5.setStretch = setStretch;
      function getSizeBasis(widget) {
        return BoxLayout4.getSizeBasis(widget);
      }
      BoxPanel5.getSizeBasis = getSizeBasis;
      function setSizeBasis(widget, value) {
        BoxLayout4.setSizeBasis(widget, value);
      }
      BoxPanel5.setSizeBasis = setSizeBasis;
    })(BoxPanel4 || (BoxPanel4 = {}));
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new BoxLayout4(options);
      }
      Private22.createLayout = createLayout;
    })(Private$b4 || (Private$b4 = {}));
    CommandPalette4 = class extends Widget5 {
      /**
       * Construct a new command palette.
       *
       * @param options - The options for initializing the palette.
       */
      constructor(options) {
        super({ node: Private$a4.createNode() });
        this._activeIndex = -1;
        this._items = [];
        this._results = null;
        this.addClass("lm-CommandPalette");
        this.setFlag(Widget5.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || CommandPalette4.defaultRenderer;
        this.commands.commandChanged.connect(this._onGenericChange, this);
        this.commands.keyBindingChanged.connect(this._onGenericChange, this);
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._items.length = 0;
        this._results = null;
        super.dispose();
      }
      /**
       * The command palette search node.
       *
       * #### Notes
       * This is the node which contains the search-related elements.
       */
      get searchNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-search")[0];
      }
      /**
       * The command palette input node.
       *
       * #### Notes
       * This is the actual input node for the search area.
       */
      get inputNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-input")[0];
      }
      /**
       * The command palette content node.
       *
       * #### Notes
       * This is the node which holds the command item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-CommandPalette-content")[0];
      }
      /**
       * A read-only array of the command items in the palette.
       */
      get items() {
        return this._items;
      }
      /**
       * Add a command item to the command palette.
       *
       * @param options - The options for creating the command item.
       *
       * @returns The command item added to the palette.
       */
      addItem(options) {
        let item = Private$a4.createItem(this.commands, options);
        this._items.push(item);
        this.refresh();
        return item;
      }
      /**
       * Adds command items to the command palette.
       *
       * @param items - An array of options for creating each command item.
       *
       * @returns The command items added to the palette.
       */
      addItems(items) {
        const newItems = items.map((item) => Private$a4.createItem(this.commands, item));
        newItems.forEach((item) => this._items.push(item));
        this.refresh();
        return newItems;
      }
      /**
       * Remove an item from the command palette.
       *
       * @param item - The item to remove from the palette.
       *
       * #### Notes
       * This is a no-op if the item is not in the palette.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the command palette.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.refresh();
      }
      /**
       * Remove all items from the command palette.
       */
      clearItems() {
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.refresh();
      }
      /**
       * Clear the search results and schedule an update.
       *
       * #### Notes
       * This should be called whenever the search results of the palette
       * should be updated.
       *
       * This is typically called automatically by the palette as needed,
       * but can be called manually if the input text is programatically
       * changed.
       *
       * The rendered results are updated asynchronously.
       */
      refresh() {
        this._results = null;
        if (this.inputNode.value !== "") {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "inherit";
        } else {
          let clear = this.node.getElementsByClassName("lm-close-icon")[0];
          clear.style.display = "none";
        }
        this.update();
      }
      /**
       * Handle the DOM events for the command palette.
       *
       * @param event - The DOM event sent to the command palette.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the command palette's DOM node.
       * It should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "click":
            this._evtClick(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "input":
            this.refresh();
            break;
          case "focus":
          case "blur":
            this._toggleFocused();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("click", this);
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("input", this);
        this.node.addEventListener("focus", this, true);
        this.node.addEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("click", this);
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("input", this);
        this.node.removeEventListener("focus", this, true);
        this.node.removeEventListener("blur", this, true);
      }
      /**
       * A message handler invoked on an `'after-show'` message.
       */
      onAfterShow(msg) {
        this.update();
        super.onAfterShow(msg);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          let input = this.inputNode;
          input.focus();
          input.select();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (!this.isVisible) {
          VirtualDOM.render(null, this.contentNode);
          return;
        }
        let query = this.inputNode.value;
        let contentNode = this.contentNode;
        let results = this._results;
        if (!results) {
          results = this._results = Private$a4.search(this._items, query);
          this._activeIndex = query ? ArrayExt.findFirstIndex(results, Private$a4.canActivate) : -1;
        }
        if (!query && results.length === 0) {
          VirtualDOM.render(null, contentNode);
          return;
        }
        if (query && results.length === 0) {
          let content2 = this.renderer.renderEmptyMessage({ query });
          VirtualDOM.render(content2, contentNode);
          return;
        }
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let content = new Array(results.length);
        for (let i6 = 0, n5 = results.length; i6 < n5; ++i6) {
          let result2 = results[i6];
          if (result2.type === "header") {
            let indices = result2.indices;
            let category = result2.category;
            content[i6] = renderer.renderHeader({ category, indices });
          } else {
            let item = result2.item;
            let indices = result2.indices;
            let active = i6 === activeIndex;
            content[i6] = renderer.renderItem({ item, indices, active });
          }
        }
        VirtualDOM.render(content, contentNode);
        if (activeIndex < 0 || activeIndex >= results.length) {
          contentNode.scrollTop = 0;
        } else {
          let element2 = contentNode.children[activeIndex];
          ElementExt.scrollIntoViewIfNeeded(contentNode, element2);
        }
      }
      /**
       * Handle the `'click'` event for the command palette.
       */
      _evtClick(event) {
        if (event.button !== 0) {
          return;
        }
        if (event.target.classList.contains("lm-close-icon")) {
          this.inputNode.value = "";
          this.refresh();
          return;
        }
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return node.contains(event.target);
        });
        if (index2 === -1) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._execute(index2);
      }
      /**
       * Handle the `'keydown'` event for the command palette.
       */
      _evtKeyDown(event) {
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
          return;
        }
        switch (event.keyCode) {
          case 13:
            event.preventDefault();
            event.stopPropagation();
            this._execute(this._activeIndex);
            break;
          case 38:
            event.preventDefault();
            event.stopPropagation();
            this._activatePreviousItem();
            break;
          case 40:
            event.preventDefault();
            event.stopPropagation();
            this._activateNextItem();
            break;
        }
      }
      /**
       * Activate the next enabled command item.
       */
      _activateNextItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this._activeIndex = ArrayExt.findFirstIndex(this._results, Private$a4.canActivate, start, stop);
        this.update();
      }
      /**
       * Activate the previous enabled command item.
       */
      _activatePreviousItem() {
        if (!this._results || this._results.length === 0) {
          return;
        }
        let ai = this._activeIndex;
        let n5 = this._results.length;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this._activeIndex = ArrayExt.findLastIndex(this._results, Private$a4.canActivate, start, stop);
        this.update();
      }
      /**
       * Execute the command item at the given index, if possible.
       */
      _execute(index2) {
        if (!this._results) {
          return;
        }
        let part = this._results[index2];
        if (!part) {
          return;
        }
        if (part.type === "header") {
          let input = this.inputNode;
          input.value = `${part.category.toLowerCase()} `;
          input.focus();
          this.refresh();
          return;
        }
        if (!part.item.isEnabled) {
          return;
        }
        this.commands.execute(part.item.command, part.item.args);
        this.inputNode.value = "";
        this.refresh();
      }
      /**
       * Toggle the focused modifier based on the input node focus state.
       */
      _toggleFocused() {
        let focused = document.activeElement === this.inputNode;
        this.toggleClass("lm-mod-focused", focused);
      }
      /**
       * A signal handler for generic command changes.
       */
      _onGenericChange() {
        this.refresh();
      }
    };
    (function(CommandPalette5) {
      class Renderer {
        /**
         * Render the virtual element for a command palette header.
         *
         * @param data - The data to use for rendering the header.
         *
         * @returns A virtual element representing the header.
         */
        renderHeader(data) {
          let content = this.formatHeader(data);
          return h.li({ className: "lm-CommandPalette-header" }, content);
        }
        /**
         * Render the virtual element for a command palette item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          if (data.item.isToggleable) {
            return h.li({
              className,
              dataset,
              role: "menuitemcheckbox",
              "aria-checked": `${data.item.isToggled}`
            }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
          }
          return h.li({
            className,
            dataset,
            role: "menuitem"
          }, this.renderItemIcon(data), this.renderItemContent(data), this.renderItemShortcut(data));
        }
        /**
         * Render the empty results message for a command palette.
         *
         * @param data - The data to use for rendering the message.
         *
         * @returns A virtual element representing the message.
         */
        renderEmptyMessage(data) {
          let content = this.formatEmptyMessage(data);
          return h.li({ className: "lm-CommandPalette-emptyMessage" }, content);
        }
        /**
         * Render the icon for a command palette item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the icon.
         */
        renderItemIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the content for a command palette item.
         *
         * @param data - The data to use for rendering the content.
         *
         * @returns A virtual element representing the content.
         */
        renderItemContent(data) {
          return h.div({ className: "lm-CommandPalette-itemContent" }, this.renderItemLabel(data), this.renderItemCaption(data));
        }
        /**
         * Render the label for a command palette item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the label.
         */
        renderItemLabel(data) {
          let content = this.formatItemLabel(data);
          return h.div({ className: "lm-CommandPalette-itemLabel" }, content);
        }
        /**
         * Render the caption for a command palette item.
         *
         * @param data - The data to use for rendering the caption.
         *
         * @returns A virtual element representing the caption.
         */
        renderItemCaption(data) {
          let content = this.formatItemCaption(data);
          return h.div({ className: "lm-CommandPalette-itemCaption" }, content);
        }
        /**
         * Render the shortcut for a command palette item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the shortcut.
         */
        renderItemShortcut(data) {
          let content = this.formatItemShortcut(data);
          return h.div({ className: "lm-CommandPalette-itemShortcut" }, content);
        }
        /**
         * Create the class name for the command palette item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the command palette item.
         */
        createItemClass(data) {
          let name = "lm-CommandPalette-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the command palette item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the command palette item.
         */
        createItemDataset(data) {
          return { ...data.item.dataset, command: data.item.command };
        }
        /**
         * Create the class name for the command item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-CommandPalette-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the header node.
         *
         * @param data - The data to use for the header content.
         *
         * @returns The content to add to the header node.
         */
        formatHeader(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.category;
          }
          return StringExt.highlight(data.category, data.indices, h.mark);
        }
        /**
         * Create the render content for the empty message node.
         *
         * @param data - The data to use for the empty message content.
         *
         * @returns The content to add to the empty message node.
         */
        formatEmptyMessage(data) {
          return `No commands found that match '${data.query}'`;
        }
        /**
         * Create the render content for the item shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatItemShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
        /**
         * Create the render content for the item label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatItemLabel(data) {
          if (!data.indices || data.indices.length === 0) {
            return data.item.label;
          }
          return StringExt.highlight(data.item.label, data.indices, h.mark);
        }
        /**
         * Create the render content for the item caption node.
         *
         * @param data - The data to use for the caption content.
         *
         * @returns The content to add to the caption node.
         */
        formatItemCaption(data) {
          return data.item.caption;
        }
      }
      CommandPalette5.Renderer = Renderer;
      CommandPalette5.defaultRenderer = new Renderer();
    })(CommandPalette4 || (CommandPalette4 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let search2 = document.createElement("div");
        let wrapper = document.createElement("div");
        let input = document.createElement("input");
        let content = document.createElement("ul");
        let clear = document.createElement("button");
        search2.className = "lm-CommandPalette-search";
        wrapper.className = "lm-CommandPalette-wrapper";
        input.className = "lm-CommandPalette-input";
        clear.className = "lm-close-icon";
        content.className = "lm-CommandPalette-content";
        content.setAttribute("role", "menu");
        input.spellcheck = false;
        wrapper.appendChild(input);
        wrapper.appendChild(clear);
        search2.appendChild(wrapper);
        node.appendChild(search2);
        node.appendChild(content);
        return node;
      }
      Private22.createNode = createNode;
      function createItem(commands, options) {
        return new CommandItem(commands, options);
      }
      Private22.createItem = createItem;
      function search(items, query) {
        let scores = matchItems(items, query);
        scores.sort(scoreCmp);
        return createResults(scores);
      }
      Private22.search = search;
      function canActivate(result2) {
        return result2.type === "item" && result2.item.isEnabled;
      }
      Private22.canActivate = canActivate;
      function normalizeCategory(category) {
        return category.trim().replace(/\s+/g, " ");
      }
      function normalizeQuery(text) {
        return text.replace(/\s+/g, "").toLowerCase();
      }
      function matchItems(items, query) {
        query = normalizeQuery(query);
        let scores = [];
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          if (!item.isVisible) {
            continue;
          }
          if (!query) {
            scores.push({
              matchType: 3,
              categoryIndices: null,
              labelIndices: null,
              score: 0,
              item
            });
            continue;
          }
          let score = fuzzySearch(item, query);
          if (!score) {
            continue;
          }
          if (!item.isEnabled) {
            score.score += 1e3;
          }
          scores.push(score);
        }
        return scores;
      }
      function fuzzySearch(item, query) {
        let category = item.category.toLowerCase();
        let label = item.label.toLowerCase();
        let source = `${category} ${label}`;
        let score = Infinity;
        let indices = null;
        let rgx = /\b\w/g;
        while (true) {
          let rgxMatch = rgx.exec(source);
          if (!rgxMatch) {
            break;
          }
          let match = StringExt.matchSumOfDeltas(source, query, rgxMatch.index);
          if (!match) {
            break;
          }
          if (match.score <= score) {
            score = match.score;
            indices = match.indices;
          }
        }
        if (!indices || score === Infinity) {
          return null;
        }
        let pivot = category.length + 1;
        let j2 = ArrayExt.lowerBound(indices, pivot, (a3, b2) => a3 - b2);
        let categoryIndices = indices.slice(0, j2);
        let labelIndices = indices.slice(j2);
        for (let i6 = 0, n5 = labelIndices.length; i6 < n5; ++i6) {
          labelIndices[i6] -= pivot;
        }
        if (categoryIndices.length === 0) {
          return {
            matchType: 0,
            categoryIndices: null,
            labelIndices,
            score,
            item
          };
        }
        if (labelIndices.length === 0) {
          return {
            matchType: 1,
            categoryIndices,
            labelIndices: null,
            score,
            item
          };
        }
        return {
          matchType: 2,
          categoryIndices,
          labelIndices,
          score,
          item
        };
      }
      function scoreCmp(a3, b2) {
        let m1 = a3.matchType - b2.matchType;
        if (m1 !== 0) {
          return m1;
        }
        let d1 = a3.score - b2.score;
        if (d1 !== 0) {
          return d1;
        }
        let i1 = 0;
        let i22 = 0;
        switch (a3.matchType) {
          case 0:
            i1 = a3.labelIndices[0];
            i22 = b2.labelIndices[0];
            break;
          case 1:
          case 2:
            i1 = a3.categoryIndices[0];
            i22 = b2.categoryIndices[0];
            break;
        }
        if (i1 !== i22) {
          return i1 - i22;
        }
        let d22 = a3.item.category.localeCompare(b2.item.category);
        if (d22 !== 0) {
          return d22;
        }
        let r1 = a3.item.rank;
        let r22 = b2.item.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.item.label.localeCompare(b2.item.label);
      }
      function createResults(scores) {
        let results = [];
        for (let i6 = 0, n5 = scores.length; i6 < n5; ++i6) {
          let { item, categoryIndices, labelIndices } = scores[i6];
          let category = item.category;
          if (i6 === 0 || category !== scores[i6 - 1].item.category) {
            results.push({ type: "header", category, indices: categoryIndices });
          }
          results.push({ type: "item", item, indices: labelIndices });
        }
        return results;
      }
      class CommandItem {
        /**
         * Construct a new command item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.category = normalizeCategory(options.category);
          this.command = options.command;
          this.args = options.args || import_coreutils19.JSONExt.emptyObject;
          this.rank = options.rank !== void 0 ? options.rank : Infinity;
        }
        /**
         * The display label for the command item.
         */
        get label() {
          return this._commands.label(this.command, this.args);
        }
        /**
         * The icon renderer for the command item.
         */
        get icon() {
          return this._commands.icon(this.command, this.args);
        }
        /**
         * The icon class for the command item.
         */
        get iconClass() {
          return this._commands.iconClass(this.command, this.args);
        }
        /**
         * The icon label for the command item.
         */
        get iconLabel() {
          return this._commands.iconLabel(this.command, this.args);
        }
        /**
         * The display caption for the command item.
         */
        get caption() {
          return this._commands.caption(this.command, this.args);
        }
        /**
         * The extra class name for the command item.
         */
        get className() {
          return this._commands.className(this.command, this.args);
        }
        /**
         * The dataset for the command item.
         */
        get dataset() {
          return this._commands.dataset(this.command, this.args);
        }
        /**
         * Whether the command item is enabled.
         */
        get isEnabled() {
          return this._commands.isEnabled(this.command, this.args);
        }
        /**
         * Whether the command item is toggled.
         */
        get isToggled() {
          return this._commands.isToggled(this.command, this.args);
        }
        /**
         * Whether the command item is toggleable.
         */
        get isToggleable() {
          return this._commands.isToggleable(this.command, this.args);
        }
        /**
         * Whether the command item is visible.
         */
        get isVisible() {
          return this._commands.isVisible(this.command, this.args);
        }
        /**
         * The key binding for the command item.
         */
        get keyBinding() {
          let { command, args } = this;
          return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
            return kb.command === command && import_coreutils19.JSONExt.deepEqual(kb.args, args);
          }) || null;
        }
      }
    })(Private$a4 || (Private$a4 = {}));
    Menu4 = class extends Widget5 {
      /**
       * Construct a new menu.
       *
       * @param options - The options for initializing the menu.
       */
      constructor(options) {
        super({ node: Private$94.createNode() });
        this._childIndex = -1;
        this._activeIndex = -1;
        this._openTimerID = 0;
        this._closeTimerID = 0;
        this._items = [];
        this._childMenu = null;
        this._parentMenu = null;
        this._aboutToClose = new Signal(this);
        this._menuRequested = new Signal(this);
        this.addClass("lm-Menu");
        this.setFlag(Widget5.Flag.DisallowLayout);
        this.commands = options.commands;
        this.renderer = options.renderer || Menu4.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the menu.
       */
      dispose() {
        this.close();
        this._items.length = 0;
        super.dispose();
      }
      /**
       * A signal emitted just before the menu is closed.
       *
       * #### Notes
       * This signal is emitted when the menu receives a `'close-request'`
       * message, just before it removes itself from the DOM.
       *
       * This signal is not emitted if the menu is already detached from
       * the DOM when it receives the `'close-request'` message.
       */
      get aboutToClose() {
        return this._aboutToClose;
      }
      /**
       * A signal emitted when a new menu is requested by the user.
       *
       * #### Notes
       * This signal is emitted whenever the user presses the right or left
       * arrow keys, and a submenu cannot be opened or closed in response.
       *
       * This signal is useful when implementing menu bars in order to open
       * the next or previous menu in response to a user key press.
       *
       * This signal is only emitted for the root menu in a hierarchy.
       */
      get menuRequested() {
        return this._menuRequested;
      }
      /**
       * The parent menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu is an open submenu.
       */
      get parentMenu() {
        return this._parentMenu;
      }
      /**
       * The child menu of the menu.
       *
       * #### Notes
       * This is `null` unless the menu has an open submenu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The root menu of the menu hierarchy.
       */
      get rootMenu() {
        let menu = this;
        while (menu._parentMenu) {
          menu = menu._parentMenu;
        }
        return menu;
      }
      /**
       * The leaf menu of the menu hierarchy.
       */
      get leafMenu() {
        let menu = this;
        while (menu._childMenu) {
          menu = menu._childMenu;
        }
        return menu;
      }
      /**
       * The menu content node.
       *
       * #### Notes
       * This is the node which holds the menu item nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-Menu-content")[0];
      }
      /**
       * Get the currently active menu item.
       */
      get activeItem() {
        return this._items[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the item will be set to `null`.
       */
      set activeItem(value) {
        this.activeIndex = value ? this._items.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu item.
       *
       * #### Notes
       * This will be `-1` if no menu item is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu item.
       *
       * #### Notes
       * If the item cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._items.length) {
          value = -1;
        }
        if (value !== -1 && !Private$94.canActivate(this._items[value])) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        if (this._activeIndex >= 0 && this.contentNode.childNodes[this._activeIndex]) {
          this.contentNode.childNodes[this._activeIndex].focus();
        }
        this.update();
      }
      /**
       * A read-only array of the menu items in the menu.
       */
      get items() {
        return this._items;
      }
      /**
       * Activate the next selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activateNextItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai < n5 - 1 ? ai + 1 : 0;
        let stop = start === 0 ? n5 - 1 : start - 1;
        this.activeIndex = ArrayExt.findFirstIndex(this._items, Private$94.canActivate, start, stop);
      }
      /**
       * Activate the previous selectable item in the menu.
       *
       * #### Notes
       * If no item is selectable, the index will be set to `-1`.
       */
      activatePreviousItem() {
        let n5 = this._items.length;
        let ai = this._activeIndex;
        let start = ai <= 0 ? n5 - 1 : ai - 1;
        let stop = start === n5 - 1 ? 0 : start + 1;
        this.activeIndex = ArrayExt.findLastIndex(this._items, Private$94.canActivate, start, stop);
      }
      /**
       * Trigger the active menu item.
       *
       * #### Notes
       * If the active item is a submenu, it will be opened and the first
       * item will be activated.
       *
       * If the active item is a command, the command will be executed.
       *
       * If the menu is not attached, this is a no-op.
       *
       * If there is no active item, this is a no-op.
       */
      triggerActiveItem() {
        if (!this.isAttached) {
          return;
        }
        let item = this.activeItem;
        if (!item) {
          return;
        }
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        if (item.type === "submenu") {
          this._openChildMenu(true);
          return;
        }
        this.rootMenu.close();
        let { command, args } = item;
        if (this.commands.isEnabled(command, args)) {
          this.commands.execute(command, args);
        } else {
          console.log(`Command '${command}' is disabled.`);
        }
      }
      /**
       * Add a menu item to the end of the menu.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       */
      addItem(options) {
        return this.insertItem(this._items.length, options);
      }
      /**
       * Insert a menu item into the menu at the specified index.
       *
       * @param index - The index at which to insert the item.
       *
       * @param options - The options for creating the menu item.
       *
       * @returns The menu item added to the menu.
       *
       * #### Notes
       * The index will be clamped to the bounds of the items.
       */
      insertItem(index2, options) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let i6 = Math.max(0, Math.min(index2, this._items.length));
        let item = Private$94.createItem(this, options);
        ArrayExt.insert(this._items, i6, item);
        this.update();
        return item;
      }
      /**
       * Remove an item from the menu.
       *
       * @param item - The item to remove from the menu.
       *
       * #### Notes
       * This is a no-op if the item is not in the menu.
       */
      removeItem(item) {
        this.removeItemAt(this._items.indexOf(item));
      }
      /**
       * Remove the item at a given index from the menu.
       *
       * @param index - The index of the item to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeItemAt(index2) {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        let item = ArrayExt.removeAt(this._items, index2);
        if (!item) {
          return;
        }
        this.update();
      }
      /**
       * Remove all menu items from the menu.
       */
      clearItems() {
        if (this.isAttached) {
          this.close();
        }
        this.activeIndex = -1;
        if (this._items.length === 0) {
          return;
        }
        this._items.length = 0;
        this.update();
      }
      /**
       * Open the menu at the specified location.
       *
       * @param x - The client X coordinate of the menu location.
       *
       * @param y - The client Y coordinate of the menu location.
       *
       * @param options - The additional options for opening the menu.
       *
       * #### Notes
       * The menu will be opened at the given location unless it will not
       * fully fit on the screen. If it will not fit, it will be adjusted
       * to fit naturally on the screen.
       *
       * The menu will be attached under the `host` element in the DOM
       * (or `document.body` if `host` is `null`) and before the `ref`
       * element (or as the last child of `host` if `ref` is `null`).
       * The menu may be displayed outside of the `host` element
       * following the rules of CSS absolute positioning.
       *
       * This is a no-op if the menu is already attached to the DOM.
       */
      open(x2, y4, options = {}) {
        var _a, _b, _c;
        if (this.isAttached) {
          return;
        }
        let forceX = options.forceX || false;
        let forceY = options.forceY || false;
        const host = (_a = options.host) !== null && _a !== void 0 ? _a : null;
        const ref = (_b = options.ref) !== null && _b !== void 0 ? _b : null;
        const horizontalAlignment = (_c = options.horizontalAlignment) !== null && _c !== void 0 ? _c : document.documentElement.dir === "rtl" ? "right" : "left";
        Private$94.openRootMenu(this, x2, y4, forceX, forceY, horizontalAlignment, host, ref);
        this.activate();
      }
      /**
       * Handle the DOM events for the menu.
       *
       * @param event - The DOM event sent to the menu.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu's DOM nodes. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mouseup":
            this._evtMouseUp(event);
            break;
          case "mousemove":
            this._evtMouseMove(event);
            break;
          case "mouseenter":
            this._evtMouseEnter(event);
            break;
          case "mouseleave":
            this._evtMouseLeave(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mouseup", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseenter", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("contextmenu", this);
        document.addEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mouseup", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseenter", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("contextmenu", this);
        document.removeEventListener("mousedown", this, true);
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this.node.focus();
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        let items = this._items;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let collapsedFlags = Private$94.computeCollapsed(items);
        let content = new Array(items.length);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let active = i6 === activeIndex;
          let collapsed = collapsedFlags[i6];
          content[i6] = renderer.renderItem({
            item,
            active,
            collapsed,
            onfocus: () => {
              this.activeIndex = i6;
            }
          });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * A message handler invoked on a `'close-request'` message.
       */
      onCloseRequest(msg) {
        this._cancelOpenTimer();
        this._cancelCloseTimer();
        this.activeIndex = -1;
        let childMenu = this._childMenu;
        if (childMenu) {
          this._childIndex = -1;
          this._childMenu = null;
          childMenu._parentMenu = null;
          childMenu.close();
        }
        let parentMenu = this._parentMenu;
        if (parentMenu) {
          this._parentMenu = null;
          parentMenu._childIndex = -1;
          parentMenu._childMenu = null;
          parentMenu.activate();
        }
        if (this.isAttached) {
          this._aboutToClose.emit(void 0);
        }
        super.onCloseRequest(msg);
      }
      /**
       * Handle the `'keydown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        let kc = event.keyCode;
        if (kc === 13) {
          this.triggerActiveItem();
          return;
        }
        if (kc === 27) {
          this.close();
          return;
        }
        if (kc === 37) {
          if (this._parentMenu) {
            this.close();
          } else {
            this._menuRequested.emit("previous");
          }
          return;
        }
        if (kc === 38) {
          this.activatePreviousItem();
          return;
        }
        if (kc === 39) {
          let item = this.activeItem;
          if (item && item.type === "submenu") {
            this.triggerActiveItem();
          } else {
            this.rootMenu._menuRequested.emit("next");
          }
          return;
        }
        if (kc === 40) {
          this.activateNextItem();
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$94.findMnemonic(this._items, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.triggerActiveItem();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
        }
      }
      /**
       * Handle the `'mouseup'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.triggerActiveItem();
      }
      /**
       * Handle the `'mousemove'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        this.activeIndex = index2;
        index2 = this.activeIndex;
        if (index2 === this._childIndex) {
          this._cancelOpenTimer();
          this._cancelCloseTimer();
          return;
        }
        if (this._childIndex !== -1) {
          this._startCloseTimer();
        }
        this._cancelOpenTimer();
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          return;
        }
        this._startOpenTimer();
      }
      /**
       * Handle the `'mouseenter'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseEnter(event) {
        for (let menu = this._parentMenu; menu; menu = menu._parentMenu) {
          menu._cancelOpenTimer();
          menu._cancelCloseTimer();
          menu.activeIndex = menu._childIndex;
        }
      }
      /**
       * Handle the `'mouseleave'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the menu node.
       */
      _evtMouseLeave(event) {
        this._cancelOpenTimer();
        if (!this._childMenu) {
          this.activeIndex = -1;
          return;
        }
        let { clientX, clientY } = event;
        if (ElementExt.hitTest(this._childMenu.node, clientX, clientY)) {
          this._cancelCloseTimer();
          return;
        }
        this.activeIndex = -1;
        this._startCloseTimer();
      }
      /**
       * Handle the `'mousedown'` event for the menu.
       *
       * #### Notes
       * This listener is attached to the document node.
       */
      _evtMouseDown(event) {
        if (this._parentMenu) {
          return;
        }
        if (Private$94.hitTestMenus(this, event.clientX, event.clientY)) {
          event.preventDefault();
          event.stopPropagation();
        } else {
          this.close();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if the active item is not a valid submenu.
       */
      _openChildMenu(activateFirst = false) {
        let item = this.activeItem;
        if (!item || item.type !== "submenu" || !item.submenu) {
          this._closeChildMenu();
          return;
        }
        let submenu = item.submenu;
        if (submenu === this._childMenu) {
          return;
        }
        Menu4.saveWindowData();
        this._closeChildMenu();
        this._childMenu = submenu;
        this._childIndex = this._activeIndex;
        submenu._parentMenu = this;
        MessageLoop5.sendMessage(this, Widget5.Msg.UpdateRequest);
        let itemNode = this.contentNode.children[this._activeIndex];
        Private$94.openSubmenu(submenu, itemNode);
        if (activateFirst) {
          submenu.activeIndex = -1;
          submenu.activateNextItem();
        }
        submenu.activate();
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (this._childMenu) {
          this._childMenu.close();
        }
      }
      /**
       * Start the open timer, unless it is already pending.
       */
      _startOpenTimer() {
        if (this._openTimerID === 0) {
          this._openTimerID = window.setTimeout(() => {
            this._openTimerID = 0;
            this._openChildMenu();
          }, Private$94.TIMER_DELAY);
        }
      }
      /**
       * Start the close timer, unless it is already pending.
       */
      _startCloseTimer() {
        if (this._closeTimerID === 0) {
          this._closeTimerID = window.setTimeout(() => {
            this._closeTimerID = 0;
            this._closeChildMenu();
          }, Private$94.TIMER_DELAY);
        }
      }
      /**
       * Cancel the open timer, if the timer is pending.
       */
      _cancelOpenTimer() {
        if (this._openTimerID !== 0) {
          clearTimeout(this._openTimerID);
          this._openTimerID = 0;
        }
      }
      /**
       * Cancel the close timer, if the timer is pending.
       */
      _cancelCloseTimer() {
        if (this._closeTimerID !== 0) {
          clearTimeout(this._closeTimerID);
          this._closeTimerID = 0;
        }
      }
      /**
       * Save window data used for menu positioning in transient cache.
       *
       * In order to avoid layout trashing it is recommended to invoke this
       * method immediately prior to opening the menu and any DOM modifications
       * (like closing previously visible menu, or adding a class to menu widget).
       *
       * The transient cache will be released upon `open()` call.
       */
      static saveWindowData() {
        Private$94.saveWindowData();
      }
    };
    (function(Menu5) {
      class Renderer {
        /**
         * Render the virtual element for a menu item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            tabindex: "0",
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data), this.renderShortcut(data), this.renderSubmenu(data));
        }
        /**
         * Render the icon element for a menu item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.item.icon, data.item.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-Menu-itemLabel" }, content);
        }
        /**
         * Render the shortcut element for a menu item.
         *
         * @param data - The data to use for rendering the shortcut.
         *
         * @returns A virtual element representing the item shortcut.
         */
        renderShortcut(data) {
          let content = this.formatShortcut(data);
          return h.div({ className: "lm-Menu-itemShortcut" }, content);
        }
        /**
         * Render the submenu icon element for a menu item.
         *
         * @param data - The data to use for rendering the submenu icon.
         *
         * @returns A virtual element representing the submenu icon.
         */
        renderSubmenu(data) {
          return h.div({ className: "lm-Menu-itemSubmenuIcon" });
        }
        /**
         * Create the class name for the menu item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-Menu-item";
          if (!data.item.isEnabled) {
            name += " lm-mod-disabled";
          }
          if (data.item.isToggled) {
            name += " lm-mod-toggled";
          }
          if (!data.item.isVisible) {
            name += " lm-mod-hidden";
          }
          if (data.active) {
            name += " lm-mod-active";
          }
          if (data.collapsed) {
            name += " lm-mod-collapsed";
          }
          let extra = data.item.className;
          if (extra) {
            name += ` ${extra}`;
          }
          return name;
        }
        /**
         * Create the dataset for the menu item.
         *
         * @param data - The data to use for creating the dataset.
         *
         * @returns The dataset for the menu item.
         */
        createItemDataset(data) {
          let result2;
          let { type, command, dataset } = data.item;
          if (type === "command") {
            result2 = { ...dataset, type, command };
          } else {
            result2 = { ...dataset, type };
          }
          return result2;
        }
        /**
         * Create the class name for the menu item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-Menu-itemIcon";
          let extra = data.item.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the aria attributes for menu item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          let aria = {};
          switch (data.item.type) {
            case "separator":
              aria.role = "presentation";
              break;
            case "submenu":
              aria["aria-haspopup"] = "true";
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              break;
            default:
              if (!data.item.isEnabled) {
                aria["aria-disabled"] = "true";
              }
              if (data.item.isToggled) {
                aria.role = "menuitemcheckbox";
                aria["aria-checked"] = "true";
              } else {
                aria.role = "menuitem";
              }
          }
          return aria;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.item;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-Menu-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
        /**
         * Create the render content for the shortcut node.
         *
         * @param data - The data to use for the shortcut content.
         *
         * @returns The content to add to the shortcut node.
         */
        formatShortcut(data) {
          let kb = data.item.keyBinding;
          return kb ? CommandRegistry.formatKeystroke(kb.keys) : null;
        }
      }
      Menu5.Renderer = Renderer;
      Menu5.defaultRenderer = new Renderer();
    })(Menu4 || (Menu4 = {}));
    (function(Private22) {
      Private22.TIMER_DELAY = 300;
      Private22.SUBMENU_OVERLAP = 3;
      let transientWindowDataCache = null;
      let transientCacheCounter = 0;
      function getWindowData() {
        if (transientCacheCounter > 0) {
          transientCacheCounter--;
          return transientWindowDataCache;
        }
        return _getWindowData();
      }
      function saveWindowData() {
        transientWindowDataCache = _getWindowData();
        transientCacheCounter++;
      }
      Private22.saveWindowData = saveWindowData;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-Menu-content";
        node.appendChild(content);
        content.setAttribute("role", "menu");
        node.tabIndex = 0;
        return node;
      }
      Private22.createNode = createNode;
      function canActivate(item) {
        return item.type !== "separator" && item.isEnabled && item.isVisible;
      }
      Private22.canActivate = canActivate;
      function createItem(owner, options) {
        return new MenuItem(owner.commands, options);
      }
      Private22.createItem = createItem;
      function hitTestMenus(menu, x2, y4) {
        for (let temp = menu; temp; temp = temp.childMenu) {
          if (ElementExt.hitTest(temp.node, x2, y4)) {
            return true;
          }
        }
        return false;
      }
      Private22.hitTestMenus = hitTestMenus;
      function computeCollapsed(items) {
        let result2 = new Array(items.length);
        ArrayExt.fill(result2, false);
        let k1 = 0;
        let n5 = items.length;
        for (; k1 < n5; ++k1) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k1] = true;
        }
        let k2 = n5 - 1;
        for (; k2 >= 0; --k2) {
          let item = items[k2];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            break;
          }
          result2[k2] = true;
        }
        let hide4 = false;
        while (++k1 < k2) {
          let item = items[k1];
          if (!item.isVisible) {
            continue;
          }
          if (item.type !== "separator") {
            hide4 = false;
          } else if (hide4) {
            result2[k1] = true;
          } else {
            hide4 = true;
          }
        }
        return result2;
      }
      Private22.computeCollapsed = computeCollapsed;
      function _getWindowData() {
        return {
          pageXOffset: window.pageXOffset,
          pageYOffset: window.pageYOffset,
          clientWidth: document.documentElement.clientWidth,
          clientHeight: document.documentElement.clientHeight
        };
      }
      function openRootMenu(menu, x2, y4, forceX, forceY, horizontalAlignment, host, ref) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop5.sendMessage(menu, Widget5.Msg.UpdateRequest);
        let maxHeight = ch - (forceY ? y4 : 0);
        let node = menu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget5.attach(menu, host || document.body, ref);
        let { width, height } = node.getBoundingClientRect();
        if (horizontalAlignment === "right") {
          x2 -= width;
        }
        if (!forceX && x2 + width > px + cw) {
          x2 = px + cw - width;
        }
        if (!forceY && y4 + height > py + ch) {
          if (y4 > py + ch) {
            y4 = py + ch - height;
          } else {
            y4 = y4 - height;
          }
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openRootMenu = openRootMenu;
      function openSubmenu(submenu, itemNode) {
        const windowData = getWindowData();
        let px = windowData.pageXOffset;
        let py = windowData.pageYOffset;
        let cw = windowData.clientWidth;
        let ch = windowData.clientHeight;
        MessageLoop5.sendMessage(submenu, Widget5.Msg.UpdateRequest);
        let maxHeight = ch;
        let node = submenu.node;
        let style = node.style;
        style.opacity = "0";
        style.maxHeight = `${maxHeight}px`;
        Widget5.attach(submenu, document.body);
        let { width, height } = node.getBoundingClientRect();
        let box = ElementExt.boxSizing(submenu.node);
        let itemRect = itemNode.getBoundingClientRect();
        let x2 = itemRect.right - Private22.SUBMENU_OVERLAP;
        if (x2 + width > px + cw) {
          x2 = itemRect.left + Private22.SUBMENU_OVERLAP - width;
        }
        let y4 = itemRect.top - box.borderTop - box.paddingTop;
        if (y4 + height > py + ch) {
          y4 = itemRect.bottom + box.borderBottom + box.paddingBottom - height;
        }
        style.transform = `translate(${Math.max(0, x2)}px, ${Math.max(0, y4)}px`;
        style.opacity = "1";
      }
      Private22.openSubmenu = openSubmenu;
      function findMnemonic(items, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let item = items[k2];
          if (!canActivate(item)) {
            continue;
          }
          let label = item.label;
          if (label.length === 0) {
            continue;
          }
          let mn = item.mnemonic;
          if (mn >= 0 && mn < label.length) {
            if (label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
      class MenuItem {
        /**
         * Construct a new menu item.
         */
        constructor(commands, options) {
          this._commands = commands;
          this.type = options.type || "command";
          this.command = options.command || "";
          this.args = options.args || import_coreutils19.JSONExt.emptyObject;
          this.submenu = options.submenu || null;
        }
        /**
         * The display label for the menu item.
         */
        get label() {
          if (this.type === "command") {
            return this._commands.label(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.label;
          }
          return "";
        }
        /**
         * The mnemonic index for the menu item.
         */
        get mnemonic() {
          if (this.type === "command") {
            return this._commands.mnemonic(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.mnemonic;
          }
          return -1;
        }
        /**
         * The icon renderer for the menu item.
         */
        get icon() {
          if (this.type === "command") {
            return this._commands.icon(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.icon;
          }
          return void 0;
        }
        /**
         * The icon class for the menu item.
         */
        get iconClass() {
          if (this.type === "command") {
            return this._commands.iconClass(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconClass;
          }
          return "";
        }
        /**
         * The icon label for the menu item.
         */
        get iconLabel() {
          if (this.type === "command") {
            return this._commands.iconLabel(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.iconLabel;
          }
          return "";
        }
        /**
         * The display caption for the menu item.
         */
        get caption() {
          if (this.type === "command") {
            return this._commands.caption(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.caption;
          }
          return "";
        }
        /**
         * The extra class name for the menu item.
         */
        get className() {
          if (this.type === "command") {
            return this._commands.className(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.className;
          }
          return "";
        }
        /**
         * The dataset for the menu item.
         */
        get dataset() {
          if (this.type === "command") {
            return this._commands.dataset(this.command, this.args);
          }
          if (this.type === "submenu" && this.submenu) {
            return this.submenu.title.dataset;
          }
          return {};
        }
        /**
         * Whether the menu item is enabled.
         */
        get isEnabled() {
          if (this.type === "command") {
            return this._commands.isEnabled(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * Whether the menu item is toggled.
         */
        get isToggled() {
          if (this.type === "command") {
            return this._commands.isToggled(this.command, this.args);
          }
          return false;
        }
        /**
         * Whether the menu item is visible.
         */
        get isVisible() {
          if (this.type === "command") {
            return this._commands.isVisible(this.command, this.args);
          }
          if (this.type === "submenu") {
            return this.submenu !== null;
          }
          return true;
        }
        /**
         * The key binding for the menu item.
         */
        get keyBinding() {
          if (this.type === "command") {
            let { command, args } = this;
            return ArrayExt.findLastValue(this._commands.keyBindings, (kb) => {
              return kb.command === command && import_coreutils19.JSONExt.deepEqual(kb.args, args);
            }) || null;
          }
          return null;
        }
      }
    })(Private$94 || (Private$94 = {}));
    (function(Private22) {
      function createItem(options, id) {
        let selector = validateSelector(options.selector);
        let rank = options.rank !== void 0 ? options.rank : Infinity;
        return { ...options, selector, rank, id };
      }
      Private22.createItem = createItem;
      function matchItems(items, event, groupByTarget, sortBySelector) {
        let target = event.target;
        if (!target) {
          return null;
        }
        let currentTarget = event.currentTarget;
        if (!currentTarget) {
          return null;
        }
        if (!currentTarget.contains(target)) {
          target = document.elementFromPoint(event.clientX, event.clientY);
          if (!target || !currentTarget.contains(target)) {
            return null;
          }
        }
        let result2 = [];
        let availableItems = items.slice();
        while (target !== null) {
          let matches2 = [];
          for (let i6 = 0, n5 = availableItems.length; i6 < n5; ++i6) {
            let item = availableItems[i6];
            if (!item) {
              continue;
            }
            if (!Selector.matches(target, item.selector)) {
              continue;
            }
            matches2.push(item);
            availableItems[i6] = null;
          }
          if (matches2.length !== 0) {
            if (groupByTarget) {
              matches2.sort(sortBySelector ? itemCmp : itemCmpRank);
            }
            result2.push(...matches2);
          }
          if (target === currentTarget) {
            break;
          }
          target = target.parentElement;
        }
        if (!groupByTarget) {
          result2.sort(sortBySelector ? itemCmp : itemCmpRank);
        }
        return result2;
      }
      Private22.matchItems = matchItems;
      function validateSelector(selector) {
        if (selector.indexOf(",") !== -1) {
          throw new Error(`Selector cannot contain commas: ${selector}`);
        }
        if (!Selector.isValid(selector)) {
          throw new Error(`Invalid selector: ${selector}`);
        }
        return selector;
      }
      function itemCmpRank(a3, b2) {
        let r1 = a3.rank;
        let r22 = b2.rank;
        if (r1 !== r22) {
          return r1 < r22 ? -1 : 1;
        }
        return a3.id - b2.id;
      }
      function itemCmp(a3, b2) {
        let s1 = Selector.calculateSpecificity(a3.selector);
        let s22 = Selector.calculateSpecificity(b2.selector);
        if (s1 !== s22) {
          return s22 - s1;
        }
        return itemCmpRank(a3, b2);
      }
    })(Private$84 || (Private$84 = {}));
    ARROW_KEYS4 = [
      "ArrowLeft",
      "ArrowUp",
      "ArrowRight",
      "ArrowDown",
      "Home",
      "End"
    ];
    TabBar5 = class extends Widget5 {
      /**
       * Construct a new tab bar.
       *
       * @param options - The options for initializing the tab bar.
       */
      constructor(options = {}) {
        super({ node: Private$74.createNode() });
        this._currentIndex = -1;
        this._titles = [];
        this._titlesEditable = false;
        this._previousTitle = null;
        this._dragData = null;
        this._addButtonEnabled = false;
        this._tabMoved = new Signal(this);
        this._currentChanged = new Signal(this);
        this._addRequested = new Signal(this);
        this._tabCloseRequested = new Signal(this);
        this._tabDetachRequested = new Signal(this);
        this._tabActivateRequested = new Signal(this);
        this.addClass("lm-TabBar");
        this.contentNode.setAttribute("role", "tablist");
        this.setFlag(Widget5.Flag.DisallowLayout);
        this._document = options.document || document;
        this.tabsMovable = options.tabsMovable || false;
        this.titlesEditable = options.titlesEditable || false;
        this.allowDeselect = options.allowDeselect || false;
        this.addButtonEnabled = options.addButtonEnabled || false;
        this.insertBehavior = options.insertBehavior || "select-tab-if-needed";
        this.name = options.name || "";
        this.orientation = options.orientation || "horizontal";
        this.removeBehavior = options.removeBehavior || "select-tab-after";
        this.renderer = options.renderer || TabBar5.defaultRenderer;
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._releaseMouse();
        this._titles.length = 0;
        this._previousTitle = null;
        super.dispose();
      }
      /**
       * A signal emitted when the current tab is changed.
       *
       * #### Notes
       * This signal is emitted when the currently selected tab is changed
       * either through user or programmatic interaction.
       *
       * Notably, this signal is not emitted when the index of the current
       * tab changes due to tabs being inserted, removed, or moved. It is
       * only emitted when the actual current tab node is changed.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * A signal emitted when a tab is moved by the user.
       *
       * #### Notes
       * This signal is emitted when a tab is moved by user interaction.
       *
       * This signal is not emitted when a tab is moved programmatically.
       */
      get tabMoved() {
        return this._tabMoved;
      }
      /**
       * A signal emitted when a tab is clicked by the user.
       *
       * #### Notes
       * If the clicked tab is not the current tab, the clicked tab will be
       * made current and the `currentChanged` signal will be emitted first.
       *
       * This signal is emitted even if the clicked tab is the current tab.
       */
      get tabActivateRequested() {
        return this._tabActivateRequested;
      }
      /**
       * A signal emitted when the tab bar add button is clicked.
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * A signal emitted when a tab close icon is clicked.
       *
       * #### Notes
       * This signal is not emitted unless the tab title is `closable`.
       */
      get tabCloseRequested() {
        return this._tabCloseRequested;
      }
      /**
       * A signal emitted when a tab is dragged beyond the detach threshold.
       *
       * #### Notes
       * This signal is emitted when the user drags a tab with the mouse,
       * and mouse is dragged beyond the detach threshold.
       *
       * The consumer of the signal should call `releaseMouse` and remove
       * the tab in order to complete the detach.
       *
       * This signal is only emitted once per drag cycle.
       */
      get tabDetachRequested() {
        return this._tabDetachRequested;
      }
      /**
       * The document to use with the tab bar.
       *
       * The default is the global `document` instance.
       */
      get document() {
        return this._document;
      }
      /**
       * Whether the titles can be user-edited.
       *
       */
      get titlesEditable() {
        return this._titlesEditable;
      }
      /**
       * Set whether titles can be user edited.
       *
       */
      set titlesEditable(value) {
        this._titlesEditable = value;
      }
      /**
       * Get the currently selected title.
       *
       * #### Notes
       * This will be `null` if no tab is selected.
       */
      get currentTitle() {
        return this._titles[this._currentIndex] || null;
      }
      /**
       * Set the currently selected title.
       *
       * #### Notes
       * If the title does not exist, the title will be set to `null`.
       */
      set currentTitle(value) {
        this.currentIndex = value ? this._titles.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently selected tab.
       *
       * #### Notes
       * This will be `-1` if no tab is selected.
       */
      get currentIndex() {
        return this._currentIndex;
      }
      /**
       * Set the index of the currently selected tab.
       *
       * #### Notes
       * If the value is out of range, the index will be set to `-1`.
       */
      set currentIndex(value) {
        if (value < 0 || value >= this._titles.length) {
          value = -1;
        }
        if (this._currentIndex === value) {
          return;
        }
        let pi = this._currentIndex;
        let pt = this._titles[pi] || null;
        let ci = value;
        let ct = this._titles[ci] || null;
        this._currentIndex = ci;
        this._previousTitle = pt;
        this.update();
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: ci,
          currentTitle: ct
        });
      }
      /**
       * Get the name of the tab bar.
       */
      get name() {
        return this._name;
      }
      /**
       * Set the name of the tab bar.
       */
      set name(value) {
        this._name = value;
        if (value) {
          this.contentNode.setAttribute("aria-label", value);
        } else {
          this.contentNode.removeAttribute("aria-label");
        }
      }
      /**
       * Get the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      get orientation() {
        return this._orientation;
      }
      /**
       * Set the orientation of the tab bar.
       *
       * #### Notes
       * This controls whether the tabs are arranged in a row or column.
       */
      set orientation(value) {
        if (this._orientation === value) {
          return;
        }
        this._releaseMouse();
        this._orientation = value;
        this.dataset["orientation"] = value;
        this.contentNode.setAttribute("aria-orientation", value);
      }
      /**
       * Whether the add button is enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add button is enabled.
       */
      set addButtonEnabled(value) {
        if (this._addButtonEnabled === value) {
          return;
        }
        this._addButtonEnabled = value;
        if (value) {
          this.addButtonNode.classList.remove("lm-mod-hidden");
        } else {
          this.addButtonNode.classList.add("lm-mod-hidden");
        }
      }
      /**
       * A read-only array of the titles in the tab bar.
       */
      get titles() {
        return this._titles;
      }
      /**
       * The tab bar content node.
       *
       * #### Notes
       * This is the node which holds the tab nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-TabBar-content")[0];
      }
      /**
       * The tab bar add button node.
       *
       * #### Notes
       * This is the node which holds the add button.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get addButtonNode() {
        return this.node.getElementsByClassName("lm-TabBar-addButton")[0];
      }
      /**
       * Add a tab to the end of the tab bar.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * If the title is already added to the tab bar, it will be moved.
       */
      addTab(value) {
        return this.insertTab(this._titles.length, value);
      }
      /**
       * Insert a tab into the tab bar at the specified index.
       *
       * @param index - The index at which to insert the tab.
       *
       * @param value - The title which holds the data for the tab,
       *   or an options object to convert to a title.
       *
       * @returns The title object added to the tab bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the tabs.
       *
       * If the title is already added to the tab bar, it will be moved.
       */
      insertTab(index2, value) {
        this._releaseMouse();
        let title = Private$74.asTitle(value);
        let i6 = this._titles.indexOf(title);
        let j2 = Math.max(0, Math.min(index2, this._titles.length));
        if (i6 === -1) {
          ArrayExt.insert(this._titles, j2, title);
          title.changed.connect(this._onTitleChanged, this);
          this.update();
          this._adjustCurrentForInsert(j2, title);
          return title;
        }
        if (j2 === this._titles.length) {
          j2--;
        }
        if (i6 === j2) {
          return title;
        }
        ArrayExt.move(this._titles, i6, j2);
        this.update();
        this._adjustCurrentForMove(i6, j2);
        return title;
      }
      /**
       * Remove a tab from the tab bar.
       *
       * @param title - The title for the tab to remove.
       *
       * #### Notes
       * This is a no-op if the title is not in the tab bar.
       */
      removeTab(title) {
        this.removeTabAt(this._titles.indexOf(title));
      }
      /**
       * Remove the tab at a given index from the tab bar.
       *
       * @param index - The index of the tab to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeTabAt(index2) {
        this._releaseMouse();
        let title = ArrayExt.removeAt(this._titles, index2);
        if (!title) {
          return;
        }
        title.changed.disconnect(this._onTitleChanged, this);
        if (title === this._previousTitle) {
          this._previousTitle = null;
        }
        this.update();
        this._adjustCurrentForRemove(index2, title);
      }
      /**
       * Remove all tabs from the tab bar.
       */
      clearTabs() {
        if (this._titles.length === 0) {
          return;
        }
        this._releaseMouse();
        for (let title of this._titles) {
          title.changed.disconnect(this._onTitleChanged, this);
        }
        let pi = this.currentIndex;
        let pt = this.currentTitle;
        this._currentIndex = -1;
        this._previousTitle = null;
        this._titles.length = 0;
        this.update();
        if (pi === -1) {
          return;
        }
        this._currentChanged.emit({
          previousIndex: pi,
          previousTitle: pt,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       *
       * #### Notes
       * This will cause the tab bar to stop handling mouse events and to
       * restore the tabs to their non-dragged positions.
       */
      releaseMouse() {
        this._releaseMouse();
      }
      /**
       * Handle the DOM events for the tab bar.
       *
       * @param event - The DOM event sent to the tab bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the tab bar's DOM node.
       *
       * This should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "dblclick":
            this._evtDblClick(event);
            break;
          case "keydown":
            event.eventPhase === Event.CAPTURING_PHASE ? this._evtKeyDownCapturing(event) : this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("pointerdown", this);
        this.node.addEventListener("dblclick", this);
        this.node.addEventListener("keydown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("pointerdown", this);
        this.node.removeEventListener("dblclick", this);
        this.node.removeEventListener("keydown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let titles = this._titles;
        let renderer = this.renderer;
        let currentTitle = this.currentTitle;
        let content = new Array(titles.length);
        const tabHandlingTabindex = (_a = this._getCurrentTabindex()) !== null && _a !== void 0 ? _a : this._currentIndex > -1 ? this._currentIndex : 0;
        for (let i6 = 0, n5 = titles.length; i6 < n5; ++i6) {
          let title = titles[i6];
          let current = title === currentTitle;
          let zIndex = current ? n5 : n5 - i6 - 1;
          let tabIndex = tabHandlingTabindex === i6 ? 0 : -1;
          content[i6] = renderer.renderTab({ title, current, zIndex, tabIndex });
        }
        VirtualDOM.render(content, this.contentNode);
      }
      /**
       * Get the index of the tab which handles tabindex="0".
       * If the add button handles tabindex="0", -1 is returned.
       * If none of the previous handles tabindex="0", null is returned.
       */
      _getCurrentTabindex() {
        let index2 = null;
        const elemTabindex = this.contentNode.querySelector('li[tabindex="0"]');
        if (elemTabindex) {
          index2 = [...this.contentNode.children].indexOf(elemTabindex);
        } else if (this._addButtonEnabled && this.addButtonNode.getAttribute("tabindex") === "0") {
          index2 = -1;
        }
        return index2;
      }
      /**
       * Handle the `'dblclick'` event for the tab bar.
       */
      _evtDblClick(event) {
        if (!this.titlesEditable) {
          return;
        }
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          return;
        }
        let title = this.titles[index2];
        let label = tabs[index2].querySelector(".lm-TabBar-tabLabel");
        if (label && label.contains(event.target)) {
          let value = title.label || "";
          let oldValue = label.innerHTML;
          label.innerHTML = "";
          let input = document.createElement("input");
          input.classList.add("lm-TabBar-tabInput");
          input.value = value;
          label.appendChild(input);
          let onblur = () => {
            input.removeEventListener("blur", onblur);
            label.innerHTML = oldValue;
            this.node.addEventListener("keydown", this);
          };
          input.addEventListener("dblclick", (event2) => event2.stopPropagation());
          input.addEventListener("blur", onblur);
          input.addEventListener("keydown", (event2) => {
            if (event2.key === "Enter") {
              if (input.value !== "") {
                title.label = title.caption = input.value;
              }
              onblur();
            } else if (event2.key === "Escape") {
              onblur();
            }
          });
          this.node.removeEventListener("keydown", this);
          input.select();
          input.focus();
          if (label.children.length > 0) {
            label.children[0].focus();
          }
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at capturing phase.
       */
      _evtKeyDownCapturing(event) {
        if (event.eventPhase !== Event.CAPTURING_PHASE) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "Escape") {
          this._releaseMouse();
        }
      }
      /**
       * Handle the `'keydown'` event for the tab bar at target phase.
       */
      _evtKeyDown(event) {
        var _a, _b, _c;
        if (event.key === "Tab" || event.eventPhase === Event.CAPTURING_PHASE) {
          return;
        }
        if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
          const focusedElement = document.activeElement;
          if (this.addButtonEnabled && this.addButtonNode.contains(focusedElement)) {
            event.preventDefault();
            event.stopPropagation();
            this._addRequested.emit();
          } else {
            const index2 = ArrayExt.findFirstIndex(this.contentNode.children, (tab) => tab.contains(focusedElement));
            if (index2 >= 0) {
              event.preventDefault();
              event.stopPropagation();
              this.currentIndex = index2;
            }
          }
        } else if (ARROW_KEYS4.includes(event.key)) {
          const focusable = [...this.contentNode.children];
          if (this.addButtonEnabled) {
            focusable.push(this.addButtonNode);
          }
          if (focusable.length <= 1) {
            return;
          }
          event.preventDefault();
          event.stopPropagation();
          let focusedIndex = focusable.indexOf(document.activeElement);
          if (focusedIndex === -1) {
            focusedIndex = this._currentIndex;
          }
          let nextFocused;
          if (event.key === "ArrowRight" && this._orientation === "horizontal" || event.key === "ArrowDown" && this._orientation === "vertical") {
            nextFocused = (_a = focusable[focusedIndex + 1]) !== null && _a !== void 0 ? _a : focusable[0];
          } else if (event.key === "ArrowLeft" && this._orientation === "horizontal" || event.key === "ArrowUp" && this._orientation === "vertical") {
            nextFocused = (_b = focusable[focusedIndex - 1]) !== null && _b !== void 0 ? _b : focusable[focusable.length - 1];
          } else if (event.key === "Home") {
            nextFocused = focusable[0];
          } else if (event.key === "End") {
            nextFocused = focusable[focusable.length - 1];
          }
          if (nextFocused) {
            (_c = focusable[focusedIndex]) === null || _c === void 0 ? void 0 : _c.setAttribute("tabindex", "-1");
            nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.setAttribute("tabindex", "0");
            nextFocused.focus();
          }
        }
      }
      /**
       * Handle the `'pointerdown'` event for the tab bar.
       */
      _evtPointerDown(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        if (this._dragData) {
          return;
        }
        if (event.target.classList.contains("lm-TabBar-tabInput")) {
          return;
        }
        let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
        let tabs = this.contentNode.children;
        let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
          return ElementExt.hitTest(tab, event.clientX, event.clientY);
        });
        if (index2 === -1 && !addButtonClicked) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._dragData = {
          tab: tabs[index2],
          index: index2,
          pressX: event.clientX,
          pressY: event.clientY,
          tabPos: -1,
          tabSize: -1,
          tabPressPos: -1,
          targetIndex: -1,
          tabLayout: null,
          contentRect: null,
          override: null,
          dragActive: false,
          dragAborted: false,
          detachRequested: false
        };
        this.document.addEventListener("pointerup", this, true);
        if (event.button === 1 || addButtonClicked) {
          return;
        }
        let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
        if (icon && icon.contains(event.target)) {
          return;
        }
        if (this.tabsMovable) {
          this.document.addEventListener("pointermove", this, true);
          this.document.addEventListener("keydown", this, true);
          this.document.addEventListener("contextmenu", this, true);
        }
        if (this.allowDeselect && this.currentIndex === index2) {
          this.currentIndex = -1;
        } else {
          this.currentIndex = index2;
        }
        if (this.currentIndex === -1) {
          return;
        }
        this._tabActivateRequested.emit({
          index: this.currentIndex,
          title: this.currentTitle
        });
      }
      /**
       * Handle the `'pointermove'` event for the tab bar.
       */
      _evtPointerMove(event) {
        let data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let tabs = this.contentNode.children;
        if (!data.dragActive && !Private$74.dragExceeded(data, event)) {
          return;
        }
        if (!data.dragActive) {
          let tabRect = data.tab.getBoundingClientRect();
          if (this._orientation === "horizontal") {
            data.tabPos = data.tab.offsetLeft;
            data.tabSize = tabRect.width;
            data.tabPressPos = data.pressX - tabRect.left;
          } else {
            data.tabPos = data.tab.offsetTop;
            data.tabSize = tabRect.height;
            data.tabPressPos = data.pressY - tabRect.top;
          }
          data.tabPressOffset = {
            x: data.pressX - tabRect.left,
            y: data.pressY - tabRect.top
          };
          data.tabLayout = Private$74.snapTabLayout(tabs, this._orientation);
          data.contentRect = this.contentNode.getBoundingClientRect();
          data.override = Drag4.overrideCursor("default");
          data.tab.classList.add("lm-mod-dragging");
          this.addClass("lm-mod-dragging");
          data.dragActive = true;
        }
        if (!data.detachRequested && Private$74.detachExceeded(data, event)) {
          data.detachRequested = true;
          let index2 = data.index;
          let clientX = event.clientX;
          let clientY = event.clientY;
          let tab = tabs[index2];
          let title = this._titles[index2];
          this._tabDetachRequested.emit({
            index: index2,
            title,
            tab,
            clientX,
            clientY,
            offset: data.tabPressOffset
          });
          if (data.dragAborted) {
            return;
          }
        }
        Private$74.layoutTabs(tabs, data, event, this._orientation);
      }
      /**
       * Handle the `'pointerup'` event for the document.
       */
      _evtPointerUp(event) {
        if (event.button !== 0 && event.button !== 1) {
          return;
        }
        const data = this._dragData;
        if (!data) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        if (!data.dragActive) {
          this._dragData = null;
          let addButtonClicked = this.addButtonEnabled && this.addButtonNode.contains(event.target);
          if (addButtonClicked) {
            this._addRequested.emit(void 0);
            return;
          }
          let tabs = this.contentNode.children;
          let index2 = ArrayExt.findFirstIndex(tabs, (tab) => {
            return ElementExt.hitTest(tab, event.clientX, event.clientY);
          });
          if (index2 !== data.index) {
            return;
          }
          let title = this._titles[index2];
          if (!title.closable) {
            return;
          }
          if (event.button === 1) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          let icon = tabs[index2].querySelector(this.renderer.closeIconSelector);
          if (icon && icon.contains(event.target)) {
            this._tabCloseRequested.emit({ index: index2, title });
            return;
          }
          return;
        }
        if (event.button !== 0) {
          return;
        }
        Private$74.finalizeTabPosition(data, this._orientation);
        data.tab.classList.remove("lm-mod-dragging");
        let duration = Private$74.parseTransitionDuration(data.tab);
        setTimeout(() => {
          if (data.dragAborted) {
            return;
          }
          this._dragData = null;
          Private$74.resetTabPositions(this.contentNode.children, this._orientation);
          data.override.dispose();
          this.removeClass("lm-mod-dragging");
          let i6 = data.index;
          let j2 = data.targetIndex;
          if (j2 === -1 || i6 === j2) {
            return;
          }
          ArrayExt.move(this._titles, i6, j2);
          this._adjustCurrentForMove(i6, j2);
          this._tabMoved.emit({
            fromIndex: i6,
            toIndex: j2,
            title: this._titles[j2]
          });
          MessageLoop5.sendMessage(this, Widget5.Msg.UpdateRequest);
        }, duration);
      }
      /**
       * Release the mouse and restore the non-dragged tab positions.
       */
      _releaseMouse() {
        let data = this._dragData;
        if (!data) {
          return;
        }
        this._dragData = null;
        this.document.removeEventListener("pointermove", this, true);
        this.document.removeEventListener("pointerup", this, true);
        this.document.removeEventListener("keydown", this, true);
        this.document.removeEventListener("contextmenu", this, true);
        data.dragAborted = true;
        if (!data.dragActive) {
          return;
        }
        Private$74.resetTabPositions(this.contentNode.children, this._orientation);
        data.override.dispose();
        data.tab.classList.remove("lm-mod-dragging");
        this.removeClass("lm-mod-dragging");
      }
      /**
       * Adjust the current index for a tab insert operation.
       *
       * This method accounts for the tab bar's insertion behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForInsert(i6, title) {
        let ct = this.currentTitle;
        let ci = this._currentIndex;
        let bh = this.insertBehavior;
        if (bh === "select-tab" || bh === "select-tab-if-needed" && ci === -1) {
          this._currentIndex = i6;
          this._previousTitle = ct;
          this._currentChanged.emit({
            previousIndex: ci,
            previousTitle: ct,
            currentIndex: i6,
            currentTitle: title
          });
          return;
        }
        if (ci >= i6) {
          this._currentIndex++;
        }
      }
      /**
       * Adjust the current index for a tab move operation.
       *
       * This method will not cause the actual current tab to change.
       * It silently adjusts the index to account for the given move.
       */
      _adjustCurrentForMove(i6, j2) {
        if (this._currentIndex === i6) {
          this._currentIndex = j2;
        } else if (this._currentIndex < i6 && this._currentIndex >= j2) {
          this._currentIndex++;
        } else if (this._currentIndex > i6 && this._currentIndex <= j2) {
          this._currentIndex--;
        }
      }
      /**
       * Adjust the current index for a tab remove operation.
       *
       * This method accounts for the tab bar's remove behavior when
       * adjusting the current index and emitting the changed signal.
       */
      _adjustCurrentForRemove(i6, title) {
        let ci = this._currentIndex;
        let bh = this.removeBehavior;
        if (ci !== i6) {
          if (ci > i6) {
            this._currentIndex--;
          }
          return;
        }
        if (this._titles.length === 0) {
          this._currentIndex = -1;
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: -1,
            currentTitle: null
          });
          return;
        }
        if (bh === "select-tab-after") {
          this._currentIndex = Math.min(i6, this._titles.length - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-tab-before") {
          this._currentIndex = Math.max(0, i6 - 1);
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        if (bh === "select-previous-tab") {
          if (this._previousTitle) {
            this._currentIndex = this._titles.indexOf(this._previousTitle);
            this._previousTitle = null;
          } else {
            this._currentIndex = Math.min(i6, this._titles.length - 1);
          }
          this._currentChanged.emit({
            previousIndex: i6,
            previousTitle: title,
            currentIndex: this._currentIndex,
            currentTitle: this.currentTitle
          });
          return;
        }
        this._currentIndex = -1;
        this._currentChanged.emit({
          previousIndex: i6,
          previousTitle: title,
          currentIndex: -1,
          currentTitle: null
        });
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged(sender) {
        this.update();
      }
    };
    (function(TabBar6) {
      class Renderer {
        constructor() {
          this.closeIconSelector = ".lm-TabBar-tabCloseIcon";
          this._tabID = 0;
          this._tabKeys = /* @__PURE__ */ new WeakMap();
          this._uuid = ++Renderer._nInstance;
        }
        /**
         * Render the virtual element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab.
         */
        renderTab(data) {
          let title = data.title.caption;
          let key = this.createTabKey(data);
          let id = key;
          let style = this.createTabStyle(data);
          let className = this.createTabClass(data);
          let dataset = this.createTabDataset(data);
          let aria = this.createTabARIA(data);
          if (data.title.closable) {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data), this.renderCloseIcon(data));
          } else {
            return h.li({ id, key, className, title, style, dataset, ...aria }, this.renderIcon(data), this.renderLabel(data));
          }
        }
        /**
         * Render the icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab icon.
         */
        renderIcon(data) {
          const { title } = data;
          let className = this.createIconClass(data);
          return h.div({ className }, title.icon, title.iconLabel);
        }
        /**
         * Render the label element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab label.
         */
        renderLabel(data) {
          return h.div({ className: "lm-TabBar-tabLabel" }, data.title.label);
        }
        /**
         * Render the close icon element for a tab.
         *
         * @param data - The data to use for rendering the tab.
         *
         * @returns A virtual element representing the tab close icon.
         */
        renderCloseIcon(data) {
          return h.div({ className: "lm-TabBar-tabCloseIcon" });
        }
        /**
         * Create a unique render key for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The unique render key for the tab.
         *
         * #### Notes
         * This method caches the key against the tab title the first time
         * the key is generated. This enables efficient rendering of moved
         * tabs and avoids subtle hover style artifacts.
         */
        createTabKey(data) {
          let key = this._tabKeys.get(data.title);
          if (key === void 0) {
            key = `tab-key-${this._uuid}-${this._tabID++}`;
            this._tabKeys.set(data.title, key);
          }
          return key;
        }
        /**
         * Create the inline style object for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The inline style data for the tab.
         */
        createTabStyle(data) {
          return { zIndex: `${data.zIndex}` };
        }
        /**
         * Create the class name for the tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab.
         */
        createTabClass(data) {
          let name = "lm-TabBar-tab";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.title.closable) {
            name += " lm-mod-closable";
          }
          if (data.current) {
            name += " lm-mod-current";
          }
          return name;
        }
        /**
         * Create the dataset for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The dataset for the tab.
         */
        createTabDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the ARIA attributes for a tab.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The ARIA attributes for the tab.
         */
        createTabARIA(data) {
          var _a;
          return {
            role: "tab",
            "aria-selected": data.current.toString(),
            tabindex: `${(_a = data.tabIndex) !== null && _a !== void 0 ? _a : "-1"}`
          };
        }
        /**
         * Create the class name for the tab icon.
         *
         * @param data - The data to use for the tab.
         *
         * @returns The full class name for the tab icon.
         */
        createIconClass(data) {
          let name = "lm-TabBar-tabIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
      }
      Renderer._nInstance = 0;
      TabBar6.Renderer = Renderer;
      TabBar6.defaultRenderer = new Renderer();
      TabBar6.addButtonSelector = ".lm-TabBar-addButton";
    })(TabBar5 || (TabBar5 = {}));
    (function(Private22) {
      Private22.DRAG_THRESHOLD = 5;
      Private22.DETACH_THRESHOLD = 20;
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.setAttribute("role", "tablist");
        content.className = "lm-TabBar-content";
        node.appendChild(content);
        let add = document.createElement("div");
        add.className = "lm-TabBar-addButton lm-mod-hidden";
        add.setAttribute("tabindex", "-1");
        add.setAttribute("role", "button");
        node.appendChild(add);
        return node;
      }
      Private22.createNode = createNode;
      function asTitle(value) {
        return value instanceof Title5 ? value : new Title5(value);
      }
      Private22.asTitle = asTitle;
      function parseTransitionDuration(tab) {
        let style = window.getComputedStyle(tab);
        return 1e3 * (parseFloat(style.transitionDuration) || 0);
      }
      Private22.parseTransitionDuration = parseTransitionDuration;
      function snapTabLayout(tabs, orientation) {
        let layout = new Array(tabs.length);
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let node = tabs[i6];
          let style = window.getComputedStyle(node);
          if (orientation === "horizontal") {
            layout[i6] = {
              pos: node.offsetLeft,
              size: node.offsetWidth,
              margin: parseFloat(style.marginLeft) || 0
            };
          } else {
            layout[i6] = {
              pos: node.offsetTop,
              size: node.offsetHeight,
              margin: parseFloat(style.marginTop) || 0
            };
          }
        }
        return layout;
      }
      Private22.snapTabLayout = snapTabLayout;
      function dragExceeded(data, event) {
        let dx = Math.abs(event.clientX - data.pressX);
        let dy = Math.abs(event.clientY - data.pressY);
        return dx >= Private22.DRAG_THRESHOLD || dy >= Private22.DRAG_THRESHOLD;
      }
      Private22.dragExceeded = dragExceeded;
      function detachExceeded(data, event) {
        let rect = data.contentRect;
        return event.clientX < rect.left - Private22.DETACH_THRESHOLD || event.clientX >= rect.right + Private22.DETACH_THRESHOLD || event.clientY < rect.top - Private22.DETACH_THRESHOLD || event.clientY >= rect.bottom + Private22.DETACH_THRESHOLD;
      }
      Private22.detachExceeded = detachExceeded;
      function layoutTabs(tabs, data, event, orientation) {
        let pressPos;
        let localPos;
        let clientPos;
        let clientSize;
        if (orientation === "horizontal") {
          pressPos = data.pressX;
          localPos = event.clientX - data.contentRect.left;
          clientPos = event.clientX;
          clientSize = data.contentRect.width;
        } else {
          pressPos = data.pressY;
          localPos = event.clientY - data.contentRect.top;
          clientPos = event.clientY;
          clientSize = data.contentRect.height;
        }
        let targetIndex = data.index;
        let targetPos = localPos - data.tabPressPos;
        let targetEnd = targetPos + data.tabSize;
        for (let i6 = 0, n5 = tabs.length; i6 < n5; ++i6) {
          let pxPos;
          let layout = data.tabLayout[i6];
          let threshold = layout.pos + (layout.size >> 1);
          if (i6 < data.index && targetPos < threshold) {
            pxPos = `${data.tabSize + data.tabLayout[i6 + 1].margin}px`;
            targetIndex = Math.min(targetIndex, i6);
          } else if (i6 > data.index && targetEnd > threshold) {
            pxPos = `${-data.tabSize - layout.margin}px`;
            targetIndex = Math.max(targetIndex, i6);
          } else if (i6 === data.index) {
            let ideal = clientPos - pressPos;
            let limit = clientSize - (data.tabPos + data.tabSize);
            pxPos = `${Math.max(-data.tabPos, Math.min(ideal, limit))}px`;
          } else {
            pxPos = "";
          }
          if (orientation === "horizontal") {
            tabs[i6].style.left = pxPos;
          } else {
            tabs[i6].style.top = pxPos;
          }
        }
        data.targetIndex = targetIndex;
      }
      Private22.layoutTabs = layoutTabs;
      function finalizeTabPosition(data, orientation) {
        let clientSize;
        if (orientation === "horizontal") {
          clientSize = data.contentRect.width;
        } else {
          clientSize = data.contentRect.height;
        }
        let ideal;
        if (data.targetIndex === data.index) {
          ideal = 0;
        } else if (data.targetIndex > data.index) {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos + tgt.size - data.tabSize - data.tabPos;
        } else {
          let tgt = data.tabLayout[data.targetIndex];
          ideal = tgt.pos - data.tabPos;
        }
        let limit = clientSize - (data.tabPos + data.tabSize);
        let final = Math.max(-data.tabPos, Math.min(ideal, limit));
        if (orientation === "horizontal") {
          data.tab.style.left = `${final}px`;
        } else {
          data.tab.style.top = `${final}px`;
        }
      }
      Private22.finalizeTabPosition = finalizeTabPosition;
      function resetTabPositions(tabs, orientation) {
        for (const tab of tabs) {
          if (orientation === "horizontal") {
            tab.style.left = "";
          } else {
            tab.style.top = "";
          }
        }
      }
      Private22.resetTabPositions = resetTabPositions;
    })(Private$74 || (Private$74 = {}));
    DockLayout4 = class extends Layout4 {
      /**
       * Construct a new dock layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options) {
        super();
        this._spacing = 4;
        this._dirty = false;
        this._root = null;
        this._box = null;
        this._items = /* @__PURE__ */ new Map();
        this.renderer = options.renderer;
        if (options.spacing !== void 0) {
          this._spacing = Utils$14.clampDimension(options.spacing);
        }
        this._document = options.document || document;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget5.HiddenMode.Display;
      }
      /**
       * Dispose of the resources held by the layout.
       *
       * #### Notes
       * This will clear and dispose all widgets in the layout.
       */
      dispose() {
        let widgets = this[Symbol.iterator]();
        this._items.forEach((item) => {
          item.dispose();
        });
        this._box = null;
        this._root = null;
        this._items.clear();
        for (const widget of widgets) {
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding child widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        for (const bar of this.tabBars()) {
          if (bar.titles.length > 1) {
            for (const title of bar.titles) {
              title.owner.hiddenMode = this._hiddenMode;
            }
          }
        }
      }
      /**
       * Get the inter-element spacing for the dock layout.
       */
      get spacing() {
        return this._spacing;
      }
      /**
       * Set the inter-element spacing for the dock layout.
       */
      set spacing(value) {
        value = Utils$14.clampDimension(value);
        if (this._spacing === value) {
          return;
        }
        this._spacing = value;
        if (!this.parent) {
          return;
        }
        this.parent.fit();
      }
      /**
       * Whether the dock layout is empty.
       */
      get isEmpty() {
        return this._root === null;
      }
      /**
       * Create an iterator over all widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       *
       * #### Notes
       * This iterator includes the generated tab bars.
       */
      [Symbol.iterator]() {
        return this._root ? this._root.iterAllWidgets() : empty();
      }
      /**
       * Create an iterator over the user widgets in the layout.
       *
       * @returns A new iterator over the user widgets in the layout.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      widgets() {
        return this._root ? this._root.iterUserWidgets() : empty();
      }
      /**
       * Create an iterator over the selected widgets in the layout.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the layout.
       */
      selectedWidgets() {
        return this._root ? this._root.iterSelectedWidgets() : empty();
      }
      /**
       * Create an iterator over the tab bars in the layout.
       *
       * @returns A new iterator over the tab bars in the layout.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      tabBars() {
        return this._root ? this._root.iterTabBars() : empty();
      }
      /**
       * Create an iterator over the handles in the layout.
       *
       * @returns A new iterator over the handles in the layout.
       */
      handles() {
        return this._root ? this._root.iterHandles() : empty();
      }
      /**
       * Move a handle to the given offset position.
       *
       * @param handle - The handle to move.
       *
       * @param offsetX - The desired offset X position of the handle.
       *
       * @param offsetY - The desired offset Y position of the handle.
       *
       * #### Notes
       * If the given handle is not contained in the layout, this is no-op.
       *
       * The handle will be moved as close as possible to the desired
       * position without violating any of the layout constraints.
       *
       * Only one of the coordinates is used depending on the orientation
       * of the handle. This method accepts both coordinates to make it
       * easy to invoke from a mouse move event without needing to know
       * the handle orientation.
       */
      moveHandle(handle, offsetX, offsetY) {
        let hidden = handle.classList.contains("lm-mod-hidden");
        if (!this._root || hidden) {
          return;
        }
        let data = this._root.findSplitNode(handle);
        if (!data) {
          return;
        }
        let delta;
        if (data.node.orientation === "horizontal") {
          delta = offsetX - handle.offsetLeft;
        } else {
          delta = offsetY - handle.offsetTop;
        }
        if (delta === 0) {
          return;
        }
        data.node.holdSizes();
        BoxEngine4.adjust(data.node.sizers, data.index, delta);
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Save the current configuration of the dock layout.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        if (!this._root) {
          return { main: null };
        }
        this._root.holdAllSizes();
        return { main: this._root.createConfig() };
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       */
      restoreLayout(config) {
        let widgetSet = /* @__PURE__ */ new Set();
        let mainConfig;
        if (config.main) {
          mainConfig = Private$64.normalizeAreaConfig(config.main, widgetSet);
        } else {
          mainConfig = null;
        }
        let oldWidgets = this.widgets();
        let oldTabBars = this.tabBars();
        let oldHandles = this.handles();
        this._root = null;
        for (const widget of oldWidgets) {
          if (!widgetSet.has(widget)) {
            widget.parent = null;
          }
        }
        for (const tabBar of oldTabBars) {
          tabBar.dispose();
        }
        for (const handle of oldHandles) {
          if (handle.parentNode) {
            handle.parentNode.removeChild(handle);
          }
        }
        for (const widget of widgetSet) {
          widget.parent = this.parent;
        }
        if (mainConfig) {
          this._root = Private$64.realizeAreaConfig(mainConfig, {
            // Ignoring optional `document` argument as we must reuse `this._document`
            createTabBar: (document2) => this._createTabBar(),
            createHandle: () => this._createHandle()
          }, this._document);
        } else {
          this._root = null;
        }
        if (!this.parent) {
          return;
        }
        widgetSet.forEach((widget) => {
          this.attachWidget(widget);
        });
        this.parent.fit();
      }
      /**
       * Add a widget to the dock layout.
       *
       * @param widget - The widget to add to the dock layout.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * The widget will be moved if it is already contained in the layout.
       *
       * An error will be thrown if the reference widget is invalid.
       */
      addWidget(widget, options = {}) {
        let ref = options.ref || null;
        let mode = options.mode || "tab-after";
        let refNode = null;
        if (this._root && ref) {
          refNode = this._root.findTabNode(ref);
        }
        if (ref && !refNode) {
          throw new Error("Reference widget is not in the layout.");
        }
        widget.parent = this.parent;
        switch (mode) {
          case "tab-after":
            this._insertTab(widget, ref, refNode, true);
            break;
          case "tab-before":
            this._insertTab(widget, ref, refNode, false);
            break;
          case "split-top":
            this._insertSplit(widget, ref, refNode, "vertical", false);
            break;
          case "split-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false);
            break;
          case "split-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true);
            break;
          case "split-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true);
            break;
          case "merge-top":
            this._insertSplit(widget, ref, refNode, "vertical", false, true);
            break;
          case "merge-left":
            this._insertSplit(widget, ref, refNode, "horizontal", false, true);
            break;
          case "merge-right":
            this._insertSplit(widget, ref, refNode, "horizontal", true, true);
            break;
          case "merge-bottom":
            this._insertSplit(widget, ref, refNode, "vertical", true, true);
            break;
        }
        if (!this.parent) {
          return;
        }
        this.attachWidget(widget);
        this.parent.fit();
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        this._removeWidget(widget);
        if (!this.parent) {
          return;
        }
        this.detachWidget(widget);
        this.parent.fit();
      }
      /**
       * Find the tab area which contains the given client position.
       *
       * @param clientX - The client X position of interest.
       *
       * @param clientY - The client Y position of interest.
       *
       * @returns The geometry of the tab area at the given position, or
       *   `null` if there is no tab area at the given position.
       */
      hitTestTabAreas(clientX, clientY) {
        if (!this._root || !this.parent || !this.parent.isVisible) {
          return null;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let rect = this.parent.node.getBoundingClientRect();
        let x2 = clientX - rect.left - this._box.borderLeft;
        let y4 = clientY - rect.top - this._box.borderTop;
        let tabNode = this._root.hitTestTabNodes(x2, y4);
        if (!tabNode) {
          return null;
        }
        let { tabBar, top, left, width, height } = tabNode;
        let borderWidth = this._box.borderLeft + this._box.borderRight;
        let borderHeight = this._box.borderTop + this._box.borderBottom;
        let right = rect.width - borderWidth - (left + width);
        let bottom = rect.height - borderHeight - (top + height);
        return { tabBar, x: x2, y: y4, top, left, right, bottom, width, height };
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
        for (const handle of this.handles()) {
          this.parent.node.appendChild(handle);
        }
        this.parent.fit();
      }
      /**
       * Attach the widget to the layout parent widget.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a no-op if the widget is already attached.
       */
      attachWidget(widget) {
        if (this.parent.node === widget.node.parentNode) {
          return;
        }
        this._items.set(widget, new LayoutItem4(widget));
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
      }
      /**
       * Detach the widget from the layout parent widget.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a no-op if the widget is not attached.
       */
      detachWidget(widget) {
        if (this.parent.node !== widget.node.parentNode) {
          return;
        }
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
        let item = this._items.get(widget);
        if (item) {
          this._items.delete(widget);
          item.dispose();
        }
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Remove the specified widget from the layout structure.
       *
       * #### Notes
       * This is a no-op if the widget is not in the layout tree.
       *
       * This does not detach the widget from the parent node.
       */
      _removeWidget(widget) {
        if (!this._root) {
          return;
        }
        let tabNode = this._root.findTabNode(widget);
        if (!tabNode) {
          return;
        }
        Private$64.removeAria(widget);
        if (tabNode.tabBar.titles.length > 1) {
          tabNode.tabBar.removeTab(widget.title);
          if (this._hiddenMode === Widget5.HiddenMode.Scale && tabNode.tabBar.titles.length == 1) {
            const existingWidget = tabNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget5.HiddenMode.Display;
          }
          return;
        }
        tabNode.tabBar.dispose();
        if (this._root === tabNode) {
          this._root = null;
          return;
        }
        this._root.holdAllSizes();
        let splitNode = tabNode.parent;
        tabNode.parent = null;
        let i6 = ArrayExt.removeFirstOf(splitNode.children, tabNode);
        let handle = ArrayExt.removeAt(splitNode.handles, i6);
        ArrayExt.removeAt(splitNode.sizers, i6);
        if (handle.parentNode) {
          handle.parentNode.removeChild(handle);
        }
        if (splitNode.children.length > 1) {
          splitNode.syncHandles();
          return;
        }
        let maybeParent = splitNode.parent;
        splitNode.parent = null;
        let childNode = splitNode.children[0];
        let childHandle = splitNode.handles[0];
        splitNode.children.length = 0;
        splitNode.handles.length = 0;
        splitNode.sizers.length = 0;
        if (childHandle.parentNode) {
          childHandle.parentNode.removeChild(childHandle);
        }
        if (this._root === splitNode) {
          childNode.parent = null;
          this._root = childNode;
          return;
        }
        let parentNode = maybeParent;
        let j2 = parentNode.children.indexOf(splitNode);
        if (childNode instanceof Private$64.TabLayoutNode) {
          childNode.parent = parentNode;
          parentNode.children[j2] = childNode;
          return;
        }
        let splitHandle = ArrayExt.removeAt(parentNode.handles, j2);
        ArrayExt.removeAt(parentNode.children, j2);
        ArrayExt.removeAt(parentNode.sizers, j2);
        if (splitHandle.parentNode) {
          splitHandle.parentNode.removeChild(splitHandle);
        }
        for (let i7 = 0, n5 = childNode.children.length; i7 < n5; ++i7) {
          let gChild = childNode.children[i7];
          let gHandle = childNode.handles[i7];
          let gSizer = childNode.sizers[i7];
          ArrayExt.insert(parentNode.children, j2 + i7, gChild);
          ArrayExt.insert(parentNode.handles, j2 + i7, gHandle);
          ArrayExt.insert(parentNode.sizers, j2 + i7, gSizer);
          gChild.parent = parentNode;
        }
        childNode.children.length = 0;
        childNode.handles.length = 0;
        childNode.sizers.length = 0;
        childNode.parent = null;
        parentNode.syncHandles();
      }
      /**
       * Create the tab layout node to hold the widget.
       */
      _createTabNode(widget) {
        let tabNode = new Private$64.TabLayoutNode(this._createTabBar());
        tabNode.tabBar.addTab(widget.title);
        Private$64.addAria(widget, tabNode.tabBar);
        return tabNode;
      }
      /**
       * Insert a widget next to an existing tab.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertTab(widget, ref, refNode, after2) {
        if (widget === ref) {
          return;
        }
        if (!this._root) {
          let tabNode = new Private$64.TabLayoutNode(this._createTabBar());
          tabNode.tabBar.addTab(widget.title);
          this._root = tabNode;
          Private$64.addAria(widget, tabNode.tabBar);
          return;
        }
        if (!refNode) {
          refNode = this._root.findFirstTabNode();
        }
        if (refNode.tabBar.titles.indexOf(widget.title) === -1) {
          this._removeWidget(widget);
          widget.hide();
        }
        let index2;
        if (ref) {
          index2 = refNode.tabBar.titles.indexOf(ref.title);
        } else {
          index2 = refNode.tabBar.currentIndex;
        }
        if (this._hiddenMode === Widget5.HiddenMode.Scale) {
          if (refNode.tabBar.titles.length === 0) {
            widget.hiddenMode = Widget5.HiddenMode.Display;
          } else if (refNode.tabBar.titles.length == 1) {
            const existingWidget = refNode.tabBar.titles[0].owner;
            existingWidget.hiddenMode = Widget5.HiddenMode.Scale;
          } else {
            widget.hiddenMode = Widget5.HiddenMode.Scale;
          }
        } else {
          widget.hiddenMode = this._hiddenMode;
        }
        refNode.tabBar.insertTab(index2 + (after2 ? 1 : 0), widget.title);
        Private$64.addAria(widget, refNode.tabBar);
      }
      /**
       * Insert a widget as a new split area.
       *
       * #### Notes
       * This does not attach the widget to the parent widget.
       */
      _insertSplit(widget, ref, refNode, orientation, after2, merge = false) {
        if (widget === ref && refNode && refNode.tabBar.titles.length === 1) {
          return;
        }
        this._removeWidget(widget);
        if (!this._root) {
          this._root = this._createTabNode(widget);
          return;
        }
        if (!refNode || !refNode.parent) {
          let root2 = this._splitRoot(orientation);
          let i7 = after2 ? root2.children.length : 0;
          root2.normalizeSizes();
          let sizer = Private$64.createSizer(refNode ? 1 : Private$64.GOLDEN_RATIO);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(root2.children, i7, tabNode2);
          ArrayExt.insert(root2.sizers, i7, sizer);
          ArrayExt.insert(root2.handles, i7, this._createHandle());
          tabNode2.parent = root2;
          root2.normalizeSizes();
          root2.syncHandles();
          return;
        }
        let splitNode = refNode.parent;
        if (splitNode.orientation === orientation) {
          let i7 = splitNode.children.indexOf(refNode);
          if (merge) {
            let j4 = i7 + (after2 ? 1 : -1);
            let sibling = splitNode.children[j4];
            if (sibling instanceof Private$64.TabLayoutNode) {
              this._insertTab(widget, null, sibling, true);
              ++sibling.tabBar.currentIndex;
              return;
            }
          }
          splitNode.normalizeSizes();
          let s8 = splitNode.sizers[i7].sizeHint /= 2;
          let j3 = i7 + (after2 ? 1 : 0);
          let tabNode2 = this._createTabNode(widget);
          ArrayExt.insert(splitNode.children, j3, tabNode2);
          ArrayExt.insert(splitNode.sizers, j3, Private$64.createSizer(s8));
          ArrayExt.insert(splitNode.handles, j3, this._createHandle());
          tabNode2.parent = splitNode;
          splitNode.syncHandles();
          return;
        }
        let i6 = ArrayExt.removeFirstOf(splitNode.children, refNode);
        let childNode = new Private$64.SplitLayoutNode(orientation);
        childNode.normalized = true;
        childNode.children.push(refNode);
        childNode.sizers.push(Private$64.createSizer(0.5));
        childNode.handles.push(this._createHandle());
        refNode.parent = childNode;
        let j2 = after2 ? 1 : 0;
        let tabNode = this._createTabNode(widget);
        ArrayExt.insert(childNode.children, j2, tabNode);
        ArrayExt.insert(childNode.sizers, j2, Private$64.createSizer(0.5));
        ArrayExt.insert(childNode.handles, j2, this._createHandle());
        tabNode.parent = childNode;
        childNode.syncHandles();
        ArrayExt.insert(splitNode.children, i6, childNode);
        childNode.parent = splitNode;
      }
      /**
       * Ensure the root is a split node with the given orientation.
       */
      _splitRoot(orientation) {
        let oldRoot = this._root;
        if (oldRoot instanceof Private$64.SplitLayoutNode) {
          if (oldRoot.orientation === orientation) {
            return oldRoot;
          }
        }
        let newRoot = this._root = new Private$64.SplitLayoutNode(orientation);
        if (oldRoot) {
          newRoot.children.push(oldRoot);
          newRoot.sizers.push(Private$64.createSizer(0));
          newRoot.handles.push(this._createHandle());
          oldRoot.parent = newRoot;
        }
        return newRoot;
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        if (this._root) {
          let limits = this._root.fit(this._spacing, this._items);
          minW = limits.minWidth;
          minH = limits.minHeight;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop5.sendMessage(this.parent.parent, Widget5.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop5.sendMessage(this.parent, Widget5.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (!this._root) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let x2 = this._box.paddingTop;
        let y4 = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        this._root.update(x2, y4, width, height, this._spacing, this._items);
      }
      /**
       * Create a new tab bar for use by the dock layout.
       *
       * #### Notes
       * The tab bar will be attached to the parent if it exists.
       */
      _createTabBar() {
        let tabBar = this.renderer.createTabBar(this._document);
        tabBar.orientation = "horizontal";
        if (this.parent) {
          this.attachWidget(tabBar);
        }
        return tabBar;
      }
      /**
       * Create a new handle for the dock layout.
       *
       * #### Notes
       * The handle will be attached to the parent if it exists.
       */
      _createHandle() {
        let handle = this.renderer.createHandle();
        let style = handle.style;
        style.position = "absolute";
        style.contain = "strict";
        style.top = "0";
        style.left = "0";
        style.width = "0";
        style.height = "0";
        if (this.parent) {
          this.parent.node.appendChild(handle);
        }
        return handle;
      }
    };
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      function createSizer(hint) {
        let sizer = new BoxSizer4();
        sizer.sizeHint = hint;
        sizer.size = hint;
        return sizer;
      }
      Private22.createSizer = createSizer;
      function normalizeAreaConfig(config, widgetSet) {
        let result2;
        if (config.type === "tab-area") {
          result2 = normalizeTabAreaConfig(config, widgetSet);
        } else {
          result2 = normalizeSplitAreaConfig(config, widgetSet);
        }
        return result2;
      }
      Private22.normalizeAreaConfig = normalizeAreaConfig;
      function realizeAreaConfig(config, renderer, document2) {
        let node;
        if (config.type === "tab-area") {
          node = realizeTabAreaConfig(config, renderer, document2);
        } else {
          node = realizeSplitAreaConfig(config, renderer, document2);
        }
        return node;
      }
      Private22.realizeAreaConfig = realizeAreaConfig;
      class TabLayoutNode {
        /**
         * Construct a new tab layout node.
         *
         * @param tabBar - The tab bar to use for the layout node.
         */
        constructor(tabBar) {
          this.parent = null;
          this._top = 0;
          this._left = 0;
          this._width = 0;
          this._height = 0;
          let tabSizer = new BoxSizer4();
          let widgetSizer = new BoxSizer4();
          tabSizer.stretch = 0;
          widgetSizer.stretch = 1;
          this.tabBar = tabBar;
          this.sizers = [tabSizer, widgetSizer];
        }
        /**
         * The most recent value for the `top` edge of the layout box.
         */
        get top() {
          return this._top;
        }
        /**
         * The most recent value for the `left` edge of the layout box.
         */
        get left() {
          return this._left;
        }
        /**
         * The most recent value for the `width` of the layout box.
         */
        get width() {
          return this._width;
        }
        /**
         * The most recent value for the `height` of the layout box.
         */
        get height() {
          return this._height;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          yield this.tabBar;
          yield* this.iterUserWidgets();
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const title of this.tabBar.titles) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          let title = this.tabBar.currentTitle;
          if (title) {
            yield title.owner;
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          yield this.tabBar;
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        // eslint-disable-next-line require-yield
        *iterHandles() {
          return;
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          return this.tabBar.titles.indexOf(widget.title) !== -1 ? this : null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          return this;
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          if (x2 < this._left || x2 >= this._left + this._width) {
            return null;
          }
          if (y4 < this._top || y4 >= this._top + this._height) {
            return null;
          }
          return this;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let widgets = this.tabBar.titles.map((title) => title.owner);
          let currentIndex = this.tabBar.currentIndex;
          return { type: "tab-area", widgets, currentIndex };
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          return;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let minWidth = 0;
          let minHeight = 0;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          let [tabBarSizer, widgetSizer] = this.sizers;
          if (tabBarItem) {
            tabBarItem.fit();
          }
          if (widgetItem) {
            widgetItem.fit();
          }
          if (tabBarItem && !tabBarItem.isHidden) {
            minWidth = Math.max(minWidth, tabBarItem.minWidth);
            minHeight += tabBarItem.minHeight;
            tabBarSizer.minSize = tabBarItem.minHeight;
            tabBarSizer.maxSize = tabBarItem.maxHeight;
          } else {
            tabBarSizer.minSize = 0;
            tabBarSizer.maxSize = 0;
          }
          if (widgetItem && !widgetItem.isHidden) {
            minWidth = Math.max(minWidth, widgetItem.minWidth);
            minHeight += widgetItem.minHeight;
            widgetSizer.minSize = widgetItem.minHeight;
            widgetSizer.maxSize = Infinity;
          } else {
            widgetSizer.minSize = 0;
            widgetSizer.maxSize = Infinity;
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          this._top = top;
          this._left = left;
          this._width = width;
          this._height = height;
          let tabBarItem = items.get(this.tabBar);
          let current = this.tabBar.currentTitle;
          let widgetItem = current ? items.get(current.owner) : void 0;
          BoxEngine4.calc(this.sizers, height);
          if (tabBarItem && !tabBarItem.isHidden) {
            let size5 = this.sizers[0].size;
            tabBarItem.update(left, top, width, size5);
            top += size5;
          }
          if (widgetItem && !widgetItem.isHidden) {
            let size5 = this.sizers[1].size;
            widgetItem.update(left, top, width, size5);
          }
        }
      }
      Private22.TabLayoutNode = TabLayoutNode;
      class SplitLayoutNode {
        /**
         * Construct a new split layout node.
         *
         * @param orientation - The orientation of the node.
         */
        constructor(orientation) {
          this.parent = null;
          this.normalized = false;
          this.children = [];
          this.sizers = [];
          this.handles = [];
          this.orientation = orientation;
        }
        /**
         * Create an iterator for all widgets in the layout tree.
         */
        *iterAllWidgets() {
          for (const child of this.children) {
            yield* child.iterAllWidgets();
          }
        }
        /**
         * Create an iterator for the user widgets in the layout tree.
         */
        *iterUserWidgets() {
          for (const child of this.children) {
            yield* child.iterUserWidgets();
          }
        }
        /**
         * Create an iterator for the selected widgets in the layout tree.
         */
        *iterSelectedWidgets() {
          for (const child of this.children) {
            yield* child.iterSelectedWidgets();
          }
        }
        /**
         * Create an iterator for the tab bars in the layout tree.
         */
        *iterTabBars() {
          for (const child of this.children) {
            yield* child.iterTabBars();
          }
        }
        /**
         * Create an iterator for the handles in the layout tree.
         */
        *iterHandles() {
          yield* this.handles;
          for (const child of this.children) {
            yield* child.iterHandles();
          }
        }
        /**
         * Find the tab layout node which contains the given widget.
         */
        findTabNode(widget) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findTabNode(widget);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the split layout node which contains the given handle.
         */
        findSplitNode(handle) {
          let index2 = this.handles.indexOf(handle);
          if (index2 !== -1) {
            return { index: index2, node: this };
          }
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].findSplitNode(handle);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Find the first tab layout node in a layout tree.
         */
        findFirstTabNode() {
          if (this.children.length === 0) {
            return null;
          }
          return this.children[0].findFirstTabNode();
        }
        /**
         * Find the tab layout node which contains the local point.
         */
        hitTestTabNodes(x2, y4) {
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let result2 = this.children[i6].hitTestTabNodes(x2, y4);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        /**
         * Create a configuration object for the layout tree.
         */
        createConfig() {
          let orientation = this.orientation;
          let sizes = this.createNormalizedSizes();
          let children = this.children.map((child) => child.createConfig());
          return { type: "split-area", orientation, children, sizes };
        }
        /**
         * Sync the visibility and orientation of the handles.
         */
        syncHandles() {
          this.handles.forEach((handle, i6) => {
            handle.setAttribute("data-orientation", this.orientation);
            if (i6 === this.handles.length - 1) {
              handle.classList.add("lm-mod-hidden");
            } else {
              handle.classList.remove("lm-mod-hidden");
            }
          });
        }
        /**
         * Hold the current sizes of the box sizers.
         *
         * This sets the size hint of each sizer to its current size.
         */
        holdSizes() {
          for (const sizer of this.sizers) {
            sizer.sizeHint = sizer.size;
          }
        }
        /**
         * Recursively hold all of the sizes in the layout tree.
         *
         * This ignores the sizers of tab layout nodes.
         */
        holdAllSizes() {
          for (const child of this.children) {
            child.holdAllSizes();
          }
          this.holdSizes();
        }
        /**
         * Normalize the sizes of the split layout node.
         */
        normalizeSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return;
          }
          this.holdSizes();
          let sum = this.sizers.reduce((v4, sizer) => v4 + sizer.sizeHint, 0);
          if (sum === 0) {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint = 1 / n5;
            }
          } else {
            for (const sizer of this.sizers) {
              sizer.size = sizer.sizeHint /= sum;
            }
          }
          this.normalized = true;
        }
        /**
         * Snap the normalized sizes of the split layout node.
         */
        createNormalizedSizes() {
          let n5 = this.sizers.length;
          if (n5 === 0) {
            return [];
          }
          let sizes = this.sizers.map((sizer) => sizer.size);
          let sum = sizes.reduce((v4, size5) => v4 + size5, 0);
          if (sum === 0) {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] = 1 / n5;
            }
          } else {
            for (let i6 = sizes.length - 1; i6 > -1; i6--) {
              sizes[i6] /= sum;
            }
          }
          return sizes;
        }
        /**
         * Fit the layout tree.
         */
        fit(spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let minWidth = horizontal ? fixed : 0;
          let minHeight = horizontal ? 0 : fixed;
          let maxWidth = Infinity;
          let maxHeight = Infinity;
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let limits = this.children[i6].fit(spacing, items);
            if (horizontal) {
              minHeight = Math.max(minHeight, limits.minHeight);
              minWidth += limits.minWidth;
              this.sizers[i6].minSize = limits.minWidth;
            } else {
              minWidth = Math.max(minWidth, limits.minWidth);
              minHeight += limits.minHeight;
              this.sizers[i6].minSize = limits.minHeight;
            }
          }
          return { minWidth, minHeight, maxWidth, maxHeight };
        }
        /**
         * Update the layout tree.
         */
        update(left, top, width, height, spacing, items) {
          let horizontal = this.orientation === "horizontal";
          let fixed = Math.max(0, this.children.length - 1) * spacing;
          let space = Math.max(0, (horizontal ? width : height) - fixed);
          if (this.normalized) {
            for (const sizer of this.sizers) {
              sizer.sizeHint *= space;
            }
            this.normalized = false;
          }
          BoxEngine4.calc(this.sizers, space);
          for (let i6 = 0, n5 = this.children.length; i6 < n5; ++i6) {
            let child = this.children[i6];
            let size5 = this.sizers[i6].size;
            let handleStyle = this.handles[i6].style;
            if (horizontal) {
              child.update(left, top, size5, height, spacing, items);
              left += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${spacing}px`;
              handleStyle.height = `${height}px`;
              left += spacing;
            } else {
              child.update(left, top, width, size5, spacing, items);
              top += size5;
              handleStyle.top = `${top}px`;
              handleStyle.left = `${left}px`;
              handleStyle.width = `${width}px`;
              handleStyle.height = `${spacing}px`;
              top += spacing;
            }
          }
        }
      }
      Private22.SplitLayoutNode = SplitLayoutNode;
      function addAria(widget, tabBar) {
        widget.node.setAttribute("role", "tabpanel");
        let renderer = tabBar.renderer;
        if (renderer instanceof TabBar5.Renderer) {
          let tabId = renderer.createTabKey({
            title: widget.title,
            current: false,
            zIndex: 0
          });
          widget.node.setAttribute("aria-labelledby", tabId);
        }
      }
      Private22.addAria = addAria;
      function removeAria(widget) {
        widget.node.removeAttribute("role");
        widget.node.removeAttribute("aria-labelledby");
      }
      Private22.removeAria = removeAria;
      function normalizeTabAreaConfig(config, widgetSet) {
        if (config.widgets.length === 0) {
          return null;
        }
        let widgets = [];
        for (const widget of config.widgets) {
          if (!widgetSet.has(widget)) {
            widgetSet.add(widget);
            widgets.push(widget);
          }
        }
        if (widgets.length === 0) {
          return null;
        }
        let index2 = config.currentIndex;
        if (index2 !== -1 && (index2 < 0 || index2 >= widgets.length)) {
          index2 = 0;
        }
        return { type: "tab-area", widgets, currentIndex: index2 };
      }
      function normalizeSplitAreaConfig(config, widgetSet) {
        let orientation = config.orientation;
        let children = [];
        let sizes = [];
        for (let i6 = 0, n5 = config.children.length; i6 < n5; ++i6) {
          let child = normalizeAreaConfig(config.children[i6], widgetSet);
          if (!child) {
            continue;
          }
          if (child.type === "tab-area" || child.orientation !== orientation) {
            children.push(child);
            sizes.push(Math.abs(config.sizes[i6] || 0));
          } else {
            children.push(...child.children);
            sizes.push(...child.sizes);
          }
        }
        if (children.length === 0) {
          return null;
        }
        if (children.length === 1) {
          return children[0];
        }
        return { type: "split-area", orientation, children, sizes };
      }
      function realizeTabAreaConfig(config, renderer, document2) {
        let tabBar = renderer.createTabBar(document2);
        for (const widget of config.widgets) {
          widget.hide();
          tabBar.addTab(widget.title);
          Private22.addAria(widget, tabBar);
        }
        tabBar.currentIndex = config.currentIndex;
        return new TabLayoutNode(tabBar);
      }
      function realizeSplitAreaConfig(config, renderer, document2) {
        let node = new SplitLayoutNode(config.orientation);
        config.children.forEach((child, i6) => {
          let childNode = realizeAreaConfig(child, renderer, document2);
          let sizer = createSizer(config.sizes[i6]);
          let handle = renderer.createHandle();
          node.children.push(childNode);
          node.handles.push(handle);
          node.sizers.push(sizer);
          childNode.parent = node;
        });
        node.syncHandles();
        node.normalizeSizes();
        return node;
      }
    })(Private$64 || (Private$64 = {}));
    DockPanel4 = class extends Widget5 {
      /**
       * Construct a new dock panel.
       *
       * @param options - The options for initializing the panel.
       */
      constructor(options = {}) {
        super();
        this._drag = null;
        this._tabsMovable = true;
        this._tabsConstrained = false;
        this._addButtonEnabled = false;
        this._pressData = null;
        this._layoutModified = new Signal(this);
        this._addRequested = new Signal(this);
        this.addClass("lm-DockPanel");
        this._document = options.document || document;
        this._mode = options.mode || "multiple-document";
        this._renderer = options.renderer || DockPanel4.defaultRenderer;
        this._edges = options.edges || Private$54.DEFAULT_EDGES;
        if (options.tabsMovable !== void 0) {
          this._tabsMovable = options.tabsMovable;
        }
        if (options.tabsConstrained !== void 0) {
          this._tabsConstrained = options.tabsConstrained;
        }
        if (options.addButtonEnabled !== void 0) {
          this._addButtonEnabled = options.addButtonEnabled;
        }
        this.dataset["mode"] = this._mode;
        let renderer = {
          createTabBar: () => this._createTabBar(),
          createHandle: () => this._createHandle()
        };
        this.layout = new DockLayout4({
          document: this._document,
          renderer,
          spacing: options.spacing,
          hiddenMode: options.hiddenMode
        });
        this.overlay = options.overlay || new DockPanel4.Overlay();
        this.node.appendChild(this.overlay.node);
      }
      /**
       * Dispose of the resources held by the panel.
       */
      dispose() {
        this._releaseMouse();
        this.overlay.hide(0);
        if (this._drag) {
          this._drag.dispose();
        }
        super.dispose();
      }
      /**
       * The method for hiding widgets.
       */
      get hiddenMode() {
        return this.layout.hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       */
      set hiddenMode(v4) {
        this.layout.hiddenMode = v4;
      }
      /**
       * A signal emitted when the layout configuration is modified.
       *
       * #### Notes
       * This signal is emitted whenever the current layout configuration
       * may have changed.
       *
       * This signal is emitted asynchronously in a collapsed fashion, so
       * that multiple synchronous modifications results in only a single
       * emit of the signal.
       */
      get layoutModified() {
        return this._layoutModified;
      }
      /**
       * A signal emitted when the add button on a tab bar is clicked.
       *
       */
      get addRequested() {
        return this._addRequested;
      }
      /**
       * The renderer used by the dock panel.
       */
      get renderer() {
        return this.layout.renderer;
      }
      /**
       * Get the spacing between the widgets.
       */
      get spacing() {
        return this.layout.spacing;
      }
      /**
       * Set the spacing between the widgets.
       */
      set spacing(value) {
        this.layout.spacing = value;
      }
      /**
       * Get the mode for the dock panel.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Set the mode for the dock panel.
       *
       * #### Notes
       * Changing the mode is a destructive operation with respect to the
       * panel's layout configuration. If layout state must be preserved,
       * save the current layout config before changing the mode.
       */
      set mode(value) {
        if (this._mode === value) {
          return;
        }
        this._mode = value;
        this.dataset["mode"] = value;
        let layout = this.layout;
        switch (value) {
          case "multiple-document":
            for (const tabBar of layout.tabBars()) {
              tabBar.show();
            }
            break;
          case "single-document":
            layout.restoreLayout(Private$54.createSingleDocumentConfig(this));
            break;
          default:
            throw "unreachable";
        }
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Whether the tabs can be dragged / moved at runtime.
       */
      get tabsMovable() {
        return this._tabsMovable;
      }
      /**
       * Enable / Disable draggable / movable tabs.
       */
      set tabsMovable(value) {
        this._tabsMovable = value;
        for (const tabBar of this.tabBars()) {
          tabBar.tabsMovable = value;
        }
      }
      /**
       * Whether the tabs are constrained to their source dock panel
       */
      get tabsConstrained() {
        return this._tabsConstrained;
      }
      /**
       * Constrain/Allow tabs to be dragged outside of this dock panel
       */
      set tabsConstrained(value) {
        this._tabsConstrained = value;
      }
      /**
       * Whether the add buttons for each tab bar are enabled.
       */
      get addButtonEnabled() {
        return this._addButtonEnabled;
      }
      /**
       * Set whether the add buttons for each tab bar are enabled.
       */
      set addButtonEnabled(value) {
        this._addButtonEnabled = value;
        for (const tabBar of this.tabBars()) {
          tabBar.addButtonEnabled = value;
        }
      }
      /**
       * Whether the dock panel is empty.
       */
      get isEmpty() {
        return this.layout.isEmpty;
      }
      /**
       * Create an iterator over the user widgets in the panel.
       *
       * @returns A new iterator over the user widgets in the panel.
       *
       * #### Notes
       * This iterator does not include the generated tab bars.
       */
      *widgets() {
        yield* this.layout.widgets();
      }
      /**
       * Create an iterator over the selected widgets in the panel.
       *
       * @returns A new iterator over the selected user widgets.
       *
       * #### Notes
       * This iterator yields the widgets corresponding to the current tab
       * of each tab bar in the panel.
       */
      *selectedWidgets() {
        yield* this.layout.selectedWidgets();
      }
      /**
       * Create an iterator over the tab bars in the panel.
       *
       * @returns A new iterator over the tab bars in the panel.
       *
       * #### Notes
       * This iterator does not include the user widgets.
       */
      *tabBars() {
        yield* this.layout.tabBars();
      }
      /**
       * Create an iterator over the handles in the panel.
       *
       * @returns A new iterator over the handles in the panel.
       */
      *handles() {
        yield* this.layout.handles();
      }
      /**
       * Select a specific widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will make the widget the current widget in its tab area.
       */
      selectWidget(widget) {
        let tabBar = find(this.tabBars(), (bar) => {
          return bar.titles.indexOf(widget.title) !== -1;
        });
        if (!tabBar) {
          throw new Error("Widget is not contained in the dock panel.");
        }
        tabBar.currentTitle = widget.title;
      }
      /**
       * Activate a specified widget in the dock panel.
       *
       * @param widget - The widget of interest.
       *
       * #### Notes
       * This will select and activate the given widget.
       */
      activateWidget(widget) {
        this.selectWidget(widget);
        widget.activate();
      }
      /**
       * Save the current layout configuration of the dock panel.
       *
       * @returns A new config object for the current layout state.
       *
       * #### Notes
       * The return value can be provided to the `restoreLayout` method
       * in order to restore the layout to its current configuration.
       */
      saveLayout() {
        return this.layout.saveLayout();
      }
      /**
       * Restore the layout to a previously saved configuration.
       *
       * @param config - The layout configuration to restore.
       *
       * #### Notes
       * Widgets which currently belong to the layout but which are not
       * contained in the config will be unparented.
       *
       * The dock panel automatically reverts to `'multiple-document'`
       * mode when a layout config is restored.
       */
      restoreLayout(config) {
        this._mode = "multiple-document";
        this.layout.restoreLayout(config);
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop5.flush();
        }
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Add a widget to the dock panel.
       *
       * @param widget - The widget to add to the dock panel.
       *
       * @param options - The additional options for adding the widget.
       *
       * #### Notes
       * If the panel is in single document mode, the options are ignored
       * and the widget is always added as tab in the hidden tab bar.
       */
      addWidget(widget, options = {}) {
        if (this._mode === "single-document") {
          this.layout.addWidget(widget);
        } else {
          this.layout.addWidget(widget, options);
        }
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Process a message sent to the widget.
       *
       * @param msg - The message sent to the widget.
       */
      processMessage(msg) {
        if (msg.type === "layout-modified") {
          this._layoutModified.emit(void 0);
        } else {
          super.processMessage(msg);
        }
      }
      /**
       * Handle the DOM events for the dock panel.
       *
       * @param event - The DOM event sent to the panel.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the panel's DOM node. It should
       * not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "lm-dragenter":
            this._evtDragEnter(event);
            break;
          case "lm-dragleave":
            this._evtDragLeave(event);
            break;
          case "lm-dragover":
            this._evtDragOver(event);
            break;
          case "lm-drop":
            this._evtDrop(event);
            break;
          case "pointerdown":
            this._evtPointerDown(event);
            break;
          case "pointermove":
            this._evtPointerMove(event);
            break;
          case "pointerup":
            this._evtPointerUp(event);
            break;
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("lm-dragenter", this);
        this.node.addEventListener("lm-dragleave", this);
        this.node.addEventListener("lm-dragover", this);
        this.node.addEventListener("lm-drop", this);
        this.node.addEventListener("pointerdown", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("lm-dragenter", this);
        this.node.removeEventListener("lm-dragleave", this);
        this.node.removeEventListener("lm-dragover", this);
        this.node.removeEventListener("lm-drop", this);
        this.node.removeEventListener("pointerdown", this);
        this._releaseMouse();
      }
      /**
       * A message handler invoked on a `'child-added'` message.
       */
      onChildAdded(msg) {
        if (Private$54.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.addClass("lm-DockPanel-widget");
      }
      /**
       * A message handler invoked on a `'child-removed'` message.
       */
      onChildRemoved(msg) {
        if (Private$54.isGeneratedTabBarProperty.get(msg.child)) {
          return;
        }
        msg.child.removeClass("lm-DockPanel-widget");
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Handle the `'lm-dragenter'` event for the dock panel.
       */
      _evtDragEnter(event) {
        if (event.mimeData.hasData("application/vnd.lumino.widget-factory")) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
      /**
       * Handle the `'lm-dragleave'` event for the dock panel.
       */
      _evtDragLeave(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this)
          return;
        event.stopPropagation();
        this.overlay.hide(1);
      }
      /**
       * Handle the `'lm-dragover'` event for the dock panel.
       */
      _evtDragOver(event) {
        event.preventDefault();
        if (this._tabsConstrained && event.source !== this || this._showOverlay(event.clientX, event.clientY) === "invalid") {
          event.dropAction = "none";
        } else {
          event.stopPropagation();
          event.dropAction = event.proposedAction;
        }
      }
      /**
       * Handle the `'lm-drop'` event for the dock panel.
       */
      _evtDrop(event) {
        event.preventDefault();
        this.overlay.hide(0);
        if (event.proposedAction === "none") {
          event.dropAction = "none";
          return;
        }
        let { clientX, clientY } = event;
        let { zone, target } = Private$54.findDropTarget(this, clientX, clientY, this._edges);
        if (this._tabsConstrained && event.source !== this || zone === "invalid") {
          event.dropAction = "none";
          return;
        }
        let mimeData = event.mimeData;
        let factory = mimeData.getData("application/vnd.lumino.widget-factory");
        if (typeof factory !== "function") {
          event.dropAction = "none";
          return;
        }
        let widget = factory();
        if (!(widget instanceof Widget5)) {
          event.dropAction = "none";
          return;
        }
        if (widget.contains(this)) {
          event.dropAction = "none";
          return;
        }
        let ref = target ? Private$54.getDropRef(target.tabBar) : null;
        switch (zone) {
          case "root-all":
            this.addWidget(widget);
            break;
          case "root-top":
            this.addWidget(widget, { mode: "split-top" });
            break;
          case "root-left":
            this.addWidget(widget, { mode: "split-left" });
            break;
          case "root-right":
            this.addWidget(widget, { mode: "split-right" });
            break;
          case "root-bottom":
            this.addWidget(widget, { mode: "split-bottom" });
            break;
          case "widget-all":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          case "widget-top":
            this.addWidget(widget, { mode: "split-top", ref });
            break;
          case "widget-left":
            this.addWidget(widget, { mode: "split-left", ref });
            break;
          case "widget-right":
            this.addWidget(widget, { mode: "split-right", ref });
            break;
          case "widget-bottom":
            this.addWidget(widget, { mode: "split-bottom", ref });
            break;
          case "widget-tab":
            this.addWidget(widget, { mode: "tab-after", ref });
            break;
          default:
            throw "unreachable";
        }
        event.dropAction = event.proposedAction;
        event.stopPropagation();
        this.activateWidget(widget);
      }
      /**
       * Handle the `'keydown'` event for the dock panel.
       */
      _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.keyCode === 27) {
          this._releaseMouse();
          MessageLoop5.postMessage(this, Private$54.LayoutModified);
        }
      }
      /**
       * Handle the `'pointerdown'` event for the dock panel.
       */
      _evtPointerDown(event) {
        if (event.button !== 0) {
          return;
        }
        let layout = this.layout;
        let target = event.target;
        let handle = find(layout.handles(), (handle2) => handle2.contains(target));
        if (!handle) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._document.addEventListener("keydown", this, true);
        this._document.addEventListener("pointerup", this, true);
        this._document.addEventListener("pointermove", this, true);
        this._document.addEventListener("contextmenu", this, true);
        let rect = handle.getBoundingClientRect();
        let deltaX = event.clientX - rect.left;
        let deltaY = event.clientY - rect.top;
        let style = window.getComputedStyle(handle);
        let override = Drag4.overrideCursor(style.cursor, this._document);
        this._pressData = { handle, deltaX, deltaY, override };
      }
      /**
       * Handle the `'pointermove'` event for the dock panel.
       */
      _evtPointerMove(event) {
        if (!this._pressData) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        let rect = this.node.getBoundingClientRect();
        let xPos = event.clientX - rect.left - this._pressData.deltaX;
        let yPos = event.clientY - rect.top - this._pressData.deltaY;
        let layout = this.layout;
        layout.moveHandle(this._pressData.handle, xPos, yPos);
      }
      /**
       * Handle the `'pointerup'` event for the dock panel.
       */
      _evtPointerUp(event) {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._releaseMouse();
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Release the mouse grab for the dock panel.
       */
      _releaseMouse() {
        if (!this._pressData) {
          return;
        }
        this._pressData.override.dispose();
        this._pressData = null;
        this._document.removeEventListener("keydown", this, true);
        this._document.removeEventListener("pointerup", this, true);
        this._document.removeEventListener("pointermove", this, true);
        this._document.removeEventListener("contextmenu", this, true);
      }
      /**
       * Show the overlay indicator at the given client position.
       *
       * Returns the drop zone at the specified client position.
       *
       * #### Notes
       * If the position is not over a valid zone, the overlay is hidden.
       */
      _showOverlay(clientX, clientY) {
        let { zone, target } = Private$54.findDropTarget(this, clientX, clientY, this._edges);
        if (zone === "invalid") {
          this.overlay.hide(100);
          return zone;
        }
        let top;
        let left;
        let right;
        let bottom;
        let box = ElementExt.boxSizing(this.node);
        let rect = this.node.getBoundingClientRect();
        switch (zone) {
          case "root-all":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-top":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = rect.height * Private$54.GOLDEN_RATIO;
            break;
          case "root-left":
            top = box.paddingTop;
            left = box.paddingLeft;
            right = rect.width * Private$54.GOLDEN_RATIO;
            bottom = box.paddingBottom;
            break;
          case "root-right":
            top = box.paddingTop;
            left = rect.width * Private$54.GOLDEN_RATIO;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "root-bottom":
            top = rect.height * Private$54.GOLDEN_RATIO;
            left = box.paddingLeft;
            right = box.paddingRight;
            bottom = box.paddingBottom;
            break;
          case "widget-all":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-top":
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height / 2;
            break;
          case "widget-left":
            top = target.top;
            left = target.left;
            right = target.right + target.width / 2;
            bottom = target.bottom;
            break;
          case "widget-right":
            top = target.top;
            left = target.left + target.width / 2;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-bottom":
            top = target.top + target.height / 2;
            left = target.left;
            right = target.right;
            bottom = target.bottom;
            break;
          case "widget-tab": {
            const tabHeight = target.tabBar.node.getBoundingClientRect().height;
            top = target.top;
            left = target.left;
            right = target.right;
            bottom = target.bottom + target.height - tabHeight;
            break;
          }
          default:
            throw "unreachable";
        }
        this.overlay.show({ top, left, right, bottom });
        return zone;
      }
      /**
       * Create a new tab bar for use by the panel.
       */
      _createTabBar() {
        let tabBar = this._renderer.createTabBar(this._document);
        Private$54.isGeneratedTabBarProperty.set(tabBar, true);
        if (this._mode === "single-document") {
          tabBar.hide();
        }
        tabBar.tabsMovable = this._tabsMovable;
        tabBar.allowDeselect = false;
        tabBar.addButtonEnabled = this._addButtonEnabled;
        tabBar.removeBehavior = "select-previous-tab";
        tabBar.insertBehavior = "select-tab-if-needed";
        tabBar.tabMoved.connect(this._onTabMoved, this);
        tabBar.currentChanged.connect(this._onCurrentChanged, this);
        tabBar.tabCloseRequested.connect(this._onTabCloseRequested, this);
        tabBar.tabDetachRequested.connect(this._onTabDetachRequested, this);
        tabBar.tabActivateRequested.connect(this._onTabActivateRequested, this);
        tabBar.addRequested.connect(this._onTabAddRequested, this);
        return tabBar;
      }
      /**
       * Create a new handle for use by the panel.
       */
      _createHandle() {
        return this._renderer.createHandle();
      }
      /**
       * Handle the `tabMoved` signal from a tab bar.
       */
      _onTabMoved() {
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Handle the `currentChanged` signal from a tab bar.
       */
      _onCurrentChanged(sender, args) {
        let { previousTitle, currentTitle } = args;
        if (previousTitle) {
          previousTitle.owner.hide();
        }
        if (currentTitle) {
          currentTitle.owner.show();
        }
        if (Platform.IS_EDGE || Platform.IS_IE) {
          MessageLoop5.flush();
        }
        MessageLoop5.postMessage(this, Private$54.LayoutModified);
      }
      /**
       * Handle the `addRequested` signal from a tab bar.
       */
      _onTabAddRequested(sender) {
        this._addRequested.emit(sender);
      }
      /**
       * Handle the `tabActivateRequested` signal from a tab bar.
       */
      _onTabActivateRequested(sender, args) {
        args.title.owner.activate();
      }
      /**
       * Handle the `tabCloseRequested` signal from a tab bar.
       */
      _onTabCloseRequested(sender, args) {
        args.title.owner.close();
      }
      /**
       * Handle the `tabDetachRequested` signal from a tab bar.
       */
      _onTabDetachRequested(sender, args) {
        if (this._drag) {
          return;
        }
        sender.releaseMouse();
        let { title, tab, clientX, clientY, offset: offset4 } = args;
        let mimeData = new import_coreutils19.MimeData();
        let factory = () => title.owner;
        mimeData.setData("application/vnd.lumino.widget-factory", factory);
        let dragImage = tab.cloneNode(true);
        if (offset4) {
          dragImage.style.top = `-${offset4.y}px`;
          dragImage.style.left = `-${offset4.x}px`;
        }
        this._drag = new Drag4({
          document: this._document,
          mimeData,
          dragImage,
          proposedAction: "move",
          supportedActions: "move",
          source: this
        });
        tab.classList.add("lm-mod-hidden");
        let cleanup = () => {
          this._drag = null;
          tab.classList.remove("lm-mod-hidden");
        };
        this._drag.start(clientX, clientY).then(cleanup);
      }
    };
    (function(DockPanel5) {
      class Overlay2 {
        /**
         * Construct a new overlay.
         */
        constructor() {
          this._timer = -1;
          this._hidden = true;
          this.node = document.createElement("div");
          this.node.classList.add("lm-DockPanel-overlay");
          this.node.classList.add("lm-mod-hidden");
          this.node.style.position = "absolute";
          this.node.style.contain = "strict";
        }
        /**
         * Show the overlay using the given overlay geometry.
         *
         * @param geo - The desired geometry for the overlay.
         */
        show(geo) {
          let style = this.node.style;
          style.top = `${geo.top}px`;
          style.left = `${geo.left}px`;
          style.right = `${geo.right}px`;
          style.bottom = `${geo.bottom}px`;
          clearTimeout(this._timer);
          this._timer = -1;
          if (!this._hidden) {
            return;
          }
          this._hidden = false;
          this.node.classList.remove("lm-mod-hidden");
        }
        /**
         * Hide the overlay node.
         *
         * @param delay - The delay (in ms) before hiding the overlay.
         *   A delay value <= 0 will hide the overlay immediately.
         */
        hide(delay) {
          if (this._hidden) {
            return;
          }
          if (delay <= 0) {
            clearTimeout(this._timer);
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
            return;
          }
          if (this._timer !== -1) {
            return;
          }
          this._timer = window.setTimeout(() => {
            this._timer = -1;
            this._hidden = true;
            this.node.classList.add("lm-mod-hidden");
          }, delay);
        }
      }
      DockPanel5.Overlay = Overlay2;
      class Renderer {
        /**
         * Create a new tab bar for use with a dock panel.
         *
         * @returns A new tab bar for a dock panel.
         */
        createTabBar(document2) {
          let bar = new TabBar5({ document: document2 });
          bar.addClass("lm-DockPanel-tabBar");
          return bar;
        }
        /**
         * Create a new handle node for use with a dock panel.
         *
         * @returns A new handle node for a dock panel.
         */
        createHandle() {
          let handle = document.createElement("div");
          handle.className = "lm-DockPanel-handle";
          return handle;
        }
      }
      DockPanel5.Renderer = Renderer;
      DockPanel5.defaultRenderer = new Renderer();
    })(DockPanel4 || (DockPanel4 = {}));
    (function(Private22) {
      Private22.GOLDEN_RATIO = 0.618;
      Private22.DEFAULT_EDGES = {
        /**
         * The size of the top edge dock zone for the root panel, in pixels.
         * This is different from the others to distinguish between the top
         * tab bar and the top root zone.
         */
        top: 12,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        right: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        bottom: 40,
        /**
         * The size of the edge dock zone for the root panel, in pixels.
         */
        left: 40
      };
      Private22.LayoutModified = new ConflatableMessage4("layout-modified");
      Private22.isGeneratedTabBarProperty = new AttachedProperty({
        name: "isGeneratedTabBar",
        create: () => false
      });
      function createSingleDocumentConfig(panel) {
        if (panel.isEmpty) {
          return { main: null };
        }
        let widgets = Array.from(panel.widgets());
        let selected = panel.selectedWidgets().next().value;
        let currentIndex = selected ? widgets.indexOf(selected) : -1;
        return { main: { type: "tab-area", widgets, currentIndex } };
      }
      Private22.createSingleDocumentConfig = createSingleDocumentConfig;
      function findDropTarget(panel, clientX, clientY, edges) {
        if (!ElementExt.hitTest(panel.node, clientX, clientY)) {
          return { zone: "invalid", target: null };
        }
        let layout = panel.layout;
        if (layout.isEmpty) {
          return { zone: "root-all", target: null };
        }
        if (panel.mode === "multiple-document") {
          let panelRect = panel.node.getBoundingClientRect();
          let pl = clientX - panelRect.left + 1;
          let pt = clientY - panelRect.top + 1;
          let pr = panelRect.right - clientX;
          let pb = panelRect.bottom - clientY;
          let pd = Math.min(pt, pr, pb, pl);
          switch (pd) {
            case pt:
              if (pt < edges.top) {
                return { zone: "root-top", target: null };
              }
              break;
            case pr:
              if (pr < edges.right) {
                return { zone: "root-right", target: null };
              }
              break;
            case pb:
              if (pb < edges.bottom) {
                return { zone: "root-bottom", target: null };
              }
              break;
            case pl:
              if (pl < edges.left) {
                return { zone: "root-left", target: null };
              }
              break;
            default:
              throw "unreachable";
          }
        }
        let target = layout.hitTestTabAreas(clientX, clientY);
        if (!target) {
          return { zone: "invalid", target: null };
        }
        if (panel.mode === "single-document") {
          return { zone: "widget-all", target };
        }
        let al = target.x - target.left + 1;
        let at = target.y - target.top + 1;
        let ar = target.left + target.width - target.x;
        let ab = target.top + target.height - target.y;
        const tabHeight = target.tabBar.node.getBoundingClientRect().height;
        if (at < tabHeight) {
          return { zone: "widget-tab", target };
        }
        let rx = Math.round(target.width / 3);
        let ry = Math.round(target.height / 3);
        if (al > rx && ar > rx && at > ry && ab > ry) {
          return { zone: "widget-all", target };
        }
        al /= rx;
        at /= ry;
        ar /= rx;
        ab /= ry;
        let ad = Math.min(al, at, ar, ab);
        let zone;
        switch (ad) {
          case al:
            zone = "widget-left";
            break;
          case at:
            zone = "widget-top";
            break;
          case ar:
            zone = "widget-right";
            break;
          case ab:
            zone = "widget-bottom";
            break;
          default:
            throw "unreachable";
        }
        return { zone, target };
      }
      Private22.findDropTarget = findDropTarget;
      function getDropRef(tabBar) {
        if (tabBar.titles.length === 0) {
          return null;
        }
        if (tabBar.currentTitle) {
          return tabBar.currentTitle.owner;
        }
        return tabBar.titles[tabBar.titles.length - 1].owner;
      }
      Private22.getDropRef = getDropRef;
    })(Private$54 || (Private$54 = {}));
    GridLayout4 = class extends Layout4 {
      /**
       * Construct a new grid layout.
       *
       * @param options - The options for initializing the layout.
       */
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._rowSpacing = 4;
        this._columnSpacing = 4;
        this._items = [];
        this._rowStarts = [];
        this._columnStarts = [];
        this._rowSizers = [new BoxSizer4()];
        this._columnSizers = [new BoxSizer4()];
        this._box = null;
        if (options.rowCount !== void 0) {
          Private$44.reallocSizers(this._rowSizers, options.rowCount);
        }
        if (options.columnCount !== void 0) {
          Private$44.reallocSizers(this._columnSizers, options.columnCount);
        }
        if (options.rowSpacing !== void 0) {
          this._rowSpacing = Private$44.clampValue(options.rowSpacing);
        }
        if (options.columnSpacing !== void 0) {
          this._columnSpacing = Private$44.clampValue(options.columnSpacing);
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          let widget = item.widget;
          item.dispose();
          widget.dispose();
        }
        this._box = null;
        this._items.length = 0;
        this._rowStarts.length = 0;
        this._rowSizers.length = 0;
        this._columnStarts.length = 0;
        this._columnSizers.length = 0;
        super.dispose();
      }
      /**
       * Get the number of rows in the layout.
       */
      get rowCount() {
        return this._rowSizers.length;
      }
      /**
       * Set the number of rows in the layout.
       *
       * #### Notes
       * The minimum row count is `1`.
       */
      set rowCount(value) {
        if (value === this.rowCount) {
          return;
        }
        Private$44.reallocSizers(this._rowSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the number of columns in the layout.
       */
      get columnCount() {
        return this._columnSizers.length;
      }
      /**
       * Set the number of columns in the layout.
       *
       * #### Notes
       * The minimum column count is `1`.
       */
      set columnCount(value) {
        if (value === this.columnCount) {
          return;
        }
        Private$44.reallocSizers(this._columnSizers, value);
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the row spacing for the layout.
       */
      get rowSpacing() {
        return this._rowSpacing;
      }
      /**
       * Set the row spacing for the layout.
       */
      set rowSpacing(value) {
        value = Private$44.clampValue(value);
        if (this._rowSpacing === value) {
          return;
        }
        this._rowSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the column spacing for the layout.
       */
      get columnSpacing() {
        return this._columnSpacing;
      }
      /**
       * Set the col spacing for the layout.
       */
      set columnSpacing(value) {
        value = Private$44.clampValue(value);
        if (this._columnSpacing === value) {
          return;
        }
        this._columnSpacing = value;
        if (this.parent) {
          this.parent.fit();
        }
      }
      /**
       * Get the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @returns The stretch factor for the row.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      rowStretch(index2) {
        let sizer = this._rowSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific row.
       *
       * @param index - The row index of interest.
       *
       * @param value - The stretch factor for the row.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setRowStretch(index2, value) {
        let sizer = this._rowSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$44.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Get the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @returns The stretch factor for the column.
       *
       * #### Notes
       * This returns `-1` if the index is out of range.
       */
      columnStretch(index2) {
        let sizer = this._columnSizers[index2];
        return sizer ? sizer.stretch : -1;
      }
      /**
       * Set the stretch factor for a specific column.
       *
       * @param index - The column index of interest.
       *
       * @param value - The stretch factor for the column.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      setColumnStretch(index2, value) {
        let sizer = this._columnSizers[index2];
        if (!sizer) {
          return;
        }
        value = Private$44.clampValue(value);
        if (sizer.stretch === value) {
          return;
        }
        sizer.stretch = value;
        if (this.parent) {
          this.parent.update();
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        for (const item of this._items) {
          yield item.widget;
        }
      }
      /**
       * Add a widget to the grid layout.
       *
       * @param widget - The widget to add to the layout.
       *
       * #### Notes
       * If the widget is already contained in the layout, this is no-op.
       */
      addWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 !== -1) {
          return;
        }
        this._items.push(new LayoutItem4(widget));
        if (this.parent) {
          this.attachWidget(widget);
        }
      }
      /**
       * Remove a widget from the grid layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        let i6 = ArrayExt.findFirstIndex(this._items, (it) => it.widget === widget);
        if (i6 === -1) {
          return;
        }
        let item = ArrayExt.removeAt(this._items, i6);
        if (this.parent) {
          this.detachWidget(widget);
        }
        item.dispose();
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowSizers[i6].minSize = 0;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnSizers[i6].minSize = 0;
        }
        let items = this._items.filter((it) => !it.isHidden);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          items[i6].fit();
        }
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        items.sort(Private$44.rowSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout4.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          Private$44.distributeMin(this._rowSizers, r1, r22, item.minHeight);
        }
        items.sort(Private$44.columnSpanCmp);
        for (let i6 = 0, n5 = items.length; i6 < n5; ++i6) {
          let item = items[i6];
          let config = GridLayout4.getCellConfig(item.widget);
          let c1 = Math.min(config.column, maxCol);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          Private$44.distributeMin(this._columnSizers, c1, c22, item.minWidth);
        }
        if (this.fitPolicy === "set-no-constraint") {
          MessageLoop5.sendMessage(this.parent, Widget5.Msg.UpdateRequest);
          return;
        }
        let minH = maxRow * this._rowSpacing;
        let minW = maxCol * this._columnSpacing;
        for (let i6 = 0, n5 = this.rowCount; i6 < n5; ++i6) {
          minH += this._rowSizers[i6].minSize;
        }
        for (let i6 = 0, n5 = this.columnCount; i6 < n5; ++i6) {
          minW += this._columnSizers[i6].minSize;
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop5.sendMessage(this.parent.parent, Widget5.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop5.sendMessage(this.parent, Widget5.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        let maxRow = this.rowCount - 1;
        let maxCol = this.columnCount - 1;
        let fixedRowSpace = maxRow * this._rowSpacing;
        let fixedColSpace = maxCol * this._columnSpacing;
        BoxEngine4.calc(this._rowSizers, Math.max(0, height - fixedRowSpace));
        BoxEngine4.calc(this._columnSizers, Math.max(0, width - fixedColSpace));
        for (let i6 = 0, pos = top, n5 = this.rowCount; i6 < n5; ++i6) {
          this._rowStarts[i6] = pos;
          pos += this._rowSizers[i6].size + this._rowSpacing;
        }
        for (let i6 = 0, pos = left, n5 = this.columnCount; i6 < n5; ++i6) {
          this._columnStarts[i6] = pos;
          pos += this._columnSizers[i6].size + this._columnSpacing;
        }
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          let config = GridLayout4.getCellConfig(item.widget);
          let r1 = Math.min(config.row, maxRow);
          let c1 = Math.min(config.column, maxCol);
          let r22 = Math.min(config.row + config.rowSpan - 1, maxRow);
          let c22 = Math.min(config.column + config.columnSpan - 1, maxCol);
          let x2 = this._columnStarts[c1];
          let y4 = this._rowStarts[r1];
          let w3 = this._columnStarts[c22] + this._columnSizers[c22].size - x2;
          let h4 = this._rowStarts[r22] + this._rowSizers[r22].size - y4;
          item.update(x2, y4, w3, h4);
        }
      }
    };
    (function(GridLayout5) {
      function getCellConfig(widget) {
        return Private$44.cellConfigProperty.get(widget);
      }
      GridLayout5.getCellConfig = getCellConfig;
      function setCellConfig(widget, value) {
        Private$44.cellConfigProperty.set(widget, Private$44.normalizeConfig(value));
      }
      GridLayout5.setCellConfig = setCellConfig;
    })(GridLayout4 || (GridLayout4 = {}));
    (function(Private22) {
      Private22.cellConfigProperty = new AttachedProperty({
        name: "cellConfig",
        create: () => ({ row: 0, column: 0, rowSpan: 1, columnSpan: 1 }),
        changed: onChildCellConfigChanged
      });
      function normalizeConfig(config) {
        let row = Math.max(0, Math.floor(config.row || 0));
        let column = Math.max(0, Math.floor(config.column || 0));
        let rowSpan = Math.max(1, Math.floor(config.rowSpan || 0));
        let columnSpan = Math.max(1, Math.floor(config.columnSpan || 0));
        return { row, column, rowSpan, columnSpan };
      }
      Private22.normalizeConfig = normalizeConfig;
      function clampValue(value) {
        return Math.max(0, Math.floor(value));
      }
      Private22.clampValue = clampValue;
      function rowSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.rowSpan - c22.rowSpan;
      }
      Private22.rowSpanCmp = rowSpanCmp;
      function columnSpanCmp(a3, b2) {
        let c1 = Private22.cellConfigProperty.get(a3.widget);
        let c22 = Private22.cellConfigProperty.get(b2.widget);
        return c1.columnSpan - c22.columnSpan;
      }
      Private22.columnSpanCmp = columnSpanCmp;
      function reallocSizers(sizers, count3) {
        count3 = Math.max(1, Math.floor(count3));
        while (sizers.length < count3) {
          sizers.push(new BoxSizer4());
        }
        if (sizers.length > count3) {
          sizers.length = count3;
        }
      }
      Private22.reallocSizers = reallocSizers;
      function distributeMin(sizers, i1, i22, minSize) {
        if (i22 < i1) {
          return;
        }
        if (i1 === i22) {
          let sizer = sizers[i1];
          sizer.minSize = Math.max(sizer.minSize, minSize);
          return;
        }
        let totalMin = 0;
        for (let i6 = i1; i6 <= i22; ++i6) {
          totalMin += sizers[i6].minSize;
        }
        if (totalMin >= minSize) {
          return;
        }
        let portion = (minSize - totalMin) / (i22 - i1 + 1);
        for (let i6 = i1; i6 <= i22; ++i6) {
          sizers[i6].minSize += portion;
        }
      }
      Private22.distributeMin = distributeMin;
      function onChildCellConfigChanged(child) {
        if (child.parent && child.parent.layout instanceof GridLayout4) {
          child.parent.fit();
        }
      }
    })(Private$44 || (Private$44 = {}));
    MenuBar4 = class extends Widget5 {
      /**
       * Construct a new menu bar.
       *
       * @param options - The options for initializing the menu bar.
       */
      constructor(options = {}) {
        super({ node: Private$34.createNode() });
        this._activeIndex = -1;
        this._tabFocusIndex = 0;
        this._menus = [];
        this._childMenu = null;
        this._overflowMenu = null;
        this._menuItemSizes = [];
        this._overflowIndex = -1;
        this.addClass("lm-MenuBar");
        this.setFlag(Widget5.Flag.DisallowLayout);
        this.renderer = options.renderer || MenuBar4.defaultRenderer;
        this._forceItemsPosition = options.forceItemsPosition || {
          forceX: true,
          forceY: true
        };
        this._overflowMenuOptions = options.overflowMenuOptions || {
          isVisible: true
        };
      }
      /**
       * Dispose of the resources held by the widget.
       */
      dispose() {
        this._closeChildMenu();
        this._menus.length = 0;
        super.dispose();
      }
      /**
       * The child menu of the menu bar.
       *
       * #### Notes
       * This will be `null` if the menu bar does not have an open menu.
       */
      get childMenu() {
        return this._childMenu;
      }
      /**
       * The overflow index of the menu bar.
       */
      get overflowIndex() {
        return this._overflowIndex;
      }
      /**
       * The overflow menu of the menu bar.
       */
      get overflowMenu() {
        return this._overflowMenu;
      }
      /**
       * Get the menu bar content node.
       *
       * #### Notes
       * This is the node which holds the menu title nodes.
       *
       * Modifying this node directly can lead to undefined behavior.
       */
      get contentNode() {
        return this.node.getElementsByClassName("lm-MenuBar-content")[0];
      }
      /**
       * Get the currently active menu.
       */
      get activeMenu() {
        return this._menus[this._activeIndex] || null;
      }
      /**
       * Set the currently active menu.
       *
       * #### Notes
       * If the menu does not exist, the menu will be set to `null`.
       */
      set activeMenu(value) {
        this.activeIndex = value ? this._menus.indexOf(value) : -1;
      }
      /**
       * Get the index of the currently active menu.
       *
       * #### Notes
       * This will be `-1` if no menu is active.
       */
      get activeIndex() {
        return this._activeIndex;
      }
      /**
       * Set the index of the currently active menu.
       *
       * #### Notes
       * If the menu cannot be activated, the index will be set to `-1`.
       */
      set activeIndex(value) {
        if (value < 0 || value >= this._menus.length) {
          value = -1;
        }
        if (value > -1 && this._menus[value].items.length === 0) {
          value = -1;
        }
        if (this._activeIndex === value) {
          return;
        }
        this._activeIndex = value;
        this.update();
      }
      /**
       * A read-only array of the menus in the menu bar.
       */
      get menus() {
        return this._menus;
      }
      /**
       * Open the active menu and activate its first menu item.
       *
       * #### Notes
       * If there is no active menu, this is a no-op.
       */
      openActiveMenu() {
        if (this._activeIndex === -1) {
          return;
        }
        this._openChildMenu();
        if (this._childMenu) {
          this._childMenu.activeIndex = -1;
          this._childMenu.activateNextItem();
        }
      }
      /**
       * Add a menu to the end of the menu bar.
       *
       * @param menu - The menu to add to the menu bar.
       *
       * #### Notes
       * If the menu is already added to the menu bar, it will be moved.
       */
      addMenu(menu, update = true) {
        this.insertMenu(this._menus.length, menu, update);
      }
      /**
       * Insert a menu into the menu bar at the specified index.
       *
       * @param index - The index at which to insert the menu.
       *
       * @param menu - The menu to insert into the menu bar.
       *
       * #### Notes
       * The index will be clamped to the bounds of the menus.
       *
       * If the menu is already added to the menu bar, it will be moved.
       */
      insertMenu(index2, menu, update = true) {
        this._closeChildMenu();
        let i6 = this._menus.indexOf(menu);
        let j2 = Math.max(0, Math.min(index2, this._menus.length));
        if (i6 === -1) {
          ArrayExt.insert(this._menus, j2, menu);
          menu.addClass("lm-MenuBar-menu");
          menu.aboutToClose.connect(this._onMenuAboutToClose, this);
          menu.menuRequested.connect(this._onMenuMenuRequested, this);
          menu.title.changed.connect(this._onTitleChanged, this);
          if (update) {
            this.update();
          }
          return;
        }
        if (j2 === this._menus.length) {
          j2--;
        }
        if (i6 === j2) {
          return;
        }
        ArrayExt.move(this._menus, i6, j2);
        if (update) {
          this.update();
        }
      }
      /**
       * Remove a menu from the menu bar.
       *
       * @param menu - The menu to remove from the menu bar.
       *
       * #### Notes
       * This is a no-op if the menu is not in the menu bar.
       */
      removeMenu(menu, update = true) {
        this.removeMenuAt(this._menus.indexOf(menu), update);
      }
      /**
       * Remove the menu at a given index from the menu bar.
       *
       * @param index - The index of the menu to remove.
       *
       * #### Notes
       * This is a no-op if the index is out of range.
       */
      removeMenuAt(index2, update = true) {
        this._closeChildMenu();
        let menu = ArrayExt.removeAt(this._menus, index2);
        if (!menu) {
          return;
        }
        menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
        menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
        menu.title.changed.disconnect(this._onTitleChanged, this);
        menu.removeClass("lm-MenuBar-menu");
        if (update) {
          this.update();
        }
      }
      /**
       * Remove all menus from the menu bar.
       */
      clearMenus() {
        if (this._menus.length === 0) {
          return;
        }
        this._closeChildMenu();
        for (let menu of this._menus) {
          menu.aboutToClose.disconnect(this._onMenuAboutToClose, this);
          menu.menuRequested.disconnect(this._onMenuMenuRequested, this);
          menu.title.changed.disconnect(this._onTitleChanged, this);
          menu.removeClass("lm-MenuBar-menu");
        }
        this._menus.length = 0;
        this.update();
      }
      /**
       * Handle the DOM events for the menu bar.
       *
       * @param event - The DOM event sent to the menu bar.
       *
       * #### Notes
       * This method implements the DOM `EventListener` interface and is
       * called in response to events on the menu bar's DOM nodes. It
       * should not be called directly by user code.
       */
      handleEvent(event) {
        switch (event.type) {
          case "keydown":
            this._evtKeyDown(event);
            break;
          case "mousedown":
            this._evtMouseDown(event);
            break;
          case "mousemove":
          case "mouseleave":
            this._evtMouseMove(event);
            break;
          case "focusout":
            this._evtFocusOut(event);
            break;
          case "contextmenu":
            event.preventDefault();
            event.stopPropagation();
            break;
        }
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        this.node.addEventListener("keydown", this);
        this.node.addEventListener("mousedown", this);
        this.node.addEventListener("mousemove", this);
        this.node.addEventListener("mouseleave", this);
        this.node.addEventListener("focusout", this);
        this.node.addEventListener("contextmenu", this);
      }
      /**
       * A message handler invoked on an `'after-detach'` message.
       */
      onAfterDetach(msg) {
        this.node.removeEventListener("keydown", this);
        this.node.removeEventListener("mousedown", this);
        this.node.removeEventListener("mousemove", this);
        this.node.removeEventListener("mouseleave", this);
        this.node.removeEventListener("focusout", this);
        this.node.removeEventListener("contextmenu", this);
        this._closeChildMenu();
      }
      /**
       * A message handler invoked on an `'activate-request'` message.
       */
      onActivateRequest(msg) {
        if (this.isAttached) {
          this._focusItemAt(0);
        }
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        this.update();
        super.onResize(msg);
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        var _a;
        let menus = this._menus;
        let renderer = this.renderer;
        let activeIndex = this._activeIndex;
        let tabFocusIndex = this._tabFocusIndex >= 0 && this._tabFocusIndex < menus.length ? this._tabFocusIndex : 0;
        let length = this._overflowIndex > -1 ? this._overflowIndex : menus.length;
        let totalMenuSize = 0;
        let isVisible2 = false;
        length = this._overflowMenu !== null ? length - 1 : length;
        let content = new Array(length);
        for (let i6 = 0; i6 < length; ++i6) {
          content[i6] = renderer.renderItem({
            title: menus[i6].title,
            active: i6 === activeIndex,
            tabbable: i6 === tabFocusIndex,
            disabled: menus[i6].items.length === 0,
            onfocus: () => {
              this._tabFocusIndex = i6;
              this.activeIndex = i6;
            }
          });
          totalMenuSize += this._menuItemSizes[i6];
          if (menus[i6].title.label === this._overflowMenuOptions.title) {
            isVisible2 = true;
            length--;
          }
        }
        if (this._overflowMenuOptions.isVisible) {
          if (this._overflowIndex > -1 && !isVisible2) {
            if (this._overflowMenu === null) {
              const overflowMenuTitle = (_a = this._overflowMenuOptions.title) !== null && _a !== void 0 ? _a : "...";
              this._overflowMenu = new Menu4({ commands: new CommandRegistry() });
              this._overflowMenu.title.label = overflowMenuTitle;
              this._overflowMenu.title.mnemonic = 0;
              this.addMenu(this._overflowMenu, false);
            }
            for (let i6 = menus.length - 2; i6 >= length; i6--) {
              const submenu = this.menus[i6];
              submenu.title.mnemonic = 0;
              this._overflowMenu.insertItem(0, {
                type: "submenu",
                submenu
              });
              this.removeMenu(submenu, false);
            }
            content[length] = renderer.renderItem({
              title: this._overflowMenu.title,
              active: length === activeIndex && menus[length].items.length !== 0,
              tabbable: length === tabFocusIndex,
              disabled: menus[length].items.length === 0,
              onfocus: () => {
                this._tabFocusIndex = length;
                this.activeIndex = length;
              }
            });
            length++;
          } else if (this._overflowMenu !== null) {
            let overflowMenuItems = this._overflowMenu.items;
            let screenSize = this.node.offsetWidth;
            let n5 = this._overflowMenu.items.length;
            for (let i6 = 0; i6 < n5; ++i6) {
              let index2 = menus.length - 1 - i6;
              if (screenSize - totalMenuSize > this._menuItemSizes[index2]) {
                let menu = overflowMenuItems[0].submenu;
                this._overflowMenu.removeItemAt(0);
                this.insertMenu(length, menu, false);
                content[length] = renderer.renderItem({
                  title: menu.title,
                  active: false,
                  tabbable: length === tabFocusIndex,
                  disabled: menus[length].items.length === 0,
                  onfocus: () => {
                    this._tabFocusIndex = length;
                    this.activeIndex = length;
                  }
                });
                length++;
              }
            }
            if (this._overflowMenu.items.length === 0) {
              this.removeMenu(this._overflowMenu, false);
              content.pop();
              this._overflowMenu = null;
              this._overflowIndex = -1;
            }
          }
        }
        VirtualDOM.render(content, this.contentNode);
        this._updateOverflowIndex();
      }
      /**
       * Calculate and update the current overflow index.
       */
      _updateOverflowIndex() {
        if (!this._overflowMenuOptions.isVisible) {
          return;
        }
        const itemMenus = this.contentNode.childNodes;
        let screenSize = this.node.offsetWidth;
        let totalMenuSize = 0;
        let index2 = -1;
        let n5 = itemMenus.length;
        if (this._menuItemSizes.length == 0) {
          for (let i6 = 0; i6 < n5; i6++) {
            let item = itemMenus[i6];
            totalMenuSize += item.offsetWidth;
            this._menuItemSizes.push(item.offsetWidth);
            if (totalMenuSize > screenSize && index2 === -1) {
              index2 = i6;
            }
          }
        } else {
          for (let i6 = 0; i6 < this._menuItemSizes.length; i6++) {
            totalMenuSize += this._menuItemSizes[i6];
            if (totalMenuSize > screenSize) {
              index2 = i6;
              break;
            }
          }
        }
        this._overflowIndex = index2;
      }
      /**
       * Handle the `'keydown'` event for the menu bar.
       *
       * #### Notes
       * All keys are trapped except the tab key that is ignored.
       */
      _evtKeyDown(event) {
        let kc = event.keyCode;
        if (kc === 9) {
          this.activeIndex = -1;
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        if (kc === 13 || kc === 32 || kc === 38 || kc === 40) {
          this.activeIndex = this._tabFocusIndex;
          if (this.activeIndex !== this._tabFocusIndex) {
            return;
          }
          this.openActiveMenu();
          return;
        }
        if (kc === 27) {
          this._closeChildMenu();
          this._focusItemAt(this.activeIndex);
          return;
        }
        if (kc === 37 || kc === 39) {
          let direction = kc === 37 ? -1 : 1;
          let start2 = this._tabFocusIndex + direction;
          let n5 = this._menus.length;
          for (let i6 = 0; i6 < n5; i6++) {
            let index2 = (n5 + start2 + direction * i6) % n5;
            if (this._menus[index2].items.length) {
              this._focusItemAt(index2);
              return;
            }
          }
          return;
        }
        let key = getKeyboardLayout().keyForKeydownEvent(event);
        if (!key) {
          return;
        }
        let start = this._activeIndex + 1;
        let result2 = Private$34.findMnemonic(this._menus, key, start);
        if (result2.index !== -1 && !result2.multiple) {
          this.activeIndex = result2.index;
          this.openActiveMenu();
        } else if (result2.index !== -1) {
          this.activeIndex = result2.index;
          this._focusItemAt(this.activeIndex);
        } else if (result2.auto !== -1) {
          this.activeIndex = result2.auto;
          this._focusItemAt(this.activeIndex);
        }
      }
      /**
       * Handle the `'mousedown'` event for the menu bar.
       */
      _evtMouseDown(event) {
        if (!ElementExt.hitTest(this.node, event.clientX, event.clientY)) {
          return;
        }
        event.stopPropagation();
        event.stopImmediatePropagation();
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === -1) {
          this._closeChildMenu();
          return;
        }
        if (event.button !== 0) {
          return;
        }
        if (this._childMenu) {
          this._closeChildMenu();
          this.activeIndex = index2;
        } else {
          event.preventDefault();
          const position = this._positionForMenu(index2);
          Menu4.saveWindowData();
          this.activeIndex = index2;
          this._openChildMenu(position);
        }
      }
      /**
       * Handle the `'mousemove'` event for the menu bar.
       */
      _evtMouseMove(event) {
        let index2 = ArrayExt.findFirstIndex(this.contentNode.children, (node) => {
          return ElementExt.hitTest(node, event.clientX, event.clientY);
        });
        if (index2 === this._activeIndex) {
          return;
        }
        if (index2 === -1 && this._childMenu) {
          return;
        }
        const position = index2 >= 0 && this._childMenu ? this._positionForMenu(index2) : null;
        Menu4.saveWindowData();
        this.activeIndex = index2;
        if (position) {
          this._openChildMenu(position);
        }
      }
      /**
       * Find initial position for the menu based on menubar item position.
       *
       * NOTE: this should be called before updating active index to avoid
       * an additional layout and style invalidation as changing active
       * index modifies DOM.
       */
      _positionForMenu(index2) {
        let itemNode = this.contentNode.children[index2];
        let { left, bottom } = itemNode.getBoundingClientRect();
        return {
          top: bottom,
          left
        };
      }
      /**
       * Handle the `'focusout'` event for the menu bar.
       */
      _evtFocusOut(event) {
        if (!this._childMenu && !this.node.contains(event.relatedTarget)) {
          this.activeIndex = -1;
        }
      }
      /**
       * Focus an item in the menu bar.
       *
       * #### Notes
       * Does not open the associated menu.
       */
      _focusItemAt(index2) {
        const itemNode = this.contentNode.childNodes[index2];
        if (itemNode) {
          itemNode.focus();
        }
      }
      /**
       * Open the child menu at the active index immediately.
       *
       * If a different child menu is already open, it will be closed,
       * even if there is no active menu.
       */
      _openChildMenu(options = {}) {
        let newMenu = this.activeMenu;
        if (!newMenu) {
          this._closeChildMenu();
          return;
        }
        let oldMenu = this._childMenu;
        if (oldMenu === newMenu) {
          return;
        }
        this._childMenu = newMenu;
        if (oldMenu) {
          oldMenu.close();
        } else {
          document.addEventListener("mousedown", this, true);
        }
        this._tabFocusIndex = this.activeIndex;
        MessageLoop5.sendMessage(this, Widget5.Msg.UpdateRequest);
        let { left, top } = options;
        if (typeof left === "undefined" || typeof top === "undefined") {
          ({ left, top } = this._positionForMenu(this._activeIndex));
        }
        if (!oldMenu) {
          this.addClass("lm-mod-active");
        }
        if (newMenu.items.length > 0) {
          newMenu.open(left, top, this._forceItemsPosition);
        }
      }
      /**
       * Close the child menu immediately.
       *
       * This is a no-op if a child menu is not open.
       */
      _closeChildMenu() {
        if (!this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        let menu = this._childMenu;
        this._childMenu = null;
        menu.close();
        this.activeIndex = -1;
      }
      /**
       * Handle the `aboutToClose` signal of a menu.
       */
      _onMenuAboutToClose(sender) {
        if (sender !== this._childMenu) {
          return;
        }
        this.removeClass("lm-mod-active");
        document.removeEventListener("mousedown", this, true);
        this._childMenu = null;
        this.activeIndex = -1;
      }
      /**
       * Handle the `menuRequested` signal of a child menu.
       */
      _onMenuMenuRequested(sender, args) {
        if (sender !== this._childMenu) {
          return;
        }
        let i6 = this._activeIndex;
        let n5 = this._menus.length;
        switch (args) {
          case "next":
            this.activeIndex = i6 === n5 - 1 ? 0 : i6 + 1;
            break;
          case "previous":
            this.activeIndex = i6 === 0 ? n5 - 1 : i6 - 1;
            break;
        }
        this.openActiveMenu();
      }
      /**
       * Handle the `changed` signal of a title object.
       */
      _onTitleChanged() {
        this.update();
      }
    };
    (function(MenuBar5) {
      class Renderer {
        /**
         * Render the virtual element for a menu bar item.
         *
         * @param data - The data to use for rendering the item.
         *
         * @returns A virtual element representing the item.
         */
        renderItem(data) {
          let className = this.createItemClass(data);
          let dataset = this.createItemDataset(data);
          let aria = this.createItemARIA(data);
          return h.li({
            className,
            dataset,
            ...data.disabled ? {} : { tabindex: data.tabbable ? "0" : "-1" },
            onfocus: data.onfocus,
            ...aria
          }, this.renderIcon(data), this.renderLabel(data));
        }
        /**
         * Render the icon element for a menu bar item.
         *
         * @param data - The data to use for rendering the icon.
         *
         * @returns A virtual element representing the item icon.
         */
        renderIcon(data) {
          let className = this.createIconClass(data);
          return h.div({ className }, data.title.icon, data.title.iconLabel);
        }
        /**
         * Render the label element for a menu item.
         *
         * @param data - The data to use for rendering the label.
         *
         * @returns A virtual element representing the item label.
         */
        renderLabel(data) {
          let content = this.formatLabel(data);
          return h.div({ className: "lm-MenuBar-itemLabel" }, content);
        }
        /**
         * Create the class name for the menu bar item.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the menu item.
         */
        createItemClass(data) {
          let name = "lm-MenuBar-item";
          if (data.title.className) {
            name += ` ${data.title.className}`;
          }
          if (data.active && !data.disabled) {
            name += " lm-mod-active";
          }
          return name;
        }
        /**
         * Create the dataset for a menu bar item.
         *
         * @param data - The data to use for the item.
         *
         * @returns The dataset for the menu bar item.
         */
        createItemDataset(data) {
          return data.title.dataset;
        }
        /**
         * Create the aria attributes for menu bar item.
         *
         * @param data - The data to use for the aria attributes.
         *
         * @returns The aria attributes object for the item.
         */
        createItemARIA(data) {
          return {
            role: "menuitem",
            "aria-haspopup": "true",
            "aria-disabled": data.disabled ? "true" : "false"
          };
        }
        /**
         * Create the class name for the menu bar item icon.
         *
         * @param data - The data to use for the class name.
         *
         * @returns The full class name for the item icon.
         */
        createIconClass(data) {
          let name = "lm-MenuBar-itemIcon";
          let extra = data.title.iconClass;
          return extra ? `${name} ${extra}` : name;
        }
        /**
         * Create the render content for the label node.
         *
         * @param data - The data to use for the label content.
         *
         * @returns The content to add to the label node.
         */
        formatLabel(data) {
          let { label, mnemonic } = data.title;
          if (mnemonic < 0 || mnemonic >= label.length) {
            return label;
          }
          let prefix = label.slice(0, mnemonic);
          let suffix = label.slice(mnemonic + 1);
          let char = label[mnemonic];
          let span = h.span({ className: "lm-MenuBar-itemMnemonic" }, char);
          return [prefix, span, suffix];
        }
      }
      MenuBar5.Renderer = Renderer;
      MenuBar5.defaultRenderer = new Renderer();
    })(MenuBar4 || (MenuBar4 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let content = document.createElement("ul");
        content.className = "lm-MenuBar-content";
        node.appendChild(content);
        content.setAttribute("role", "menubar");
        return node;
      }
      Private22.createNode = createNode;
      function findMnemonic(menus, key, start) {
        let index2 = -1;
        let auto = -1;
        let multiple = false;
        let upperKey = key.toUpperCase();
        for (let i6 = 0, n5 = menus.length; i6 < n5; ++i6) {
          let k2 = (i6 + start) % n5;
          let title = menus[k2].title;
          if (title.label.length === 0) {
            continue;
          }
          let mn = title.mnemonic;
          if (mn >= 0 && mn < title.label.length) {
            if (title.label[mn].toUpperCase() === upperKey) {
              if (index2 === -1) {
                index2 = k2;
              } else {
                multiple = true;
              }
            }
            continue;
          }
          if (auto === -1 && title.label[0].toUpperCase() === upperKey) {
            auto = k2;
          }
        }
        return { index: index2, multiple, auto };
      }
      Private22.findMnemonic = findMnemonic;
    })(Private$34 || (Private$34 = {}));
    (function(Private22) {
      function createNode() {
        let node = document.createElement("div");
        let decrement = document.createElement("div");
        let increment = document.createElement("div");
        let track = document.createElement("div");
        let thumb = document.createElement("div");
        decrement.className = "lm-ScrollBar-button";
        increment.className = "lm-ScrollBar-button";
        decrement.dataset["action"] = "decrement";
        increment.dataset["action"] = "increment";
        track.className = "lm-ScrollBar-track";
        thumb.className = "lm-ScrollBar-thumb";
        track.appendChild(thumb);
        node.appendChild(decrement);
        node.appendChild(track);
        node.appendChild(increment);
        return node;
      }
      Private22.createNode = createNode;
      function findPart(scrollBar, target) {
        if (scrollBar.thumbNode.contains(target)) {
          return "thumb";
        }
        if (scrollBar.trackNode.contains(target)) {
          return "track";
        }
        if (scrollBar.decrementNode.contains(target)) {
          return "decrement";
        }
        if (scrollBar.incrementNode.contains(target)) {
          return "increment";
        }
        return null;
      }
      Private22.findPart = findPart;
    })(Private$24 || (Private$24 = {}));
    SingletonLayout4 = class extends Layout4 {
      constructor() {
        super(...arguments);
        this._widget = null;
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        if (this._widget) {
          let widget = this._widget;
          this._widget = null;
          widget.dispose();
        }
        super.dispose();
      }
      /**
       * Get the child widget for the layout.
       */
      get widget() {
        return this._widget;
      }
      /**
       * Set the child widget for the layout.
       *
       * #### Notes
       * Setting the child widget will cause the old child widget to be
       * automatically disposed. If that is not desired, set the parent
       * of the old child to `null` before assigning a new child.
       */
      set widget(widget) {
        if (widget) {
          widget.parent = this.parent;
        }
        if (this._widget === widget) {
          return;
        }
        if (this._widget) {
          this._widget.dispose();
        }
        this._widget = widget;
        if (this.parent && widget) {
          this.attachWidget(widget);
        }
      }
      /**
       * Create an iterator over the widgets in the layout.
       *
       * @returns A new iterator over the widgets in the layout.
       */
      *[Symbol.iterator]() {
        if (this._widget) {
          yield this._widget;
        }
      }
      /**
       * Remove a widget from the layout.
       *
       * @param widget - The widget to remove from the layout.
       *
       * #### Notes
       * A widget is automatically removed from the layout when its `parent`
       * is set to `null`. This method should only be invoked directly when
       * removing a widget from a layout which has yet to be installed on a
       * parent widget.
       *
       * This method does *not* modify the widget's `parent`.
       */
      removeWidget(widget) {
        if (this._widget !== widget) {
          return;
        }
        this._widget = null;
        if (this.parent) {
          this.detachWidget(widget);
        }
      }
      /**
       * Perform layout initialization which requires the parent widget.
       */
      init() {
        super.init();
        for (const widget of this) {
          this.attachWidget(widget);
        }
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation adds the widgets's node to the parent's
       * node at the proper location, and sends the appropriate attach
       * messages to the widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is added to the parent's node.
       */
      attachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This method is called automatically by the single layout at the
       * appropriate time. It should not be called directly by user code.
       *
       * The default implementation removes the widget's node from the
       * parent's node, and sends the appropriate detach messages to the
       * widget if the parent is attached to the DOM.
       *
       * Subclasses may reimplement this method to control how the widget's
       * node is removed from the parent's node.
       */
      detachWidget(widget) {
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
      }
    };
    StackedLayout4 = class extends PanelLayout5 {
      constructor(options = {}) {
        super(options);
        this._dirty = false;
        this._items = [];
        this._box = null;
        this._hiddenMode = options.hiddenMode !== void 0 ? options.hiddenMode : Widget5.HiddenMode.Display;
      }
      /**
       * The method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      get hiddenMode() {
        return this._hiddenMode;
      }
      /**
       * Set the method for hiding widgets.
       *
       * #### Notes
       * If there is only one child widget, `Display` hiding mode will be used
       * regardless of this setting.
       */
      set hiddenMode(v4) {
        if (this._hiddenMode === v4) {
          return;
        }
        this._hiddenMode = v4;
        if (this.widgets.length > 1) {
          this.widgets.forEach((w3) => {
            w3.hiddenMode = this._hiddenMode;
          });
        }
      }
      /**
       * Dispose of the resources held by the layout.
       */
      dispose() {
        for (const item of this._items) {
          item.dispose();
        }
        this._box = null;
        this._items.length = 0;
        super.dispose();
      }
      /**
       * Attach a widget to the parent's DOM node.
       *
       * @param index - The current index of the widget in the layout.
       *
       * @param widget - The widget to attach to the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      attachWidget(index2, widget) {
        if (this._hiddenMode === Widget5.HiddenMode.Scale && this._items.length > 0) {
          if (this._items.length === 1) {
            this.widgets[0].hiddenMode = Widget5.HiddenMode.Scale;
          }
          widget.hiddenMode = Widget5.HiddenMode.Scale;
        } else {
          widget.hiddenMode = Widget5.HiddenMode.Display;
        }
        ArrayExt.insert(this._items, index2, new LayoutItem4(widget));
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeAttach);
        }
        this.parent.node.appendChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterAttach);
        }
        this.parent.fit();
      }
      /**
       * Move a widget in the parent's DOM node.
       *
       * @param fromIndex - The previous index of the widget in the layout.
       *
       * @param toIndex - The current index of the widget in the layout.
       *
       * @param widget - The widget to move in the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      moveWidget(fromIndex, toIndex, widget) {
        ArrayExt.move(this._items, fromIndex, toIndex);
        this.parent.update();
      }
      /**
       * Detach a widget from the parent's DOM node.
       *
       * @param index - The previous index of the widget in the layout.
       *
       * @param widget - The widget to detach from the parent.
       *
       * #### Notes
       * This is a reimplementation of the superclass method.
       */
      detachWidget(index2, widget) {
        let item = ArrayExt.removeAt(this._items, index2);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.BeforeDetach);
        }
        this.parent.node.removeChild(widget.node);
        if (this.parent.isAttached) {
          MessageLoop5.sendMessage(widget, Widget5.Msg.AfterDetach);
        }
        item.widget.node.style.zIndex = "";
        if (this._hiddenMode === Widget5.HiddenMode.Scale) {
          widget.hiddenMode = Widget5.HiddenMode.Display;
          if (this._items.length === 1) {
            this._items[0].widget.hiddenMode = Widget5.HiddenMode.Display;
          }
        }
        item.dispose();
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'before-show'` message.
       */
      onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.parent.update();
      }
      /**
       * A message handler invoked on a `'before-attach'` message.
       */
      onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-shown'` message.
       */
      onChildShown(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'child-hidden'` message.
       */
      onChildHidden(msg) {
        this.parent.fit();
      }
      /**
       * A message handler invoked on a `'resize'` message.
       */
      onResize(msg) {
        if (this.parent.isVisible) {
          this._update(msg.width, msg.height);
        }
      }
      /**
       * A message handler invoked on an `'update-request'` message.
       */
      onUpdateRequest(msg) {
        if (this.parent.isVisible) {
          this._update(-1, -1);
        }
      }
      /**
       * A message handler invoked on a `'fit-request'` message.
       */
      onFitRequest(msg) {
        if (this.parent.isAttached) {
          this._fit();
        }
      }
      /**
       * Fit the layout to the total size required by the widgets.
       */
      _fit() {
        let minW = 0;
        let minH = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.fit();
          minW = Math.max(minW, item.minWidth);
          minH = Math.max(minH, item.minHeight);
        }
        let box = this._box = ElementExt.boxSizing(this.parent.node);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        let style = this.parent.node.style;
        style.minWidth = `${minW}px`;
        style.minHeight = `${minH}px`;
        this._dirty = true;
        if (this.parent.parent) {
          MessageLoop5.sendMessage(this.parent.parent, Widget5.Msg.FitRequest);
        }
        if (this._dirty) {
          MessageLoop5.sendMessage(this.parent, Widget5.Msg.UpdateRequest);
        }
      }
      /**
       * Update the layout position and size of the widgets.
       *
       * The parent offset dimensions should be `-1` if unknown.
       */
      _update(offsetWidth, offsetHeight) {
        this._dirty = false;
        let nVisible = 0;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          nVisible += +!this._items[i6].isHidden;
        }
        if (nVisible === 0) {
          return;
        }
        if (offsetWidth < 0) {
          offsetWidth = this.parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
          offsetHeight = this.parent.node.offsetHeight;
        }
        if (!this._box) {
          this._box = ElementExt.boxSizing(this.parent.node);
        }
        let top = this._box.paddingTop;
        let left = this._box.paddingLeft;
        let width = offsetWidth - this._box.horizontalSum;
        let height = offsetHeight - this._box.verticalSum;
        for (let i6 = 0, n5 = this._items.length; i6 < n5; ++i6) {
          let item = this._items[i6];
          if (item.isHidden) {
            continue;
          }
          item.widget.node.style.zIndex = `${i6}`;
          item.update(left, top, width, height);
        }
      }
    };
    (function(Private22) {
      function createLayout(options) {
        return options.layout || new StackedLayout4();
      }
      Private22.createLayout = createLayout;
    })(Private$14 || (Private$14 = {}));
    (function(Private22) {
      function orientationFromPlacement(plc) {
        return placementToOrientationMap[plc];
      }
      Private22.orientationFromPlacement = orientationFromPlacement;
      function directionFromPlacement(plc) {
        return placementToDirectionMap[plc];
      }
      Private22.directionFromPlacement = directionFromPlacement;
      const placementToOrientationMap = {
        top: "horizontal",
        left: "vertical",
        right: "vertical",
        bottom: "horizontal"
      };
      const placementToDirectionMap = {
        top: "top-to-bottom",
        left: "left-to-right",
        right: "right-to-left",
        bottom: "bottom-to-top"
      };
    })(Private21 || (Private21 = {}));
  }
});

// ../../node_modules/@jupyterlab/json-extension/lib/index.js
var React105, import_client, CSS_CLASS, MIME_TYPE, MIME_TYPES_JSONL, RenderedJSON, rendererFactory2;
var init_lib15 = __esm({
  "../../node_modules/@jupyterlab/json-extension/lib/index.js"() {
    init_lib3();
    init_lib();
    init_index_es626();
    React105 = __toESM(require_react());
    import_client = __toESM(require_client());
    CSS_CLASS = "jp-RenderedJSON";
    MIME_TYPE = "application/json";
    MIME_TYPES_JSONL = [
      "text/jsonl",
      "application/jsonl",
      "application/json-lines"
    ];
    RenderedJSON = class extends Widget5 {
      /**
       * Create a new widget for rendering JSON.
       */
      constructor(options) {
        super();
        this._rootDOM = null;
        this.addClass(CSS_CLASS);
        this.addClass("CodeMirror");
        this._mimeType = options.mimeType;
        this.translator = options.translator || nullTranslator;
      }
      [Printing.symbol]() {
        return () => Printing.printWidget(this);
      }
      /**
       * Render JSON into this widget's node.
       */
      async renderModel(model) {
        const { Component } = await import("/build/_shared/component-2I35LYEA.js");
        let data;
        if (MIME_TYPES_JSONL.indexOf(this._mimeType) >= 0) {
          const lines = (model.data[this._mimeType] || "").trim().split(/\n/);
          data = JSON.parse(`[${lines.join(",")}]`);
        } else {
          data = model.data[this._mimeType] || {};
        }
        const metadata = model.metadata[this._mimeType] || {};
        if (this._rootDOM === null) {
          this._rootDOM = (0, import_client.createRoot)(this.node);
        }
        return new Promise((resolve, reject4) => {
          this._rootDOM.render(React105.createElement(Component, { data, metadata, translator: this.translator, forwardedRef: () => resolve() }));
        });
      }
      /**
       * Called before the widget is detached from the DOM.
       */
      onBeforeDetach(msg) {
        if (this._rootDOM) {
          this._rootDOM.unmount();
          this._rootDOM = null;
        }
      }
    };
    rendererFactory2 = {
      safe: true,
      mimeTypes: [MIME_TYPE, ...MIME_TYPES_JSONL],
      createRenderer: (options) => new RenderedJSON(options)
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/config.js
var Config;
var init_config = __esm({
  "../../node_modules/thebe-core/dist/esm/config.js"() {
    init_options();
    init_events();
    Config = class {
      constructor(opts = {}, extraConfig) {
        var _a, _b, _c, _d, _e2, _f, _g;
        this._events = (_a = extraConfig === null || extraConfig === void 0 ? void 0 : extraConfig.events) !== null && _a !== void 0 ? _a : new ThebeEvents();
        this._options = {
          mathjaxUrl: (_b = opts.mathjaxUrl) !== null && _b !== void 0 ? _b : "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js",
          mathjaxConfig: (_c = opts.mathjaxConfig) !== null && _c !== void 0 ? _c : "TeX-AMS_CHTML-full,Safe"
        };
        this._binderOptions = makeBinderOptions((_d = opts.binderOptions) !== null && _d !== void 0 ? _d : {});
        this._savedSessions = makeSavedSessionOptions((_e2 = opts.savedSessionOptions) !== null && _e2 !== void 0 ? _e2 : {});
        this._kernelOptions = makeKernelOptions((_f = opts.kernelOptions) !== null && _f !== void 0 ? _f : {});
        this._serverSettings = makeServerSettings((_g = opts.serverSettings) !== null && _g !== void 0 ? _g : {});
        console.debug("thebe:config:constructor", this);
      }
      get events() {
        return this._events;
      }
      get base() {
        return this._options;
      }
      get mathjax() {
        return {
          mathjaxUrl: this._options.mathjaxUrl,
          mathjaxConfig: this._options.mathjaxConfig
        };
      }
      get binder() {
        return this._binderOptions;
      }
      get savedSessions() {
        return this._savedSessions;
      }
      get kernels() {
        return this._kernelOptions;
      }
      get serverSettings() {
        return this._serverSettings;
      }
      set serverSettings(newSettings) {
        this._serverSettings = newSettings;
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/options.js
function makeBinderOptions(opts) {
  return Object.assign({ repo: "executablebooks/thebe-binder-base", ref: "HEAD", binderUrl: "https://mybinder.org", repoProvider: "github" }, opts);
}
function makeSavedSessionOptions(opts) {
  return Object.assign({ enabled: true, maxAge: 86400, storagePrefix: "thebe-binder" }, opts);
}
function makeKernelOptions(opts) {
  var _a, _b;
  return {
    path: (_a = opts.path) !== null && _a !== void 0 ? _a : "/",
    kernelName: (_b = opts.kernelName) !== null && _b !== void 0 ? _b : "python"
  };
}
function makeServerSettings(settings) {
  var _a, _b;
  const baseUrl = (_a = settings.baseUrl) !== null && _a !== void 0 ? _a : "http://localhost:8888";
  const wsUrl = (_b = settings.wsUrl) !== null && _b !== void 0 ? _b : baseUrl.replace(/^http/, "ws");
  return Object.assign(Object.assign({ token: shortId(), appendToken: true }, settings), {
    wsUrl,
    baseUrl
  });
}
function makeMathjaxOptions(opts) {
  return Object.assign({ mathjaxUrl: "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js", mathjaxConfig: "TeX-AMS_CHTML-full,Safe" }, opts);
}
function makeConfiguration(options, events) {
  return new Config(options, { events });
}
function ensureCoreOptions(options, events) {
  const config = new Config(options, { events });
  return Object.assign(Object.assign({}, config.base), { binderOptions: config.binder, savedSessionOptions: config.savedSessions, kernelOptions: config.kernels, serverSettings: config.serverSettings });
}
var init_options = __esm({
  "../../node_modules/thebe-core/dist/esm/options.js"() {
    init_config();
    init_utils4();
  }
});

// ../../node_modules/thebe-core/dist/esm/rendermime.js
function getRenderers(mathjax) {
  if (RENDERERS == null) {
    RENDERERS = EXTENDED_FACTORIES.filter((f6) => {
      if (f6.mimeTypes.indexOf("text/latex") >= 0) {
        if (mathjax.mathjaxUrl) {
          return true;
        } else {
          console.debug("thebe:getRenderers MathJax unavailable");
          return false;
        }
      } else {
        return true;
      }
    });
  }
  let latexTypesetter;
  if (mathjax.mathjaxUrl && mathjax.mathjaxConfig) {
    latexTypesetter = new MathJaxTypesetter({
      url: mathjax.mathjaxUrl,
      config: mathjax.mathjaxConfig
    });
  }
  return {
    initialFactories: [...RENDERERS],
    latexTypesetter
  };
}
function makeRenderMimeRegistry(mathjax) {
  const rendermime = new RenderMimeRegistry(getRenderers(mathjax !== null && mathjax !== void 0 ? mathjax : makeMathjaxOptions()));
  rendermime.addFactory(rendererFactory2, 10);
  return rendermime;
}
var EXTENDED_FACTORIES, RENDERERS;
var init_rendermime = __esm({
  "../../node_modules/thebe-core/dist/esm/rendermime.js"() {
    init_lib6();
    init_lib13();
    init_lib14();
    init_lib15();
    init_options();
    EXTENDED_FACTORIES = [
      htmlRendererFactory,
      markdownRendererFactory,
      latexRendererFactory,
      svgRendererFactory,
      imageRendererFactory,
      rendererFactory,
      textRendererFactory,
      errorRendererFactory
    ];
    RENDERERS = null;
  }
});

// ../../node_modules/thebe-core/dist/esm/passive.js
var PassiveCellRenderer, passive_default;
var init_passive = __esm({
  "../../node_modules/thebe-core/dist/esm/passive.js"() {
    init_rendermime();
    init_lib7();
    init_options();
    init_index_es614();
    init_index_es612();
    PassiveCellRenderer = class {
      constructor(id, rendermime, mathjax) {
        this.id = id;
        this.rendermime = rendermime !== null && rendermime !== void 0 ? rendermime : makeRenderMimeRegistry(mathjax !== null && mathjax !== void 0 ? mathjax : makeMathjaxOptions());
        this.model = new OutputAreaModel({ trusted: true });
        this.area = new OutputArea({
          model: this.model,
          rendermime: this.rendermime
        });
      }
      /**
       * Serialize the model state to JSON
       */
      get outputs() {
        return this.model.toJSON();
      }
      get isAttachedToDOM() {
        return this.area.isAttached;
      }
      attachToDOM(el, strict = false) {
        if (!this.area || !el) {
          console.error(`thebe:renderer:attachToDOM - could not attach to DOM - area: ${this.area}, el: ${el}`);
          return;
        }
        if (this.area.isAttached) {
          console.debug(`thebe:renderer:attachToDOM - already attached`);
          if (strict)
            return;
        } else {
          console.debug(`thebe:renderer:attachToDOM ${this.id} - appending existing contents`);
          if (el.innerHTML) {
            this.area.model.add({
              output_type: "display_data",
              data: {
                "text/html": el.innerHTML
              }
            });
          }
        }
        el.textContent = "";
        const div = document.createElement("div");
        div.style.position = "relative";
        div.className = "thebe-output";
        el.append(div);
        MessageLoop2.sendMessage(this.area, Widget2.Msg.BeforeAttach);
        div.appendChild(this.area.node);
        MessageLoop2.sendMessage(this.area, Widget2.Msg.AfterAttach);
      }
      setOutputText(text) {
        if (!this.area)
          return;
        this.area.model.clear(true);
        this.area.model.add({
          output_type: "stream",
          name: "stdout",
          text
        });
      }
      /**
       * Clears the output area model
       *
       * @returns
       */
      clear() {
        if (!this.area)
          return;
        this.area.model.clear();
      }
      /**
       * Will trigger the output to render an error with text taken from the optional argument
       *
       * @param error
       * @returns
       */
      clearOnError(error) {
        if (!this.area)
          return;
        this.area.model.clear();
        this.area.model.add({
          output_type: "stream",
          name: "stderr",
          text: `Failed to execute. ${error !== null && error !== void 0 ? error : ""} Please refresh the page.`
        });
      }
      /**
       * Render output data directly from json
       *
       * @param outputs - serialised jupyter outputs
       * @returns
       */
      render(outputs) {
        this.model.fromJSON(outputs);
      }
    };
    passive_default = PassiveCellRenderer;
  }
});

// ../../node_modules/thebe-core/dist/esm/cell.js
var ThebeCodeCell, cell_default;
var init_cell = __esm({
  "../../node_modules/thebe-core/dist/esm/cell.js"() {
    init_tslib_es6();
    init_passive();
    init_events();
    init_emitter();
    init_utils4();
    ThebeCodeCell = class extends passive_default {
      constructor(id, notebookId, source, config, metadata, rendermime) {
        super(id, rendermime);
        this.kind = "code";
        this.events = new EventEmitter(id, config, EventSubject.cell, this);
        this.notebookId = notebookId;
        this.source = source;
        this.metadata = metadata;
        this.busy = false;
        this.executionCount = null;
        this.initialOutputs = [];
        console.debug("thebe:cell constructor", this);
      }
      static fromICodeCell(icc, notebookId, config, rendermime) {
        var _a;
        const cell = new ThebeCodeCell((_a = icc.id) !== null && _a !== void 0 ? _a : shortId(), notebookId, ensureString2(icc.source), config, icc.metadata, rendermime);
        Object.assign(cell.metadata, icc.metadata);
        return cell;
      }
      get isBusy() {
        return this.busy;
      }
      get isAttached() {
        return this.session !== void 0;
      }
      get tags() {
        var _a;
        return (_a = this.metadata.tags) !== null && _a !== void 0 ? _a : [];
      }
      /**
       * Attaches to the session and adds the widgets factory to the rendermine registry
       * call this version if using ThebeCell in isolation, otherwise call ThebeNotebook::attachSession
       *
       * @param session
       */
      attachSession(session) {
        this.session = session;
        this.events.triggerStatus({
          status: CellStatusEvent.attached,
          message: "Attached to session"
        });
      }
      /**
       * Detaches from the session and removes the widgets factory from the rendermine registry
       * call this version if using ThebeCell in isolation, otherwise call ThebeNotebook::detachSession
       *
       */
      detachSession() {
        this.session = void 0;
        this.events.triggerStatus({
          status: CellStatusEvent.detached,
          message: "Detached from session"
        });
      }
      setAsBusy() {
        console.debug(`thebe:renderer:message:busy ${this.id}`);
        this.busy = true;
        this.events.triggerStatus({
          status: CellStatusEvent.executing,
          message: "Executing..."
        });
      }
      setAsIdle() {
        console.debug(`thebe:renderer:message:completed ${this.id}`);
        this.busy = false;
        this.events.triggerStatus({
          status: CellStatusEvent.idle,
          message: "Completed"
        });
      }
      /**
       * reset the DOM representation of the cell to the initial state
       * along with the execution count
       *
       * @param hideWidgets boolean - if true, hide widgets
       */
      initOutputs(initialOutputs) {
        this.initialOutputs = initialOutputs;
        this.render(initialOutputs);
        this.executionCount = null;
      }
      /**
       * reset the DOM representation of the cell to the initial state
       * along with the execution count
       *
       * @param hideWidgets boolean - if true, hide widgets
       */
      reset() {
        this.render(this.initialOutputs);
        this.executionCount = null;
      }
      /**
       * TODO
       *  - pass execute_count or timestamp or something back to redux on success/failure?
       *
       * @param source?
       * @returns
       */
      execute(source) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.session || !this.session.kernel) {
            console.warn("Attempting to execute on a cell without an attached kernel");
            return null;
          }
          const code3 = source !== null && source !== void 0 ? source : this.source;
          try {
            console.debug(`thebe:renderer:execute ${this.id}`);
            if (!this.isBusy)
              this.setAsBusy();
            this.area.future = this.session.kernel.requestExecute({ code: code3 });
            const reply = yield this.area.future.done;
            this.executionCount = reply.content.execution_count;
            let executeErrors;
            for (let i6 = 0; i6 < this.model.length; i6++) {
              const out = this.model.get(i6);
              console.debug("thebecell:execute:output", { out: out.toJSON() });
              if (out.type === "error") {
                const json = out.toJSON();
                if (json.ename === "stderr") {
                  this.events.triggerError({
                    status: ErrorStatusEvent.warning,
                    message: errorToMessage(json)
                  });
                } else {
                  if (!executeErrors)
                    executeErrors = [json];
                  else
                    executeErrors === null || executeErrors === void 0 ? void 0 : executeErrors.push(json);
                  this.events.triggerError({
                    status: ErrorStatusEvent.executeError,
                    message: errorToMessage(json)
                  });
                }
              }
            }
            this.setAsIdle();
            return {
              id: this.id,
              height: this.area.node.offsetHeight,
              width: this.area.node.offsetWidth,
              error: executeErrors
            };
          } catch (err) {
            console.error("thebe:renderer:execute Error:", err);
            this.clearOnError(err);
            this.events.triggerError(err.message);
            return null;
          }
        });
      }
    };
    cell_default = ThebeCodeCell;
  }
});

// ../../node_modules/thebe-core/dist/esm/markdown.js
var ThebeMarkdownCell;
var init_markdown = __esm({
  "../../node_modules/thebe-core/dist/esm/markdown.js"() {
    init_tslib_es6();
    init_passive();
    init_utils4();
    ThebeMarkdownCell = class extends passive_default {
      constructor(id, notebookId, source, metadata, rendermime) {
        super(id, rendermime);
        this.kind = "markdown";
        this.id = id;
        this.notebookId = notebookId;
        this.source = source;
        this.busy = false;
        this.metadata = metadata;
      }
      static fromICell(ic, notebookId, rendermime) {
        const cell = new ThebeMarkdownCell(typeof ic.id === "string" ? ic.id : shortId(), notebookId, ensureString2(ic.source), ic.metadata, rendermime);
        return cell;
      }
      get isAttachedToDOM() {
        return false;
      }
      get isBusy() {
        return false;
      }
      get isAttached() {
        return false;
      }
      get executionCount() {
        return null;
      }
      setAsBusy() {
      }
      setAsIdle() {
      }
      initOutputs(initialOutputs) {
      }
      reset() {
      }
      attachToDOM(el) {
      }
      attachSession(session) {
      }
      detachSession() {
      }
      setOutputText(text) {
      }
      clear() {
      }
      clearOnError(error) {
      }
      messageBusy() {
      }
      messageCompleted() {
      }
      messageError(message) {
      }
      render(outputs) {
      }
      get tags() {
        return [];
      }
      get outputs() {
        return [];
      }
      execute(source) {
        return __awaiter(this, void 0, void 0, function* () {
          return { id: this.id, height: 0, width: 0 };
        });
      }
    };
  }
});

// ../../node_modules/thebe-core/dist/esm/notebook.js
var ThebeNotebook, notebook_default;
var init_notebook = __esm({
  "../../node_modules/thebe-core/dist/esm/notebook.js"() {
    init_tslib_es6();
    init_cell();
    init_utils4();
    init_events();
    init_emitter();
    init_markdown();
    ThebeNotebook = class {
      constructor(id, config, rendermime) {
        this.id = id;
        this.events = new EventEmitter(id, config, EventSubject.notebook, this);
        this.cells = [];
        this.metadata = {};
        this.rendermime = rendermime;
        console.debug("thebe:notebook constructor", this);
      }
      static fromCodeBlocks(blocks, config, rendermime) {
        const id = shortId();
        const notebook = new ThebeNotebook(id, config, rendermime);
        notebook.cells = blocks.map((c6) => {
          const metadata = {};
          const cell = new cell_default(c6.id, id, c6.source, config, metadata, notebook.rendermime);
          console.debug(`thebe:notebook:fromCodeBlocks Initializing cell ${c6.id}`);
          return cell;
        });
        return notebook;
      }
      static fromIpynb(ipynb, config, rendermime) {
        const notebook = new ThebeNotebook(shortId(), config, rendermime);
        Object.assign(notebook.metadata, ipynb.metadata);
        notebook.cells = ipynb.cells.map((c6) => {
          if (c6.cell_type === "code")
            return cell_default.fromICodeCell(c6, notebook.id, config, notebook.rendermime);
          return ThebeMarkdownCell.fromICell(c6, notebook.id, notebook.rendermime);
        });
        return notebook;
      }
      get parameters() {
        const p3 = this.findCells("parameters");
        if (!p3 || (p3 === null || p3 === void 0 ? void 0 : p3.length) === 0)
          return void 0;
        if (p3.length > 1)
          console.warn(`Mulitple parameter cells found in notebook ${this.id}`);
        return p3;
      }
      get widgets() {
        var _a;
        return (_a = this.findCells("widget")) !== null && _a !== void 0 ? _a : [];
      }
      get last() {
        if (this.cells.length === 0)
          throw new Error("empty notebook");
        return this.cells[this.cells.length - 1];
      }
      get markdown() {
        return this.cells.filter((c6) => c6.kind === "markdown");
      }
      get code() {
        return this.cells.filter((c6) => c6.kind === "code");
      }
      /**
       * reset the notebook to its initial state by resetting each cell
       *
       * @param hideWidgets boolean
       */
      reset() {
        this.cells.forEach((cell) => cell.reset());
      }
      numCells() {
        var _a, _b;
        return (_b = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      }
      findCells(tag) {
        const found = this.cells.filter((c6) => c6.tags.includes(tag));
        return found.length > 0 ? found : void 0;
      }
      getCell(idx) {
        if (!this.cells)
          throw Error("Dag not initialized");
        if (idx >= this.cells.length)
          throw Error(`Notebook.cells index out of range: ${idx}:${this.cells.length}`);
        return this.cells[idx];
      }
      getCellById(id) {
        var _a;
        const cell = (_a = this.cells) === null || _a === void 0 ? void 0 : _a.find((c6) => c6.id === id);
        return cell;
      }
      lastCell() {
        if (!this.cells)
          throw Error("Notebook not initialized");
        return this.cells[this.cells.length - 1];
      }
      updateParameters(newSource, interpolate = false) {
        if (interpolate)
          throw new Error("Not implemented yet");
        if (this.parameters)
          this.parameters[0].source = newSource;
      }
      waitForKernel(kernel) {
        return __awaiter(this, void 0, void 0, function* () {
          return kernel.then((k2) => {
            this.attachSession(k2);
            return k2;
          });
        });
      }
      attachSession(session) {
        var _a;
        if (!session.kernel)
          throw Error("ThebeNotebook - cannot connect to session, no kernel");
        this.session = session;
        (_a = this.cells) === null || _a === void 0 ? void 0 : _a.forEach((cell) => cell.session = session);
        this.events.triggerStatus({
          status: NotebookStatusEvent.attached,
          message: "Attached to session"
        });
      }
      detachSession() {
        var _a;
        (_a = this.cells) === null || _a === void 0 ? void 0 : _a.map((cell) => cell.session = void 0);
        this.session = void 0;
        this.events.triggerStatus({
          status: NotebookStatusEvent.detached,
          message: "Detached from session"
        });
      }
      clear() {
        this.cells.forEach((cell) => cell.clear());
      }
      executeUpTo(cellId, stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeUpTo ${cellId}`
          });
          const idx = this.cells.findIndex((c6) => c6.id === cellId);
          if (idx === -1)
            return [];
          const cellsToExecute = this.cells.slice(0, idx + 1);
          cellsToExecute.map((cell) => cell.setAsBusy());
          const result2 = yield this.executeCells(cellsToExecute.map((c6) => c6.id), stopOnError, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeUpTo ${cellId}`
          });
          return result2;
        });
      }
      executeOnly(cellId, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return null;
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeOnly ${cellId}`
          });
          const result2 = yield this.executeCells([cellId], false, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeUpTo ${cellId}`
          });
          return result2[0];
        });
      }
      executeCells(cellIds, stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeCells ${cellIds.length} cells`
          });
          const cells = this.cells.filter((c6) => {
            const found = cellIds.find((id) => id === c6.id);
            if (!found) {
              console.warn(`Cell ${c6.id} not found in notebook`);
            }
            return Boolean(found);
          });
          let result2 = [];
          if (stopOnError) {
            let skipRemaining = false;
            for (const cell of cells) {
              if (skipRemaining)
                continue;
              const cellReturn = yield cell.execute(preprocessor ? preprocessor(cell.source) : cell.source);
              if (cellReturn == null || cellReturn.error)
                skipRemaining = true;
              result2.push(cellReturn);
            }
          } else {
            result2 = yield Promise.all(cells.map((cell) => cell.execute(preprocessor ? preprocessor(cell.source) : cell.source)));
          }
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeCells executed ${cellIds.length} cells`
          });
          return result2;
        });
      }
      executeAll(stopOnError = false, preprocessor) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.cells)
            return [];
          this.events.triggerStatus({
            status: NotebookStatusEvent.executing,
            message: `executeAll`
          });
          this.cells.map((cell) => cell.setAsBusy());
          const result2 = yield this.executeCells(this.cells.map((c6) => c6.id), stopOnError, preprocessor);
          this.events.triggerStatus({
            status: NotebookStatusEvent.idle,
            message: `executeAll`
          });
          return result2;
        });
      }
    };
    notebook_default = ThebeNotebook;
  }
});

// ../../node_modules/thebe-core/dist/esm/version.js
var version2, version_default;
var init_version3 = __esm({
  "../../node_modules/thebe-core/dist/esm/version.js"() {
    version2 = "0.5.0";
    version_default = version2;
  }
});

// ../../node_modules/thebe-core/dist/esm/thebe/api.js
function connectToBinder(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect binder \u{1F4E1}`, config.binder);
  server.connectToServerViaBinder();
  return server;
}
function connectToJupyter(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect direct \u{1F50C}`, config.serverSettings);
  server.connectToJupyterServer();
  return server;
}
function connectToJupyterLite(config) {
  const server = new server_default(config);
  console.debug(`thebe:api:connect JupyterLite \u{1F918}`);
  server.connectToJupyterLiteServer();
  return server;
}
function makeEvents() {
  return new ThebeEvents();
}
function makeServer(config) {
  return new server_default(config);
}
function setupNotebookFromBlocks(blocks, config, rendermime) {
  return notebook_default.fromCodeBlocks(blocks, config, rendermime);
}
function setupNotebookFromIpynb(ipynb, config, rendermime) {
  return notebook_default.fromIpynb(ipynb, config, rendermime);
}
function setupThebeCore() {
  var _a;
  console.debug(`thebe-core (v${version_default})`, { coreModule: esm_exports });
  window.thebeCore = Object.assign((_a = window.thebeCore) !== null && _a !== void 0 ? _a : {}, {
    module: esm_exports,
    api: {
      makeConfiguration,
      makeEvents,
      makeServer,
      makeRenderMimeRegistry,
      connectToBinder,
      connectToJupyter,
      connectToJupyterLite,
      setupNotebookFromBlocks,
      setupNotebookFromIpynb
    },
    version: version_default
  });
}
var init_api = __esm({
  "../../node_modules/thebe-core/dist/esm/thebe/api.js"() {
    init_server();
    init_notebook();
    init_events();
    init_options();
    init_rendermime();
    init_esm();
    init_version3();
  }
});

// ../../node_modules/thebe-core/dist/esm/thebe/entrypoint.js
var init_entrypoint = __esm({
  "../../node_modules/thebe-core/dist/esm/thebe/entrypoint.js"() {
    init_api();
    if (typeof window !== "undefined")
      setupThebeCore();
  }
});

// ../../node_modules/thebe-core/dist/esm/types.js
var init_types = __esm({
  "../../node_modules/thebe-core/dist/esm/types.js"() {
  }
});

// ../../node_modules/thebe-core/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CellStatusEvent: () => CellStatusEvent,
  Config: () => Config,
  ErrorStatusEvent: () => ErrorStatusEvent,
  EventSubject: () => EventSubject,
  KernelStatusEvent: () => KernelStatusEvent,
  NotebookStatusEvent: () => NotebookStatusEvent,
  PassiveCellRenderer: () => passive_default,
  ServerStatusEvent: () => ServerStatusEvent,
  SessionStatusEvent: () => SessionStatusEvent,
  ThebeCodeCell: () => cell_default,
  ThebeEventType: () => ThebeEventType,
  ThebeEvents: () => ThebeEvents,
  ThebeManager: () => ThebeManager,
  ThebeMarkdownCell: () => ThebeMarkdownCell,
  ThebeNotebook: () => notebook_default,
  ThebeServer: () => server_default,
  ThebeSession: () => session_default,
  WIDGET_MIMETYPE: () => WIDGET_MIMETYPE,
  clearAllSavedSessions: () => clearAllSavedSessions,
  clearSavedSession: () => clearSavedSession,
  connectToBinder: () => connectToBinder,
  connectToJupyter: () => connectToJupyter,
  connectToJupyterLite: () => connectToJupyterLite,
  ensureCoreOptions: () => ensureCoreOptions,
  ensureString: () => ensureString2,
  errorToMessage: () => errorToMessage,
  getRenderers: () => getRenderers,
  isMimeBundle: () => isMimeBundle,
  makeBinderOptions: () => makeBinderOptions,
  makeConfiguration: () => makeConfiguration,
  makeEvents: () => makeEvents,
  makeKernelOptions: () => makeKernelOptions,
  makeMathjaxOptions: () => makeMathjaxOptions,
  makeRenderMimeRegistry: () => makeRenderMimeRegistry,
  makeSavedSessionOptions: () => makeSavedSessionOptions,
  makeServer: () => makeServer,
  makeServerSettings: () => makeServerSettings,
  placeholder: () => placeholder,
  setupNotebookFromBlocks: () => setupNotebookFromBlocks,
  setupNotebookFromIpynb: () => setupNotebookFromIpynb,
  setupThebeCore: () => setupThebeCore,
  shortId: () => shortId,
  stripWidgets: () => stripWidgets,
  version: () => version_default
});
var init_esm = __esm({
  "../../node_modules/thebe-core/dist/esm/index.js"() {
    init_server();
    init_session();
    init_notebook();
    init_cell();
    init_markdown();
    init_passive();
    init_version3();
    init_options();
    init_events();
    init_api();
    init_entrypoint();
    init_utils4();
    init_manager3();
    init_rendermime();
    init_types();
    init_config();
    init_sessions();
  }
});

// ../../node_modules/thebe-react/dist/ThebeLoaderProvider.js
var require_ThebeLoaderProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeLoaderProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useThebeLoader = exports.ThebeBundleLoaderProvider = exports.ThebeLoaderProvider = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var version_1 = tslib_1.__importDefault(require_version());
    var ThebeLoaderContext = react_1.default.createContext(void 0);
    function ThebeLoaderProvider({ start, children }) {
      const [startLoad, setStartLoad] = (0, react_1.useState)(start);
      const [loading, setLoading] = (0, react_1.useState)(false);
      const [core, setCore] = (0, react_1.useState)();
      const [error, setError] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (!startLoad || core)
          return;
        setLoading(true);
        console.debug(`thebe-react (v${version_1.default}) importing thebe-core...`);
        Promise.resolve().then(() => tslib_1.__importStar((init_esm(), __toCommonJS(esm_exports)))).then((thebeCore) => {
          console.debug(`thebe-core (v${thebeCore.version}) loaded`);
          setCore(thebeCore);
          setLoading(false);
        }).catch(({ message }) => {
          console.debug(`thebe-core load failed ${message}`);
          setError(message);
          setLoading(false);
        });
      }, [startLoad]);
      return (0, jsx_runtime_1.jsx)(ThebeLoaderContext.Provider, Object.assign({ value: { core, error, loading, load: () => setStartLoad(true) } }, { children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children }) }));
    }
    exports.ThebeLoaderProvider = ThebeLoaderProvider;
    function ThebeBundleLoaderProvider2({ start, loadThebeLite, publicPath, children, options = {} }) {
      const [startLoad, setStartLoad] = (0, react_1.useState)(start);
      const [loading, setLoading] = (0, react_1.useState)(false);
      const [core, setCore] = (0, react_1.useState)();
      const [error, setError] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        var _a;
        if (!startLoad || core)
          return;
        setLoading(true);
        console.debug(`thebe-react (v${version_1.default}) importing thebe-core...`);
        if (typeof document !== "undefined" && typeof window !== "undefined") {
          try {
            if (!window.thebeCore) {
              const script = document.createElement("script");
              script.setAttribute("src", `${publicPath !== null && publicPath !== void 0 ? publicPath : ""}/thebe-core.min.js`);
              script.setAttribute("async", "true");
              script.setAttribute("type", "text/javascript");
              document.head.appendChild(script);
            }
            if (loadThebeLite) {
              const liteScript = document.createElement("script");
              liteScript.setAttribute("src", `${publicPath !== null && publicPath !== void 0 ? publicPath : ""}/thebe-lite.min.js`);
              liteScript.setAttribute("async", "true");
              liteScript.setAttribute("type", "text/javascript");
              document.head.appendChild(liteScript);
            }
            let attempts = 0;
            const timer = setInterval(() => {
              var _a2, _b, _c, _d, _e2, _f;
              if (window.thebeCore && (window.thebeLite || !loadThebeLite)) {
                setLoading(false);
                setCore((_a2 = window.thebeCore) === null || _a2 === void 0 ? void 0 : _a2.module);
                console.debug(`thebe-core (v${(_c = (_b = window.thebeCore) === null || _b === void 0 ? void 0 : _b.version) !== null && _c !== void 0 ? _c : "0"}) loaded`);
                if (window.thebeLite)
                  console.debug(`thebe-lite (v${(_e2 = (_d = window.thebeLite) === null || _d === void 0 ? void 0 : _d.version) !== null && _e2 !== void 0 ? _e2 : "0"}) loaded`);
                clearInterval(timer);
              }
              if (attempts > ((_f = options === null || options === void 0 ? void 0 : options.attempts) !== null && _f !== void 0 ? _f : 50)) {
                setError("thebe-core load failed");
                setLoading(false);
                clearInterval(timer);
                console.warn("thebe load timed out");
                if (!window.thebeCore)
                  console.debug("thebe-core failed to load");
                if (!window.thebeLite)
                  console.debug("thebe-lite failed to load");
              }
              attempts += 1;
            }, (_a = options === null || options === void 0 ? void 0 : options.delay) !== null && _a !== void 0 ? _a : 300);
          } catch (err) {
            setError(err);
            setLoading(false);
          }
        }
      }, [startLoad]);
      return (0, jsx_runtime_1.jsx)(ThebeLoaderContext.Provider, Object.assign({ value: { core, error, loading, load: () => setStartLoad(true) } }, { children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children }) }));
    }
    exports.ThebeBundleLoaderProvider = ThebeBundleLoaderProvider2;
    function useThebeLoader5() {
      const context = react_1.default.useContext(ThebeLoaderContext);
      return context !== null && context !== void 0 ? context : { loading: false, load: () => ({}) };
    }
    exports.useThebeLoader = useThebeLoader5;
  }
});

// ../../node_modules/thebe-react/dist/ThebeServerProvider.js
var require_ThebeServerProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeServerProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useThebeServer = exports.useDisposeThebeServer = exports.useThebeConfig = exports.ThebeServerProvider = exports.ThebeServerContext = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    exports.ThebeServerContext = react_1.default.createContext(void 0);
    function ThebeServerProvider2({ connect = true, config, options, useBinder, useJupyterLite, customConnectFn, customRepoProviders, events, children }) {
      var _a;
      const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const [doConnect, setDoConnect] = (0, react_1.useState)(connect);
      const [connecting, setConnecting] = (0, react_1.useState)(false);
      const [server, setServer] = (0, react_1.useState)();
      const [ready, setReady] = (0, react_1.useState)(false);
      const [error, setError] = (0, react_1.useState)();
      const configRef = (0, react_1.useRef)();
      const thebeConfig = (0, react_1.useMemo)(() => config !== null && config !== void 0 ? config : core === null || core === void 0 ? void 0 : core.makeConfiguration(options !== null && options !== void 0 ? options : {}, events), [core, config, options]);
      (0, react_1.useEffect)(() => {
        if (!core || !thebeConfig)
          return;
        else if (thebeConfig === configRef.current && server)
          return;
        const svr = new core.ThebeServer(thebeConfig);
        const handler = (evt, data) => {
          const subjects = [
            core.EventSubject.server,
            core.EventSubject.session,
            core.EventSubject.kernel
          ];
          if (data.subject && subjects.includes(data.subject)) {
            setError(`${data.status} - ${data.message}`);
          }
        };
        thebeConfig.events.on(core.ThebeEventType.error, handler);
        configRef.current = thebeConfig;
        setServer(svr);
      }, [core, thebeConfig, server]);
      const connectToServer = () => {
        if (!server)
          return;
        setConnecting(true);
        if (customConnectFn)
          customConnectFn(server);
        else if (useBinder)
          server.connectToServerViaBinder(customRepoProviders);
        else if (useJupyterLite)
          server.connectToJupyterLiteServer();
        else
          server.connectToJupyterServer();
        server.ready.then(() => {
          setConnecting(false);
          setReady(true);
        }, () => {
          setConnecting(false);
          setReady(false);
        });
        return server.ready;
      };
      (0, react_1.useEffect)(() => {
        if (!server || !doConnect)
          return;
        if (server.isReady && server.userServerUrl)
          return;
        connectToServer();
      }, [server, doConnect]);
      return (0, jsx_runtime_1.jsx)(exports.ThebeServerContext.Provider, Object.assign({ value: {
        config: thebeConfig,
        events: events !== null && events !== void 0 ? events : thebeConfig === null || thebeConfig === void 0 ? void 0 : thebeConfig.events,
        server,
        connecting,
        ready: ((_a = server === null || server === void 0 ? void 0 : server.isReady) !== null && _a !== void 0 ? _a : false) && ready,
        connect: connectToServer,
        disconnect: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (core && thebeConfig && server) {
            server.dispose();
            setServer(new core.ThebeServer(thebeConfig));
          }
          setReady(false);
          setDoConnect(false);
          setConnecting(false);
          setError(void 0);
        }),
        error
      } }, { children }));
    }
    exports.ThebeServerProvider = ThebeServerProvider2;
    function useThebeConfig3() {
      const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
      if (serverContext === void 0) {
        throw new Error("useThebeServer must be used inside a ThebeServerProvider");
      }
      return { config: serverContext.config };
    }
    exports.useThebeConfig = useThebeConfig3;
    function useDisposeThebeServer() {
      const [disposed, setDisposed] = (0, react_1.useState)(false);
      const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
      if (serverContext === void 0) {
        throw new Error("useThebeServer must be used inside a ThebeServerProvider");
      }
      const { server, ready } = serverContext;
      (0, react_1.useEffect)(() => {
        if (!server || !ready)
          return;
        Promise.resolve().then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield server.shutdownAllSessions();
          server.dispose();
          setDisposed(true);
        }));
      }, [ready, server]);
      return disposed;
    }
    exports.useDisposeThebeServer = useDisposeThebeServer;
    function useThebeServer5() {
      const thebe = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { core } = thebe !== null && thebe !== void 0 ? thebe : {};
      const serverContext = (0, react_1.useContext)(exports.ThebeServerContext);
      const { config, events, server, connecting, ready, connect, disconnect, error } = serverContext !== null && serverContext !== void 0 ? serverContext : {
        ready: false,
        connecting: false
      };
      const [eventCallbacks, setEventCallbacks] = (0, react_1.useState)([]);
      const subscribe = (0, react_1.useCallback)((fn) => {
        if (!core || !config || !server)
          return;
        const callbackFn = (evt, data) => {
          const subjects = [
            core.EventSubject.server,
            core.EventSubject.session,
            core.EventSubject.kernel
          ];
          if (data.subject && subjects.includes(data.subject))
            fn(data);
        };
        config === null || config === void 0 ? void 0 : config.events.on(core.ThebeEventType.status, callbackFn);
        setEventCallbacks([...eventCallbacks, callbackFn]);
      }, [config, server]);
      const unsubAll = (0, react_1.useCallback)(() => {
        if (!core)
          return;
        eventCallbacks.forEach((cb2) => {
          config === null || config === void 0 ? void 0 : config.events.off(core.ThebeEventType.status, cb2);
        });
        setEventCallbacks([]);
      }, [config, server]);
      return serverContext ? {
        config,
        events,
        server,
        connecting,
        ready,
        error,
        connect,
        disconnect,
        subscribe,
        unsubAll
      } : { connecting: false, ready: false };
    }
    exports.useThebeServer = useThebeServer5;
  }
});

// ../../node_modules/thebe-react/dist/ThebeRenderMimeRegistryProvider.js
var require_ThebeRenderMimeRegistryProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeRenderMimeRegistryProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useRenderMimeRegistry = exports.ThebeRenderMimeRegistryProvider = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importDefault(require_react());
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var RenderMimeRegistryContext = react_1.default.createContext(void 0);
    function ThebeRenderMimeRegistryProvider({ children }) {
      const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = react_1.default.useMemo(() => core === null || core === void 0 ? void 0 : core.makeRenderMimeRegistry(config === null || config === void 0 ? void 0 : config.mathjax), [core, config]);
      return (0, jsx_runtime_1.jsx)(RenderMimeRegistryContext.Provider, Object.assign({ value: { rendermime } }, { children }));
    }
    exports.ThebeRenderMimeRegistryProvider = ThebeRenderMimeRegistryProvider;
    function useRenderMimeRegistry() {
      const context = react_1.default.useContext(RenderMimeRegistryContext);
      return context === null || context === void 0 ? void 0 : context.rendermime;
    }
    exports.useRenderMimeRegistry = useRenderMimeRegistry;
  }
});

// ../../node_modules/thebe-react/dist/ThebeSessionProvider.js
var require_ThebeSessionProvider = __commonJS({
  "../../node_modules/thebe-react/dist/ThebeSessionProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useThebeSession = exports.ThebeSessionProvider = exports.ThebeSessionContext = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = tslib_1.__importStar(require_react());
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var ThebeRenderMimeRegistryProvider_1 = require_ThebeRenderMimeRegistryProvider();
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    exports.ThebeSessionContext = react_1.default.createContext(void 0);
    function ThebeSessionProvider({ start = true, path, shutdownOnUnmount = false, children }) {
      const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config, server, ready: serverReady } = (0, ThebeServerProvider_1.useThebeServer)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [doStart, setDoStart] = (0, react_1.useState)(start);
      const [starting, setStarting] = (0, react_1.useState)(false);
      const [session, setSession] = (0, react_1.useState)();
      const [ready, setReady] = (0, react_1.useState)(false);
      const [error, setError] = (0, react_1.useState)();
      const [unsubscribe, setUnsubscribe] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (!server || !serverReady || !doStart || starting || ready)
          return;
        startSession();
      }, [ready, doStart, starting, server, serverReady]);
      (0, react_1.useEffect)(() => {
        if (!core || !config || !session)
          return;
        const handler = (evt, data) => {
          const subjects = [core.EventSubject.session, core.EventSubject.kernel];
          if (data.subject && subjects.includes(data.subject) && data.status === "shutdown" && data.id === session.id) {
            setError(`session ${session.path} - ${data.status} - ${data.message}`);
          }
        };
        setUnsubscribe(config.events.on(core.ThebeEventType.status, handler));
      }, [core, config, session]);
      const startSession = () => {
        if (!rendermime)
          throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
        setStarting(true);
        server === null || server === void 0 ? void 0 : server.startNewSession(rendermime, { path }).then((sesh) => {
          setStarting(false);
          if (sesh == null) {
            server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
              setError(`Could not start a session - available kernels: ${Object.keys(specs.kernelspecs)}`);
            });
            return;
          }
          setSession(sesh);
          setReady(true);
        }, (err) => {
          setError(typeof err === "object" ? err.message : JSON.stringify(err));
          setReady(false);
          setDoStart(false);
          setStarting(false);
        });
      };
      (0, react_1.useEffect)(() => {
        return () => {
          if (shutdownOnUnmount) {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            setUnsubscribe(void 0);
            session === null || session === void 0 ? void 0 : session.shutdown().then(() => {
              setReady(false);
              setStarting(false);
              setError(void 0);
            });
          }
        };
      }, [session]);
      return (0, jsx_runtime_1.jsx)(exports.ThebeSessionContext.Provider, Object.assign({ value: {
        path,
        starting,
        ready,
        session,
        // eslint-disable-next-line @typescript-eslint/no-shadow
        start: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!!session && ready) {
            yield session.restart();
          } else {
            startSession();
          }
        }),
        shutdown: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (session) {
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
            setUnsubscribe(void 0);
            yield session.shutdown();
            setSession(void 0);
            setReady(false);
            setStarting(false);
            setError(void 0);
          }
        }),
        error
      } }, { children }));
    }
    exports.ThebeSessionProvider = ThebeSessionProvider;
    function useThebeSession() {
      const sessionContext = (0, react_1.useContext)(exports.ThebeSessionContext);
      return sessionContext !== null && sessionContext !== void 0 ? sessionContext : { starting: false, ready: false };
    }
    exports.useThebeSession = useThebeSession;
  }
});

// ../../node_modules/thebe-react/dist/hooks/notebook.js
var require_notebook = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useNotebookfromSourceLegacy = exports.useNotebookFromSource = exports.useNotebook = exports.useNotebookBase = exports.findErrors = void 0;
    var react_1 = require_react();
    var ThebeServerProvider_1 = require_ThebeServerProvider();
    var ThebeLoaderProvider_1 = require_ThebeLoaderProvider();
    var ThebeSessionProvider_1 = require_ThebeSessionProvider();
    var ThebeRenderMimeRegistryProvider_1 = require_ThebeRenderMimeRegistryProvider();
    function findErrors2(execReturns) {
      return execReturns.reduce((acc, retval, index2) => {
        if (retval === null || retval === void 0 ? void 0 : retval.error) {
          if (acc == null)
            return [Object.assign(Object.assign({}, retval), { index: index2 })];
          else
            return [...acc, Object.assign(Object.assign({}, retval), { index: index2 })];
        }
        return acc;
      }, null);
    }
    exports.findErrors = findErrors2;
    function useNotebookBase() {
      const { session, ready: sessionReady } = (0, ThebeSessionProvider_1.useThebeSession)();
      const [notebook, setNotebook] = (0, react_1.useState)();
      const [refs, setRefs] = (0, react_1.useState)([]);
      const [sessionAttached, setSessionAttached] = (0, react_1.useState)(false);
      const [executing, setExecuting] = (0, react_1.useState)(false);
      const [executed, setExecuted] = (0, react_1.useState)(false);
      const [errors, setErrors] = (0, react_1.useState)(null);
      (0, react_1.useEffect)(() => {
        if (!notebook || !session || !sessionReady)
          return;
        console.debug(`thebe-react: attaching notebook to session`, { notebook, session });
        notebook.attachSession(session);
        setSessionAttached(true);
      }, [notebook, session, sessionReady]);
      const executeAll = (options) => {
        var _a, _b;
        if (!notebook)
          throw new Error("executeAll called before notebook available");
        if (!session)
          throw new Error("executeAll called before session available");
        (_a = options === null || options === void 0 ? void 0 : options.before) === null || _a === void 0 ? void 0 : _a.call(options);
        setExecuting(true);
        return notebook.executeAll((_b = options === null || options === void 0 ? void 0 : options.stopOnError) !== null && _b !== void 0 ? _b : true, options === null || options === void 0 ? void 0 : options.preprocessor).then((execReturns) => {
          var _a2;
          (_a2 = options === null || options === void 0 ? void 0 : options.after) === null || _a2 === void 0 ? void 0 : _a2.call(options);
          const errs = findErrors2(execReturns);
          if (errs != null)
            setErrors(errs);
          setExecuted(true);
          setExecuting(false);
          return execReturns;
        });
      };
      const executeSome = (predicate, options) => {
        var _a, _b;
        if (!notebook)
          throw new Error("executeSome called before notebook available");
        if (!session)
          throw new Error("executeAll called before session available");
        (_a = options === null || options === void 0 ? void 0 : options.before) === null || _a === void 0 ? void 0 : _a.call(options);
        setExecuting(true);
        const filteredCells = notebook.cells.filter(predicate).map((c6) => c6.id);
        return notebook.executeCells(filteredCells, (_b = options === null || options === void 0 ? void 0 : options.stopOnError) !== null && _b !== void 0 ? _b : true, options === null || options === void 0 ? void 0 : options.preprocessor).then((execReturns) => {
          var _a2;
          (_a2 = options === null || options === void 0 ? void 0 : options.after) === null || _a2 === void 0 ? void 0 : _a2.call(options);
          const errs = findErrors2(execReturns);
          if (errs != null)
            setErrors(errs);
          setExecuted(true);
          setExecuting(false);
          return execReturns;
        });
      };
      const clear = () => {
        if (!notebook)
          throw new Error("clear called before notebook available");
        notebook.clear();
        setExecuted(false);
      };
      return {
        ready: !!notebook && sessionAttached,
        attached: sessionAttached,
        executing,
        executed,
        errors,
        notebook,
        setNotebook,
        refs,
        setRefs,
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports.useNotebookBase = useNotebookBase;
    function useNotebook(name, fetchNotebook, opts = { refsForWidgetsOnly: true }) {
      var _a, _b;
      const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [loading, setLoading] = (0, react_1.useState)(false);
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const { ready, attached, executing, executed, errors, notebook, setNotebook, refs, setRefs, executeAll, executeSome, clear, session } = useNotebookBase();
      (0, react_1.useEffect)(() => {
        if (!core || !config)
          return;
        setLoading(true);
        fetchNotebook(name).then((ipynb) => {
          return core === null || core === void 0 ? void 0 : core.ThebeNotebook.fromIpynb(ipynb, config, rendermime);
        }).then((nb) => {
          var _a2, _b2;
          const cells = (opts === null || opts === void 0 ? void 0 : opts.refsForWidgetsOnly) ? (_a2 = nb === null || nb === void 0 ? void 0 : nb.widgets) !== null && _a2 !== void 0 ? _a2 : [] : (_b2 = nb === null || nb === void 0 ? void 0 : nb.cells) !== null && _b2 !== void 0 ? _b2 : [];
          setRefs(Array(cells.length).fill(null).map((_4, idx) => (node) => {
            console.debug(`new ref[${idx}] - attaching to dom...`, node);
            if (node != null)
              cells[idx].attachToDOM(node);
          }));
          setNotebook(nb);
          setLoading(false);
        });
      }, [core, config]);
      return {
        ready,
        loading,
        attached,
        executing,
        executed,
        errors,
        notebook,
        cellRefs: refs,
        cellIds: (opts.refsForWidgetsOnly ? (_a = notebook === null || notebook === void 0 ? void 0 : notebook.widgets) !== null && _a !== void 0 ? _a : [] : (_b = notebook === null || notebook === void 0 ? void 0 : notebook.cells) !== null && _b !== void 0 ? _b : []).map((c6) => c6.id),
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports.useNotebook = useNotebook;
    function useNotebookFromSource(sourceCode, opts = { refsForWidgetsOnly: true }) {
      var _a, _b;
      const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      const [loading, setLoading] = (0, react_1.useState)(false);
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const { ready, attached, executing, executed, errors, notebook, setNotebook, refs, setRefs, executeAll, executeSome, clear, session } = useNotebookBase();
      (0, react_1.useEffect)(() => {
        var _a2, _b2;
        if (!core || !config || loading || notebook)
          return;
        setLoading(true);
        const nb = core.ThebeNotebook.fromCodeBlocks(sourceCode.map((source) => ({ id: core === null || core === void 0 ? void 0 : core.shortId(), source })), config, rendermime);
        const cells = (opts === null || opts === void 0 ? void 0 : opts.refsForWidgetsOnly) ? (_a2 = nb === null || nb === void 0 ? void 0 : nb.widgets) !== null && _a2 !== void 0 ? _a2 : [] : (_b2 = nb === null || nb === void 0 ? void 0 : nb.cells) !== null && _b2 !== void 0 ? _b2 : [];
        setRefs(Array(cells.length).fill(null).map((_4, idx) => (node) => {
          console.debug(`new ref[${idx}] - attaching to dom...`, node);
          if (node != null)
            cells[idx].attachToDOM(node);
        }));
        setNotebook(nb);
        setLoading(false);
      }, [core, notebook, loading]);
      return {
        ready,
        loading,
        attached,
        executing,
        executed,
        errors,
        notebook,
        cellRefs: refs,
        cellIds: (opts.refsForWidgetsOnly ? (_a = notebook === null || notebook === void 0 ? void 0 : notebook.widgets) !== null && _a !== void 0 ? _a : [] : (_b = notebook === null || notebook === void 0 ? void 0 : notebook.cells) !== null && _b !== void 0 ? _b : []).map((c6) => c6.id),
        executeAll,
        executeSome,
        clear,
        session
      };
    }
    exports.useNotebookFromSource = useNotebookFromSource;
    function useNotebookfromSourceLegacy(sourceCode) {
      const { core } = (0, ThebeLoaderProvider_1.useThebeLoader)();
      const { config } = (0, ThebeServerProvider_1.useThebeConfig)();
      const rendermime = (0, ThebeRenderMimeRegistryProvider_1.useRenderMimeRegistry)();
      if (!rendermime)
        throw new Error("ThebeSessionProvider requires a RenderMimeRegistryProvider");
      const [busy, setBusy] = (0, react_1.useState)(false);
      const [notebook, setNotebook] = (0, react_1.useState)();
      const [_4, setReRender] = (0, react_1.useState)({});
      const [cellRefs] = (0, react_1.useState)(Array(sourceCode.length).fill(void 0).map(() => (0, react_1.createRef)()));
      (0, react_1.useEffect)(() => {
        if (!core || !config || notebook)
          return;
        setNotebook(core.ThebeNotebook.fromCodeBlocks(sourceCode.map((source) => ({ id: core === null || core === void 0 ? void 0 : core.shortId(), source })), config, rendermime));
      }, [core, notebook]);
      const execute = () => {
        if (!notebook)
          throw new Error("execute called before notebook available");
        setBusy(true);
        notebook.executeAll().then(() => {
          setBusy(false);
        });
      };
      const attach = (session) => {
        if (session.kernel == null)
          return;
        if (!notebook) {
          console.warn("attach called before notebook available");
          return;
        }
        notebook === null || notebook === void 0 ? void 0 : notebook.detachSession();
        notebook === null || notebook === void 0 ? void 0 : notebook.attachSession(session);
        notebook === null || notebook === void 0 ? void 0 : notebook.cells.forEach((cell, idx) => {
          var _a;
          if (cellRefs[idx].current)
            cell.attachToDOM((_a = cellRefs[idx].current) !== null && _a !== void 0 ? _a : void 0);
        });
      };
      return {
        notebook,
        busy,
        execute,
        attach,
        cellRefs,
        rerender: () => setReRender({})
      };
    }
    exports.useNotebookfromSourceLegacy = useNotebookfromSourceLegacy;
  }
});

// ../../node_modules/thebe-react/dist/hooks/interpolate.js
var require_interpolate = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/interpolate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interpolatorFactoryFn = exports.PYTHON_PARAM = void 0;
    exports.PYTHON_PARAM = /^(.*)=([^;]*);*\s*#\|*\s*@param\s*(.*)$/;
    function interpolatorFactoryFn(parameterMap) {
      return (source) => {
        const params = new Set(Object.keys(parameterMap));
        const lines = source.split("\n");
        const interpolated = lines.map((line) => {
          if (exports.PYTHON_PARAM.test(line)) {
            const match = line.match(exports.PYTHON_PARAM);
            if (match != null) {
              const [_4, variable, value, schemaString] = match;
              let schema = {};
              try {
                if (schemaString !== "")
                  schema = JSON.parse(schemaString);
              } catch (err) {
                console.error("Could not parse schema from", line, err);
              }
              if (params.has(variable.trim())) {
                return `${variable}= ${parameterMap[variable.trim()]} #| @param${schema ? ` ${JSON.stringify(Object.assign(Object.assign({}, schema), { last: value }))}` : ""}`;
              }
            }
          }
          return line;
        });
        return interpolated.join("\n");
      };
    }
    exports.interpolatorFactoryFn = interpolatorFactoryFn;
  }
});

// ../../node_modules/thebe-react/dist/hooks/index.js
var require_hooks = __commonJS({
  "../../node_modules/thebe-react/dist/hooks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_notebook(), exports);
    tslib_1.__exportStar(require_interpolate(), exports);
  }
});

// ../../node_modules/thebe-react/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/thebe-react/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_OutputAreaByRef(), exports);
    tslib_1.__exportStar(require_ThebeLoaderProvider(), exports);
    tslib_1.__exportStar(require_ThebeServerProvider(), exports);
    tslib_1.__exportStar(require_ThebeSessionProvider(), exports);
    tslib_1.__exportStar(require_ThebeRenderMimeRegistryProvider(), exports);
    tslib_1.__exportStar(require_hooks(), exports);
    var version_1 = require_version();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return tslib_1.__importDefault(version_1).default;
    } });
  }
});

// ../../node_modules/anser/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/anser/lib/index.js"(exports, module) {
    "use strict";
    var _createClass2 = function() {
      function defineProperties(target, props) {
        for (var i6 = 0; i6 < props.length; i6++) {
          var descriptor = props[i6];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];
    var linkRegex = /(https?:\/\/(?:[A-Za-z0-9#;/?:@=+$',_.!~*()[\]-]|&amp;|%[A-Fa-f0-9]{2})+)/gm;
    var Anser2 = function() {
      _createClass2(Anser3, null, [{
        key: "escapeForHtml",
        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
          return new Anser3().escapeForHtml(txt);
        }
        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. You should apply this after you have run `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return new Anser3().linkify(txt);
        }
        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return new Anser3().ansiToHtml(txt, options);
        }
        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          return new Anser3().ansiToJson(txt, options);
        }
        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return new Anser3().ansiToText(txt);
        }
        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */
      }]);
      function Anser3() {
        _classCallCheck2(this, Anser3);
        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
        this.decorations = [];
      }
      _createClass2(Anser3, [{
        key: "setupPalette",
        value: function setupPalette() {
          this.PALETTE_COLORS = [];
          for (var i6 = 0; i6 < 2; ++i6) {
            for (var j2 = 0; j2 < 8; ++j2) {
              this.PALETTE_COLORS.push(ANSI_COLORS[i6][j2].color);
            }
          }
          var levels = [0, 95, 135, 175, 215, 255];
          var format2 = function format3(r5, g5, b3) {
            return levels[r5] + ", " + levels[g5] + ", " + levels[b3];
          };
          var r4 = void 0, g4 = void 0, b2 = void 0;
          for (var _r = 0; _r < 6; ++_r) {
            for (var _g = 0; _g < 6; ++_g) {
              for (var _b = 0; _b < 6; ++_b) {
                this.PALETTE_COLORS.push(format2(_r, _g, _b));
              }
            }
          }
          var level = 8;
          for (var _i = 0; _i < 24; ++_i, level += 10) {
            this.PALETTE_COLORS.push(format2(level, level, level));
          }
        }
        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */
      }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
          return txt.replace(/[&<>\"]/gm, function(str) {
            return str == "&" ? "&amp;" : str == '"' ? "&quot;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
          });
        }
        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */
      }, {
        key: "linkify",
        value: function linkify(txt) {
          return txt.replace(linkRegex, function(str) {
            return '<a href="' + str + '">' + str + "</a>";
          });
        }
        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */
      }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
          return this.process(txt, options, true);
        }
        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */
      }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
          options = options || {};
          options.json = true;
          options.clearLine = false;
          return this.process(txt, options, true);
        }
        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */
      }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
          return this.process(txt, {}, false);
        }
        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */
      }, {
        key: "process",
        value: function process2(txt, options, markup) {
          var _this = this;
          var self2 = this;
          var raw_text_chunks = txt.split(/\033\[/);
          var first_chunk = raw_text_chunks.shift();
          if (options === void 0 || options === null) {
            options = {};
          }
          options.clearLine = /\r/.test(txt);
          var color_chunks = raw_text_chunks.map(function(chunk2) {
            return _this.processChunk(chunk2, options, markup);
          });
          if (options && options.json) {
            var first2 = self2.processChunkJson("");
            first2.content = first_chunk;
            first2.clearLine = options.clearLine;
            color_chunks.unshift(first2);
            if (options.remove_empty) {
              color_chunks = color_chunks.filter(function(c6) {
                return !c6.isEmpty();
              });
            }
            return color_chunks;
          } else {
            color_chunks.unshift(first_chunk);
          }
          return color_chunks.join("");
        }
        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */
      }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {
          options = typeof options == "undefined" ? {} : options;
          var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
          var key = options.key = use_classes ? "class" : "color";
          var result2 = {
            content: text,
            fg: null,
            bg: null,
            fg_truecolor: null,
            bg_truecolor: null,
            isInverted: false,
            clearLine: options.clearLine,
            decoration: null,
            decorations: [],
            was_processed: false,
            isEmpty: function isEmpty2() {
              return !result2.content;
            }
          };
          var matches2 = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
          if (!matches2)
            return result2;
          var orig_txt = result2.content = matches2[4];
          var nums = matches2[2].split(";");
          if (matches2[1] !== "" || matches2[3] !== "m") {
            return result2;
          }
          if (!markup) {
            return result2;
          }
          var self2 = this;
          while (nums.length > 0) {
            var num_str = nums.shift();
            var num = parseInt(num_str);
            if (isNaN(num) || num === 0) {
              self2.fg = self2.bg = null;
              self2.decorations = [];
            } else if (num === 1) {
              self2.decorations.push("bold");
            } else if (num === 2) {
              self2.decorations.push("dim");
            } else if (num === 3) {
              self2.decorations.push("italic");
            } else if (num === 4) {
              self2.decorations.push("underline");
            } else if (num === 5) {
              self2.decorations.push("blink");
            } else if (num === 7) {
              self2.decorations.push("reverse");
            } else if (num === 8) {
              self2.decorations.push("hidden");
            } else if (num === 9) {
              self2.decorations.push("strikethrough");
            } else if (num === 21) {
              self2.removeDecoration("bold");
            } else if (num === 22) {
              self2.removeDecoration("bold");
              self2.removeDecoration("dim");
            } else if (num === 23) {
              self2.removeDecoration("italic");
            } else if (num === 24) {
              self2.removeDecoration("underline");
            } else if (num === 25) {
              self2.removeDecoration("blink");
            } else if (num === 27) {
              self2.removeDecoration("reverse");
            } else if (num === 28) {
              self2.removeDecoration("hidden");
            } else if (num === 29) {
              self2.removeDecoration("strikethrough");
            } else if (num === 39) {
              self2.fg = null;
            } else if (num === 49) {
              self2.bg = null;
            } else if (num >= 30 && num < 38) {
              self2.fg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 90 && num < 98) {
              self2.fg = ANSI_COLORS[1][num % 10][key];
            } else if (num >= 40 && num < 48) {
              self2.bg = ANSI_COLORS[0][num % 10][key];
            } else if (num >= 100 && num < 108) {
              self2.bg = ANSI_COLORS[1][num % 10][key];
            } else if (num === 38 || num === 48) {
              var is_foreground = num === 38;
              if (nums.length >= 1) {
                var mode = nums.shift();
                if (mode === "5" && nums.length >= 1) {
                  var palette_index = parseInt(nums.shift());
                  if (palette_index >= 0 && palette_index <= 255) {
                    if (!use_classes) {
                      if (!this.PALETTE_COLORS) {
                        self2.setupPalette();
                      }
                      if (is_foreground) {
                        self2.fg = this.PALETTE_COLORS[palette_index];
                      } else {
                        self2.bg = this.PALETTE_COLORS[palette_index];
                      }
                    } else {
                      var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                      if (is_foreground) {
                        self2.fg = klass;
                      } else {
                        self2.bg = klass;
                      }
                    }
                  }
                } else if (mode === "2" && nums.length >= 3) {
                  var r4 = parseInt(nums.shift());
                  var g4 = parseInt(nums.shift());
                  var b2 = parseInt(nums.shift());
                  if (r4 >= 0 && r4 <= 255 && g4 >= 0 && g4 <= 255 && b2 >= 0 && b2 <= 255) {
                    var color2 = r4 + ", " + g4 + ", " + b2;
                    if (!use_classes) {
                      if (is_foreground) {
                        self2.fg = color2;
                      } else {
                        self2.bg = color2;
                      }
                    } else {
                      if (is_foreground) {
                        self2.fg = "ansi-truecolor";
                        self2.fg_truecolor = color2;
                      } else {
                        self2.bg = "ansi-truecolor";
                        self2.bg_truecolor = color2;
                      }
                    }
                  }
                }
              }
            }
          }
          if (self2.fg === null && self2.bg === null && self2.decorations.length === 0) {
            return result2;
          } else {
            var styles = [];
            var classes = [];
            var data = {};
            result2.fg = self2.fg;
            result2.bg = self2.bg;
            result2.fg_truecolor = self2.fg_truecolor;
            result2.bg_truecolor = self2.bg_truecolor;
            result2.decorations = self2.decorations;
            result2.decoration = self2.decorations.slice(-1).pop() || null;
            result2.was_processed = true;
            return result2;
          }
        }
        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */
      }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
          var _this2 = this;
          options = options || {};
          var jsonChunk = this.processChunkJson(text, options, markup);
          var use_classes = options.use_classes;
          jsonChunk.decorations = jsonChunk.decorations.filter(function(decoration) {
            if (decoration === "reverse") {
              if (!jsonChunk.fg) {
                jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? "class" : "color"];
              }
              if (!jsonChunk.bg) {
                jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? "class" : "color"];
              }
              var tmpFg = jsonChunk.fg;
              jsonChunk.fg = jsonChunk.bg;
              jsonChunk.bg = tmpFg;
              var tmpFgTrue = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = tmpFgTrue;
              jsonChunk.isInverted = true;
              return false;
            }
            return true;
          });
          if (options.json) {
            return jsonChunk;
          }
          if (jsonChunk.isEmpty()) {
            return "";
          }
          if (!jsonChunk.was_processed) {
            return jsonChunk.content;
          }
          var colors = [];
          var decorations = [];
          var textDecorations = [];
          var data = {};
          var render_data = function render_data2(data2) {
            var fragments = [];
            var key = void 0;
            for (key in data2) {
              if (data2.hasOwnProperty(key)) {
                fragments.push("data-" + key + '="' + _this2.escapeForHtml(data2[key]) + '"');
              }
            }
            return fragments.length > 0 ? " " + fragments.join(" ") : "";
          };
          if (jsonChunk.isInverted) {
            data["ansi-is-inverted"] = "true";
          }
          if (jsonChunk.fg) {
            if (use_classes) {
              colors.push(jsonChunk.fg + "-fg");
              if (jsonChunk.fg_truecolor !== null) {
                data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                jsonChunk.fg_truecolor = null;
              }
            } else {
              colors.push("color:rgb(" + jsonChunk.fg + ")");
            }
          }
          if (jsonChunk.bg) {
            if (use_classes) {
              colors.push(jsonChunk.bg + "-bg");
              if (jsonChunk.bg_truecolor !== null) {
                data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                jsonChunk.bg_truecolor = null;
              }
            } else {
              colors.push("background-color:rgb(" + jsonChunk.bg + ")");
            }
          }
          jsonChunk.decorations.forEach(function(decoration) {
            if (use_classes) {
              decorations.push("ansi-" + decoration);
              return;
            }
            if (decoration === "bold") {
              decorations.push("font-weight:bold");
            } else if (decoration === "dim") {
              decorations.push("opacity:0.5");
            } else if (decoration === "italic") {
              decorations.push("font-style:italic");
            } else if (decoration === "hidden") {
              decorations.push("visibility:hidden");
            } else if (decoration === "strikethrough") {
              textDecorations.push("line-through");
            } else {
              textDecorations.push(decoration);
            }
          });
          if (textDecorations.length) {
            decorations.push("text-decoration:" + textDecorations.join(" "));
          }
          if (use_classes) {
            return '<span class="' + colors.concat(decorations).join(" ") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          } else {
            return '<span style="' + colors.concat(decorations).join(";") + '"' + render_data(data) + ">" + jsonChunk.content + "</span>";
          }
        }
      }, {
        key: "removeDecoration",
        value: function removeDecoration(decoration) {
          var index2 = this.decorations.indexOf(decoration);
          if (index2 >= 0) {
            this.decorations.splice(index2, 1);
          }
        }
      }]);
      return Anser3;
    }();
    module.exports = Anser2;
  }
});

// ../../node_modules/escape-carriage/index.js
var require_escape_carriage = __commonJS({
  "../../node_modules/escape-carriage/index.js"(exports, module) {
    function escapeCarriageReturn2(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      txt = txt.replace(/\r+\n/gm, "\n");
      while (/\r./.test(txt)) {
        txt = txt.replace(/^([^\r\n]*)\r+([^\r\n]+)/gm, function(_4, base, insert) {
          return insert + base.slice(insert.length);
        });
      }
      return txt;
    }
    function findLongestString(arr) {
      var longest = 0;
      for (var i6 = 0; i6 < arr.length; i6++) {
        if (arr[longest].length <= arr[i6].length) {
          longest = i6;
        }
      }
      return longest;
    }
    function escapeSingleLineSafe(txt) {
      if (!/\r/.test(txt))
        return txt;
      var arr = txt.split("\r");
      var res = [];
      while (arr.length > 0) {
        var longest = findLongestString(arr);
        res.push(arr[longest]);
        arr = arr.slice(longest + 1);
      }
      return res.join("\r");
    }
    function escapeCarriageReturnSafe(txt) {
      if (!txt)
        return "";
      if (!/\r/.test(txt))
        return txt;
      if (!/\n/.test(txt))
        return escapeSingleLineSafe(txt);
      txt = txt.replace(/\r+\n/gm, "\n");
      var idx = txt.lastIndexOf("\n");
      return escapeCarriageReturn2(txt.slice(0, idx)) + "\n" + escapeSingleLineSafe(txt.slice(idx + 1));
    }
    module.exports = escapeCarriageReturn2;
    module.exports.escapeCarriageReturn = escapeCarriageReturn2;
    module.exports.escapeCarriageReturnSafe = escapeCarriageReturnSafe;
  }
});

// ../../packages/providers/dist/hooks.js
var import_react = __toESM(require_react(), 1);
function useMediaQuery(query) {
  const ssr = typeof document === "undefined";
  const getMatches = (match) => {
    if (ssr)
      return false;
    return window.matchMedia(match).matches;
  };
  const [matches2, setMatches] = (0, import_react.useState)(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  (0, import_react.useEffect)(() => {
    if (ssr)
      return;
    const matchMedia = window.matchMedia(query);
    handleChange();
    matchMedia.addEventListener("change", handleChange);
    return () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]);
  return matches2;
}

// ../../packages/providers/dist/theme.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// ../../packages/providers/dist/renderers.js
function validateRenderers(renderers2) {
  if (!renderers2)
    return {};
  const validatedRenderers = {};
  for (const key in renderers2) {
    const renderer = renderers2[key];
    if (typeof renderer === "function") {
      validatedRenderers[key] = { base: renderer };
    } else if (typeof renderer === "object" && "base" in renderer) {
      validatedRenderers[key] = renderer;
    } else {
      throw new Error(`Renderer for "${key}" must be either a function or an object containing a "base" renderer.`);
    }
  }
  return validatedRenderers;
}
function mergeRenderers(renderers2, validate) {
  const mergedRenderers = {};
  for (const renderersObj of renderers2) {
    for (const key in renderersObj) {
      const next = typeof renderersObj[key] === "function" ? { base: renderersObj[key] } : renderersObj[key];
      mergedRenderers[key] = Object.assign(Object.assign({}, mergedRenderers[key]), next);
    }
  }
  if (validate)
    return validateRenderers(mergedRenderers);
  return mergedRenderers;
}

// ../../node_modules/nbtx/dist/esm/minify/utils.js
function walkOutputs(outputs, func) {
  outputs.forEach((output) => {
    if ("data" in output && output.data) {
      Object.entries(output.data).forEach(([, bundle]) => {
        func(bundle);
      });
    } else {
      func(output);
    }
  });
}
function ensureString(maybeString, joinWith = "") {
  if (!maybeString)
    return "";
  if (typeof maybeString === "string")
    return maybeString;
  if (maybeString.join)
    return maybeString.join(joinWith);
  return maybeString;
}

// ../../node_modules/nbtx/dist/esm/minify/convert.js
var __rest2 = function(s8, e3) {
  var t11 = {};
  for (var p3 in s8)
    if (Object.prototype.hasOwnProperty.call(s8, p3) && e3.indexOf(p3) < 0)
      t11[p3] = s8[p3];
  if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p3 = Object.getOwnPropertySymbols(s8); i6 < p3.length; i6++) {
      if (e3.indexOf(p3[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p3[i6]))
        t11[p3[i6]] = s8[p3[i6]];
    }
  return t11;
};
function convertToIOutputs(minified, outputCache) {
  return minified.map((m5) => {
    switch (m5.output_type) {
      case "stream": {
        const { hash } = m5, rest2 = __rest2(m5, ["hash"]);
        if (hash && outputCache[hash]) {
          return Object.assign(Object.assign({}, rest2), { text: outputCache[hash][0] });
        }
        return rest2;
      }
      case "error": {
        const { hash, traceback } = m5, rest2 = __rest2(m5, ["hash", "traceback"]);
        if (hash && outputCache[hash]) {
          return Object.assign(Object.assign({}, rest2), { traceback: [outputCache[hash][0]] });
        }
        return Object.assign(Object.assign({}, rest2), { traceback: [traceback] });
      }
      default: {
        return Object.assign(Object.assign({}, m5), { data: Object.entries(m5.data).reduce((acc, [mimetype, payload]) => {
          let { content } = payload;
          const { hash } = payload;
          if (hash && outputCache[hash]) {
            [content] = outputCache[hash];
          }
          if (content && mimetype !== "application/javascript" && mimetype.startsWith("application/")) {
            try {
              content = JSON.parse(content);
            } catch (e3) {
              console.debug(`${mimetype} is not json parsable, leaving as is`);
            }
          }
          if (content && mimetype.startsWith("image/") && !mimetype.startsWith("image/svg") && content.startsWith("data:") && content.includes(";base64,")) {
            const [data] = content.split(";base64,").reverse();
            content = data;
          }
          if (!content)
            return acc;
          return Object.assign(Object.assign({}, acc), { [mimetype]: content });
        }, {}) });
      }
    }
  });
}

// ../../node_modules/nbtx/dist/esm/types.js
var KnownCellOutputMimeTypes;
(function(KnownCellOutputMimeTypes2) {
  KnownCellOutputMimeTypes2["TextPlain"] = "text/plain";
  KnownCellOutputMimeTypes2["TextHtml"] = "text/html";
  KnownCellOutputMimeTypes2["TextLatex"] = "text/latex";
  KnownCellOutputMimeTypes2["ImagePng"] = "image/png";
  KnownCellOutputMimeTypes2["ImageBmp"] = "image/bmp";
  KnownCellOutputMimeTypes2["ImageJpeg"] = "image/jpeg";
  KnownCellOutputMimeTypes2["ImageSvg"] = "image/svg+xml";
  KnownCellOutputMimeTypes2["ImageGif"] = "image/gif";
  KnownCellOutputMimeTypes2["AppJson"] = "application/json";
  KnownCellOutputMimeTypes2["AppGeoJson"] = "application/geo+json";
  KnownCellOutputMimeTypes2["AppPlotly"] = "application/vnd.plotly.v1+json";
  KnownCellOutputMimeTypes2["AppVega"] = "application/vnd.vega.v5+json";
  KnownCellOutputMimeTypes2["AppVegaLite"] = "application/vnd.vegalite.v3+json";
  KnownCellOutputMimeTypes2["AppVirtualDom"] = "application/vdom.v1+json";
  KnownCellOutputMimeTypes2["AppJavascript"] = "application/javascript";
  KnownCellOutputMimeTypes2["AppWidgetView"] = "application/vnd.jupyter.widget-view+json";
  KnownCellOutputMimeTypes2["AppWidgetState"] = "application/vnd.jupyter.widget-state+json";
  KnownCellOutputMimeTypes2["AppBokehLoad"] = "application/vnd.bokehjs_load.v0+json";
  KnownCellOutputMimeTypes2["AppBokehExec"] = "application/vnd.bokehjs_exec.v0+json";
})(KnownCellOutputMimeTypes || (KnownCellOutputMimeTypes = {}));
var CELL_TYPES;
(function(CELL_TYPES2) {
  CELL_TYPES2["raw"] = "raw";
  CELL_TYPES2["markdown"] = "markdown";
  CELL_TYPES2["code"] = "code";
})(CELL_TYPES || (CELL_TYPES = {}));

// ../../packages/common/dist/utils.js
function getProject(config, projectSlug) {
  var _a, _b;
  if (!config)
    return void 0;
  if (!config.projects || config.projects.length === 0)
    return void 0;
  if (!projectSlug)
    return config.projects[0];
  const project = (_b = (_a = config.projects) === null || _a === void 0 ? void 0 : _a.find((p3) => p3.slug === projectSlug)) !== null && _b !== void 0 ? _b : config.projects[0];
  return project;
}
function getProjectHeadings(config, projectSlug, opts = { addGroups: false }) {
  const project = getProject(config, projectSlug);
  if (!project)
    return void 0;
  const headings = [
    {
      title: project.title,
      short_title: project.short_title,
      slug: project.index,
      path: project.slug ? `/${project.slug}` : "/",
      level: "index",
      enumerator: project.enumerator
    },
    ...project.pages.map((p3) => {
      if (!("slug" in p3))
        return p3;
      const slug = slugToUrl(p3.slug);
      return {
        ...p3,
        path: projectSlug && project.slug ? `/${project.slug}/${slug}` : `/${slug}`
      };
    })
  ];
  if (opts.addGroups) {
    let lastTitle = project.short_title || project.title;
    return headings.map((heading) => {
      if (!heading.slug || heading.level === "index") {
        lastTitle = heading.short_title || heading.title;
      }
      return { ...heading, group: lastTitle };
    });
  }
  return headings;
}

// ../../packages/common/dist/types.js
var Theme;
(function(Theme2) {
  Theme2["light"] = "light";
  Theme2["dark"] = "dark";
})(Theme || (Theme = {}));
var ErrorStatus;
(function(ErrorStatus2) {
  ErrorStatus2["noSite"] = "Site was not found";
  ErrorStatus2["noArticle"] = "Article was not found";
})(ErrorStatus || (ErrorStatus = {}));

// ../../packages/common/dist/index.js
var MYST_SPEC_VERSION = 3;

// ../../packages/providers/dist/theme.js
var __rest3 = function(s8, e3) {
  var t11 = {};
  for (var p3 in s8)
    if (Object.prototype.hasOwnProperty.call(s8, p3) && e3.indexOf(p3) < 0)
      t11[p3] = s8[p3];
  if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p3 = Object.getOwnPropertySymbols(s8); i6 < p3.length; i6++) {
      if (e3.indexOf(p3[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p3[i6]))
        t11[p3[i6]] = s8[p3[i6]];
    }
  return t11;
};
function HtmlLink(_a) {
  var { to, className, children, prefetch } = _a, props = __rest3(_a, ["to", "className", "children", "prefetch"]);
  return (0, import_jsx_runtime.jsx)("a", Object.assign({ href: to, className }, props, { children }));
}
function HtmlNavLink(_a) {
  var { to, className, children, prefetch } = _a, props = __rest3(_a, ["to", "className", "children", "prefetch"]);
  const staticClass = typeof className === "function" ? className({ isActive: false }) : className;
  return (0, import_jsx_runtime.jsx)("a", Object.assign({ href: to, className: staticClass }, props, { children }));
}
function isTheme(value) {
  return typeof value === "string" && Object.values(Theme).includes(value);
}
var ThemeContext = import_react2.default.createContext(void 0);
ThemeContext.displayName = "ThemeContext";
function ThemeProvider({ theme, setTheme, children, renderers: renderers2, Link: Link2, NavLink: NavLink2, navigate, top }) {
  const validatedRenderers = validateRenderers(renderers2);
  return (0, import_jsx_runtime.jsx)(ThemeContext.Provider, { value: { theme, setTheme, renderers: validatedRenderers, Link: Link2, NavLink: NavLink2, navigate, top }, children });
}
function useThemeSwitcher() {
  const context = import_react2.default.useContext(ThemeContext);
  if (context === void 0) {
    const error = "useThemeSwitcher should be used within a ThemeProvider";
    const throwError = () => {
      throw new Error(error);
    };
    console.error(error);
    return {
      theme: Theme.light,
      isLight: true,
      isDark: false,
      setTheme: throwError,
      nextTheme: throwError
    };
  }
  const { theme, setTheme } = context;
  const isDark = theme === Theme.dark;
  const isLight = theme === Theme.light;
  const nextTheme = import_react2.default.useCallback(() => {
    const next = theme === Theme.light ? Theme.dark : Theme.light;
    setTheme(next);
  }, [theme]);
  return { theme, isLight, isDark, setTheme, nextTheme };
}
function useNodeRenderers() {
  const context = import_react2.default.useContext(ThemeContext);
  const { renderers: renderers2 } = context !== null && context !== void 0 ? context : {};
  return renderers2 !== null && renderers2 !== void 0 ? renderers2 : {};
}
function useLinkProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { Link: Link2 } = context !== null && context !== void 0 ? context : {};
  return Link2 !== null && Link2 !== void 0 ? Link2 : HtmlLink;
}
function useNavLinkProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { NavLink: NavLink2 } = context !== null && context !== void 0 ? context : {};
  return NavLink2 !== null && NavLink2 !== void 0 ? NavLink2 : HtmlNavLink;
}
function useNavigateProvider() {
  const context = import_react2.default.useContext(ThemeContext);
  const { navigate } = context !== null && context !== void 0 ? context : {};
  return navigate !== null && navigate !== void 0 ? navigate : (to) => {
    window.location.href = to;
  };
}
function useThemeTop() {
  const context = import_react2.default.useContext(ThemeContext);
  const { top } = context !== null && context !== void 0 ? context : {};
  return top || 0;
}

// ../../packages/providers/dist/grid.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var Context = import_react3.default.createContext(void 0);
Context.displayName = "GridSystemContext";
function GridSystemProvider({ children, gridSystem }) {
  return (0, import_jsx_runtime2.jsx)(Context.Provider, { value: { gridSystem }, children });
}
function useGridSystemProvider() {
  const context = import_react3.default.useContext(Context);
  const { gridSystem } = context !== null && context !== void 0 ? context : {};
  return gridSystem || "article-grid";
}

// ../../packages/providers/dist/article.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var ArticleContext = import_react4.default.createContext({});
function ArticleProvider({ kind, references, frontmatter, children }) {
  return (0, import_jsx_runtime3.jsx)(ArticleContext.Provider, { value: { kind, references, frontmatter }, children });
}
function useReferences() {
  const data = (0, import_react4.useContext)(ArticleContext);
  return data === null || data === void 0 ? void 0 : data.references;
}
function useFrontmatter() {
  const data = (0, import_react4.useContext)(ArticleContext);
  return data === null || data === void 0 ? void 0 : data.frontmatter;
}
function usePageKind() {
  var _a;
  const data = (0, import_react4.useContext)(ArticleContext);
  return (_a = data === null || data === void 0 ? void 0 : data.kind) !== null && _a !== void 0 ? _a : SourceFileKind.Article;
}

// ../../packages/providers/dist/baseurl.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var BaseUrlContext = import_react5.default.createContext({});
function BaseUrlProvider({ baseurl, children }) {
  return (0, import_jsx_runtime4.jsx)(BaseUrlContext.Provider, { value: { baseurl }, children });
}
function useBaseurl() {
  const data = (0, import_react5.useContext)(BaseUrlContext);
  return data === null || data === void 0 ? void 0 : data.baseurl;
}
function withBaseurl(url, baseurl) {
  const isExternal = /^(https?|mailto):/.test(url || "");
  if (!baseurl || isExternal) {
    return url;
  }
  return baseurl + url;
}

// ../../packages/providers/dist/ui.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var UiContext = (0, import_react6.createContext)(void 0);
function UiStateProvider({ children }) {
  const wide = useMediaQuery("(min-width: 1280px)");
  const [state, setState] = (0, import_react6.useState)({ isNavOpen: false });
  (0, import_react6.useEffect)(() => {
    if (wide)
      setState(Object.assign(Object.assign({}, state), { isNavOpen: false, isWide: wide }));
  }, [wide]);
  return (0, import_jsx_runtime5.jsx)(UiContext.Provider, { value: [state, setState], children });
}
function useNavOpen() {
  var _a, _b;
  const [state, setState] = (_a = (0, import_react6.useContext)(UiContext)) !== null && _a !== void 0 ? _a : [];
  const setOpen = (open) => {
    if (open === (state === null || state === void 0 ? void 0 : state.isNavOpen))
      return;
    setState === null || setState === void 0 ? void 0 : setState(Object.assign(Object.assign({}, state), { isNavOpen: open }));
  };
  return [(_b = state === null || state === void 0 ? void 0 : state.isNavOpen) !== null && _b !== void 0 ? _b : false, setOpen];
}
function useIsWide() {
  var _a, _b;
  const [state] = (_a = (0, import_react6.useContext)(UiContext)) !== null && _a !== void 0 ? _a : [];
  return (_b = state === null || state === void 0 ? void 0 : state.isWide) !== null && _b !== void 0 ? _b : false;
}

// ../../packages/providers/dist/site.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var SiteContext = import_react7.default.createContext(void 0);
function SiteProvider({ config, children }) {
  return (0, import_jsx_runtime6.jsx)(SiteContext.Provider, { value: config, children });
}
function useSiteManifest() {
  const config = (0, import_react7.useContext)(SiteContext);
  return config;
}

// ../../packages/providers/dist/search.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var SearchFactoryContext = import_react8.default.createContext(void 0);
function SearchFactoryProvider({ factory, children }) {
  return (0, import_jsx_runtime7.jsx)(SearchFactoryContext.Provider, { value: factory, children });
}
function useSearchFactory() {
  const config = (0, import_react8.useContext)(SearchFactoryContext);
  return config;
}

// ../../packages/providers/dist/tabs.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var TabContext = (0, import_react9.createContext)(void 0);
function TabStateProvider({ children }) {
  const [state, setState] = (0, import_react9.useState)("");
  return (0, import_jsx_runtime8.jsx)(TabContext.Provider, { value: [state, setState], children });
}
function useTabSet() {
  return (0, import_react9.useContext)(TabContext);
}

// ../../packages/providers/dist/xref.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var XRefContext = (0, import_react10.createContext)(void 0);
function useXRefState() {
  var _a;
  const state = (_a = (0, import_react10.useContext)(XRefContext)) !== null && _a !== void 0 ? _a : { inCrossRef: false, remote: false };
  return state;
}
function XRefProvider({ remote, url, dataUrl, remoteBaseUrl, children }) {
  const parent = useXRefState();
  const value = {
    inCrossRef: true,
    remote: remote !== null && remote !== void 0 ? remote : parent.remote,
    url: url !== null && url !== void 0 ? url : parent.url,
    dataUrl: dataUrl !== null && dataUrl !== void 0 ? dataUrl : parent.dataUrl,
    remoteBaseUrl: remoteBaseUrl !== null && remoteBaseUrl !== void 0 ? remoteBaseUrl : parent.remoteBaseUrl
  };
  if (value.remote && !value.url) {
    value.remote = false;
  }
  return (0, import_jsx_runtime9.jsx)(XRefContext.Provider, { value, children });
}

// ../../packages/providers/dist/project.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var ProjectContext = import_react11.default.createContext(void 0);
function ProjectProvider({ project, children }) {
  var _a;
  const config = useSiteManifest();
  return (0, import_jsx_runtime10.jsx)(ProjectContext.Provider, { value: project !== null && project !== void 0 ? project : (_a = config === null || config === void 0 ? void 0 : config.projects) === null || _a === void 0 ? void 0 : _a[0], children });
}
function useProjectManifest() {
  const config = (0, import_react11.useContext)(ProjectContext);
  return config;
}

// ../../packages/providers/dist/banner.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var BannerStateContext = (0, import_react12.createContext)(void 0);
function BannerStateProvider({ children }) {
  const [bannerState, setBannerState] = (0, import_react12.useState)({ visible: void 0, height: 0 });
  const value = (0, import_react12.useMemo)(() => ({ bannerState, setBannerState }), [bannerState]);
  return (0, import_jsx_runtime11.jsx)(BannerStateContext.Provider, { value, children });
}
function useBannerState() {
  const ctx = (0, import_react12.useContext)(BannerStateContext);
  if (!ctx) {
    throw new Error("useBannerState must be used from within BannerStateProvider");
  }
  return ctx;
}

// ../../packages/myst-to-react/dist/basic.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);

// ../../packages/myst-to-react/dist/hashLink.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_classnames = __toESM(require_classnames(), 1);
function openDetails(el) {
  if (!el)
    return;
  if (el.nodeName === "DETAILS") {
    el.open = true;
  }
  openDetails(el.parentElement);
}
function scrollToElement(el, { htmlId = el === null || el === void 0 ? void 0 : el.id, scrollBehavior = "smooth", historyState = "replace", focusTarget = true } = {}) {
  if (!el)
    return;
  openDetails(el);
  el.scrollIntoView({ behavior: scrollBehavior });
  if (historyState === "push") {
    history.pushState(void 0, "", `#${htmlId}`);
  } else if (historyState === "replace") {
    history.replaceState(void 0, "", `#${htmlId}`);
  }
  if (focusTarget) {
    if (el.tabIndex === -1)
      el.tabIndex = -1;
    el.focus({ preventScroll: true });
  }
}
function HashLink({ id, kind, title = `Link to this ${kind}`, children = "\xB6", canSelectText = false, hover, className = "font-normal", hideInPopup, scrollBehavior, historyState, focusTarget, noWidth }) {
  const { inCrossRef } = useXRefState();
  if (inCrossRef || !id) {
    return hideInPopup ? null : (0, import_jsx_runtime12.jsx)("span", { className: (0, import_classnames.default)("select-none", className), children });
  }
  const scroll = (evt) => {
    evt.preventDefault();
    const el = document.getElementById(id);
    scrollToElement(el, { scrollBehavior, historyState, focusTarget });
  };
  return (0, import_jsx_runtime12.jsx)("a", { className: (0, import_classnames.default)("no-underline text-inherit hover:text-inherit", { "inline-block w-0 px-0 translate-x-[10px]": noWidth === true }, className, {
    "select-none": !canSelectText,
    "transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70": hover === true,
    "[@media(hover:hover)]:transition-opacity [@media(hover:hover)]:opacity-0 [@media(hover:hover)]:focus:opacity-100 [@media(hover:hover)]:group-hover:opacity-70": hover === "desktop",
    "hover:underline": !hover
  }), onClick: scroll, href: `#${id}`, title, "aria-label": title, children });
}

// ../../packages/myst-to-react/dist/basic.js
var import_classnames5 = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/components/CopyIcon.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowDownTrayIcon.js
var React8 = __toESM(require_react(), 1);
function ArrowDownTrayIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React8.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React8.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React8.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
  }));
}
var ForwardRef = /* @__PURE__ */ React8.forwardRef(ArrowDownTrayIcon);
var ArrowDownTrayIcon_default = ForwardRef;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowLeftIcon.js
var React9 = __toESM(require_react(), 1);
function ArrowLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React9.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React9.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React9.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
  }));
}
var ForwardRef2 = /* @__PURE__ */ React9.forwardRef(ArrowLeftIcon);
var ArrowLeftIcon_default = ForwardRef2;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowRightCircleIcon.js
var React10 = __toESM(require_react(), 1);
function ArrowRightCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React10.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React10.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React10.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m12.75 15 3-3m0 0-3-3m3 3h-7.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
var ForwardRef3 = /* @__PURE__ */ React10.forwardRef(ArrowRightCircleIcon);
var ArrowRightCircleIcon_default = ForwardRef3;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowRightIcon.js
var React11 = __toESM(require_react(), 1);
function ArrowRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React11.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React11.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React11.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"
  }));
}
var ForwardRef4 = /* @__PURE__ */ React11.forwardRef(ArrowRightIcon);
var ArrowRightIcon_default = ForwardRef4;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowTopRightOnSquareIcon.js
var React12 = __toESM(require_react(), 1);
function ArrowTopRightOnSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React12.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React12.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React12.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"
  }));
}
var ForwardRef5 = /* @__PURE__ */ React12.forwardRef(ArrowTopRightOnSquareIcon);
var ArrowTopRightOnSquareIcon_default = ForwardRef5;

// ../../node_modules/@heroicons/react/24/outline/esm/ArrowUturnLeftIcon.js
var React13 = __toESM(require_react(), 1);
function ArrowUturnLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React13.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React13.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React13.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3"
  }));
}
var ForwardRef6 = /* @__PURE__ */ React13.forwardRef(ArrowUturnLeftIcon);
var ArrowUturnLeftIcon_default = ForwardRef6;

// ../../node_modules/@heroicons/react/24/outline/esm/BoltIcon.js
var React14 = __toESM(require_react(), 1);
function BoltIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React14.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React14.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React14.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m3.75 13.5 10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75Z"
  }));
}
var ForwardRef7 = /* @__PURE__ */ React14.forwardRef(BoltIcon);
var BoltIcon_default = ForwardRef7;

// ../../node_modules/@heroicons/react/24/outline/esm/CheckCircleIcon.js
var React15 = __toESM(require_react(), 1);
function CheckCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React15.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React15.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React15.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
var ForwardRef8 = /* @__PURE__ */ React15.forwardRef(CheckCircleIcon);
var CheckCircleIcon_default = ForwardRef8;

// ../../node_modules/@heroicons/react/24/outline/esm/CheckIcon.js
var React16 = __toESM(require_react(), 1);
function CheckIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React16.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React16.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React16.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m4.5 12.75 6 6 9-13.5"
  }));
}
var ForwardRef9 = /* @__PURE__ */ React16.forwardRef(CheckIcon);
var CheckIcon_default = ForwardRef9;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentArrowDownIcon.js
var React17 = __toESM(require_react(), 1);
function DocumentArrowDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React17.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React17.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React17.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m.75 12 3 3m0 0 3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
  }));
}
var ForwardRef10 = /* @__PURE__ */ React17.forwardRef(DocumentArrowDownIcon);
var DocumentArrowDownIcon_default = ForwardRef10;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentDuplicateIcon.js
var React18 = __toESM(require_react(), 1);
function DocumentDuplicateIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React18.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React18.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React18.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"
  }));
}
var ForwardRef11 = /* @__PURE__ */ React18.forwardRef(DocumentDuplicateIcon);
var DocumentDuplicateIcon_default = ForwardRef11;

// ../../node_modules/@heroicons/react/24/outline/esm/DocumentIcon.js
var React19 = __toESM(require_react(), 1);
function DocumentIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React19.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React19.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React19.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
  }));
}
var ForwardRef12 = /* @__PURE__ */ React19.forwardRef(DocumentIcon);
var DocumentIcon_default = ForwardRef12;

// ../../node_modules/@heroicons/react/24/outline/esm/ExclamationCircleIcon.js
var React20 = __toESM(require_react(), 1);
function ExclamationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React20.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React20.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React20.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"
  }));
}
var ForwardRef13 = /* @__PURE__ */ React20.forwardRef(ExclamationCircleIcon);
var ExclamationCircleIcon_default = ForwardRef13;

// ../../node_modules/@heroicons/react/24/outline/esm/ExclamationTriangleIcon.js
var React21 = __toESM(require_react(), 1);
function ExclamationTriangleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React21.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React21.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React21.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
  }));
}
var ForwardRef14 = /* @__PURE__ */ React21.forwardRef(ExclamationTriangleIcon);
var ExclamationTriangleIcon_default = ForwardRef14;

// ../../node_modules/@heroicons/react/24/outline/esm/InformationCircleIcon.js
var React22 = __toESM(require_react(), 1);
function InformationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React22.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React22.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React22.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
  }));
}
var ForwardRef15 = /* @__PURE__ */ React22.forwardRef(InformationCircleIcon);
var InformationCircleIcon_default = ForwardRef15;

// ../../node_modules/@heroicons/react/24/outline/esm/LightBulbIcon.js
var React23 = __toESM(require_react(), 1);
function LightBulbIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React23.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React23.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React23.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18"
  }));
}
var ForwardRef16 = /* @__PURE__ */ React23.forwardRef(LightBulbIcon);
var LightBulbIcon_default = ForwardRef16;

// ../../node_modules/@heroicons/react/24/outline/esm/LinkIcon.js
var React24 = __toESM(require_react(), 1);
function LinkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React24.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React24.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React24.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244"
  }));
}
var ForwardRef17 = /* @__PURE__ */ React24.forwardRef(LinkIcon);
var LinkIcon_default = ForwardRef17;

// ../../node_modules/@heroicons/react/24/outline/esm/MegaphoneIcon.js
var React25 = __toESM(require_react(), 1);
function MegaphoneIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React25.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React25.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React25.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.34 15.84c-.688-.06-1.386-.09-2.09-.09H7.5a4.5 4.5 0 1 1 0-9h.75c.704 0 1.402-.03 2.09-.09m0 9.18c.253.962.584 1.892.985 2.783.247.55.06 1.21-.463 1.511l-.657.38c-.551.318-1.26.117-1.527-.461a20.845 20.845 0 0 1-1.44-4.282m3.102.069a18.03 18.03 0 0 1-.59-4.59c0-1.586.205-3.124.59-4.59m0 9.18a23.848 23.848 0 0 1 8.835 2.535M10.34 6.66a23.847 23.847 0 0 0 8.835-2.535m0 0A23.74 23.74 0 0 0 18.795 3m.38 1.125a23.91 23.91 0 0 1 1.014 5.395m-1.014 8.855c-.118.38-.245.754-.38 1.125m.38-1.125a23.91 23.91 0 0 0 1.014-5.395m0-3.46c.495.413.811 1.035.811 1.73 0 .695-.316 1.317-.811 1.73m0-3.46a24.347 24.347 0 0 1 0 3.46"
  }));
}
var ForwardRef18 = /* @__PURE__ */ React25.forwardRef(MegaphoneIcon);
var MegaphoneIcon_default = ForwardRef18;

// ../../node_modules/@heroicons/react/24/outline/esm/MinusCircleIcon.js
var React26 = __toESM(require_react(), 1);
function MinusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React26.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React26.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React26.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15 12H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
var ForwardRef19 = /* @__PURE__ */ React26.forwardRef(MinusCircleIcon);
var MinusCircleIcon_default = ForwardRef19;

// ../../node_modules/@heroicons/react/24/outline/esm/PencilSquareIcon.js
var React27 = __toESM(require_react(), 1);
function PencilSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React27.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React27.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React27.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10"
  }));
}
var ForwardRef20 = /* @__PURE__ */ React27.forwardRef(PencilSquareIcon);
var PencilSquareIcon_default = ForwardRef20;

// ../../node_modules/@heroicons/react/24/outline/esm/PlayCircleIcon.js
var React28 = __toESM(require_react(), 1);
function PlayCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React28.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React28.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React28.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }), /* @__PURE__ */ React28.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.91 11.672a.375.375 0 0 1 0 .656l-5.603 3.113a.375.375 0 0 1-.557-.328V8.887c0-.286.307-.466.557-.327l5.603 3.112Z"
  }));
}
var ForwardRef21 = /* @__PURE__ */ React28.forwardRef(PlayCircleIcon);
var PlayCircleIcon_default = ForwardRef21;

// ../../node_modules/@heroicons/react/24/outline/esm/PlusCircleIcon.js
var React29 = __toESM(require_react(), 1);
function PlusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React29.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React29.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React29.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
var ForwardRef22 = /* @__PURE__ */ React29.forwardRef(PlusCircleIcon);
var PlusCircleIcon_default = ForwardRef22;

// ../../node_modules/@heroicons/react/24/outline/esm/PowerIcon.js
var React30 = __toESM(require_react(), 1);
function PowerIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React30.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React30.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React30.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M5.636 5.636a9 9 0 1 0 12.728 0M12 3v9"
  }));
}
var ForwardRef23 = /* @__PURE__ */ React30.forwardRef(PowerIcon);
var PowerIcon_default = ForwardRef23;

// ../../node_modules/@heroicons/react/24/outline/esm/ScaleIcon.js
var React31 = __toESM(require_react(), 1);
function ScaleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React31.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React31.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React31.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 3v17.25m0 0c-1.472 0-2.882.265-4.185.75M12 20.25c1.472 0 2.882.265 4.185.75M18.75 4.97A48.416 48.416 0 0 0 12 4.5c-2.291 0-4.545.16-6.75.47m13.5 0c1.01.143 2.01.317 3 .52m-3-.52 2.62 10.726c.122.499-.106 1.028-.589 1.202a5.988 5.988 0 0 1-2.031.352 5.988 5.988 0 0 1-2.031-.352c-.483-.174-.711-.703-.59-1.202L18.75 4.971Zm-16.5.52c.99-.203 1.99-.377 3-.52m0 0 2.62 10.726c.122.499-.106 1.028-.589 1.202a5.989 5.989 0 0 1-2.031.352 5.989 5.989 0 0 1-2.031-.352c-.483-.174-.711-.703-.59-1.202L5.25 4.971Z"
  }));
}
var ForwardRef24 = /* @__PURE__ */ React31.forwardRef(ScaleIcon);
var ScaleIcon_default = ForwardRef24;

// ../../node_modules/@heroicons/react/24/outline/esm/SunIcon.js
var React32 = __toESM(require_react(), 1);
function SunIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React32.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React32.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React32.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"
  }));
}
var ForwardRef25 = /* @__PURE__ */ React32.forwardRef(SunIcon);
var SunIcon_default = ForwardRef25;

// ../../packages/myst-to-react/dist/components/CopyIcon.js
var import_react13 = __toESM(require_react(), 1);
var import_classnames2 = __toESM(require_classnames(), 1);
function CopyIcon({ text, className }) {
  const [copied, setCopied] = (0, import_react13.useState)(false);
  const onClick = () => {
    if (copied)
      return;
    navigator.clipboard.writeText(text).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 3e3);
    });
  };
  return (0, import_jsx_runtime13.jsx)("button", { title: copied ? "Copied!!" : "Copy to Clipboard", className: (0, import_classnames2.default)("inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2", "transition-color duration-200 ease-in-out", {
    "text-blue-400 hover:text-blue-500": !copied,
    "text-green-500 hover:text-green-500": copied
  }, className), onClick, "aria-pressed": copied ? "true" : "false", "aria-label": "Copy code to clipboard", children: copied ? (0, import_jsx_runtime13.jsx)(CheckIcon_default, { width: 24, height: 24, className: "text-success" }) : (0, import_jsx_runtime13.jsx)(DocumentDuplicateIcon_default, { width: 24, height: 24 }) });
}

// ../../packages/myst-to-react/dist/components/HoverPopover.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-hover-card/dist/index.mjs
var React48 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}

// ../../node_modules/@radix-ui/react-context/dist/index.mjs
var React33 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function createContext22(rootComponentName, defaultContext) {
  const Context2 = React33.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = React33.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Context2.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext22(consumerName) {
    const context = React33.useContext(Context2);
    if (context)
      return context;
    if (defaultContext !== void 0)
      return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React33.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope, children, ...context } = props;
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React33.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Context2.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React33.useContext(Context2);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React33.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React33.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React33.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React35 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React34 = __toESM(require_react(), 1);
var useLayoutEffect2 = globalThis?.document ? React34.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React210 = __toESM(require_react(), 1);
var useInsertionEffect = React35[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React35.useRef(prop !== void 0);
    React35.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React35.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React35.useState(defaultProp);
  const prevValueRef = React35.useRef(value);
  const onChangeRef = React35.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React35.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React36 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i6 = 0; i6 < cleanups.length; i6++) {
          const cleanup = cleanups[i6];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i6], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React36.useCallback(composeRefs(...refs), refs);
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
var React43 = __toESM(require_react(), 1);

// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v4) => ({
  x: v4,
  y: v4
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y4,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y4,
    left: x2,
    right: x2 + width,
    bottom: y4 + height,
    x: x2,
    y: y4
  };
}

// ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y4
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i6 = 0; i6 < validMiddleware.length; i6++) {
    const {
      name,
      fn
    } = validMiddleware[i6];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y4,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y4 = nextY != null ? nextY : y4;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y4
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i6 = -1;
    }
  }
  return {
    x: x2,
    y: y4,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y4,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y4,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y4,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element: element2,
      padding = 0
    } = evaluate(options, state) || {};
    if (element2 == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y4
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element2);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d6) => getSideAxis(d6.placement) === initialSideAxis ? d6.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d6) => d6.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d6) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d6.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d6) => [d6.placement, d6.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y4,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y4 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y4,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y5
            } = _ref;
            return {
              x: x3,
              y: y5
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y4
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min3, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min3, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y4,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y4,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y4
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element2) {
  return tableElements.has(getNodeName(element2));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element2) {
  return topLayerSelectors.some((selector) => {
    try {
      return element2.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.scrollX,
    scrollTop: element2.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result2 = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result2) ? result2.host : result2;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css = getComputedStyle2(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $8
  } = getCssDimensions(domElement);
  let x2 = ($8 ? round(rect.width) : rect.width) / width;
  let y4 = ($8 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y4 || !Number.isFinite(y4)) {
    y4 = 1;
  }
  return {
    x: x2,
    y: y4
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y4 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y4 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y4 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y4
  });
}
function getWindowScrollBarX(element2, rect) {
  const leftScroll = getNodeScroll(element2).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element2)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y4 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y4
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y4 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y4
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x2,
    y: y4
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y4 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y4
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache2) {
  const cachedResult = cache2.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result2 = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result2 = result2.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element2, result2);
  return result2;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y4 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y4,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element2) {
  return getComputedStyle2(element2).position === "static";
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  let rawOffsetParent = element2.offsetParent;
  if (getDocumentElement(element2) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element2, polyfill) {
  const win = getWindow(element2);
  if (isTopLayer(element2)) {
    return win;
  }
  if (!isHTMLElement(element2)) {
    let svgOffsetParent = getParentNode(element2);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element2) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b2) {
  return a3.x === b2.x && a3.y === b2.y && a3.width === b2.width && a3.height === b2.height;
}
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element2.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element2.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React37 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react14.useLayoutEffect : noop;
function deepEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (typeof a3 !== typeof b2) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i6;
  let keys2;
  if (a3 && b2 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b2.length)
        return false;
      for (i6 = length; i6-- !== 0; ) {
        if (!deepEqual(a3[i6], b2[i6])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a3);
    length = keys2.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i6 = length; i6-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys2[i6])) {
        return false;
      }
    }
    for (i6 = length; i6-- !== 0; ) {
      const key = keys2[i6];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
function getDPR(element2) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React37.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React37.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React37.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React37.useState(null);
  const [_floating, _setFloating] = React37.useState(null);
  const setReference = React37.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React37.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React37.useRef(null);
  const floatingRef = React37.useRef(null);
  const dataRef = React37.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React37.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React37.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React37.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React37.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React37.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y4 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y4 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y4
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React37.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element: element2,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element2 && isRef(element2)) {
        if (element2.current != null) {
          return arrow2({
            element: element2.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element2) {
        return arrow2({
          element: element2,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
var React40 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
var React39 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// ../../node_modules/@radix-ui/react-slot/dist/index.mjs
var React38 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = React38.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React38.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React38.Children.count(newElement) > 1)
            return React38.Children.only(null);
          return React38.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React38.isValidElement(newElement) ? React38.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
function createSlotClone(ownerName) {
  const SlotClone = React38.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React38.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React38.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React38.cloneElement(children, props2);
    }
    return React38.Children.count(children) > 1 ? React38.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
  return React38.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result2 = childPropValue(...args);
          slotPropValue(...args);
          return result2;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element2) {
  let getter = Object.getOwnPropertyDescriptor(element2.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element2, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.props.ref;
  }
  return element2.props.ref || element2.ref;
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot(`Primitive.${node}`);
  const Node2 = React39.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target)
    ReactDOM2.flushSync(() => target.dispatchEvent(event));
}

// ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React40.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root = Arrow;

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React41 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React41.useRef(callback);
  React41.useEffect(() => {
    callbackRef.current = callback;
  });
  return React41.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}

// ../../node_modules/@radix-ui/react-use-size/dist/index.mjs
var React42 = __toESM(require_react(), 1);
function useSize(element2) {
  const [size5, setSize] = React42.useState(void 0);
  useLayoutEffect2(() => {
    if (element2) {
      setSize({ width: element2.offsetWidth, height: element2.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element2.offsetWidth;
          height = element2.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element2, { box: "border-box" });
      return () => resizeObserver.unobserve(element2);
    } else {
      setSize(void 0);
    }
  }, [element2]);
  return size5;
}

// ../../node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
"use client";
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React43.useState(null);
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React43.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React43.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React43.useRef(null);
    React43.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React43.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React43.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React43.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull2),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React43.useState();
    useLayoutEffect2(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React43.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull2(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y4 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y4 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y4 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y4 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y4 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y4 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// ../../node_modules/@radix-ui/react-portal/dist/index.mjs
var React44 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
"use client";
var PORTAL_NAME = "Portal";
var Portal = React44.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React44.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? import_react_dom2.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// ../../node_modules/@radix-ui/react-presence/dist/index.mjs
var React211 = __toESM(require_react(), 1);
var React45 = __toESM(require_react(), 1);
"use client";
function useStateMachine(initialState, machine) {
  return React45.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React211.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React211.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React211.useState();
  const stylesRef = React211.useRef(null);
  const prevPresentRef = React211.useRef(present);
  const prevAnimationNameRef = React211.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React211.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React211.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef2(element2) {
  let getter = Object.getOwnPropertyDescriptor(element2.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element2, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.props.ref;
  }
  return element2.props.ref || element2.ref;
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React47 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React46 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React46.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
"use client";
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React47.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React47.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React47.useContext(DismissableLayerContext);
    const [node, setNode] = React47.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = React47.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented)
        onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch)
        return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented)
        onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React47.useEffect(() => {
      if (!node)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React47.useEffect(() => {
      return () => {
        if (!node)
          return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React47.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React47.forwardRef((props, forwardedRef) => {
  const context = React47.useContext(DismissableLayerContext);
  const ref = React47.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React47.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React47.useRef(false);
  const handleClickRef = React47.useRef(() => {
  });
  React47.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React47.useRef(false);
  React47.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler)
    target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// ../../node_modules/@radix-ui/react-hover-card/dist/index.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
"use client";
var originalBodyUserSelect;
var HOVERCARD_NAME = "HoverCard";
var [createHoverCardContext, createHoverCardScope] = createContextScope(HOVERCARD_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [HoverCardProvider, useHoverCardContext] = createHoverCardContext(HOVERCARD_NAME);
var HoverCard = (props) => {
  const {
    __scopeHoverCard,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    openDelay = 700,
    closeDelay = 300
  } = props;
  const popperScope = usePopperScope(__scopeHoverCard);
  const openTimerRef = React48.useRef(0);
  const closeTimerRef = React48.useRef(0);
  const hasSelectionRef = React48.useRef(false);
  const isPointerDownOnContentRef = React48.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: HOVERCARD_NAME
  });
  const handleOpen = React48.useCallback(() => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = window.setTimeout(() => setOpen(true), openDelay);
  }, [openDelay, setOpen]);
  const handleClose = React48.useCallback(() => {
    clearTimeout(openTimerRef.current);
    if (!hasSelectionRef.current && !isPointerDownOnContentRef.current) {
      closeTimerRef.current = window.setTimeout(() => setOpen(false), closeDelay);
    }
  }, [closeDelay, setOpen]);
  const handleDismiss = React48.useCallback(() => setOpen(false), [setOpen]);
  React48.useEffect(() => {
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    HoverCardProvider,
    {
      scope: __scopeHoverCard,
      open,
      onOpenChange: setOpen,
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Root2, { ...popperScope, children })
    }
  );
};
HoverCard.displayName = HOVERCARD_NAME;
var TRIGGER_NAME = "HoverCardTrigger";
var HoverCardTrigger = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeHoverCard, ...triggerProps } = props;
    const context = useHoverCardContext(TRIGGER_NAME, __scopeHoverCard);
    const popperScope = usePopperScope(__scopeHoverCard);
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      Primitive.a,
      {
        "data-state": context.open ? "open" : "closed",
        ...triggerProps,
        ref: forwardedRef,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, excludeTouch(context.onClose)),
        onFocus: composeEventHandlers(props.onFocus, context.onOpen),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onTouchStart: composeEventHandlers(props.onTouchStart, (event) => event.preventDefault())
      }
    ) });
  }
);
HoverCardTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "HoverCardPortal";
var [PortalProvider, usePortalContext] = createHoverCardContext(PORTAL_NAME2, {
  forceMount: void 0
});
var HoverCardPortal = (props) => {
  const { __scopeHoverCard, forceMount, children, container } = props;
  const context = useHoverCardContext(PORTAL_NAME2, __scopeHoverCard);
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(PortalProvider, { scope: __scopeHoverCard, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Portal, { asChild: true, container, children }) }) });
};
HoverCardPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "HoverCardContent";
var HoverCardContent = React48.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeHoverCard);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useHoverCardContext(CONTENT_NAME2, props.__scopeHoverCard);
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      HoverCardContentImpl,
      {
        "data-state": context.open ? "open" : "closed",
        ...contentProps,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, excludeTouch(context.onOpen)),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, excludeTouch(context.onClose)),
        ref: forwardedRef
      }
    ) });
  }
);
HoverCardContent.displayName = CONTENT_NAME2;
var HoverCardContentImpl = React48.forwardRef((props, forwardedRef) => {
  const {
    __scopeHoverCard,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    ...contentProps
  } = props;
  const context = useHoverCardContext(CONTENT_NAME2, __scopeHoverCard);
  const popperScope = usePopperScope(__scopeHoverCard);
  const ref = React48.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [containSelection, setContainSelection] = React48.useState(false);
  React48.useEffect(() => {
    if (containSelection) {
      const body = document.body;
      originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
      body.style.userSelect = "none";
      body.style.webkitUserSelect = "none";
      return () => {
        body.style.userSelect = originalBodyUserSelect;
        body.style.webkitUserSelect = originalBodyUserSelect;
      };
    }
  }, [containSelection]);
  React48.useEffect(() => {
    if (ref.current) {
      const handlePointerUp = () => {
        setContainSelection(false);
        context.isPointerDownOnContentRef.current = false;
        setTimeout(() => {
          const hasSelection = document.getSelection()?.toString() !== "";
          if (hasSelection)
            context.hasSelectionRef.current = true;
        });
      };
      document.addEventListener("pointerup", handlePointerUp);
      return () => {
        document.removeEventListener("pointerup", handlePointerUp);
        context.hasSelectionRef.current = false;
        context.isPointerDownOnContentRef.current = false;
      };
    }
  }, [context.isPointerDownOnContentRef, context.hasSelectionRef]);
  React48.useEffect(() => {
    if (ref.current) {
      const tabbables = getTabbableNodes(ref.current);
      tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
    }
  });
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    DismissableLayer,
    {
      asChild: true,
      disableOutsidePointerEvents: false,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside: composeEventHandlers(onFocusOutside, (event) => {
        event.preventDefault();
      }),
      onDismiss: context.onDismiss,
      children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
        Content,
        {
          ...popperScope,
          ...contentProps,
          onPointerDown: composeEventHandlers(contentProps.onPointerDown, (event) => {
            if (event.currentTarget.contains(event.target)) {
              setContainSelection(true);
            }
            context.hasSelectionRef.current = false;
            context.isPointerDownOnContentRef.current = true;
          }),
          ref: composedRefs,
          style: {
            ...contentProps.style,
            userSelect: containSelection ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: containSelection ? "text" : void 0,
            // re-namespace exposed content custom properties
            ...{
              "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
              "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
              "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
            }
          }
        }
      )
    }
  );
});
var ARROW_NAME2 = "HoverCardArrow";
var HoverCardArrow = React48.forwardRef(
  (props, forwardedRef) => {
    const { __scopeHoverCard, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeHoverCard);
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
HoverCardArrow.displayName = ARROW_NAME2;
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
var Root22 = HoverCard;
var Trigger = HoverCardTrigger;
var Portal2 = HoverCardPortal;
var Content2 = HoverCardContent;
var Arrow22 = HoverCardArrow;

// ../../packages/myst-to-react/dist/components/HoverPopover.js
var import_classnames3 = __toESM(require_classnames(), 1);
function HoverPopover({ children, openDelay = 400, card, side, arrowClass = "fill-white" }) {
  const [load2, setLoad] = (0, import_react15.useState)(false);
  return (0, import_jsx_runtime22.jsxs)(Root22, { openDelay, children: [(0, import_jsx_runtime22.jsx)(Trigger, { asChild: true, onMouseEnter: () => setLoad(true), children }), (0, import_jsx_runtime22.jsx)(Portal2, { children: (0, import_jsx_runtime22.jsxs)(Content2, { className: "exclude-from-outline hover-card-content", sideOffset: 5, side, children: [typeof card === "function" ? load2 && card({ load: load2 }) : card, (0, import_jsx_runtime22.jsx)(Arrow22, { className: arrowClass })] }) })] });
}
function Tooltip({ title, children, className }) {
  return (0, import_jsx_runtime22.jsx)(HoverPopover, { side: "top", card: (0, import_jsx_runtime22.jsx)("div", { className: (0, import_classnames3.default)("p-1 text-xs text-white bg-blue-900 dark:bg-white dark:text-black", className), children: title }), arrowClass: "fill-blue-900 dark:fill-white", children });
}

// ../../packages/myst-to-react/dist/components/LinkCard.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_classnames4 = __toESM(require_classnames(), 1);
function LinkCard({ url, title, internal = false, loading = false, description, thumbnail, className = "w-[300px] sm:max-w-[500px] bg-white rounded shadow-md" }) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const to = withBaseurl(url, baseurl);
  return (0, import_jsx_runtime23.jsxs)("div", { className: (0, import_classnames4.default)("hover-card-content rounded overflow-hidden", className, {
    "animate-pulse": loading
  }), children: [!loading && thumbnail && (0, import_jsx_runtime23.jsx)("img", { src: thumbnail, className: "w-full h-[150px] object-cover object-top object-left m-0" }), loading && (0, import_jsx_runtime23.jsx)("div", { className: "animate-pulse bg-slate-100 dark:bg-slate-800 w-full h-[150px]" }), internal && (0, import_jsx_runtime23.jsx)(Link2, { to, className: "block px-3 mt-3 text-sm font-semibold text-inherit hover:text-inherit", prefetch: "intent", children: title }), !internal && (0, import_jsx_runtime23.jsxs)("a", { href: to, className: "block px-3 mt-3 text-sm font-semibold text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime23.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }), title] }), !loading && description && (0, import_jsx_runtime23.jsx)("div", { className: "p-3 prose text-sm max-h-[300px] overflow-hidden", children: description })] });
}

// ../../packages/myst-to-react/dist/MyST.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
function DefaultComponent({ node, className }) {
  if (!node.children)
    return (0, import_jsx_runtime24.jsx)("span", { className, children: node.value });
  return (0, import_jsx_runtime24.jsx)("div", { className, children: (0, import_jsx_runtime24.jsx)(MyST, { ast: node.children }) });
}
function selectRenderer(renderers2, node) {
  var _a, _b, _c;
  const componentRenderers = (_a = renderers2[node.type]) !== null && _a !== void 0 ? _a : renderers2["DefaultComponent"];
  const SpecificComponent = (_b = Object.entries(componentRenderers !== null && componentRenderers !== void 0 ? componentRenderers : {}).reverse().find(([selector]) => selector !== "base" && matches(selector, node))) === null || _b === void 0 ? void 0 : _b[1];
  return (_c = SpecificComponent !== null && SpecificComponent !== void 0 ? SpecificComponent : componentRenderers === null || componentRenderers === void 0 ? void 0 : componentRenderers.base) !== null && _c !== void 0 ? _c : DefaultComponent;
}
function MyST({ ast, className }) {
  const renderers2 = useNodeRenderers();
  if (!ast)
    return null;
  if (!Array.isArray(ast)) {
    const Component = selectRenderer(renderers2, ast);
    return (0, import_jsx_runtime24.jsx)(Component, { node: ast, className }, ast.key);
  }
  if (ast.length === 0)
    return null;
  return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: ast === null || ast === void 0 ? void 0 : ast.map((node) => {
    const Component = selectRenderer(renderers2, node);
    return (0, import_jsx_runtime24.jsx)(Component, { node, className }, node.key);
  }) });
}

// ../../packages/myst-to-react/dist/basic.js
var BASIC_RENDERERS = {
  text({ node }) {
    var _a;
    if (!((_a = node.value) === null || _a === void 0 ? void 0 : _a.includes("\u200B"))) {
      return (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, { children: node.value });
    }
    const text = node.value.split("\u200B");
    return (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, { children: text.map((v4, i6) => (0, import_jsx_runtime25.jsxs)(import_react16.default.Fragment, { children: [v4, i6 < text.length - 1 && (0, import_jsx_runtime25.jsx)("wbr", {})] }, i6)) });
  },
  span({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("span", { className: (0, import_classnames5.default)(node.class, className), style: node.style, id: node.html_id, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  div({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("div", { className: (0, import_classnames5.default)(node.class, className), style: node.style, id: node.html_id, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  delete({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("del", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  strong({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("strong", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  emphasis({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("em", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  underline({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("span", { style: { textDecoration: "underline" }, className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  smallcaps({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("span", { style: { fontVariant: "small-caps" }, className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  link({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("a", { target: "_blank", href: node.url, className: (0, import_classnames5.default)(node.class, className), rel: "noreferrer", children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  paragraph({ node, className }) {
    var _a, _b, _c, _d;
    const isSingleImage = ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) === 1 && node.children[0].type === "image";
    const isSingleLinkedImage = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) === 1 && node.children[0].type === "link" && ((_c = node.children[0].children) === null || _c === void 0 ? void 0 : _c.length) === 1 && ((_d = node.children[0].children[0]) === null || _d === void 0 ? void 0 : _d.type) === "image";
    if (!isSingleImage && !isSingleLinkedImage) {
      return (0, import_jsx_runtime25.jsx)("p", { id: node.html_id, className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children });
  },
  algorithmLine({ node, className }) {
    var _a;
    const style = {
      paddingLeft: `${((_a = node.indent) !== null && _a !== void 0 ? _a : 0) + 2}rem`
    };
    return (0, import_jsx_runtime25.jsx)("p", { className: (0, import_classnames5.default)("line", className), style, "data-line-number": node.enumerator, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  break({ className }) {
    return (0, import_jsx_runtime25.jsx)("br", { className });
  },
  inlineMath({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("code", { className, children: node.value });
  },
  math({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("code", { className, children: node.value });
  },
  list({ node, className }) {
    if (node.ordered) {
      return (0, import_jsx_runtime25.jsx)("ol", { start: node.start || void 0, id: node.html_id, className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime25.jsx)("ul", { id: node.html_id, className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  listItem({ node, className }) {
    if (node.checked == null) {
      return (0, import_jsx_runtime25.jsx)("li", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
    }
    return (0, import_jsx_runtime25.jsxs)("li", { className: (0, import_classnames5.default)("task-list-item", className), children: [(0, import_jsx_runtime25.jsx)("input", { type: "checkbox", className: "task-list-item-checkbox", defaultChecked: node.checked }), (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children })] });
  },
  container({ node, className }) {
    const figureName = `fig-${node.kind}`;
    return (0, import_jsx_runtime25.jsx)("figure", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames5.default)({ [figureName]: !!node.kind, subcontainer: node.subcontainer }, node.class, className), children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  caption({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("figcaption", { className: (0, import_classnames5.default)("group", className), children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  legend({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("figcaption", { className: (0, import_classnames5.default)("text-sm", className), children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  blockquote({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("blockquote", { id: node.html_id, className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  thematicBreak() {
    return (0, import_jsx_runtime25.jsx)("hr", { className: "py-2 my-5 translate-y-2" });
  },
  captionNumber({ node, className }) {
    const id = node.html_id || node.identifier || node.key;
    return (0, import_jsx_runtime25.jsx)(HashLink, { id, kind: node.kind, className: (0, import_classnames5.default)("mr-1 font-semibold text-inherit hover:text-inherit hover:font-semibold", className), children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  table({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("table", { className: (0, import_classnames5.default)(node.class, className), style: node.style, children: (0, import_jsx_runtime25.jsx)("tbody", { children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) }) });
  },
  tableRow({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("tr", { className: (0, import_classnames5.default)(node.class, className), style: node.style, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  tableCell({ node, className }) {
    const ifGreaterThanOne = (num) => num === 1 ? void 0 : num;
    const attrs = {
      rowSpan: ifGreaterThanOne(node.rowspan),
      colSpan: ifGreaterThanOne(node.colspan)
    };
    const align = {
      "text-left": node.align === "left",
      "text-right": node.align === "right",
      "text-center": node.align === "center"
    };
    if (node.header)
      return (0, import_jsx_runtime25.jsx)("th", Object.assign({ className: (0, import_classnames5.default)(node.class, align, className), style: node.style }, attrs, { children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) }));
    return (0, import_jsx_runtime25.jsx)("td", Object.assign({ className: (0, import_classnames5.default)(node.class, align, className), style: node.style }, attrs, { children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) }));
  },
  subscript({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("sub", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  superscript({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("sup", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  abbreviation({ node, className }) {
    return (0, import_jsx_runtime25.jsx)(Tooltip, { title: node.title, className: (0, import_classnames5.default)(className), children: (0, import_jsx_runtime25.jsx)("abbr", { "aria-label": node.title, className: "border-b border-dotted cursor-help", children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) }) });
  },
  mystComment() {
    return null;
  },
  comment() {
    return null;
  },
  definitionList({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("dl", { className: (0, import_classnames5.default)("my-5", className), id: node.html_id || node.identifier || node.key, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  definitionTerm({ node, className }) {
    var _a, _b;
    const allowedStrongTypes = /* @__PURE__ */ new Set(["text", "emphasis"]);
    const makeStrong = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.reduce((allowed, n5) => allowed && allowedStrongTypes.has(n5.type), true)) !== null && _b !== void 0 ? _b : false;
    return (0, import_jsx_runtime25.jsx)("dt", { id: node.html_id || node.identifier || node.key, className, children: makeStrong ? (0, import_jsx_runtime25.jsx)("strong", { children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) }) : (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  definitionDescription({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("dd", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  keyboard({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("kbd", { className, children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  include({ node, className }) {
    return (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children, className });
  },
  glossary({ node, className }) {
    return (0, import_jsx_runtime25.jsx)("div", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames5.default)(node.class, className), children: (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children }) });
  },
  root({ node, className }) {
    return (0, import_jsx_runtime25.jsx)(MyST, { ast: node.children, className });
  }
};
var basic_default = BASIC_RENDERERS;

// ../../packages/myst-to-react/dist/admonitions.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@heroicons/react/24/solid/esm/ArrowTopRightOnSquareIcon.js
var React50 = __toESM(require_react(), 1);
function ArrowTopRightOnSquareIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React50.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React50.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React50.createElement("path", {
    fillRule: "evenodd",
    d: "M15.75 2.25H21a.75.75 0 0 1 .75.75v5.25a.75.75 0 0 1-1.5 0V4.81L8.03 17.03a.75.75 0 0 1-1.06-1.06L19.19 3.75h-3.44a.75.75 0 0 1 0-1.5Zm-10.5 4.5a1.5 1.5 0 0 0-1.5 1.5v10.5a1.5 1.5 0 0 0 1.5 1.5h10.5a1.5 1.5 0 0 0 1.5-1.5V10.5a.75.75 0 0 1 1.5 0v8.25a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3V8.25a3 3 0 0 1 3-3h8.25a.75.75 0 0 1 0 1.5H5.25Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef26 = /* @__PURE__ */ React50.forwardRef(ArrowTopRightOnSquareIcon2);
var ArrowTopRightOnSquareIcon_default2 = ForwardRef26;

// ../../node_modules/@heroicons/react/24/solid/esm/ArrowTurnDownLeftIcon.js
var React51 = __toESM(require_react(), 1);
function ArrowTurnDownLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React51.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React51.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React51.createElement("path", {
    fillRule: "evenodd",
    d: "M20.239 3.749a.75.75 0 0 0-.75.75V15H5.549l2.47-2.47a.75.75 0 0 0-1.06-1.06l-3.75 3.75a.75.75 0 0 0 0 1.06l3.75 3.75a.75.75 0 1 0 1.06-1.06L5.55 16.5h14.69a.75.75 0 0 0 .75-.75V4.5a.75.75 0 0 0-.75-.751Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef27 = /* @__PURE__ */ React51.forwardRef(ArrowTurnDownLeftIcon);
var ArrowTurnDownLeftIcon_default = ForwardRef27;

// ../../node_modules/@heroicons/react/24/solid/esm/Bars3BottomLeftIcon.js
var React52 = __toESM(require_react(), 1);
function Bars3BottomLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React52.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React52.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React52.createElement("path", {
    fillRule: "evenodd",
    d: "M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75H12a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef28 = /* @__PURE__ */ React52.forwardRef(Bars3BottomLeftIcon);
var Bars3BottomLeftIcon_default = ForwardRef28;

// ../../node_modules/@heroicons/react/24/solid/esm/Bars3Icon.js
var React53 = __toESM(require_react(), 1);
function Bars3Icon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React53.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React53.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React53.createElement("path", {
    fillRule: "evenodd",
    d: "M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef29 = /* @__PURE__ */ React53.forwardRef(Bars3Icon);
var Bars3Icon_default = ForwardRef29;

// ../../node_modules/@heroicons/react/24/solid/esm/BoltIcon.js
var React54 = __toESM(require_react(), 1);
function BoltIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React54.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React54.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React54.createElement("path", {
    fillRule: "evenodd",
    d: "M14.615 1.595a.75.75 0 0 1 .359.852L12.982 9.75h7.268a.75.75 0 0 1 .548 1.262l-10.5 11.25a.75.75 0 0 1-1.272-.71l1.992-7.302H3.75a.75.75 0 0 1-.548-1.262l10.5-11.25a.75.75 0 0 1 .913-.143Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef30 = /* @__PURE__ */ React54.forwardRef(BoltIcon2);
var BoltIcon_default2 = ForwardRef30;

// ../../node_modules/@heroicons/react/24/solid/esm/ChevronDownIcon.js
var React55 = __toESM(require_react(), 1);
function ChevronDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React55.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React55.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React55.createElement("path", {
    fillRule: "evenodd",
    d: "M12.53 16.28a.75.75 0 0 1-1.06 0l-7.5-7.5a.75.75 0 0 1 1.06-1.06L12 14.69l6.97-6.97a.75.75 0 1 1 1.06 1.06l-7.5 7.5Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef31 = /* @__PURE__ */ React55.forwardRef(ChevronDownIcon);
var ChevronDownIcon_default = ForwardRef31;

// ../../node_modules/@heroicons/react/24/solid/esm/ChevronRightIcon.js
var React56 = __toESM(require_react(), 1);
function ChevronRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React56.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React56.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React56.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef32 = /* @__PURE__ */ React56.forwardRef(ChevronRightIcon);
var ChevronRightIcon_default = ForwardRef32;

// ../../node_modules/@heroicons/react/24/solid/esm/EllipsisVerticalIcon.js
var React57 = __toESM(require_react(), 1);
function EllipsisVerticalIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React57.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React57.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React57.createElement("path", {
    fillRule: "evenodd",
    d: "M10.5 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm0 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm0 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef33 = /* @__PURE__ */ React57.forwardRef(EllipsisVerticalIcon);
var EllipsisVerticalIcon_default = ForwardRef33;

// ../../node_modules/@heroicons/react/24/solid/esm/ExclamationCircleIcon.js
var React58 = __toESM(require_react(), 1);
function ExclamationCircleIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React58.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React58.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React58.createElement("path", {
    fillRule: "evenodd",
    d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75Zm0 8.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef34 = /* @__PURE__ */ React58.forwardRef(ExclamationCircleIcon2);
var ExclamationCircleIcon_default2 = ForwardRef34;

// ../../node_modules/@heroicons/react/24/solid/esm/ExclamationTriangleIcon.js
var React59 = __toESM(require_react(), 1);
function ExclamationTriangleIcon2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React59.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React59.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React59.createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75Zm0 8.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef35 = /* @__PURE__ */ React59.forwardRef(ExclamationTriangleIcon2);
var ExclamationTriangleIcon_default2 = ForwardRef35;

// ../../node_modules/@heroicons/react/24/solid/esm/HashtagIcon.js
var React60 = __toESM(require_react(), 1);
function HashtagIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React60.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React60.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React60.createElement("path", {
    fillRule: "evenodd",
    d: "M11.097 1.515a.75.75 0 0 1 .589.882L10.666 7.5h4.47l1.079-5.397a.75.75 0 1 1 1.47.294L16.665 7.5h3.585a.75.75 0 0 1 0 1.5h-3.885l-1.2 6h3.585a.75.75 0 0 1 0 1.5h-3.885l-1.08 5.397a.75.75 0 1 1-1.47-.294l1.02-5.103h-4.47l-1.08 5.397a.75.75 0 1 1-1.47-.294l1.02-5.103H3.75a.75.75 0 0 1 0-1.5h3.885l1.2-6H5.25a.75.75 0 0 1 0-1.5h3.885l1.08-5.397a.75.75 0 0 1 .882-.588ZM10.365 9l-1.2 6h4.47l1.2-6h-4.47Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef36 = /* @__PURE__ */ React60.forwardRef(HashtagIcon);
var HashtagIcon_default = ForwardRef36;

// ../../node_modules/@heroicons/react/24/solid/esm/MagnifyingGlassIcon.js
var React61 = __toESM(require_react(), 1);
function MagnifyingGlassIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React61.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React61.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React61.createElement("path", {
    fillRule: "evenodd",
    d: "M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef37 = /* @__PURE__ */ React61.forwardRef(MagnifyingGlassIcon);
var MagnifyingGlassIcon_default = ForwardRef37;

// ../../node_modules/@heroicons/react/24/solid/esm/MoonIcon.js
var React62 = __toESM(require_react(), 1);
function MoonIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React62.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React62.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React62.createElement("path", {
    fillRule: "evenodd",
    d: "M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef38 = /* @__PURE__ */ React62.forwardRef(MoonIcon);
var MoonIcon_default = ForwardRef38;

// ../../node_modules/@heroicons/react/24/solid/esm/XCircleIcon.js
var React63 = __toESM(require_react(), 1);
function XCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React63.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React63.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React63.createElement("path", {
    fillRule: "evenodd",
    d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-1.72 6.97a.75.75 0 1 0-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06L12 13.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L13.06 12l1.72-1.72a.75.75 0 1 0-1.06-1.06L12 10.94l-1.72-1.72Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef39 = /* @__PURE__ */ React63.forwardRef(XCircleIcon);
var XCircleIcon_default = ForwardRef39;

// ../../node_modules/@heroicons/react/24/solid/esm/XMarkIcon.js
var React64 = __toESM(require_react(), 1);
function XMarkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React64.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React64.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React64.createElement("path", {
    fillRule: "evenodd",
    d: "M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z",
    clipRule: "evenodd"
  }));
}
var ForwardRef40 = /* @__PURE__ */ React64.forwardRef(XMarkIcon);
var XMarkIcon_default = ForwardRef40;

// ../../packages/myst-to-react/dist/admonitions.js
var import_classnames6 = __toESM(require_classnames(), 1);
var AdmonitionKind;
(function(AdmonitionKind2) {
  AdmonitionKind2["admonition"] = "admonition";
  AdmonitionKind2["attention"] = "attention";
  AdmonitionKind2["caution"] = "caution";
  AdmonitionKind2["danger"] = "danger";
  AdmonitionKind2["error"] = "error";
  AdmonitionKind2["important"] = "important";
  AdmonitionKind2["hint"] = "hint";
  AdmonitionKind2["note"] = "note";
  AdmonitionKind2["seealso"] = "seealso";
  AdmonitionKind2["tip"] = "tip";
  AdmonitionKind2["warning"] = "warning";
})(AdmonitionKind || (AdmonitionKind = {}));
function getClasses(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s8) => s8.trim().toLowerCase()).filter((s8) => !!s8)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function getFirstKind({ kind, classes = [] }) {
  if (kind === AdmonitionKind.note || classes.includes("note")) {
    return { kind: AdmonitionKind.note, color: "blue" };
  }
  if (kind === AdmonitionKind.important || classes.includes("important")) {
    return { kind: AdmonitionKind.important, color: "blue" };
  }
  if (kind === AdmonitionKind.hint || classes.includes("hint")) {
    return { kind: AdmonitionKind.hint, color: "green" };
  }
  if (kind === AdmonitionKind.seealso || classes.includes("seealso")) {
    return { kind: AdmonitionKind.seealso, color: "green" };
  }
  if (kind === AdmonitionKind.tip || classes.includes("tip")) {
    return { kind: AdmonitionKind.tip, color: "green" };
  }
  if (kind === AdmonitionKind.attention || classes.includes("attention")) {
    return { kind: AdmonitionKind.attention, color: "yellow" };
  }
  if (kind === AdmonitionKind.warning || classes.includes("warning")) {
    return { kind: AdmonitionKind.warning, color: "yellow" };
  }
  if (kind === AdmonitionKind.caution || classes.includes("caution")) {
    return { kind: AdmonitionKind.caution, color: "yellow" };
  }
  if (kind === AdmonitionKind.danger || classes.includes("danger")) {
    return { kind: AdmonitionKind.danger, color: "red" };
  }
  if (kind === AdmonitionKind.error || classes.includes("error")) {
    return { kind: AdmonitionKind.error, color: "red" };
  }
  return { kind: AdmonitionKind.note, color: "blue" };
}
var iconClass = "myst-admonition-header-icon inline-block pl-2 mr-2 self-center flex-none";
function AdmonitionIcon({ kind, className }) {
  const cn = (0, import_classnames6.default)(iconClass, className);
  const opts = { width: "2rem", height: "2rem", className: cn };
  if (kind === AdmonitionKind.note)
    return (0, import_jsx_runtime26.jsx)(InformationCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.caution)
    return (0, import_jsx_runtime26.jsx)(ExclamationCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.warning)
    return (0, import_jsx_runtime26.jsx)(ExclamationTriangleIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.danger)
    return (0, import_jsx_runtime26.jsx)(ExclamationCircleIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.error)
    return (0, import_jsx_runtime26.jsx)(XCircleIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.attention)
    return (0, import_jsx_runtime26.jsx)(MegaphoneIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.tip)
    return (0, import_jsx_runtime26.jsx)(PencilSquareIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.hint)
    return (0, import_jsx_runtime26.jsx)(LightBulbIcon_default, Object.assign({}, opts));
  if (kind === AdmonitionKind.important)
    return (0, import_jsx_runtime26.jsx)(BoltIcon_default2, Object.assign({}, opts));
  if (kind === AdmonitionKind.seealso)
    return (0, import_jsx_runtime26.jsx)(ArrowRightCircleIcon_default, Object.assign({}, opts));
  return (0, import_jsx_runtime26.jsx)(InformationCircleIcon_default, Object.assign({}, opts));
}
var AdmonitionTitle = ({ node, className }) => {
  return (0, import_jsx_runtime26.jsx)(MyST, { ast: node.children, className });
};
var WrapperElement = ({ dropdown, className, children, open }) => {
  if (dropdown)
    return (0, import_jsx_runtime26.jsx)("details", { className, open, children });
  return (0, import_jsx_runtime26.jsx)("aside", { className, children });
};
var HeaderElement = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime26.jsx)("summary", { className, children });
  return (0, import_jsx_runtime26.jsx)("div", { className, children });
};
function Admonition({ title, kind, color: color2, simple, dropdown, children, hideIcon, className, open }) {
  return (0, import_jsx_runtime26.jsxs)(WrapperElement, { dropdown, open, className: (0, import_classnames6.default)(`myst-admonition myst-admonition-${kind} my-5 shadow-md dark:shadow-2xl dark:shadow-neutral-900`, "bg-gray-50/10 dark:bg-stone-800", "overflow-hidden", {
    "myst-admonition-default rounded border-l-4": !simple,
    "myst-admonition-simple border-l-2": simple,
    "border-blue-500": !color2 || color2 === "blue",
    "border-green-600": color2 === "green",
    "border-amber-600": color2 === "yellow",
    "border-red-600": color2 === "red"
  }, className), children: [title && (0, import_jsx_runtime26.jsxs)(HeaderElement, { dropdown, className: (0, import_classnames6.default)("myst-admonition-header m-0 font-medium py-1 flex min-w-0", {
    "text-lg": !simple,
    "text-md": simple,
    "bg-gray-100 dark:bg-stone-700": simple,
    "text-blue-600 bg-blue-50 dark:bg-slate-900": !simple && (!color2 || color2 === "blue"),
    "text-green-600 bg-green-50 dark:bg-slate-900": !simple && color2 === "green",
    "text-amber-600 bg-amber-50 dark:bg-slate-900": !simple && color2 === "yellow",
    "text-red-600 bg-red-50 dark:bg-slate-900": !simple && color2 === "red",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [!hideIcon && (0, import_jsx_runtime26.jsx)(AdmonitionIcon, { kind: kind !== null && kind !== void 0 ? kind : AdmonitionKind.note, className: (0, import_classnames6.default)({
    // Needed for simple!
    "text-blue-600": !color2 || color2 === "blue",
    "text-green-600": color2 === "green",
    "text-amber-600": color2 === "yellow",
    "text-red-600": color2 === "red"
  }) }), (0, import_jsx_runtime26.jsx)("div", { className: (0, import_classnames6.default)("myst-admonition-header-text text-neutral-900 dark:text-white grow self-center overflow-hidden break-words", { "ml-4": hideIcon }), children: title }), dropdown && (0, import_jsx_runtime26.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime26.jsx)(ChevronRightIcon_default, { width: "2rem", height: "2rem", className: (0, import_classnames6.default)(iconClass, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime26.jsx)("div", { className: (0, import_classnames6.default)("myst-admonition-body px-4", {
    "py-1": !simple,
    "details-body": dropdown
  }), children })] });
}
var AdmonitionRenderer = ({ node, className }) => {
  const [title, ...rest2] = node.children;
  const classes = getClasses(node.class);
  const { kind, color: color2 } = getFirstKind({ kind: node.kind, classes });
  const isDropdown = classes.includes("dropdown");
  const isSimple = classes.includes("simple");
  const hideIcon = node.icon === false;
  const isOpen = node.open === true;
  const useTitle = (title === null || title === void 0 ? void 0 : title.type) === "admonitionTitle";
  return (0, import_jsx_runtime26.jsx)(Admonition, { title: useTitle ? (0, import_jsx_runtime26.jsx)(MyST, { ast: [title] }) : void 0, kind, color: color2, dropdown: isDropdown, open: isOpen, simple: isSimple, hideIcon, className: (0, import_classnames6.default)(classes, className), children: useTitle ? (0, import_jsx_runtime26.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime26.jsx)(MyST, { ast: node.children }) });
};
var ADMONITION_RENDERERS = {
  admonition: AdmonitionRenderer,
  admonitionTitle: AdmonitionTitle
};
var admonitions_default = ADMONITION_RENDERERS;

// ../../packages/myst-to-react/dist/dropdown.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_classnames7 = __toESM(require_classnames(), 1);
var iconClass2 = "myst-dropdown-header-icon inline-block pl-2 mr-2 -translate-y-[1px]";
var SummaryTitle = ({ node, className }) => {
  return (0, import_jsx_runtime27.jsx)(MyST, { ast: node.children, className });
};
function Details({ title, children, open, className }) {
  return (0, import_jsx_runtime27.jsxs)("details", { className: (0, import_classnames7.default)("myst-dropdown rounded-md my-5 shadow dark:shadow-2xl dark:shadow-neutral-900 overflow-hidden", "bg-gray-50 dark:bg-stone-800", className), open, children: [(0, import_jsx_runtime27.jsx)("summary", { className: (0, import_classnames7.default)("myst-dropdown-header m-0 text-lg font-medium py-1 min-h-[2em] pl-3", "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]", "bg-gray-100 dark:bg-slate-900"), children: (0, import_jsx_runtime27.jsxs)("span", { className: "myst-dropdown-header-title text-neutral-900 dark:text-white", children: [(0, import_jsx_runtime27.jsx)("span", { className: "block float-right text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime27.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames7.default)(iconClass2, "details-toggle", "transition-transform") }) }), title] }) }), (0, import_jsx_runtime27.jsx)("div", { className: "myst-dropdown-body px-4 py-1 details-body", children })] });
}
var DetailsRenderer = ({ node, className }) => {
  const [title, ...rest2] = node.children;
  return (0, import_jsx_runtime27.jsx)(Details, { title: (0, import_jsx_runtime27.jsx)(MyST, { ast: [title] }), open: node.open, className: (0, import_classnames7.default)(node.class, className), children: (0, import_jsx_runtime27.jsx)(MyST, { ast: rest2 }) });
};
var DROPDOWN_RENDERERS = {
  details: DetailsRenderer,
  summary: SummaryTitle
};
var dropdown_default = DROPDOWN_RENDERERS;

// ../../packages/myst-to-react/dist/block.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_classnames8 = __toESM(require_classnames(), 1);
function Block({ node, className }) {
  var _a, _b, _c;
  const cn = (0, import_classnames8.default)(className, node.class, {
    [(_a = node.data) === null || _a === void 0 ? void 0 : _a.class]: typeof ((_b = node.data) === null || _b === void 0 ? void 0 : _b.class) === "string"
  });
  if (node.visibility === "remove")
    return null;
  const identifier = (_c = node.html_id) !== null && _c !== void 0 ? _c : node.identifier;
  const block = cn || identifier ? (0, import_jsx_runtime28.jsx)("div", { id: identifier, className: cn, children: (0, import_jsx_runtime28.jsx)(MyST, { ast: node.children }) }) : (0, import_jsx_runtime28.jsx)(MyST, { ast: node.children });
  if (node.visibility === "hide") {
    return (0, import_jsx_runtime28.jsx)(Details, { title: "Block", children: block });
  }
  return block;
}
var BLOCK_RENDERERS = {
  block: Block
};
var block_default = BLOCK_RENDERERS;

// ../../packages/myst-to-react/dist/card.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_classnames9 = __toESM(require_classnames(), 1);
var Header = ({ node, className }) => {
  return (0, import_jsx_runtime29.jsx)("header", { className: (0, import_classnames9.default)("myst-card-header py-1 pl-3 m-0 border-b border-gray-100 bg-gray-50 dark:bg-slate-900 dark:border-gray-800", className), children: (0, import_jsx_runtime29.jsx)(MyST, { ast: node.children }) });
};
var Footer = ({ node, className }) => {
  return (0, import_jsx_runtime29.jsx)("footer", { className: (0, import_classnames9.default)("myst-card-footer py-1 pl-3 m-0 border-t border-gray-100 bg-gray-50 dark:bg-slate-900 dark:border-gray-800", className), children: (0, import_jsx_runtime29.jsx)(MyST, { ast: node.children }) });
};
var CardTitle = ({ node, className }) => {
  return (0, import_jsx_runtime29.jsx)("div", { className: (0, import_classnames9.default)("myst-card-title pt-3 font-bold group-hover:underline", className), children: (0, import_jsx_runtime29.jsx)(MyST, { ast: node.children }) });
};
function getParts(children) {
  var _a, _b;
  const parts = {};
  if (!Array.isArray(children))
    return parts;
  const next = [...children];
  if (((_a = next[0]) === null || _a === void 0 ? void 0 : _a.type) === "header") {
    parts.header = next.splice(0, 1);
  }
  if (((_b = next[next.length - 1]) === null || _b === void 0 ? void 0 : _b.type) === "footer") {
    parts.footer = next.splice(-1, 1);
  }
  parts.body = next;
  return parts;
}
function ExternalOrInternalLink({ to, className, isStatic, prefetch = "intent", children }) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  if (to.startsWith("http") || isStatic) {
    return (0, import_jsx_runtime29.jsx)("a", { href: to, className, target: "_blank", rel: "noopener noreferrer", children });
  }
  return (0, import_jsx_runtime29.jsx)(Link2, { to: withBaseurl(to, baseurl), className, prefetch, children });
}
var CardRenderer = ({ node, className }) => {
  const parts = getParts(node.children);
  const url = node.url;
  const isStatic = node.static || false;
  const link = !!url;
  const sharedStyle = "myst-card my-5 rounded shadow dark:shadow-neutral-800 overflow-hidden border border-gray-100 dark:border-gray-800 flex flex-col";
  if (link) {
    return (0, import_jsx_runtime29.jsxs)(ExternalOrInternalLink, { to: url, isStatic, className: (0, import_classnames9.default)(sharedStyle, "text-inherit hover:text-inherit", "block font-normal no-underline hover:no-underline cursor-pointer group", "hover:border-blue-500 dark:hover:border-blue-400", className), children: [(0, import_jsx_runtime29.jsx)(MyST, { ast: parts.header }), (0, import_jsx_runtime29.jsx)("div", { className: "myst-card-body flex-grow px-4 py-2", children: (0, import_jsx_runtime29.jsx)(MyST, { ast: parts.body }) }), (0, import_jsx_runtime29.jsx)(MyST, { ast: parts.footer })] });
  }
  return (0, import_jsx_runtime29.jsxs)("div", { className: (0, import_classnames9.default)(sharedStyle, className), children: [(0, import_jsx_runtime29.jsx)(MyST, { ast: parts.header }), (0, import_jsx_runtime29.jsx)("div", { className: "myst-card-body flex-grow px-4 py-2", children: (0, import_jsx_runtime29.jsx)(MyST, { ast: parts.body }) }), (0, import_jsx_runtime29.jsx)(MyST, { ast: parts.footer })] });
};
var CARD_RENDERERS = {
  card: CardRenderer,
  cardTitle: CardTitle,
  header: Header,
  footer: Footer
};
var card_default = CARD_RENDERERS;

// ../../packages/myst-to-react/dist/grid.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_classnames10 = __toESM(require_classnames(), 1);
var gridClassNames = {
  main: [
    "grid-cols-1",
    "grid-cols-2",
    "grid-cols-3",
    "grid-cols-4",
    "grid-cols-5",
    "grid-cols-6",
    "grid-cols-7",
    "grid-cols-8",
    "grid-cols-9",
    "grid-cols-10",
    "grid-cols-11",
    "grid-cols-12"
  ],
  sm: [
    "sm:grid-cols-1",
    "sm:grid-cols-2",
    "sm:grid-cols-3",
    "sm:grid-cols-4",
    "sm:grid-cols-5",
    "sm:grid-cols-6",
    "sm:grid-cols-7",
    "sm:grid-cols-8",
    "sm:grid-cols-9",
    "sm:grid-cols-10",
    "sm:grid-cols-11",
    "sm:grid-cols-12"
  ],
  md: [
    "md:grid-cols-1",
    "md:grid-cols-2",
    "md:grid-cols-3",
    "md:grid-cols-4",
    "md:grid-cols-5",
    "md:grid-cols-6",
    "md:grid-cols-7",
    "md:grid-cols-8",
    "md:grid-cols-9",
    "md:grid-cols-10",
    "md:grid-cols-11",
    "md:grid-cols-12"
  ],
  lg: [
    "lg:grid-cols-1",
    "lg:grid-cols-2",
    "lg:grid-cols-3",
    "lg:grid-cols-4",
    "lg:grid-cols-5",
    "lg:grid-cols-6",
    "lg:grid-cols-7",
    "lg:grid-cols-8",
    "lg:grid-cols-9",
    "lg:grid-cols-10",
    "lg:grid-cols-11",
    "lg:grid-cols-12"
  ],
  xl: [
    "xl:grid-cols-1",
    "xl:grid-cols-2",
    "xl:grid-cols-3",
    "xl:grid-cols-4",
    "xl:grid-cols-5",
    "xl:grid-cols-6",
    "xl:grid-cols-7",
    "xl:grid-cols-8",
    "xl:grid-cols-9",
    "xl:grid-cols-10",
    "xl:grid-cols-11",
    "xl:grid-cols-12"
  ]
};
var DEFAULT_NUM_COLUMNS = 3;
function getColumnClassName(classes, number) {
  var _a;
  const num = Number(number);
  if (!number || Number.isNaN(num)) {
    return getColumnClassName(classes, DEFAULT_NUM_COLUMNS);
  }
  return (_a = classes[num - 1]) !== null && _a !== void 0 ? _a : classes[DEFAULT_NUM_COLUMNS];
}
function gridColumnClasses(columns) {
  if (!columns || columns.length <= 1) {
    return getColumnClassName(gridClassNames.main, columns === null || columns === void 0 ? void 0 : columns[0]);
  }
  if (columns.length !== 4) {
    return getColumnClassName(gridClassNames.main, columns[0]);
  }
  return [
    // getColumnClassName(gridClassNames.main, columns[0]),
    getColumnClassName(gridClassNames.main, columns[0]),
    getColumnClassName(gridClassNames.md, columns[1]),
    getColumnClassName(gridClassNames.lg, columns[2]),
    getColumnClassName(gridClassNames.xl, columns[3])
  ].join(" ");
}
function Grid({ columns, children, className }) {
  const gridClasses = gridColumnClasses(columns);
  const gutterClasses = "gap-4";
  return (0, import_jsx_runtime30.jsx)("div", { className: (0, import_classnames10.default)("myst-grid grid my-5", gridClasses, gutterClasses, className), children });
}
var GridRenderer = ({ node, className }) => {
  return (0, import_jsx_runtime30.jsx)(Grid, { columns: node.columns, className: (0, import_classnames10.default)(className, node.class), children: (0, import_jsx_runtime30.jsx)(MyST, { ast: node.children }) });
};
var GRID_RENDERERS = {
  grid: GridRenderer
};
var grid_default = GRID_RENDERERS;

// ../../packages/myst-to-react/dist/cite.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_classnames12 = __toESM(require_classnames(), 1);

// ../../packages/myst-to-react/dist/inlineError.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_classnames11 = __toESM(require_classnames(), 1);
function InlineError({ value, message, className }) {
  return (0, import_jsx_runtime31.jsxs)("span", { className: (0, import_classnames11.default)("text-yellow-600", className), title: message || value, children: [(0, import_jsx_runtime31.jsx)(ExclamationCircleIcon_default, { width: "1rem", height: "1rem", className: "inline mr-1" }), value] });
}

// ../../packages/myst-to-react/dist/cite.js
function useNumberedReferences() {
  var _a;
  const config = useSiteManifest();
  const numbered_references = !!((_a = config === null || config === void 0 ? void 0 : config.options) === null || _a === void 0 ? void 0 : _a.numbered_references);
  return numbered_references;
}
function CiteChild({ html }) {
  return (0, import_jsx_runtime32.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", dangerouslySetInnerHTML: { __html: html || "" } });
}
var CiteGroup = ({ node, className }) => {
  var _a, _b;
  const allCite = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.every((child) => child.type === "cite")) !== null && _b !== void 0 ? _b : false;
  return (0, import_jsx_runtime32.jsx)("span", { className: (0, import_classnames12.default)({
    "cite-group": allCite,
    "xref-group": !allCite,
    narrative: node.kind === "narrative",
    parenthetical: node.kind === "parenthetical"
  }, className), children: (0, import_jsx_runtime32.jsx)(MyST, { ast: node.children }) });
};
var Cite = ({ label, error, children, className }) => {
  var _a, _b;
  const references = useReferences();
  if (!label) {
    return (0, import_jsx_runtime32.jsx)(InlineError, { value: "cite (no label)", message: "Citation Has No Label", className });
  }
  const { html, doi: doiString, url: refUrl } = (_b = (_a = references === null || references === void 0 ? void 0 : references.cite) === null || _a === void 0 ? void 0 : _a.data[label]) !== null && _b !== void 0 ? _b : {};
  if (error) {
    return (0, import_jsx_runtime32.jsx)(InlineError, { value: label, message: "Citation Not Found", className });
  }
  const url = doiString ? doi.buildUrl(doiString) : refUrl;
  const isButtonLike = (className !== null && className !== void 0 ? className : "").split(" ").includes("button");
  return (0, import_jsx_runtime32.jsx)(HoverPopover, { openDelay: 300, card: (0, import_jsx_runtime32.jsx)(CiteChild, { html }), children: (0, import_jsx_runtime32.jsxs)("cite", { className, children: [url && (0, import_jsx_runtime32.jsx)("a", { href: url, target: "_blank", rel: "noreferrer", className: (0, import_classnames12.default)({ "hover-link": !isButtonLike }), children }), !url && (0, import_jsx_runtime32.jsx)("span", { className: "hover-link", children })] }) });
};
var CiteRenderer = ({ node, className }) => {
  const numbered = useNumberedReferences();
  return (0, import_jsx_runtime32.jsx)(Cite, { label: node.label, error: node.error, className: (0, import_classnames12.default)(className, node.class), children: numbered && node.kind === "parenthetical" ? node.enumerator : (0, import_jsx_runtime32.jsx)(MyST, { ast: node.children }) });
};
var CITE_RENDERERS = {
  citeGroup: CiteGroup,
  cite: CiteRenderer
};
var cite_default = CITE_RENDERERS;

// ../../packages/myst-to-react/dist/footnotes.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
function FootnoteDefinition({ identifier }) {
  var _a, _b;
  const references = useReferences();
  const node = (_b = (_a = references === null || references === void 0 ? void 0 : references.footnotes) === null || _a === void 0 ? void 0 : _a[identifier]) !== null && _b !== void 0 ? _b : select(`footnoteDefinition[identifier=${identifier}]`, references === null || references === void 0 ? void 0 : references.article);
  return (0, import_jsx_runtime33.jsx)(XRefProvider, { children: (0, import_jsx_runtime33.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] px-3 text-sm", children: (0, import_jsx_runtime33.jsx)(MyST, { ast: node === null || node === void 0 ? void 0 : node.children }) }) });
}
var FootnoteReference = ({ node, className }) => {
  var _a, _b;
  return (0, import_jsx_runtime33.jsx)(HoverPopover, { openDelay: 0, card: (0, import_jsx_runtime33.jsx)(FootnoteDefinition, { identifier: node.identifier }), children: (0, import_jsx_runtime33.jsx)("span", { id: `fnref-${node.key}`, className, children: (0, import_jsx_runtime33.jsx)("sup", { className: "hover-link", children: (0, import_jsx_runtime33.jsxs)(HashLink, { id: `fn-${node.identifier}`, title: "Link to Footnote", scrollBehavior: "instant", canSelectText: true, children: ["[", (_b = (_a = node.enumerator) !== null && _a !== void 0 ? _a : node.number) !== null && _b !== void 0 ? _b : node.identifier, "]"] }) }) }) });
};
var FOOTNOTE_RENDERERS = {
  footnoteReference: FootnoteReference,
  // Do not render the definitions, they get pulled in by a handler
  footnoteDefinition: () => null
};
var footnotes_default = FOOTNOTE_RENDERERS;

// ../../packages/myst-to-react/dist/code.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r4, e3) {
  if (null == r4)
    return {};
  var t11 = {};
  for (var n5 in r4)
    if ({}.hasOwnProperty.call(r4, n5)) {
      if (-1 !== e3.indexOf(n5))
        continue;
      t11[n5] = r4[n5];
    }
  return t11;
}

// ../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e3, t11) {
  if (null == e3)
    return {};
  var o11, r4, i6 = _objectWithoutPropertiesLoose(e3, t11);
  if (Object.getOwnPropertySymbols) {
    var n5 = Object.getOwnPropertySymbols(e3);
    for (r4 = 0; r4 < n5.length; r4++)
      o11 = n5[r4], -1 === t11.indexOf(o11) && {}.propertyIsEnumerable.call(e3, o11) && (i6[o11] = e3[o11]);
  }
  return i6;
}

// ../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
init_arrayLikeToArray();
function _arrayWithoutHoles(r4) {
  if (Array.isArray(r4))
    return _arrayLikeToArray(r4);
}

// ../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r4) {
  if ("undefined" != typeof Symbol && null != r4[Symbol.iterator] || null != r4["@@iterator"])
    return Array.from(r4);
}

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
init_unsupportedIterableToArray();

// ../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r4) {
  return _arrayWithoutHoles(r4) || _iterableToArray(r4) || _unsupportedIterableToArray(r4) || _nonIterableSpread();
}

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/highlight.js
init_defineProperty();
var import_react18 = __toESM(require_react());

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/create-element.js
init_extends();
init_defineProperty();
var import_react17 = __toESM(require_react());
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = null != arguments[i6] ? arguments[i6] : {};
    i6 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames52) {
  if (classNames52.length === 0 || classNames52.length === 1)
    return classNames52;
  var key = classNames52.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames52);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames52) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames52.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames52) {
  return classNames52.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i6) {
      return createElement41({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i6)
      });
    });
  };
}
function createElement41(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
  var properties = node.properties, type = node.type, TagName = node.tagName, value = node.value;
  if (type === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2))
            classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return /* @__PURE__ */ import_react17.default.createElement(TagName, _extends({
      key
    }, props), children);
  }
}

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default = function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
};

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/highlight.js
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = null != arguments[i6] ? arguments[i6] : {};
    i6 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var newLineRegex = /\n/g;
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_4, i6) {
    var number = i6 + startingLineNumber;
    return /* @__PURE__ */ import_react18.default.createElement("span", {
      key: "line-".concat(i6),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number) : style
    }, "".concat(number, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return /* @__PURE__ */ import_react18.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
  var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
  properties["className"] = className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread2(_objectSpread2({}, properties.style), {}, {
      display: "flex"
    });
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i6 = 0; i6 < tree.length; i6++) {
    var node = tree[i6];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray(new Set(className))
      }));
    } else if (node.children) {
      var classNames52 = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames52).forEach(function(i7) {
        return newTree.push(i7);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index2 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index2];
    var value = node.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text, i6) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text, "\n")
        };
        if (i6 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i6 === splitValue.length - 1) {
          var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index2 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index2;
    }
    index2++;
  };
  while (index2 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i6) {
    return createElement41({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i6)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code3 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code3);
    } else {
      return astGenerator.highlightAuto(code3);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code3, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e3) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread2(_objectSpread2({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code3 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest2 = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /* @__PURE__ */ import_react18.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code3
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest2, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest2, {
      className: rest2.className ? "".concat(generatorClassName, " ").concat(rest2.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre-wrap"
      });
    } else {
      codeTagProps.style = _objectSpread2(_objectSpread2({}, codeTagProps.style), {}, {
        whiteSpace: "pre"
      });
    }
    if (!astGenerator) {
      return /* @__PURE__ */ import_react18.default.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ import_react18.default.createElement(CodeTag, codeTagProps, code3));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines)
      wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code3
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code: code3,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /* @__PURE__ */ import_react18.default.createElement(PreTag, preProps, /* @__PURE__ */ import_react18.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}

// ../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n5, t11, e3, r4, o11, a3, c6) {
  try {
    var i6 = n5[a3](c6), u6 = i6.value;
  } catch (n6) {
    return void e3(n6);
  }
  i6.done ? t11(u6) : Promise.resolve(u6).then(r4, o11);
}
function _asyncToGenerator(n5) {
  return function() {
    var t11 = this, e3 = arguments;
    return new Promise(function(r4, o11) {
      var a3 = n5.apply(t11, e3);
      function _next(n6) {
        asyncGeneratorStep(a3, r4, o11, _next, _throw, "next", n6);
      }
      function _throw(n6) {
        asyncGeneratorStep(a3, r4, o11, _next, _throw, "throw", n6);
      }
      _next(void 0);
    });
  };
}

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
init_extends();

// ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a3, n5) {
  if (!(a3 instanceof n5))
    throw new TypeError("Cannot call a class as a function");
}

// ../../node_modules/@babel/runtime/helpers/esm/createClass.js
init_toPropertyKey();
function _defineProperties(e3, r4) {
  for (var t11 = 0; t11 < r4.length; t11++) {
    var o11 = r4[t11];
    o11.enumerable = o11.enumerable || false, o11.configurable = true, "value" in o11 && (o11.writable = true), Object.defineProperty(e3, toPropertyKey(o11.key), o11);
  }
}
function _createClass(e3, r4, t11) {
  return r4 && _defineProperties(e3.prototype, r4), t11 && _defineProperties(e3, t11), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}

// ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t11, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t12, e4) {
    return t12.__proto__ = e4, t12;
  }, _setPrototypeOf(t11, e3);
}

// ../../node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t11, e3) {
  if ("function" != typeof e3 && null !== e3)
    throw new TypeError("Super expression must either be null or a function");
  t11.prototype = Object.create(e3 && e3.prototype, {
    constructor: {
      value: t11,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t11, "prototype", {
    writable: false
  }), e3 && _setPrototypeOf(t11, e3);
}

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
init_typeof();

// ../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e3) {
  if (void 0 === e3)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t11, e3) {
  if (e3 && ("object" == _typeof(e3) || "function" == typeof e3))
    return e3;
  if (void 0 !== e3)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t11);
}

// ../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t11) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t12) {
    return t12.__proto__ || Object.getPrototypeOf(t12);
  }, _getPrototypeOf(t11);
}

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
init_defineProperty();
var import_regenerator = __toESM(require_regenerator2());
var import_react19 = __toESM(require_react());
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var async_syntax_highlighter_default = function(options) {
  var loader2 = options.loader, isLanguageRegistered2 = options.isLanguageRegistered, registerLanguage2 = options.registerLanguage, languageLoaders = options.languageLoaders, noAsyncLoadingLanguages = options.noAsyncLoadingLanguages;
  var ReactAsyncHighlighter = /* @__PURE__ */ function(_React$PureComponent) {
    _inherits(ReactAsyncHighlighter2, _React$PureComponent);
    var _super = _createSuper(ReactAsyncHighlighter2);
    function ReactAsyncHighlighter2() {
      _classCallCheck(this, ReactAsyncHighlighter2);
      return _super.apply(this, arguments);
    }
    _createClass(ReactAsyncHighlighter2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this = this;
        if (!ReactAsyncHighlighter2.astGeneratorPromise) {
          ReactAsyncHighlighter2.loadAstGenerator();
        }
        if (!ReactAsyncHighlighter2.astGenerator) {
          ReactAsyncHighlighter2.astGeneratorPromise.then(function() {
            _this.forceUpdate();
          });
        }
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "loadLanguage",
      value: function loadLanguage() {
        var _this2 = this;
        var language = this.props.language;
        if (language === "text") {
          return;
        }
        ReactAsyncHighlighter2.loadLanguage(language).then(function() {
          return _this2.forceUpdate();
        })["catch"](function() {
        });
      }
    }, {
      key: "normalizeLanguage",
      value: function normalizeLanguage2(language) {
        return ReactAsyncHighlighter2.isSupportedLanguage(language) ? language : "text";
      }
    }, {
      key: "render",
      value: function render() {
        return /* @__PURE__ */ import_react19.default.createElement(ReactAsyncHighlighter2.highlightInstance, _extends({}, this.props, {
          language: this.normalizeLanguage(this.props.language),
          astGenerator: ReactAsyncHighlighter2.astGenerator
        }));
      }
    }], [{
      key: "preload",
      value: function preload() {
        return ReactAsyncHighlighter2.loadAstGenerator();
      }
    }, {
      key: "loadLanguage",
      value: function() {
        var _loadLanguage = _asyncToGenerator(/* @__PURE__ */ import_regenerator.default.mark(function _callee(language) {
          var languageLoader;
          return import_regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  languageLoader = languageLoaders[language];
                  if (!(typeof languageLoader === "function")) {
                    _context.next = 5;
                    break;
                  }
                  return _context.abrupt("return", languageLoader(ReactAsyncHighlighter2.registerLanguage));
                case 5:
                  throw new Error("Language ".concat(language, " not supported"));
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function loadLanguage(_x) {
          return _loadLanguage.apply(this, arguments);
        }
        return loadLanguage;
      }()
    }, {
      key: "isSupportedLanguage",
      value: function isSupportedLanguage(language) {
        return ReactAsyncHighlighter2.isRegistered(language) || typeof languageLoaders[language] === "function";
      }
    }, {
      key: "loadAstGenerator",
      value: function loadAstGenerator() {
        ReactAsyncHighlighter2.astGeneratorPromise = loader2().then(function(astGenerator) {
          ReactAsyncHighlighter2.astGenerator = astGenerator;
          if (registerLanguage2) {
            ReactAsyncHighlighter2.languages.forEach(function(language, name) {
              return registerLanguage2(astGenerator, name, language);
            });
          }
        });
        return ReactAsyncHighlighter2.astGeneratorPromise;
      }
    }]);
    return ReactAsyncHighlighter2;
  }(import_react19.default.PureComponent);
  _defineProperty(ReactAsyncHighlighter, "astGenerator", null);
  _defineProperty(ReactAsyncHighlighter, "highlightInstance", highlight_default(null, {}));
  _defineProperty(ReactAsyncHighlighter, "astGeneratorPromise", null);
  _defineProperty(ReactAsyncHighlighter, "languages", /* @__PURE__ */ new Map());
  _defineProperty(ReactAsyncHighlighter, "supportedLanguages", options.supportedLanguages || Object.keys(languageLoaders || {}));
  _defineProperty(ReactAsyncHighlighter, "isRegistered", function(language) {
    if (noAsyncLoadingLanguages) {
      return true;
    }
    if (!registerLanguage2) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (!ReactAsyncHighlighter.astGenerator) {
      return ReactAsyncHighlighter.languages.has(language);
    }
    return isLanguageRegistered2(ReactAsyncHighlighter.astGenerator, language);
  });
  _defineProperty(ReactAsyncHighlighter, "registerLanguage", function(name, language) {
    if (!registerLanguage2) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (ReactAsyncHighlighter.astGenerator) {
      return registerLanguage2(ReactAsyncHighlighter.astGenerator, name, language);
    } else {
      ReactAsyncHighlighter.languages.set(name, language);
    }
  });
  return ReactAsyncHighlighter;
};

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/async-languages/create-language-async-loader.js
var import_regenerator2 = __toESM(require_regenerator2());
var create_language_async_loader_default = function(name, loader2) {
  return /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(/* @__PURE__ */ import_regenerator2.default.mark(function _callee(registerLanguage2) {
      var module;
      return import_regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return loader2();
            case 2:
              module = _context.sent;
              registerLanguage2(name, module["default"] || module);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/async-languages/hljs.js
var hljs_default = {
  oneC: create_language_async_loader_default("oneC", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oneC" */
      "/build/_shared/1c-IPKSHA4E.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_abnf" */
      "/build/_shared/abnf-C33QBXSX.js"
    );
  }),
  accesslog: create_language_async_loader_default("accesslog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_accesslog" */
      "/build/_shared/accesslog-UHSG2BZF.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_actionscript" */
      "/build/_shared/actionscript-NOEVHCAJ.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ada" */
      "/build/_shared/ada-KCSJZC4T.js"
    );
  }),
  angelscript: create_language_async_loader_default("angelscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_angelscript" */
      "/build/_shared/angelscript-J5QT7S4A.js"
    );
  }),
  apache: create_language_async_loader_default("apache", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_apache" */
      "/build/_shared/apache-GDDC7LQ3.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_applescript" */
      "/build/_shared/applescript-GDRRS2BT.js"
    );
  }),
  arcade: create_language_async_loader_default("arcade", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arcade" */
      "/build/_shared/arcade-MNZOWGEV.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arduino" */
      "/build/_shared/arduino-ONLMH7IA.js"
    );
  }),
  armasm: create_language_async_loader_default("armasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_armasm" */
      "/build/_shared/armasm-5MTCE2S5.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_asciidoc" */
      "/build/_shared/asciidoc-AJVCY74C.js"
    );
  }),
  aspectj: create_language_async_loader_default("aspectj", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_aspectj" */
      "/build/_shared/aspectj-XONGF66R.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autohotkey" */
      "/build/_shared/autohotkey-AYZ4LUJJ.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autoit" */
      "/build/_shared/autoit-ABYJWDX4.js"
    );
  }),
  avrasm: create_language_async_loader_default("avrasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_avrasm" */
      "/build/_shared/avrasm-BKD3NPZJ.js"
    );
  }),
  awk: create_language_async_loader_default("awk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_awk" */
      "/build/_shared/awk-5SOG2SZL.js"
    );
  }),
  axapta: create_language_async_loader_default("axapta", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_axapta" */
      "/build/_shared/axapta-ZWGH36IY.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bash" */
      "/build/_shared/bash-2JPXFWMK.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_basic" */
      "/build/_shared/basic-VU5EYEOM.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bnf" */
      "/build/_shared/bnf-T3KQHXJO.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_brainfuck" */
      "/build/_shared/brainfuck-3OAN3GLN.js"
    );
  }),
  cLike: create_language_async_loader_default("cLike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cLike" */
      "/build/_shared/c-like-J2NHU5CI.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_c" */
      "/build/_shared/c-S6JJOG7F.js"
    );
  }),
  cal: create_language_async_loader_default("cal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cal" */
      "/build/_shared/cal-7ZREG6PY.js"
    );
  }),
  capnproto: create_language_async_loader_default("capnproto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_capnproto" */
      "/build/_shared/capnproto-B6KKV6WA.js"
    );
  }),
  ceylon: create_language_async_loader_default("ceylon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ceylon" */
      "/build/_shared/ceylon-ZKJ6CMAP.js"
    );
  }),
  clean: create_language_async_loader_default("clean", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clean" */
      "/build/_shared/clean-X33RUM5L.js"
    );
  }),
  clojureRepl: create_language_async_loader_default("clojureRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojureRepl" */
      "/build/_shared/clojure-repl-X5VETLNI.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojure" */
      "/build/_shared/clojure-AMWNVHNT.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cmake" */
      "/build/_shared/cmake-OHI43MN5.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coffeescript" */
      "/build/_shared/coffeescript-7SVDFN7H.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coq" */
      "/build/_shared/coq-I6MBISEE.js"
    );
  }),
  cos: create_language_async_loader_default("cos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cos" */
      "/build/_shared/cos-OTXHFTTC.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cpp" */
      "/build/_shared/cpp-KY534ROQ.js"
    );
  }),
  crmsh: create_language_async_loader_default("crmsh", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crmsh" */
      "/build/_shared/crmsh-EQIYYD23.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crystal" */
      "/build/_shared/crystal-TKRKPCIQ.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csharp" */
      "/build/_shared/csharp-AOY2GLX6.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csp" */
      "/build/_shared/csp-GHOPDS4F.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_css" */
      "/build/_shared/css-TOK3G2XH.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_d" */
      "/build/_shared/d-HHKVDACB.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dart" */
      "/build/_shared/dart-RUSNUN43.js"
    );
  }),
  delphi: create_language_async_loader_default("delphi", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_delphi" */
      "/build/_shared/delphi-WVYNU27M.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_diff" */
      "/build/_shared/diff-CSNSKFAE.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_django" */
      "/build/_shared/django-LZDK32GX.js"
    );
  }),
  dns: create_language_async_loader_default("dns", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dns" */
      "/build/_shared/dns-EC57ZCT3.js"
    );
  }),
  dockerfile: create_language_async_loader_default("dockerfile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dockerfile" */
      "/build/_shared/dockerfile-ZJC5G4JE.js"
    );
  }),
  dos: create_language_async_loader_default("dos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dos" */
      "/build/_shared/dos-3EP5SJG3.js"
    );
  }),
  dsconfig: create_language_async_loader_default("dsconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dsconfig" */
      "/build/_shared/dsconfig-VFNAWR7R.js"
    );
  }),
  dts: create_language_async_loader_default("dts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dts" */
      "/build/_shared/dts-DRX5TT4I.js"
    );
  }),
  dust: create_language_async_loader_default("dust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dust" */
      "/build/_shared/dust-RFLKGTWW.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ebnf" */
      "/build/_shared/ebnf-2K7ELIYO.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elixir" */
      "/build/_shared/elixir-46BRCSM6.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elm" */
      "/build/_shared/elm-WXEVH4LG.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erb" */
      "/build/_shared/erb-2BQ4ROQY.js"
    );
  }),
  erlangRepl: create_language_async_loader_default("erlangRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlangRepl" */
      "/build/_shared/erlang-repl-NQ4A4RF6.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlang" */
      "/build/_shared/erlang-NOUNQZUB.js"
    );
  }),
  excel: create_language_async_loader_default("excel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_excel" */
      "/build/_shared/excel-DNTMJJF3.js"
    );
  }),
  fix: create_language_async_loader_default("fix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fix" */
      "/build/_shared/fix-BYQGB3GD.js"
    );
  }),
  flix: create_language_async_loader_default("flix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_flix" */
      "/build/_shared/flix-GXEJQ36B.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fortran" */
      "/build/_shared/fortran-4FENY6OD.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fsharp" */
      "/build/_shared/fsharp-7EJANNGL.js"
    );
  }),
  gams: create_language_async_loader_default("gams", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gams" */
      "/build/_shared/gams-4YAUNXTO.js"
    );
  }),
  gauss: create_language_async_loader_default("gauss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gauss" */
      "/build/_shared/gauss-CSYOGZKR.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gcode" */
      "/build/_shared/gcode-OQE6L2XT.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gherkin" */
      "/build/_shared/gherkin-PAVW34OH.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_glsl" */
      "/build/_shared/glsl-3XFBYYQU.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gml" */
      "/build/_shared/gml-O6LQ7DOF.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_go" */
      "/build/_shared/go-MAZI5OWP.js"
    );
  }),
  golo: create_language_async_loader_default("golo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_golo" */
      "/build/_shared/golo-YGMQZ22W.js"
    );
  }),
  gradle: create_language_async_loader_default("gradle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gradle" */
      "/build/_shared/gradle-6D3GYEMJ.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_groovy" */
      "/build/_shared/groovy-MYYZNIXH.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haml" */
      "/build/_shared/haml-OBQ7BWER.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_handlebars" */
      "/build/_shared/handlebars-BPQE3VDO.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haskell" */
      "/build/_shared/haskell-Q4LAZD77.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haxe" */
      "/build/_shared/haxe-OJMFVDER.js"
    );
  }),
  hsp: create_language_async_loader_default("hsp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hsp" */
      "/build/_shared/hsp-AWPNJWHJ.js"
    );
  }),
  htmlbars: create_language_async_loader_default("htmlbars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_htmlbars" */
      "/build/_shared/htmlbars-APYUL26S.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_http" */
      "/build/_shared/http-NDT6AFW2.js"
    );
  }),
  hy: create_language_async_loader_default("hy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hy" */
      "/build/_shared/hy-AH6F52TQ.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_inform7" */
      "/build/_shared/inform7-QJ4DD7HV.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ini" */
      "/build/_shared/ini-FMHP6J7N.js"
    );
  }),
  irpf90: create_language_async_loader_default("irpf90", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_irpf90" */
      "/build/_shared/irpf90-LGAZUJHT.js"
    );
  }),
  isbl: create_language_async_loader_default("isbl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_isbl" */
      "/build/_shared/isbl-D5GESWZW.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_java" */
      "/build/_shared/java-E54JBMMB.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_javascript" */
      "/build/_shared/javascript-7J5PVFM7.js"
    );
  }),
  jbossCli: create_language_async_loader_default("jbossCli", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_jbossCli" */
      "/build/_shared/jboss-cli-3EFU7SKJ.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_json" */
      "/build/_shared/json-WHDGF45S.js"
    );
  }),
  juliaRepl: create_language_async_loader_default("juliaRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_juliaRepl" */
      "/build/_shared/julia-repl-FNCWDQ5U.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_julia" */
      "/build/_shared/julia-PFBYOAVG.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_kotlin" */
      "/build/_shared/kotlin-65HXB34U.js"
    );
  }),
  lasso: create_language_async_loader_default("lasso", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lasso" */
      "/build/_shared/lasso-UF5VF6QS.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_latex" */
      "/build/_shared/latex-WB2B7ADL.js"
    );
  }),
  ldif: create_language_async_loader_default("ldif", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ldif" */
      "/build/_shared/ldif-HVHSOMYI.js"
    );
  }),
  leaf: create_language_async_loader_default("leaf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_leaf" */
      "/build/_shared/leaf-VQGGX7PV.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_less" */
      "/build/_shared/less-DNDSQKZ2.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lisp" */
      "/build/_shared/lisp-CU4XAYB7.js"
    );
  }),
  livecodeserver: create_language_async_loader_default("livecodeserver", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livecodeserver" */
      "/build/_shared/livecodeserver-MSL75AYE.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livescript" */
      "/build/_shared/livescript-RR3KXPCN.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_llvm" */
      "/build/_shared/llvm-MXUZY2NG.js"
    );
  }),
  lsl: create_language_async_loader_default("lsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lsl" */
      "/build/_shared/lsl-WDHI55YT.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lua" */
      "/build/_shared/lua-SPPIQZXR.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_makefile" */
      "/build/_shared/makefile-HQPARP43.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_markdown" */
      "/build/_shared/markdown-RHVAPKA4.js"
    );
  }),
  mathematica: create_language_async_loader_default("mathematica", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mathematica" */
      "/build/_shared/mathematica-HEP25EQ4.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_matlab" */
      "/build/_shared/matlab-ABHRWOTT.js"
    );
  }),
  maxima: create_language_async_loader_default("maxima", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_maxima" */
      "/build/_shared/maxima-PQKHY4KB.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mel" */
      "/build/_shared/mel-HXEUYW3T.js"
    );
  }),
  mercury: create_language_async_loader_default("mercury", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mercury" */
      "/build/_shared/mercury-HIDV7SBZ.js"
    );
  }),
  mipsasm: create_language_async_loader_default("mipsasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mipsasm" */
      "/build/_shared/mipsasm-JPKEFSL4.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mizar" */
      "/build/_shared/mizar-ZRTDJXJ6.js"
    );
  }),
  mojolicious: create_language_async_loader_default("mojolicious", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mojolicious" */
      "/build/_shared/mojolicious-HGKXBKLS.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_monkey" */
      "/build/_shared/monkey-WMSOXAHX.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_moonscript" */
      "/build/_shared/moonscript-SMVGHDVU.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_n1ql" */
      "/build/_shared/n1ql-QQ6BTB4V.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nginx" */
      "/build/_shared/nginx-7ILN5UEI.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nim" */
      "/build/_shared/nim-TW6FUM2E.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nix" */
      "/build/_shared/nix-THBG4LAT.js"
    );
  }),
  nodeRepl: create_language_async_loader_default("nodeRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nodeRepl" */
      "/build/_shared/node-repl-O2ICLQBA.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nsis" */
      "/build/_shared/nsis-5CY2IGLA.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_objectivec" */
      "/build/_shared/objectivec-CTXRL6TC.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ocaml" */
      "/build/_shared/ocaml-W4MG3ZCW.js"
    );
  }),
  openscad: create_language_async_loader_default("openscad", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_openscad" */
      "/build/_shared/openscad-YJQEQSMU.js"
    );
  }),
  oxygene: create_language_async_loader_default("oxygene", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oxygene" */
      "/build/_shared/oxygene-44IL7AEA.js"
    );
  }),
  parser3: create_language_async_loader_default("parser3", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_parser3" */
      "/build/_shared/parser3-SRJDQB5A.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_perl" */
      "/build/_shared/perl-M6EZHFA4.js"
    );
  }),
  pf: create_language_async_loader_default("pf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pf" */
      "/build/_shared/pf-X7P5IGAB.js"
    );
  }),
  pgsql: create_language_async_loader_default("pgsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pgsql" */
      "/build/_shared/pgsql-QCSP2FQC.js"
    );
  }),
  phpTemplate: create_language_async_loader_default("phpTemplate", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_phpTemplate" */
      "/build/_shared/php-template-P6NJTCWN.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_php" */
      "/build/_shared/php-2BEMAWSP.js"
    );
  }),
  plaintext: create_language_async_loader_default("plaintext", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_plaintext" */
      "/build/_shared/plaintext-BWCF6ZFV.js"
    );
  }),
  pony: create_language_async_loader_default("pony", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pony" */
      "/build/_shared/pony-Z7Z5LQGS.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_powershell" */
      "/build/_shared/powershell-CLQEPVGZ.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_processing" */
      "/build/_shared/processing-QVO6XVZA.js"
    );
  }),
  profile: create_language_async_loader_default("profile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_profile" */
      "/build/_shared/profile-FTNUDPO2.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_prolog" */
      "/build/_shared/prolog-AN5OSMMS.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_properties" */
      "/build/_shared/properties-DF2B5ZKV.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_protobuf" */
      "/build/_shared/protobuf-5M63AFPY.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_puppet" */
      "/build/_shared/puppet-UIOXKLBS.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_purebasic" */
      "/build/_shared/purebasic-7MB4F43O.js"
    );
  }),
  pythonRepl: create_language_async_loader_default("pythonRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pythonRepl" */
      "/build/_shared/python-repl-R6H4KFTT.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_python" */
      "/build/_shared/python-73C266VD.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_q" */
      "/build/_shared/q-GIS76RHU.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_qml" */
      "/build/_shared/qml-YR54X6VZ.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_r" */
      "/build/_shared/r-MGZM4FUU.js"
    );
  }),
  reasonml: create_language_async_loader_default("reasonml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_reasonml" */
      "/build/_shared/reasonml-4CQBVGJA.js"
    );
  }),
  rib: create_language_async_loader_default("rib", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rib" */
      "/build/_shared/rib-IPBKO7LS.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_roboconf" */
      "/build/_shared/roboconf-TOEYAKC7.js"
    );
  }),
  routeros: create_language_async_loader_default("routeros", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_routeros" */
      "/build/_shared/routeros-JWWEDVEH.js"
    );
  }),
  rsl: create_language_async_loader_default("rsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rsl" */
      "/build/_shared/rsl-A72YEBU3.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruby" */
      "/build/_shared/ruby-THCS76C6.js"
    );
  }),
  ruleslanguage: create_language_async_loader_default("ruleslanguage", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruleslanguage" */
      "/build/_shared/ruleslanguage-I47ADSG2.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rust" */
      "/build/_shared/rust-UL2BRG6H.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sas" */
      "/build/_shared/sas-2AMAMQFI.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scala" */
      "/build/_shared/scala-KSCWN52X.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scheme" */
      "/build/_shared/scheme-UUE7MSE2.js"
    );
  }),
  scilab: create_language_async_loader_default("scilab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scilab" */
      "/build/_shared/scilab-3WYN4EWD.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scss" */
      "/build/_shared/scss-G2SOKEMP.js"
    );
  }),
  shell: create_language_async_loader_default("shell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_shell" */
      "/build/_shared/shell-6Y37AU72.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smali" */
      "/build/_shared/smali-HSRKQQ5P.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smalltalk" */
      "/build/_shared/smalltalk-RBRXGAYB.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sml" */
      "/build/_shared/sml-LFNSAI73.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqf" */
      "/build/_shared/sqf-PL736WG2.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sql" */
      "/build/_shared/sql-JYMDUR3S.js"
    );
  }),
  sqlMore: create_language_async_loader_default("sqlMore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqlMore" */
      "/build/_shared/sql_more-7QOIJ3B2.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stan" */
      "/build/_shared/stan-QFWT5BN2.js"
    );
  }),
  stata: create_language_async_loader_default("stata", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stata" */
      "/build/_shared/stata-RITWKLTA.js"
    );
  }),
  step21: create_language_async_loader_default("step21", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_step21" */
      "/build/_shared/step21-KBGFBN2Z.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stylus" */
      "/build/_shared/stylus-AGGMHNVF.js"
    );
  }),
  subunit: create_language_async_loader_default("subunit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_subunit" */
      "/build/_shared/subunit-TBN23I3R.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_swift" */
      "/build/_shared/swift-2RPS6J6S.js"
    );
  }),
  taggerscript: create_language_async_loader_default("taggerscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_taggerscript" */
      "/build/_shared/taggerscript-M2XFEJXS.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tap" */
      "/build/_shared/tap-6BP2H7WO.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tcl" */
      "/build/_shared/tcl-7UABWQRL.js"
    );
  }),
  thrift: create_language_async_loader_default("thrift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_thrift" */
      "/build/_shared/thrift-D66KLTA6.js"
    );
  }),
  tp: create_language_async_loader_default("tp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tp" */
      "/build/_shared/tp-OLENCBUQ.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_twig" */
      "/build/_shared/twig-72ZCO7SO.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_typescript" */
      "/build/_shared/typescript-I53XKLFK.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vala" */
      "/build/_shared/vala-VXYUZK6S.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbnet" */
      "/build/_shared/vbnet-HRXLSA35.js"
    );
  }),
  vbscriptHtml: create_language_async_loader_default("vbscriptHtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscriptHtml" */
      "/build/_shared/vbscript-html-XLLGZQMF.js"
    );
  }),
  vbscript: create_language_async_loader_default("vbscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscript" */
      "/build/_shared/vbscript-HEZ7VS2Y.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_verilog" */
      "/build/_shared/verilog-3M6HMXRK.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vhdl" */
      "/build/_shared/vhdl-2JQWEDPL.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vim" */
      "/build/_shared/vim-GWBSWV4C.js"
    );
  }),
  x86asm: create_language_async_loader_default("x86asm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_x86asm" */
      "/build/_shared/x86asm-APHZLTJU.js"
    );
  }),
  xl: create_language_async_loader_default("xl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xl" */
      "/build/_shared/xl-7P4TFZJG.js"
    );
  }),
  xml: create_language_async_loader_default("xml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xml" */
      "/build/_shared/xml-URPKGRLJ.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xquery" */
      "/build/_shared/xquery-4GTGNZHA.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_yaml" */
      "/build/_shared/yaml-NBGEA765.js"
    );
  }),
  zephir: create_language_async_loader_default("zephir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_zephir" */
      "/build/_shared/zephir-UIPJ2B4I.js"
    );
  })
};

// ../../packages/myst-to-react/node_modules/react-syntax-highlighter/dist/esm/light-async.js
var light_async_default = async_syntax_highlighter_default({
  loader: function loader() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/lowlight-import" */
      "/build/_shared/core-Z44T46PJ.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  isLanguageRegistered: function isLanguageRegistered(instance, language) {
    return !!checkForListedLanguage_default(instance, language);
  },
  languageLoaders: hljs_default,
  registerLanguage: function registerLanguage(instance, name, language) {
    return instance.registerLanguage(name, language);
  }
});

// ../../packages/myst-to-react/dist/code.js
var import_classnames13 = __toESM(require_classnames(), 1);
var import_react20 = __toESM(require_react(), 1);
function normalizeLanguage(lang) {
  switch (lang) {
    case "html":
      return "xml";
    default:
      return lang;
  }
}
function CodeBlock(props) {
  const { value, lang, identifier, emphasizeLines, showLineNumbers, className, showCopy = true, startingLineNumber = 1, filename, shadow, background, border } = props;
  const highlighterProps = (0, import_react20.useMemo)(() => {
    const highlightLines = new Set(emphasizeLines);
    return {
      language: normalizeLanguage(lang),
      startingLineNumber,
      showLineNumbers,
      useInlineStyles: true,
      wrapLines: true,
      lineNumberContainerStyle: {
        // This stops page content shifts
        display: "inline-block",
        float: "left",
        minWidth: "1.25em",
        paddingRight: "1em",
        textAlign: "right",
        userSelect: "none",
        borderLeft: "4px solid transparent"
      },
      lineProps: (line) => {
        if (typeof line === "boolean")
          return {};
        return highlightLines.has(line) ? {
          "data-line-number": `${line}`,
          "data-highlight": "true"
        } : { "data-line-number": `${line}` };
      },
      customStyle: {
        backgroundColor: "unset"
      }
    };
  }, [emphasizeLines]);
  return (0, import_jsx_runtime34.jsxs)("div", { id: identifier, className: (0, import_classnames13.default)("relative myst-code group not-prose", className, {
    "my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900": shadow,
    "bg-stone-200/10": background,
    "border border-l-4 border-gray-200 border-l-blue-400 dark:border-l-blue-400 dark:border-gray-800": border
  }), children: [filename && (0, import_jsx_runtime34.jsxs)("div", { className: "flex flex-row pl-2 bg-white border-b dark:bg-slate-600 dark:border-slate-300", children: [(0, import_jsx_runtime34.jsx)(DocumentIcon_default, { width: "16px", height: "16px", className: "inline-block flex-none self-center text-gray-500 myst-code-filename-icon dark:text-gray-100" }), (0, import_jsx_runtime34.jsx)("div", { className: "self-center p-2 text-sm leading-3 myst-code-filename-title prose text-slate-600 dark:text-white", children: filename })] }), (0, import_jsx_runtime34.jsx)(light_async_default, Object.assign({}, highlighterProps, { className: "block overflow-auto p-3 myst-code-body hljs", children: value })), showCopy && (0, import_jsx_runtime34.jsx)(CopyIcon, { text: value, className: (0, import_classnames13.default)("absolute right-1 myst-code-copy-icon", {
    "top-[32px]": filename,
    "top-1": !filename
  }) })] });
}
var code2 = ({ node, className }) => {
  const child = (0, import_jsx_runtime34.jsx)(CodeBlock, { identifier: node.html_id, "data-mdast-node-type": node.type, "data-mdast-node-id": node.key, value: node.value || "", lang: node.lang, filename: node.filename, emphasizeLines: node.emphasizeLines, showLineNumbers: node.showLineNumbers, startingLineNumber: node.startingLineNumber, shadow: true, border: node.executable, background: !node.executable, className: (0, import_classnames13.default)({ hidden: node.visibility === "remove" }, node.class, className) });
  if (node.visibility === "hide") {
    return (0, import_jsx_runtime34.jsx)(Details, { title: "Source", children: child });
  }
  return child;
};
function isColor(maybeColorHash) {
  if (!maybeColorHash || maybeColorHash.length > 9)
    return void 0;
  if (!(/* @__PURE__ */ new Set([4, 7, 9])).has(maybeColorHash.length))
    return void 0;
  const match = /^#([0-9A-Fa-f]{3,8})$/.exec(maybeColorHash);
  if (!match)
    return void 0;
  const color2 = match[1];
  return color2;
}
var inlineCode = ({ node, className }) => {
  if (isColor(node.value)) {
    return (0, import_jsx_runtime34.jsxs)("code", { className: (0, import_classnames13.default)("px-1 rounded bg-slate-100 text-slate-700 dark:bg-slate-800 dark:text-slate-100", className), children: [node.value, (0, import_jsx_runtime34.jsx)("span", { style: { backgroundColor: node.value }, className: "inline-block w-[10px] h-[10px] rounded-full ml-1" })] });
  }
  if (node.children && node.children.length > 0) {
    return (0, import_jsx_runtime34.jsx)("code", { className, children: (0, import_jsx_runtime34.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime34.jsx)("code", { className, children: node.value });
};
var CODE_RENDERERS = {
  code: code2,
  inlineCode
};
var code_default = CODE_RENDERERS;

// ../../packages/myst-to-react/dist/math.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_classnames14 = __toESM(require_classnames(), 1);
var mathRenderer = ({ node, className }) => {
  if (node.type === "math") {
    if (node.error || !node.html) {
      return (0, import_jsx_runtime35.jsxs)("pre", { title: node.message, className, children: [(0, import_jsx_runtime35.jsxs)("span", { className: "text-red-500", children: [(0, import_jsx_runtime35.jsx)(ExclamationCircleIcon_default, { width: "1rem", height: "1rem", className: "inline mr-1" }), node.message, "\n\n"] }), node.value] });
    }
    const id = node.html_id || node.identifier || node.key;
    return (0, import_jsx_runtime35.jsxs)("div", { id, className: (0, import_classnames14.default)("flex my-5 group", className), children: [(0, import_jsx_runtime35.jsx)("div", { dangerouslySetInnerHTML: { __html: node.html }, className: "flex-grow overflow-x-auto overflow-y-hidden" }), node.enumerator && (0, import_jsx_runtime35.jsx)("div", { className: "relative self-center flex-none pl-2 m-0 text-right select-none", children: (0, import_jsx_runtime35.jsxs)(HashLink, { id, kind: "Equation", className: "text-inherit hover:text-inherit", children: ["(", node.enumerator, ")"] }) })] });
  }
  if (node.error || !node.html) {
    return (0, import_jsx_runtime35.jsx)(InlineError, { value: node.value, message: node.message, className });
  }
  return (0, import_jsx_runtime35.jsx)("span", { dangerouslySetInnerHTML: { __html: node.html }, className });
};
var MATH_RENDERERS = {
  math: mathRenderer,
  inlineMath: mathRenderer
};
var math_default = MATH_RENDERERS;

// ../../packages/myst-to-react/dist/reactive.js
var import_react21 = __toESM(require_react(), 1);
var RVar = ({ node, className }) => {
  return (0, import_react21.createElement)("r-var", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    format: node.format,
    className
  });
};
var RDisplay = ({ node, className }) => {
  return (0, import_react21.createElement)("r-display", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    format: node.format,
    className
  });
};
var RDynamic = ({ node, className }) => {
  return (0, import_react21.createElement)("r-dynamic", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    max: node.max,
    ":max": node.maxFunction,
    min: node.min,
    ":min": node.minFunction,
    step: node.step,
    ":step": node.stepFunction,
    ":change": node.changeFunction,
    format: node.format,
    className
  });
};
var RRange = ({ node, className }) => {
  return (0, import_react21.createElement)("r-range", {
    name: node.name,
    value: node.value,
    ":value": node.valueFunction,
    max: node.max,
    ":max": node.maxFunction,
    min: node.min,
    ":min": node.minFunction,
    step: node.step,
    ":step": node.stepFunction,
    ":change": node.changeFunction,
    className
  });
};
var REACTIVE_RENDERERS = {
  "r:var": RVar,
  "r:display": RDisplay,
  "r:dynamic": RDynamic,
  "r:range": RRange
};
var reactive_default = REACTIVE_RENDERERS;

// ../../packages/myst-to-react/dist/iframe.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_classnames15 = __toESM(require_classnames(), 1);
function getStyleValue(width) {
  if (typeof width === "number" && Number.isNaN(width)) {
    return void 0;
  }
  if (typeof width === "string") {
    if (width.endsWith("%")) {
      return getStyleValue(Number(width.replace("%", "")));
    } else if (width.endsWith("px")) {
      const px = getStyleValue(Number(width.replace("px", "")));
      return px ? px / 750 : 70;
    } else if (!Number.isNaN(Number(width))) {
      return Number(width);
    }
    console.log(`Unknown width ${width} in getImageWidth`);
    return void 0;
  }
  return width;
}
var IFrame = ({ node, className }) => {
  const width = getStyleValue(node.width) || 70;
  return (0, import_jsx_runtime36.jsx)("div", { id: node.label || void 0, style: { textAlign: node.align || "center" }, className: (0, import_classnames15.default)("leading-[0]", node.class, className), children: (0, import_jsx_runtime36.jsx)("div", { className: "relative inline-block", style: {
    paddingBottom: "60%",
    width: `min(max(${width}%, 500px), 100%)`
  }, children: (0, import_jsx_runtime36.jsx)("iframe", { width: "100%", height: "100%", src: node.src, title: node.title, allowFullScreen: true, allow: "autoplay", style: {
    width: "100%",
    height: "100%",
    position: "absolute",
    top: 0,
    left: 0,
    border: "none"
  } }) }) });
};
var IFRAME_RENDERERS = {
  iframe: IFrame
};
var iframe_default = IFRAME_RENDERERS;

// ../../packages/myst-to-react/dist/image.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_classnames16 = __toESM(require_classnames(), 1);
function getStyleValue2(width) {
  if (typeof width === "number" && Number.isNaN(width)) {
    return void 0;
  }
  if (typeof width === "string") {
    if (width.endsWith("%")) {
      return width;
    } else if (width.endsWith("px")) {
      return Number(width.replace("px", ""));
    } else if (!Number.isNaN(Number(width))) {
      return Number(width);
    }
    console.log(`Unknown width ${width} in getImageWidth`);
    return void 0;
  }
  return width;
}
function alignToMargin(align) {
  switch (align) {
    case "left":
      return { marginRight: "auto" };
    case "right":
      return { marginLeft: "auto" };
    case "center":
      return { marginLeft: "auto", marginRight: "auto" };
    default:
      return {};
  }
}
function Video({ className, id, src, urlSource, align = "center", width, height }) {
  return (0, import_jsx_runtime37.jsx)("video", {
    className,
    id,
    style: Object.assign({ width: getStyleValue2(width), height: getStyleValue2(height) }, alignToMargin(align)),
    src,
    "data-canonical-url": urlSource,
    autoPlay: true,
    // For autoplay, the element needs to be muted to actually start!
    muted: true,
    "webkit-playsinline": "true",
    playsInline: true,
    loop: true
  });
}
function Picture({ className, id, src, srcOptimized, urlSource, align = "center", alt, width, height }) {
  if (src.endsWith(".mp4") || (urlSource === null || urlSource === void 0 ? void 0 : urlSource.endsWith(".mp4"))) {
    return (0, import_jsx_runtime37.jsx)(Video, { className, id, width, height, align, src, urlSource });
  }
  const image = (0, import_jsx_runtime37.jsx)("img", {
    id,
    style: Object.assign({ width: getStyleValue2(width), height: getStyleValue2(height) }, alignToMargin(align)),
    src,
    alt,
    "data-canonical-url": urlSource,
    // Don't set className if nested under picture
    className: srcOptimized ? void 0 : className
  });
  if (!srcOptimized)
    return image;
  return (0, import_jsx_runtime37.jsxs)("picture", { className, children: [(0, import_jsx_runtime37.jsx)("source", { srcSet: srcOptimized, type: "image/webp" }), image] });
}
var Image2 = ({ node, className }) => {
  return (0, import_jsx_runtime37.jsx)(Picture, {
    className: (0, import_classnames16.default)(node.class, className),
    id: node.html_id || node.identifier || node.key,
    src: node.url,
    srcOptimized: node.urlOptimized,
    alt: node.alt || node.title,
    width: node.width || void 0,
    height: node.height || void 0,
    align: node.align,
    // Note that sourceUrl is for backwards compatibility
    urlSource: node.urlSource || node.sourceUrl
  });
};
var IMAGE_RENDERERS = {
  image: Image2
};
var image_default = IMAGE_RENDERERS;

// ../../packages/myst-to-react/dist/links/index.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);

// ../../packages/myst-to-react/dist/links/wiki.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/swr/dist/index/index.mjs
var import_react24 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);

// ../../node_modules/swr/dist/_internal/config-context-12s-Dh3trQsc.mjs
var import_react22 = __toESM(require_react(), 1);

// ../../node_modules/swr/dist/_internal/events.mjs
var events_exports = {};
__export(events_exports, {
  ERROR_REVALIDATE_EVENT: () => ERROR_REVALIDATE_EVENT,
  FOCUS_EVENT: () => FOCUS_EVENT,
  MUTATE_EVENT: () => MUTATE_EVENT,
  RECONNECT_EVENT: () => RECONNECT_EVENT
});
var FOCUS_EVENT = 0;
var RECONNECT_EVENT = 1;
var MUTATE_EVENT = 2;
var ERROR_REVALIDATE_EVENT = 3;

// ../../node_modules/dequal/lite/index.mjs
var has = Object.prototype.hasOwnProperty;
function dequal(foo, bar) {
  var ctor2, len;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor2 = foo.constructor) === bar.constructor) {
    if (ctor2 === Date)
      return foo.getTime() === bar.getTime();
    if (ctor2 === RegExp)
      return foo.toString() === bar.toString();
    if (ctor2 === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (!ctor2 || typeof foo === "object") {
      len = 0;
      for (ctor2 in foo) {
        if (has.call(foo, ctor2) && ++len && !has.call(bar, ctor2))
          return false;
        if (!(ctor2 in bar) || !dequal(foo[ctor2], bar[ctor2]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// ../../node_modules/swr/dist/_internal/config-context-12s-Dh3trQsc.mjs
"use client";
var SWRGlobalState = /* @__PURE__ */ new WeakMap();
var noop3 = () => {
};
var UNDEFINED = (
  /*#__NOINLINE__*/
  noop3()
);
var OBJECT = Object;
var isUndefined = (v4) => v4 === UNDEFINED;
var isFunction2 = (v4) => typeof v4 == "function";
var mergeObjects = (a3, b2) => ({
  ...a3,
  ...b2
});
var isPromiseLike = (x2) => isFunction2(x2.then);
var EMPTY_CACHE = {};
var INITIAL_CACHE = {};
var STR_UNDEFINED = "undefined";
var isWindowDefined = typeof window != STR_UNDEFINED;
var isDocumentDefined = typeof document != STR_UNDEFINED;
var isLegacyDeno = isWindowDefined && "Deno" in window;
var hasRequestAnimationFrame = () => isWindowDefined && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
var createCacheHelper = (cache2, key) => {
  const state = SWRGlobalState.get(cache2);
  return [
    // Getter
    () => !isUndefined(key) && cache2.get(key) || EMPTY_CACHE,
    // Setter
    (info) => {
      if (!isUndefined(key)) {
        const prev = cache2.get(key);
        if (!(key in INITIAL_CACHE)) {
          INITIAL_CACHE[key] = prev;
        }
        state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);
      }
    },
    // Subscriber
    state[6],
    // Get server cache snapshot
    () => {
      if (!isUndefined(key)) {
        if (key in INITIAL_CACHE)
          return INITIAL_CACHE[key];
      }
      return !isUndefined(key) && cache2.get(key) || EMPTY_CACHE;
    }
  ];
};
var online = true;
var isOnline = () => online;
var [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  noop3,
  noop3
];
var isVisible = () => {
  const visibilityState = isDocumentDefined && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
};
var initFocus = (callback) => {
  if (isDocumentDefined) {
    document.addEventListener("visibilitychange", callback);
  }
  onWindowEvent("focus", callback);
  return () => {
    if (isDocumentDefined) {
      document.removeEventListener("visibilitychange", callback);
    }
    offWindowEvent("focus", callback);
  };
};
var initReconnect = (callback) => {
  const onOnline = () => {
    online = true;
    callback();
  };
  const onOffline = () => {
    online = false;
  };
  onWindowEvent("online", onOnline);
  onWindowEvent("offline", onOffline);
  return () => {
    offWindowEvent("online", onOnline);
    offWindowEvent("offline", onOffline);
  };
};
var preset = {
  isOnline,
  isVisible
};
var defaultConfigOptions = {
  initFocus,
  initReconnect
};
var IS_REACT_LEGACY = !import_react22.default.useId;
var IS_SERVER = !isWindowDefined || isLegacyDeno;
var rAF = (f6) => hasRequestAnimationFrame() ? window["requestAnimationFrame"](f6) : setTimeout(f6, 1);
var useIsomorphicLayoutEffect = IS_SERVER ? import_react22.useEffect : import_react22.useLayoutEffect;
var navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
var slowConnection = !IS_SERVER && navigatorConnection && ([
  "slow-2g",
  "2g"
].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
var table = /* @__PURE__ */ new WeakMap();
var getTypeName = (value) => OBJECT.prototype.toString.call(value);
var isObjectTypeName = (typeName, type) => typeName === `[object ${type}]`;
var counter = 0;
var stableHash = (arg) => {
  const type = typeof arg;
  const typeName = getTypeName(arg);
  const isDate = isObjectTypeName(typeName, "Date");
  const isRegex = isObjectTypeName(typeName, "RegExp");
  const isPlainObject = isObjectTypeName(typeName, "Object");
  let result2;
  let index2;
  if (OBJECT(arg) === arg && !isDate && !isRegex) {
    result2 = table.get(arg);
    if (result2)
      return result2;
    result2 = ++counter + "~";
    table.set(arg, result2);
    if (Array.isArray(arg)) {
      result2 = "@";
      for (index2 = 0; index2 < arg.length; index2++) {
        result2 += stableHash(arg[index2]) + ",";
      }
      table.set(arg, result2);
    }
    if (isPlainObject) {
      result2 = "#";
      const keys2 = OBJECT.keys(arg).sort();
      while (!isUndefined(index2 = keys2.pop())) {
        if (!isUndefined(arg[index2])) {
          result2 += index2 + ":" + stableHash(arg[index2]) + ",";
        }
      }
      table.set(arg, result2);
    }
  } else {
    result2 = isDate ? arg.toJSON() : type == "symbol" ? arg.toString() : type == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result2;
};
var serialize = (key) => {
  if (isFunction2(key)) {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  const args = key;
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  return [
    key,
    args
  ];
};
var __timestamp = 0;
var getTimestamp = () => ++__timestamp;
async function internalMutate(...args) {
  const [cache2, _key, _data, _opts] = args;
  const options = mergeObjects({
    populateCache: true,
    throwOnError: true
  }, typeof _opts === "boolean" ? {
    revalidate: _opts
  } : _opts || {});
  let populateCache = options.populateCache;
  const rollbackOnErrorOption = options.rollbackOnError;
  let optimisticData = options.optimisticData;
  const rollbackOnError = (error) => {
    return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;
  };
  const throwOnError = options.throwOnError;
  if (isFunction2(_key)) {
    const keyFilter = _key;
    const matchedKeys = [];
    const it = cache2.keys();
    for (const key of it) {
      if (
        // Skip the special useSWRInfinite and useSWRSubscription keys.
        !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k)
      ) {
        matchedKeys.push(key);
      }
    }
    return Promise.all(matchedKeys.map(mutateByKey));
  }
  return mutateByKey(_key);
  async function mutateByKey(_k) {
    const [key] = serialize(_k);
    if (!key)
      return;
    const [get2, set2] = createCacheHelper(cache2, key);
    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
    const startRevalidate = () => {
      const revalidators = EVENT_REVALIDATORS[key];
      const revalidate = isFunction2(options.revalidate) ? options.revalidate(get2().data, _k) : options.revalidate !== false;
      if (revalidate) {
        delete FETCH[key];
        delete PRELOAD[key];
        if (revalidators && revalidators[0]) {
          return revalidators[0](MUTATE_EVENT).then(() => get2().data);
        }
      }
      return get2().data;
    };
    if (args.length < 3) {
      return startRevalidate();
    }
    let data = _data;
    let error;
    let isError2 = false;
    const beforeMutationTs = getTimestamp();
    MUTATION[key] = [
      beforeMutationTs,
      0
    ];
    const hasOptimisticData = !isUndefined(optimisticData);
    const state = get2();
    const displayedData = state.data;
    const currentData = state._c;
    const committedData = isUndefined(currentData) ? displayedData : currentData;
    if (hasOptimisticData) {
      optimisticData = isFunction2(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;
      set2({
        data: optimisticData,
        _c: committedData
      });
    }
    if (isFunction2(data)) {
      try {
        data = data(committedData);
      } catch (err) {
        error = err;
        isError2 = true;
      }
    }
    if (data && isPromiseLike(data)) {
      data = await data.catch((err) => {
        error = err;
        isError2 = true;
      });
      if (beforeMutationTs !== MUTATION[key][0]) {
        if (isError2)
          throw error;
        return data;
      } else if (isError2 && hasOptimisticData && rollbackOnError(error)) {
        populateCache = true;
        set2({
          data: committedData,
          _c: UNDEFINED
        });
      }
    }
    if (populateCache) {
      if (!isError2) {
        if (isFunction2(populateCache)) {
          const populateCachedData = populateCache(data, committedData);
          set2({
            data: populateCachedData,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        } else {
          set2({
            data,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        }
      }
    }
    MUTATION[key][1] = getTimestamp();
    Promise.resolve(startRevalidate()).then(() => {
      set2({
        _c: UNDEFINED
      });
    });
    if (isError2) {
      if (throwOnError)
        throw error;
      return;
    }
    return data;
  }
}
var revalidateAllKeys = (revalidators, type) => {
  for (const key in revalidators) {
    if (revalidators[key][0])
      revalidators[key][0](type);
  }
};
var initCache = (provider, options) => {
  if (!SWRGlobalState.has(provider)) {
    const opts = mergeObjects(defaultConfigOptions, options);
    const EVENT_REVALIDATORS = /* @__PURE__ */ Object.create(null);
    const mutate2 = internalMutate.bind(UNDEFINED, provider);
    let unmount = noop3;
    const subscriptions = /* @__PURE__ */ Object.create(null);
    const subscribe = (key, callback) => {
      const subs = subscriptions[key] || [];
      subscriptions[key] = subs;
      subs.push(callback);
      return () => subs.splice(subs.indexOf(callback), 1);
    };
    const setter = (key, value, prev) => {
      provider.set(key, value);
      const subs = subscriptions[key];
      if (subs) {
        for (const fn of subs) {
          fn(value, prev);
        }
      }
    };
    const initProvider = () => {
      if (!SWRGlobalState.has(provider)) {
        SWRGlobalState.set(provider, [
          EVENT_REVALIDATORS,
          /* @__PURE__ */ Object.create(null),
          /* @__PURE__ */ Object.create(null),
          /* @__PURE__ */ Object.create(null),
          mutate2,
          setter,
          subscribe
        ]);
        if (!IS_SERVER) {
          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
          unmount = () => {
            releaseFocus && releaseFocus();
            releaseReconnect && releaseReconnect();
            SWRGlobalState.delete(provider);
          };
        }
      }
    };
    initProvider();
    return [
      provider,
      mutate2,
      initProvider,
      unmount
    ];
  }
  return [
    provider,
    SWRGlobalState.get(provider)[4]
  ];
};
var onErrorRetry = (_4, __, config, revalidate, opts) => {
  const maxRetryCount = config.errorRetryCount;
  const currentRetryCount = opts.retryCount;
  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;
  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
    return;
  }
  setTimeout(revalidate, timeout, opts);
};
var compare = dequal;
var [cache, mutate] = initCache(/* @__PURE__ */ new Map());
var defaultConfig = mergeObjects(
  {
    // events
    onLoadingSlow: noop3,
    onSuccess: noop3,
    onError: noop3,
    onErrorRetry,
    onDiscarded: noop3,
    // switches
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    revalidateIfStale: true,
    shouldRetryOnError: true,
    // timeouts
    errorRetryInterval: slowConnection ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: slowConnection ? 5e3 : 3e3,
    // providers
    compare,
    isPaused: () => false,
    cache,
    mutate,
    fallback: {}
  },
  // use web preset by default
  preset
);
var mergeConfigs = (a3, b2) => {
  const v4 = mergeObjects(a3, b2);
  if (b2) {
    const { use: u1, fallback: f1 } = a3;
    const { use: u22, fallback: f22 } = b2;
    if (u1 && u22) {
      v4.use = u1.concat(u22);
    }
    if (f1 && f22) {
      v4.fallback = mergeObjects(f1, f22);
    }
  }
  return v4;
};
var SWRConfigContext = (0, import_react22.createContext)({});
var SWRConfig = (props) => {
  const { value } = props;
  const parentConfig = (0, import_react22.useContext)(SWRConfigContext);
  const isFunctionalConfig = isFunction2(value);
  const config = (0, import_react22.useMemo)(() => isFunctionalConfig ? value(parentConfig) : value, [
    isFunctionalConfig,
    parentConfig,
    value
  ]);
  const extendedConfig = (0, import_react22.useMemo)(() => isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [
    isFunctionalConfig,
    parentConfig,
    config
  ]);
  const provider = config && config.provider;
  const cacheContextRef = (0, import_react22.useRef)(UNDEFINED);
  if (provider && !cacheContextRef.current) {
    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);
  }
  const cacheContext = cacheContextRef.current;
  if (cacheContext) {
    extendedConfig.cache = cacheContext[0];
    extendedConfig.mutate = cacheContext[1];
  }
  useIsomorphicLayoutEffect(() => {
    if (cacheContext) {
      cacheContext[2] && cacheContext[2]();
      return cacheContext[3];
    }
  }, []);
  return (0, import_react22.createElement)(SWRConfigContext.Provider, mergeObjects(props, {
    value: extendedConfig
  }));
};

// ../../node_modules/swr/dist/_internal/constants.mjs
var INFINITE_PREFIX = "$inf$";

// ../../node_modules/swr/dist/_internal/index.mjs
var import_react23 = __toESM(require_react(), 1);
var enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
var use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
var setupDevTools = () => {
  if (enableDevtools) {
    window.__SWR_DEVTOOLS_REACT__ = import_react23.default;
  }
};
var normalize = (args) => {
  return isFunction2(args[1]) ? [
    args[0],
    args[1],
    args[2] || {}
  ] : [
    args[0],
    null,
    (args[1] === null ? args[2] : args[1]) || {}
  ];
};
var useSWRConfig = () => {
  const parentConfig = (0, import_react23.useContext)(SWRConfigContext);
  const mergedConfig = (0, import_react23.useMemo)(() => mergeObjects(defaultConfig, parentConfig), [
    parentConfig
  ]);
  return mergedConfig;
};
var middleware = (useSWRNext) => (key_, fetcher_, config) => {
  const fetcher7 = fetcher_ && ((...args) => {
    const [key] = serialize(key_);
    const [, , , PRELOAD] = SWRGlobalState.get(cache);
    if (key.startsWith(INFINITE_PREFIX)) {
      return fetcher_(...args);
    }
    const req = PRELOAD[key];
    if (isUndefined(req))
      return fetcher_(...args);
    delete PRELOAD[key];
    return req;
  });
  return useSWRNext(key_, fetcher7, config);
};
var BUILT_IN_MIDDLEWARE = use.concat(middleware);
var withArgs = (hook) => {
  return function useSWRArgs(...args) {
    const fallbackConfig = useSWRConfig();
    const [key, fn, _config] = normalize(args);
    const config = mergeConfigs(fallbackConfig, _config);
    let next = hook;
    const { use: use4 } = config;
    const middleware2 = (use4 || []).concat(BUILT_IN_MIDDLEWARE);
    for (let i6 = middleware2.length; i6--; ) {
      next = middleware2[i6](next);
    }
    return next(key, fn || config.fetcher || null, config);
  };
};
var subscribeCallback = (key, callbacks, callback) => {
  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  keyedRevalidators.push(callback);
  return () => {
    const index2 = keyedRevalidators.indexOf(callback);
    if (index2 >= 0) {
      keyedRevalidators[index2] = keyedRevalidators[keyedRevalidators.length - 1];
      keyedRevalidators.pop();
    }
  };
};
var withMiddleware = (useSWR2, middleware2) => {
  return (...args) => {
    const [key, fn, config] = normalize(args);
    const uses = (config.use || []).concat(middleware2);
    return useSWR2(key, fn, {
      ...config,
      use: uses
    });
  };
};
setupDevTools();

// ../../node_modules/swr/dist/index/index.mjs
var noop4 = () => {
};
var UNDEFINED2 = (
  /*#__NOINLINE__*/
  noop4()
);
var use2 = import_react24.default.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((thenable) => {
  switch (thenable.status) {
    case "pending":
      throw thenable;
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      thenable.status = "pending";
      thenable.then((v4) => {
        thenable.status = "fulfilled";
        thenable.value = v4;
      }, (e3) => {
        thenable.status = "rejected";
        thenable.reason = e3;
      });
      throw thenable;
  }
});
var WITH_DEDUPE = {
  dedupe: true
};
var resolvedUndef = Promise.resolve(UNDEFINED);
var useSWRHandler = (_key, fetcher7, config) => {
  const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData, strictServerPrefetchWarning } = config;
  const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
  const [key, fnArg] = serialize(_key);
  const initialMountedRef = (0, import_react24.useRef)(false);
  const unmountedRef = (0, import_react24.useRef)(false);
  const keyRef = (0, import_react24.useRef)(key);
  const fetcherRef = (0, import_react24.useRef)(fetcher7);
  const configRef = (0, import_react24.useRef)(config);
  const getConfig = () => configRef.current;
  const isActive = () => getConfig().isVisible() && getConfig().isOnline();
  const [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache2, key);
  const stateDependencies = (0, import_react24.useRef)({}).current;
  const fallback = isUndefined(fallbackData) ? isUndefined(config.fallback) ? UNDEFINED : config.fallback[key] : fallbackData;
  const isEqual3 = (prev, current) => {
    for (const _4 in stateDependencies) {
      const t11 = _4;
      if (t11 === "data") {
        if (!compare2(prev[t11], current[t11])) {
          if (!isUndefined(prev[t11])) {
            return false;
          }
          if (!compare2(returnedData, current[t11])) {
            return false;
          }
        }
      } else {
        if (current[t11] !== prev[t11]) {
          return false;
        }
      }
    }
    return true;
  };
  const getSnapshot = (0, import_react24.useMemo)(() => {
    const shouldStartRequest = (() => {
      if (!key)
        return false;
      if (!fetcher7)
        return false;
      if (!isUndefined(revalidateOnMount))
        return revalidateOnMount;
      if (getConfig().isPaused())
        return false;
      if (suspense)
        return false;
      return revalidateIfStale !== false;
    })();
    const getSelectedCache = (state) => {
      const snapshot = mergeObjects(state);
      delete snapshot._k;
      if (!shouldStartRequest) {
        return snapshot;
      }
      return {
        isValidating: true,
        isLoading: true,
        ...snapshot
      };
    };
    const cachedData2 = getCache();
    const initialData = getInitialCache();
    const clientSnapshot = getSelectedCache(cachedData2);
    const serverSnapshot = cachedData2 === initialData ? clientSnapshot : getSelectedCache(initialData);
    let memorizedSnapshot = clientSnapshot;
    return [
      () => {
        const newSnapshot = getSelectedCache(getCache());
        const compareResult = isEqual3(newSnapshot, memorizedSnapshot);
        if (compareResult) {
          memorizedSnapshot.data = newSnapshot.data;
          memorizedSnapshot.isLoading = newSnapshot.isLoading;
          memorizedSnapshot.isValidating = newSnapshot.isValidating;
          memorizedSnapshot.error = newSnapshot.error;
          return memorizedSnapshot;
        } else {
          memorizedSnapshot = newSnapshot;
          return newSnapshot;
        }
      },
      () => serverSnapshot
    ];
  }, [
    cache2,
    key
  ]);
  const cached = (0, import_shim.useSyncExternalStore)((0, import_react24.useCallback)(
    (callback) => subscribeCache(key, (current, prev) => {
      if (!isEqual3(prev, current))
        callback();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      cache2,
      key
    ]
  ), getSnapshot[0], getSnapshot[1]);
  const isInitialMount = !initialMountedRef.current;
  const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
  const cachedData = cached.data;
  const data = isUndefined(cachedData) ? fallback && isPromiseLike(fallback) ? use2(fallback) : fallback : cachedData;
  const error = cached.error;
  const laggyDataRef = (0, import_react24.useRef)(data);
  const returnedData = keepPreviousData ? isUndefined(cachedData) ? isUndefined(laggyDataRef.current) ? data : laggyDataRef.current : cachedData : data;
  const hasKeyButNoData = key && isUndefined(data);
  const isHydration = !IS_SERVER && // eslint-disable-next-line react-hooks/rules-of-hooks
  (0, import_shim.useSyncExternalStore)(() => noop3, () => false, () => true);
  if (strictServerPrefetchWarning && isHydration && !suspense && hasKeyButNoData) {
    console.warn(`Missing pre-initiated data for serialized key "${key}" during server-side rendering. Data fethcing should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);
  }
  const shouldDoInitialRevalidation = (() => {
    if (hasRevalidator && !isUndefined(error))
      return false;
    if (isInitialMount && !isUndefined(revalidateOnMount))
      return revalidateOnMount;
    if (getConfig().isPaused())
      return false;
    if (suspense)
      return isUndefined(data) ? false : revalidateIfStale;
    return isUndefined(data) || revalidateIfStale;
  })();
  const defaultValidatingState = !!(key && fetcher7 && isInitialMount && shouldDoInitialRevalidation);
  const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
  const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
  const revalidate = (0, import_react24.useCallback)(
    async (revalidateOpts) => {
      const currentFetcher = fetcherRef.current;
      if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
        return false;
      }
      let newData;
      let startAt;
      let loading = true;
      const opts = revalidateOpts || {};
      const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
      const callbackSafeguard = () => {
        if (IS_REACT_LEGACY) {
          return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
        }
        return key === keyRef.current;
      };
      const finalState = {
        isValidating: false,
        isLoading: false
      };
      const finishRequestAndUpdateState = () => {
        setCache(finalState);
      };
      const cleanupState = () => {
        const requestInfo = FETCH[key];
        if (requestInfo && requestInfo[1] === startAt) {
          delete FETCH[key];
        }
      };
      const initialState = {
        isValidating: true
      };
      if (isUndefined(getCache().data)) {
        initialState.isLoading = true;
      }
      try {
        if (shouldStartNewRequest) {
          setCache(initialState);
          if (config.loadingTimeout && isUndefined(getCache().data)) {
            setTimeout(() => {
              if (loading && callbackSafeguard()) {
                getConfig().onLoadingSlow(key, config);
              }
            }, config.loadingTimeout);
          }
          FETCH[key] = [
            currentFetcher(fnArg),
            getTimestamp()
          ];
        }
        ;
        [newData, startAt] = FETCH[key];
        newData = await newData;
        if (shouldStartNewRequest) {
          setTimeout(cleanupState, config.dedupingInterval);
        }
        if (!FETCH[key] || FETCH[key][1] !== startAt) {
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        finalState.error = UNDEFINED;
        const mutationInfo = MUTATION[key];
        if (!isUndefined(mutationInfo) && // case 1
        (startAt <= mutationInfo[0] || // case 2
        startAt <= mutationInfo[1] || // case 3
        mutationInfo[1] === 0)) {
          finishRequestAndUpdateState();
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        const cacheData = getCache().data;
        finalState.data = compare2(cacheData, newData) ? cacheData : newData;
        if (shouldStartNewRequest) {
          if (callbackSafeguard()) {
            getConfig().onSuccess(newData, key, config);
          }
        }
      } catch (err) {
        cleanupState();
        const currentConfig = getConfig();
        const { shouldRetryOnError } = currentConfig;
        if (!currentConfig.isPaused()) {
          finalState.error = err;
          if (shouldStartNewRequest && callbackSafeguard()) {
            currentConfig.onError(err, key, currentConfig);
            if (shouldRetryOnError === true || isFunction2(shouldRetryOnError) && shouldRetryOnError(err)) {
              if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {
                currentConfig.onErrorRetry(err, key, currentConfig, (_opts) => {
                  const revalidators = EVENT_REVALIDATORS[key];
                  if (revalidators && revalidators[0]) {
                    revalidators[0](events_exports.ERROR_REVALIDATE_EVENT, _opts);
                  }
                }, {
                  retryCount: (opts.retryCount || 0) + 1,
                  dedupe: true
                });
              }
            }
          }
        }
      }
      loading = false;
      finishRequestAndUpdateState();
      return true;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      key,
      cache2
    ]
  );
  const boundMutate = (0, import_react24.useCallback)(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...args) => {
      return internalMutate(cache2, keyRef.current, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useIsomorphicLayoutEffect(() => {
    fetcherRef.current = fetcher7;
    configRef.current = config;
    if (!isUndefined(cachedData)) {
      laggyDataRef.current = cachedData;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (!key)
      return;
    const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    let nextFocusRevalidatedAt = 0;
    if (getConfig().revalidateOnFocus) {
      const initNow = Date.now();
      nextFocusRevalidatedAt = initNow + getConfig().focusThrottleInterval;
    }
    const onRevalidate = (type, opts = {}) => {
      if (type == events_exports.FOCUS_EVENT) {
        const now = Date.now();
        if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {
          nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;
          softRevalidate();
        }
      } else if (type == events_exports.RECONNECT_EVENT) {
        if (getConfig().revalidateOnReconnect && isActive()) {
          softRevalidate();
        }
      } else if (type == events_exports.MUTATE_EVENT) {
        return revalidate();
      } else if (type == events_exports.ERROR_REVALIDATE_EVENT) {
        return revalidate(opts);
      }
      return;
    };
    const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
    unmountedRef.current = false;
    keyRef.current = key;
    initialMountedRef.current = true;
    setCache({
      _k: fnArg
    });
    if (shouldDoInitialRevalidation) {
      if (!FETCH[key]) {
        if (isUndefined(data) || IS_SERVER) {
          softRevalidate();
        } else {
          rAF(softRevalidate);
        }
      }
    }
    return () => {
      unmountedRef.current = true;
      unsubEvents();
    };
  }, [
    key
  ]);
  useIsomorphicLayoutEffect(() => {
    let timer;
    function next() {
      const interval = isFunction2(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;
      if (interval && timer !== -1) {
        timer = setTimeout(execute, interval);
      }
    }
    function execute() {
      if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
        revalidate(WITH_DEDUPE).then(next);
      } else {
        next();
      }
    }
    next();
    return () => {
      if (timer) {
        clearTimeout(timer);
        timer = -1;
      }
    };
  }, [
    refreshInterval,
    refreshWhenHidden,
    refreshWhenOffline,
    key
  ]);
  (0, import_react24.useDebugValue)(returnedData);
  if (suspense) {
    if (!IS_REACT_LEGACY && IS_SERVER && hasKeyButNoData) {
      throw new Error("Fallback data is required when using Suspense in SSR.");
    }
    if (hasKeyButNoData) {
      fetcherRef.current = fetcher7;
      configRef.current = config;
      unmountedRef.current = false;
    }
    const req = PRELOAD[key];
    const mutateReq = !isUndefined(req) && hasKeyButNoData ? boundMutate(req) : resolvedUndef;
    use2(mutateReq);
    if (!isUndefined(error) && hasKeyButNoData) {
      throw error;
    }
    const revalidation = hasKeyButNoData ? revalidate(WITH_DEDUPE) : resolvedUndef;
    if (!isUndefined(returnedData) && hasKeyButNoData) {
      revalidation.status = "fulfilled";
      revalidation.value = true;
    }
    use2(revalidation);
  }
  const swrResponse = {
    mutate: boundMutate,
    get data() {
      stateDependencies.data = true;
      return returnedData;
    },
    get error() {
      stateDependencies.error = true;
      return error;
    },
    get isValidating() {
      stateDependencies.isValidating = true;
      return isValidating;
    },
    get isLoading() {
      stateDependencies.isLoading = true;
      return isLoading;
    }
  };
  return swrResponse;
};
var SWRConfig2 = OBJECT.defineProperty(SWRConfig, "defaultValue", {
  value: defaultConfig
});
var useSWR = withArgs(useSWRHandler);

// ../../packages/myst-to-react/dist/links/wiki.js
var import_classnames17 = __toESM(require_classnames(), 1);
var WikiTextMark = () => (0, import_jsx_runtime38.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", version: "1.1", id: "svg3400", viewBox: "0 0 500 85", className: "h-4", children: (0, import_jsx_runtime38.jsxs)("g", { transform: "translate(-357.71336,-784.65111)", children: [(0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 412.98736,806.72288 c 0,0 -1.468,-2.984 -1.968,-3.976 -3.336,-6.612 -3.264,-6.964 -6.636,-7.408 -0.944,-0.124 -1.432,-0.244 -1.432,-0.712 v -2.092 l 0.284,-0.204 c 6.092,-0.008 19.648,-0.008 19.648,-0.008 l 0.52,0.172 v 2.084 c 0,0.476 -0.34,0.72 -1.032,0.72 l -1.424,0.204 c -3.6,0.28 -3.012,1.752 -0.62,6.516 l 22.708,46.46 0.776,0.212 20.16,-47.844 c 0.7,-1.928 0.592,-3.296 -0.308,-4.1 -0.904,-0.784 -1.54,-1.248 -3.876,-1.344 l -1.892,-0.096 c -0.232,0 -0.452,-0.084 -0.664,-0.24 -0.208,-0.148 -0.316,-0.344 -0.316,-0.58 v -1.992 l 0.288,-0.204 c 5.68,0 22.776,0 22.776,0 l 0.232,0.204 v 1.992 c 0,0.54 -0.308,0.812 -0.916,0.812 -2.984,0.132 -5.196,0.78 -6.628,1.936 -1.436,1.164 -2.556,2.768 -3.36,4.852 0,0 -18.54,42.436 -24.884,56.54 -2.428,4.624 -4.816,4.2 -6.916,-0.132 -4.436,-9.136 -16.928,-36.852 -16.928,-36.852 l -7.592,-14.92 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 449.37136,792.29888 c 0,0 -12.812,-0.04 -18.516,0 l -0.284,0.204 v 1.984 c 0,0.244 0.104,0.436 0.312,0.584 0.212,0.156 0.428,0.236 0.66,0.236 l 0.916,0.1 c 2.332,0.096 3.404,0.708 3.724,1.092 0.556,0.68 0.832,1.416 -0.516,4.356 l -23.92,47.708 -0.628,-0.164 c 0,0 -17.132,-36.124 -22.092,-48.208 -0.516,-1.252 -0.748,-2.18 -0.748,-2.752 0,-1.228 1.108,-1.892 3.324,-1.984 l 2.584,-0.108 c 0.684,0 1.032,-0.264 1.032,-0.812 v -1.984 l -0.232,-0.204 c 0,0 -20.52,-0.024 -24.76,0 l -0.232,0.204 v 2.084 c 0,0.376 0.476,0.608 1.432,0.712 2.604,0.14 4.316,0.556 5.14,1.248 0.82,0.7 1.688,2.468 2.84,5.224 6.228,14.96 19.46,41.656 25.904,56.86 1.856,4.152 4.188,4.796 7.02,-0.128 4.904,-9.096 18.2,-36.872 18.2,-36.872 l 10.472,-19.584 c 1.22,-2.068 2.396,-3.912 2.992,-4.772 1.092,-1.572 1.704,-1.868 4.688,-2.008 0.608,0 0.916,-0.272 0.916,-0.82 v -1.984 l -0.228,-0.212 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 488.32736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.128,-0.212 -2.912,0 -11.024,0.212 -11.024,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.432,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.252,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.44,0.208 2.808,0 10.816,-0.208 10.816,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 v 34.632 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 519.01936,854.23088 c 0,2.288 1.352,3.432 4.368,3.952 l 1.144,0.212 c 0.312,0.1 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -6.552,-0.212 -9.672,-0.212 -2.912,0 -11.44,0.212 -11.44,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.12,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.144,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.528,0.208 11.752,0.208 2.916,0 9.464,-0.208 9.464,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.416 -0.624,0.52 l -1.144,0.212 c -3.224,0.62 -4.368,1.144 -4.368,3.228 v 15.704 c 3.432,0 5.408,-1.764 9.984,-6.656 4.16,-4.58 7.384,-8.42 7.384,-10.4 0,-0.836 -0.936,-1.768 -3.016,-2.084 -0.416,-0.1 -0.624,-0.208 -0.624,-0.52 v -2.396 l 0.104,-0.1 c 0,0 8.424,0.208 11.44,0.208 2.704,0 7.28,-0.208 7.28,-0.208 l 0.312,0.1 v 2.396 c 0,0.312 -0.312,0.52 -0.832,0.52 -4.056,0.312 -6.864,0.52 -10.608,4.784 l -8.944,10.292 c -1.768,1.876 -2.392,3.016 -2.392,3.852 0,0.624 0.416,1.14 0.936,1.764 l 15.704,18.928 c 1.248,1.452 3.744,2.08 5.824,2.492 l 0.52,0.1 c 0.312,0.104 0.728,0.312 0.728,0.624 v 2.184 l -0.312,0.104 c 0,0 -5.512,-0.104 -8.424,-0.104 -2.6,0 -6.344,0.104 -6.344,0.104 l -0.104,-0.104 v -1.248 c 0,-1.356 -0.104,-2.492 -1.56,-4.156 l -11.544,-14.356 c -1.56,-2.084 -3.224,-2.596 -5.512,-2.596 v 15.404 l 0,0 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 575.08736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.128,-0.212 -2.912,0 -11.024,0.212 -11.024,0.212 l -0.208,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.08,-0.212 c 3.432,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.248,-2.916 -4.472,-3.22 l -2.08,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.44,0.208 2.808,0 10.816,-0.208 10.816,-0.208 l 0.104,0.208 v 2.288 c 0,0.312 -0.208,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 v 34.632 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 597.55936,819.80288 c 0,-3.224 -1.352,-3.328 -6.24,-3.64 -0.624,0 -0.728,-0.308 -0.728,-0.52 v -2.392 l 0.208,-0.104 c 1.56,0 7.696,0.208 10.712,0.208 2.912,0 7.072,-0.208 10.92,-0.208 14.76,0 17.464,7.276 17.464,12.692 0,6.244 -3.016,16.016 -17.776,16.016 -2.6,0 -4.68,-0.212 -6.556,-1.04 v 13.928 c 0,2.288 1.248,2.812 4.58,3.328 l 2.084,0.312 c 0.416,0.104 0.728,0.212 0.728,0.624 v 2.184 l -0.1,0.208 c 0,0 -8.32,-0.208 -11.544,-0.208 -2.912,0 -10.712,0.208 -10.712,0.208 l -0.104,-0.208 v -2.184 c 0,-0.416 0.208,-0.52 0.624,-0.624 l 2.184,-0.312 c 3.224,-0.416 4.264,-1.352 4.264,-3.328 l -0.008,-34.94 0,0 z m 8.008,18.1 c 2.08,0.836 4.68,0.936 6.76,0.936 6.244,0 9.248,-3.752 9.248,-11.752 0,-8.944 -4.056,-10.92 -9.768,-10.92 -4.996,0 -6.244,0.936 -6.244,3.64 l 0.004,18.096 0,0 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 647.80736,861.19888 c -3.12,0 -10.292,0.212 -10.292,0.212 l -0.108,-0.212 v -2.288 c 0,-0.204 0.108,-0.516 0.624,-0.516 l 2.396,-0.212 c 3.228,-0.312 4.164,-2.392 4.164,-4.468 v -34.32 c 0,-2.4 -1.252,-2.812 -4.164,-3.016 l -2.396,-0.216 c -0.624,-0.096 -0.624,-0.308 -0.624,-0.416 v -2.396 l 0.108,-0.208 c 0,0 8.108,0.208 11.228,0.208 h 15.288 c 3.12,0 10.508,-0.208 10.508,-0.208 l 0.212,0.208 c 0.1,4.472 0.828,8.536 1.56,12.484 l -2.596,0.416 c -1.14,-3.852 -3.116,-9.36 -9.772,-9.36 h -8.32 c -1.976,0 -3.016,0.728 -3.016,2.492 v 15.084 h 7.796 c 2.916,0 3.64,-1.248 4.06,-3.328 l 0.62,-2.184 c 0,-0.312 0.212,-0.524 0.624,-0.524 h 1.764 c 0.212,0 0.212,0.108 0.212,0.312 -0.212,2.288 -0.624,5.204 -0.624,7.7 0,2.596 0.416,4.784 0.624,7.176 l -0.212,0.212 h -1.764 c -0.516,0 -0.732,-0.212 -0.732,-0.524 l -0.52,-2.284 c -0.416,-2.084 -1.352,-3.228 -4.064,-3.228 h -7.792 v 15.916 c 0,1.972 1.136,3.948 3.016,3.948 h 9.88 c 5.304,0 8.22,-3.328 9.464,-8.74 l 2.596,0.312 -2.084,11.956 -0.208,0.208 c 0,0 -6.136,-0.208 -9.256,-0.208 l -18.2,0.012 0,0 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 686.91936,858.39488 2.392,-0.212 c 3.124,-0.312 4.164,-1.248 4.164,-4.468 v -34.32 c 0,-2.712 -0.736,-2.712 -4.164,-3.016 l -2.28,-0.216 c -0.416,0 -0.736,-0.208 -0.736,-0.52 v -2.288 l 0.1,-0.208 c 0,0 9.156,0.208 11.032,0.208 1.968,0 11.024,-0.208 13.728,-0.208 17.368,0 25.9,10.816 25.9,24.648 0,18.204 -12.9,23.604 -24.44,23.604 -8.32,0 -11.956,-0.208 -15.18,-0.208 -3.124,0 -11.028,0.208 -11.028,0.208 l -0.104,-0.208 v -2.184 c -0.008,-0.3 0.204,-0.612 0.616,-0.612 z m 23.196,0 c 11.436,0 17.892,-4.26 17.892,-18.828 0,-10.812 -2.396,-23.404 -19.868,-23.404 -4.056,0 -6.656,0.624 -6.656,3.232 v 34.32 c 0,2.904 0.724,4.68 8.632,4.68 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 761.60736,854.23088 c 0,2.288 1.04,3.64 4.368,3.952 l 2.184,0.212 c 0.312,0 0.624,0.204 0.624,0.62 v 2.184 l -0.104,0.212 c 0,0 -7.904,-0.212 -11.124,-0.212 -2.916,0 -11.024,0.212 -11.024,0.212 l -0.212,-0.212 v -2.184 c 0,-0.416 0.312,-0.62 0.728,-0.62 l 2.084,-0.212 c 3.428,-0.312 4.472,-1.976 4.472,-3.952 v -34.632 c 0,-2.284 -1.252,-2.916 -4.472,-3.22 l -2.084,-0.216 c -0.416,0 -0.728,-0.096 -0.728,-0.416 v -2.396 l 0.104,-0.208 c 0,0 8.216,0.208 11.432,0.208 2.808,0 10.82,-0.208 10.82,-0.208 l 0.1,0.208 v 2.288 c 0,0.312 -0.212,0.52 -0.624,0.52 l -2.184,0.212 c -3.224,0.308 -4.368,1.144 -4.368,3.228 l 0.008,34.632 0,0 z" }), (0, import_jsx_runtime38.jsx)("path", { fill: "currentColor", d: "m 793.64736,858.18288 3.016,0.212 c 0.416,0 0.832,0.312 0.832,0.828 v 1.976 l -0.208,0.212 c 0,0 -11.336,-0.212 -13.832,-0.212 -2.708,0 -9.364,0.212 -9.364,0.212 l -0.212,-0.212 v -1.976 c 0,-0.516 0.312,-0.828 0.836,-0.828 4.58,-0.312 7.172,-1.148 10.084,-7.804 l 23.084,-54.084 c 1.14,-2.704 1.976,-3.748 3.54,-3.748 1.452,0 1.976,1.044 2.804,3.124 l 21.32,56.368 c 1.46,4.06 3.54,5.616 7.7,6.032 l 1.144,0.1 c 0.52,0 1.04,0.312 1.04,0.836 v 1.972 l -0.312,0.208 c 0,0 -8.008,-0.208 -12.064,-0.208 -3.64,0 -13.836,0.208 -13.836,0.208 l -0.1,-0.208 v -1.972 c 0,-0.524 0.208,-0.836 0.736,-0.836 l 2.912,-0.208 c 3.948,-0.308 5.412,-1.564 4.368,-4.472 l -6.344,-17.58 h -21.632 c -2.496,0 -3.12,0.416 -3.636,1.764 l -6.036,15.084 c -1.04,2.608 0.312,4.9 4.16,5.212 z m 25.48,-26.424 -10.088,-27.764 h -0.208 l -10.4,26.416 c -0.416,1.044 0.308,1.352 2.596,1.352 h 18.1 z" })] }) });
var fetcher = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
var ENGLISH_WIKIPEDIA = "https://en.wikipedia.org/";
function createWikiUrl(name, wiki) {
  return `${wiki || ENGLISH_WIKIPEDIA}wiki/${name}`;
}
function createWikiApiUrl(name, wiki) {
  return `${wiki || ENGLISH_WIKIPEDIA}api/rest_v1/page/summary/${name}`;
}
function WikiChild({ page, wiki, load: load2 }) {
  var _a, _b;
  const { data, error } = useSWR(load2 ? createWikiApiUrl(page, wiki) : null, fetcher);
  const { thumbnail, extract, content_urls } = data !== null && data !== void 0 ? data : {};
  const url = (_b = (_a = content_urls === null || content_urls === void 0 ? void 0 : content_urls.desktop) === null || _a === void 0 ? void 0 : _a.page) !== null && _b !== void 0 ? _b : createWikiUrl(page);
  const image = thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.source;
  if (error) {
    return (0, import_jsx_runtime38.jsxs)("span", { children: [(0, import_jsx_runtime38.jsxs)("a", { href: url, className: "block text-inherit hover:text-inherit", target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime38.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }), (0, import_jsx_runtime38.jsx)(WikiTextMark, {})] }), (0, import_jsx_runtime38.jsxs)("div", { className: "mt-2", children: ['Error loading "', page, '" from wikipedia.'] })] });
  }
  return (0, import_jsx_runtime38.jsx)(LinkCard, { loading: !data, url, title: (0, import_jsx_runtime38.jsx)(WikiTextMark, {}), thumbnail: image, description: extract });
}
function WikiLink({ children, page, url, wiki, className }) {
  return (0, import_jsx_runtime38.jsx)(HoverPopover, { card: ({ load: load2 }) => (0, import_jsx_runtime38.jsx)(WikiChild, { wiki, page, load: load2 }), children: (0, import_jsx_runtime38.jsx)("a", { href: url, className: (0, import_classnames17.default)("italic", className), target: "_blank", rel: "noreferrer", children }) });
}

// ../../packages/myst-to-react/dist/links/rrid.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var fetcher2 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function RRIDChild({ rrid }) {
  var _a, _b, _c, _d, _e2, _f, _g;
  const { data, error } = useSWR(`https://scicrunch.org/resolver/${rrid}.json`, fetcher2);
  if (!data && !error) {
    return (0, import_jsx_runtime39.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  const hit = (_b = (_a = data === null || data === void 0 ? void 0 : data.hits) === null || _a === void 0 ? void 0 : _a.hits) === null || _b === void 0 ? void 0 : _b[0];
  if (error || !hit) {
    return (0, import_jsx_runtime39.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: ["Error loading ", rrid, "."] });
  }
  const { name: title, curie, description, supercategory, keywords, types: categories } = (_d = (_c = hit === null || hit === void 0 ? void 0 : hit._source) === null || _c === void 0 ? void 0 : _c.item) !== null && _d !== void 0 ? _d : {};
  const category = (_e2 = supercategory === null || supercategory === void 0 ? void 0 : supercategory[0]) === null || _e2 === void 0 ? void 0 : _e2.name;
  const types = (_f = categories === null || categories === void 0 ? void 0 : categories.map(({ name }) => name)) !== null && _f !== void 0 ? _f : [];
  const tags = (_g = keywords === null || keywords === void 0 ? void 0 : keywords.map(({ keyword }) => keyword)) !== null && _g !== void 0 ? _g : [];
  return (0, import_jsx_runtime39.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", children: [(0, import_jsx_runtime39.jsxs)("p", { className: "text-sm font-light", children: ["RRID: ", category] }), (0, import_jsx_runtime39.jsxs)("div", { className: "mb-4 text-xl font-bold", children: [title, " ", (0, import_jsx_runtime39.jsx)("code", { children: curie })] }), (0, import_jsx_runtime39.jsx)("p", { className: "text-md", children: description }), types.length > 0 && (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [(0, import_jsx_runtime39.jsx)("div", { className: "my-2 text-xs font-thin", children: "Categories" }), (0, import_jsx_runtime39.jsx)("div", { className: "flex flex-wrap ml-1", children: types === null || types === void 0 ? void 0 : types.map((tag) => (0, import_jsx_runtime39.jsx)("span", { className: "inline-flex items-center px-3 py-1 ml-1 text-xs uppercase border rounded-full", children: tag })) })] }), tags.length > 0 && (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [(0, import_jsx_runtime39.jsx)("div", { className: "my-2 text-xs font-thin", children: "Tags" }), (0, import_jsx_runtime39.jsx)("div", { className: "flex flex-wrap ml-1", children: tags === null || tags === void 0 ? void 0 : tags.map((tag) => (0, import_jsx_runtime39.jsx)("span", { className: "inline-flex items-center px-3 py-1 ml-1 text-xs uppercase border rounded-full", children: tag })) })] })] });
}
function RRIDLink({ rrid, className }) {
  return (0, import_jsx_runtime39.jsx)(HoverPopover, { card: (0, import_jsx_runtime39.jsx)(RRIDChild, { rrid }), children: (0, import_jsx_runtime39.jsxs)("a", { href: `https://scicrunch.org/resolver/${rrid}`, target: "_blank", rel: "noopener noreferrer", className, children: ["RRID: ", (0, import_jsx_runtime39.jsx)("cite", { className: "italic", children: rrid })] }) });
}

// ../../packages/myst-to-react/dist/links/ror.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@scienceicons/react/24/solid/esm/BinderIcon.js
var React71 = __toESM(require_react(), 1);
function BinderIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React71.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React71.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React71.createElement("path", {
    d: "M14.1 10.6c-3 0-5.5 2.5-5.5 5.5s2.5 5.5 5.5 5.5 5.5-2.5 5.5-5.5-2.4-5.5-5.5-5.5zm0 2.3c1.8 0 3.2 1.4 3.2 3.2 0 1.8-1.4 3.2-3.2 3.2-1.8 0-3.2-1.4-3.2-3.2 0-1.8 1.5-3.2 3.2-3.2z"
  }), /* @__PURE__ */ React71.createElement("path", {
    d: "M9.9 6.5c-3 0-5.5 2.5-5.5 5.5s2.5 5.5 5.5 5.5 5.5-2.5 5.5-5.5c-.1-3.1-2.5-5.5-5.5-5.5zm0 2.2c1.8 0 3.2 1.4 3.2 3.2 0 1.8-1.4 3.2-3.2 3.2-1.8 0-3.2-1.4-3.2-3.2-.1-1.7 1.4-3.2 3.2-3.2z"
  }), /* @__PURE__ */ React71.createElement("path", {
    d: "M14.1 2.2c-3 0-5.5 2.5-5.5 5.5s2.5 5.5 5.5 5.5 5.5-2.5 5.5-5.5c0-3.1-2.4-5.5-5.5-5.5zm0 2.2c1.8 0 3.2 1.4 3.2 3.2 0 1.8-1.4 3.2-3.2 3.2-1.8 0-3.2-1.4-3.2-3.2 0-1.8 1.5-3.2 3.2-3.2z"
  }));
}
var ForwardRef41 = React71.forwardRef(BinderIcon);
var BinderIcon_default = ForwardRef41;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcByIcon.js
var React72 = __toESM(require_react(), 1);
function CcByIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React72.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React72.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React72.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.8c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9-1.8-1.7-2.8-4-2.8-6.7s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.3C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.7C16.1 4.8 14.2 4 12 4zm2.6 5.6v4h-1.1v4.7h-3v-4.7H9.4v-4c0-.2.1-.3.2-.4.1-.2.2-.2.4-.2h4c.2 0 .3.1.4.2.2.1.2.2.2.4zm-4-2.5c0-.9.5-1.4 1.4-1.4s1.4.5 1.4 1.4c0 .9-.5 1.4-1.4 1.4s-1.4-.5-1.4-1.4z"
  }));
}
var ForwardRef42 = React72.forwardRef(CcByIcon);
var CcByIcon_default = ForwardRef42;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcNcIcon.js
var React73 = __toESM(require_react(), 1);
function CcNcIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React73.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React73.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React73.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.8c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9-1.9-1.9-2.9-4.2-2.9-6.9s1-5 2.9-6.9c2-1.7 4.3-2.7 7-2.7zM4.4 9.4C4.2 10.2 4 11 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4.6-.5 1-1.1 1.3-1.7l-3.7-1.6c-.1.6-.4 1.1-.9 1.5-.5.4-1.1.6-1.8.7V18h-1.1v-1.5c-1.1 0-2.1-.4-3-1.2l1.3-1.4c.6.6 1.4.9 2.2.9.3 0 .6-.1.9-.2.2-.2.4-.4.4-.7 0-.2-.1-.4-.3-.6l-.9-.4-1.1-.6-1.5-.7-5.1-2.2zM12 4c-2.2 0-4.1.8-5.6 2.3-.4.4-.7.9-1.1 1.3L9 9.3c.2-.5.5-.9 1-1.2.5-.3 1-.5 1.6-.5V6.1h1.1v1.5c.9 0 1.7.3 2.4.9l-1.3 1.3c-.5-.4-1.1-.6-1.7-.6-.3 0-.6.1-.8.2-.2.1-.3.3-.3.6 0 .1 0 .2.1.2l1.2.6.9.4 1.6.7 5 2.2c.2-.7.2-1.4.2-2.1 0-2.2-.8-4.1-2.3-5.7C16.1 4.8 14.2 4 12 4z"
  }));
}
var ForwardRef43 = React73.forwardRef(CcNcIcon);
var CcNcIcon_default = ForwardRef43;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcNdIcon.js
var React74 = __toESM(require_react(), 1);
function CcNdIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React74.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React74.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React74.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.9c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9C3.2 17 2.2 14.7 2.2 12s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.4C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.6C16.1 4.8 14.2 4 12 4zm3.7 5.7v1.7H8.6V9.7h7.1zm0 3.1v1.7H8.6v-1.7h7.1z"
  }));
}
var ForwardRef44 = React74.forwardRef(CcNdIcon);
var CcNdIcon_default = ForwardRef44;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcSaIcon.js
var React75 = __toESM(require_react(), 1);
function CcSaIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React75.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React75.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React75.createElement("path", {
    d: "M12 2.2c2.7 0 5 .9 6.9 2.8 1.9 1.9 2.8 4.2 2.8 6.9s-.9 5-2.8 6.9c-2 1.9-4.3 2.9-7 2.9-2.6 0-4.9-1-6.9-2.9C3.2 17 2.2 14.7 2.2 12s1-5 2.9-6.9C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.4C4.8 8 4 9.9 4 12c0 2.2.8 4 2.4 5.6C8 19.2 9.8 20 12 20c2.2 0 4.1-.8 5.7-2.4 1.5-1.5 2.3-3.3 2.3-5.6 0-2.2-.8-4.1-2.3-5.6C16.1 4.8 14.2 4 12 4zm-4.3 6.6c.2-1.2.7-2.1 1.4-2.8.8-.7 1.7-1 2.8-1 1.5 0 2.8.5 3.7 1.5.9 1 1.4 2.3 1.4 3.8s-.5 2.7-1.4 3.7c-.9 1-2.2 1.5-3.7 1.5-1.1 0-2.1-.3-2.9-1-.8-.7-1.3-1.6-1.4-2.8h2.5c.1 1.2.8 1.8 2.1 1.8.7 0 1.2-.3 1.7-.9.4-.6.6-1.4.6-2.4s-.2-1.8-.6-2.4c-.4-.5-.9-.8-1.7-.8-1.3 0-2 .6-2.2 1.7h.7l-1.9 1.9-1.9-1.9.8.1z"
  }));
}
var ForwardRef45 = React75.forwardRef(CcSaIcon);
var CcSaIcon_default = ForwardRef45;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcZeroIcon.js
var React76 = __toESM(require_react(), 1);
function CcZeroIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React76.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React76.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React76.createElement("path", {
    d: "M12 6.4c-3.2 0-4 3-4 5.6 0 2.6.8 5.6 4 5.6s4-3 4-5.6c0-2.6-.8-5.6-4-5.6zm0 2.1h.4c.2.2.3.5.1.9l-2.1 3.9c-.1-.5-.1-1-.1-1.4 0-1 0-3.4 1.7-3.4zm1.6 1.8c.1.6.1 1.2.1 1.7 0 1.1-.1 3.5-1.7 3.5h-.4-.1-.1c-.4-.2-.6-.4-.3-.9l2.5-4.3z"
  }), /* @__PURE__ */ React76.createElement("path", {
    d: "M12 2.2c-2.7 0-5 .9-6.8 2.8-1 1-1.7 2.1-2.2 3.3-.5 1.2-.8 2.4-.8 3.7 0 1.3.2 2.5.7 3.7.5 1.2 1.2 2.2 2.1 3.2.9.9 2 1.6 3.2 2.1 1.2.5 2.4.7 3.7.7 1.3 0 2.5-.3 3.7-.8 1.2-.5 2.3-1.2 3.2-2.2.9-.9 1.6-1.9 2.1-3.1.5-1.2.7-2.4.7-3.8 0-1.3-.2-2.6-.7-3.7-.3-1-1-2.1-1.9-3-2-1.9-4.3-2.9-7-2.9zM12 4c2.2 0 4.1.8 5.7 2.3.7.8 1.3 1.7 1.7 2.6.4 1 .6 2 .6 3.1 0 2.2-.8 4.1-2.3 5.6-.8.8-1.7 1.4-2.7 1.8-1 .4-2 .6-3 .6-1.1 0-2.1-.2-3-.6-1-.4-1.8-1-2.6-1.7C5.6 16.9 5 16 4.6 15c-.4-1-.6-2-.6-3 0-1.1.2-2.1.6-3 .4-1 1-1.9 1.8-2.6C7.9 4.8 9.8 4 12 4z"
  }));
}
var ForwardRef46 = React76.forwardRef(CcZeroIcon);
var CcZeroIcon_default = ForwardRef46;

// ../../node_modules/@scienceicons/react/24/solid/esm/CcIcon.js
var React77 = __toESM(require_react(), 1);
function CcIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React77.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React77.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React77.createElement("path", {
    d: "M12 2.2c2.7 0 5 1 7 2.9.9.9 1.6 2 2.1 3.1.5 1.2.7 2.4.7 3.8 0 1.3-.2 2.6-.7 3.8-.5 1.2-1.2 2.2-2.1 3.1-1 .9-2 1.7-3.2 2.2-1.2.5-2.5.7-3.7.7s-2.6-.3-3.8-.8c-1.2-.5-2.2-1.2-3.2-2.1s-1.6-2-2.1-3.2-.8-2.4-.8-3.7c0-1.3.2-2.5.7-3.7S4.2 6 5.1 5.1C7 3.2 9.3 2.2 12 2.2zM12 4c-2.2 0-4.1.8-5.6 2.3C5.6 7.1 5 8 4.6 9c-.4 1-.6 2-.6 3s.2 2.1.6 3c.4 1 1 1.8 1.8 2.6S8 19 9 19.4c1 .4 2 .6 3 .6s2.1-.2 3-.6c1-.4 1.9-1 2.7-1.8 1.5-1.5 2.3-3.3 2.3-5.6 0-1.1-.2-2.1-.6-3.1-.4-1-1-1.8-1.7-2.6C16.1 4.8 14.2 4 12 4zm-.1 6.4l-1.3.7c-.1-.3-.3-.5-.5-.6-.2-.1-.4-.2-.6-.2-.9 0-1.3.6-1.3 1.7 0 .5.1.9.3 1.3.2.3.5.5 1 .5.6 0 1-.3 1.2-.8l1.2.6c-.3.5-.6.9-1.1 1.1-.5.3-1 .4-1.5.4-.9 0-1.6-.3-2.1-.8-.5-.6-.8-1.3-.8-2.3 0-.9.3-1.7.8-2.2.6-.6 1.3-.8 2.1-.8 1.2 0 2.1.4 2.6 1.4zm5.6 0l-1.3.7c-.1-.3-.3-.5-.5-.6-.2-.1-.4-.2-.6-.2-.9 0-1.3.6-1.3 1.7 0 .5.1.9.3 1.3.2.3.5.5 1 .5.6 0 1-.3 1.2-.8l1.2.6c-.3.5-.6.9-1.1 1.1-.4.2-.9.3-1.4.3-.9 0-1.6-.3-2.1-.8s-.8-1.3-.8-2.2c0-.9.3-1.7.8-2.2.5-.5 1.2-.8 2-.8 1.2 0 2.1.4 2.6 1.4z"
  }));
}
var ForwardRef47 = React77.forwardRef(CcIcon);
var CcIcon_default = ForwardRef47;

// ../../node_modules/@scienceicons/react/24/solid/esm/EmailIcon.js
var React78 = __toESM(require_react(), 1);
function EmailIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React78.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React78.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React78.createElement("path", {
    d: "M21.8 18c0 1.1-.9 2-1.9 2H4.2c-1.1 0-1.9-.9-1.9-2V9.9c0-.5.3-.7.8-.4l7.8 4.7c.7.4 1.7.4 2.4 0L21 9.5c.4-.2.8-.1.8.4V18z"
  }), /* @__PURE__ */ React78.createElement("path", {
    d: "M21.8 6c0-1.1-.9-2-1.9-2H4.2c-1.1 0-2 .9-2 2v.4c0 .5.3 1.1.8 1.3l8.5 5.1c.2.1.7.1.9 0l8.6-5c.4-.3.8-.9.8-1.3-.1-.1-.1-.5 0-.5z"
  }));
}
var ForwardRef48 = React78.forwardRef(EmailIcon);
var EmailIcon_default = ForwardRef48;

// ../../node_modules/@scienceicons/react/24/solid/esm/GithubIcon.js
var React79 = __toESM(require_react(), 1);
function GithubIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React79.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React79.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React79.createElement("path", {
    d: "M12 2.5c-5.4 0-9.8 4.4-9.8 9.7 0 4.3 2.8 8 6.7 9.2.5.1.7-.2.7-.5v-1.8c-2.4.5-3.1-.6-3.3-1.1-.1-.3-.6-1.1-1-1.4-.3-.2-.8-.6 0-.6s1.3.7 1.5 1c.9 1.5 2.3 1.1 2.8.8.1-.6.3-1.1.6-1.3-2.2-.2-4.4-1.1-4.4-4.8 0-1.1.4-1.9 1-2.6-.1-.2-.4-1.2.1-2.6 0 0 .8-.3 2.7 1 .8-.2 1.6-.3 2.4-.3.8 0 1.7.1 2.4.3 1.9-1.3 2.7-1 2.7-1 .5 1.3.2 2.3.1 2.6.6.7 1 1.5 1 2.6 0 3.7-2.3 4.6-4.4 4.8.4.3.7.9.7 1.8V21c0 .3.2.6.7.5 3.9-1.3 6.6-4.9 6.6-9.2 0-5.4-4.4-9.8-9.8-9.8z"
  }));
}
var ForwardRef49 = React79.forwardRef(GithubIcon);
var GithubIcon_default = ForwardRef49;

// ../../node_modules/@scienceicons/react/24/solid/esm/JupyterIcon.js
var React80 = __toESM(require_react(), 1);
function JupyterIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React80.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React80.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React80.createElement("path", {
    d: "M20.2 1.7c0 .8-.5 1.4-1.3 1.5-.8 0-1.4-.5-1.5-1.3 0-.8.5-1.4 1.3-1.5.8-.1 1.5.5 1.5 1.3zM12 17.9c-3.7 0-7-1.3-8.7-3.3 1.8 4.8 7.1 7.3 11.9 5.5 2.5-.9 4.5-2.9 5.5-5.5-1.7 2-4.9 3.3-8.7 3.3zM12 5.1c3.7 0 7 1.3 8.7 3.3-1.8-4.8-7.1-7.3-11.9-5.5-2.5.9-4.5 2.9-5.5 5.5 1.7-2 5-3.3 8.7-3.3zM6.9 21.8c.1 1-.7 1.8-1.7 1.9-1 .1-1.8-.7-1.9-1.7 0-1 .7-1.8 1.7-1.9 1-.1 1.8.7 1.9 1.7zM3.7 4.6c-.6 0-1-.4-1-1s.4-1 1-1 1 .4 1 1c0 .5-.4 1-1 1z"
  }));
}
var ForwardRef50 = React80.forwardRef(JupyterIcon);
var JupyterIcon_default = ForwardRef50;

// ../../node_modules/@scienceicons/react/24/solid/esm/OpenAccessIcon.js
var React81 = __toESM(require_react(), 1);
function OpenAccessIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React81.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React81.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React81.createElement("path", {
    d: "M17.1 12.6h-2V7.5c0-1.7-1.4-3.1-3-3.1-.8 0-1.6.3-2.2.9-.6.5-.9 1.3-.9 2.2v.7H7v-.7c0-1.4.5-2.7 1.5-3.7s2.2-1.5 3.6-1.5 2.6.5 3.6 1.5 1.5 2.3 1.5 3.7v5.1z"
  }), /* @__PURE__ */ React81.createElement("path", {
    d: "M12 21.8c-.8 0-1.6-.2-2.3-.5-.7-.3-1.4-.8-1.9-1.3-.6-.6-1-1.2-1.3-2-.3-.8-.5-1.6-.5-2.4s.2-1.6.5-2.4c.3-.7.7-1.4 1.3-2s1.2-1 1.9-1.3c.7-.3 1.5-.5 2.3-.5.8 0 1.6.2 2.3.5.7.3 1.4.8 1.9 1.3.6.6 1 1.2 1.3 2 .3.8.5 1.6.5 2.4s-.2 1.6-.5 2.4c-.3.7-.7 1.4-1.3 2-.6.6-1.2 1-1.9 1.3-.7.3-1.5.5-2.3.5zm0-10.3c-2.2 0-4 1.8-4 4.1s1.8 4.1 4 4.1 4-1.8 4-4.1-1.8-4.1-4-4.1z"
  }), /* @__PURE__ */ React81.createElement("circle", {
    cx: 12,
    cy: 15.6,
    r: 1.7
  }));
}
var ForwardRef51 = React81.forwardRef(OpenAccessIcon);
var OpenAccessIcon_default = ForwardRef51;

// ../../node_modules/@scienceicons/react/24/solid/esm/OrcidIcon.js
var React82 = __toESM(require_react(), 1);
function OrcidIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React82.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React82.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React82.createElement("path", {
    d: "M21.8 12c0 5.4-4.4 9.8-9.8 9.8S2.2 17.4 2.2 12 6.6 2.2 12 2.2s9.8 4.4 9.8 9.8zM8.2 5.8c-.4 0-.8.3-.8.8s.3.8.8.8.8-.4.8-.8-.3-.8-.8-.8zm2.3 9.6h1.2v-6h1.8c2.3 0 3.3 1.4 3.3 3s-1.5 3-3.3 3h-3v1.1H9V8.3H7.7v8.2h5.9c3.3 0 4.5-2.2 4.5-4.1s-1.2-4.1-4.3-4.1h-3.2l-.1 7.1z"
  }));
}
var ForwardRef52 = React82.forwardRef(OrcidIcon);
var OrcidIcon_default = ForwardRef52;

// ../../node_modules/@scienceicons/react/24/solid/esm/OsiIcon.js
var React83 = __toESM(require_react(), 1);
function OsiIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React83.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React83.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React83.createElement("path", {
    d: "M13.2 15.6c1.4-.5 2.1-1.6 2.1-3.3S13.8 8.9 12 8.9c-1.9 0-3.3 1.6-3.3 3.3 0 1.8.8 3 2.2 3.4l-2.3 5.9c-3.1-.8-6.3-4.6-6.3-9.3 0-5.5 4.3-10 9.7-10s9.8 4.5 9.8 10c0 4.7-3.1 8.5-6.3 9.3l-2.3-5.9z"
  }));
}
var ForwardRef53 = React83.forwardRef(OsiIcon);
var OsiIcon_default = ForwardRef53;

// ../../node_modules/@scienceicons/react/24/solid/esm/RorIcon.js
var React84 = __toESM(require_react(), 1);
function RorIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /* @__PURE__ */ React84.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /* @__PURE__ */ React84.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React84.createElement("path", {
    d: "M10 4.2L8.3 6.8 6.6 4.2H10zM17.1 4.2l-1.7 2.6-1.7-2.6h3.4zM6.6 19.8l1.7-2.6 1.7 2.6H6.6zM13.7 19.8l1.7-2.6 1.7 2.6h-3.4zM20.8 12.5c.6-.1 1.1-.4 1.4-.8.3-.4.5-.9.5-1.5 0-.5-.1-.9-.3-1.2-.2-.3-.4-.6-.7-.8-.3-.2-.6-.3-1-.4-.4-.1-.8-.1-1.2-.1h-3.3v2.6c0-.1-.1-.2-.1-.2-.2-.6-.6-1-1-1.4-.4-.4-.9-.7-1.5-.9-.6-.2-1.2-.3-1.9-.3s-1.3.1-1.9.3c-.5.1-1 .4-1.4.8-.3.4-.6.8-.9 1.3 0-.3-.1-.6-.2-.9-.2-.4-.4-.6-.7-.8-.3-.2-.6-.3-1-.4s-.8-.2-1.3-.2H1v8.5h1.9v-3.4h.9l1.8 3.4h2.3l-2.2-3.6c.6-.1 1.1-.4 1.4-.8v-.1.2c0 .7.1 1.3.3 1.8.2.6.6 1 1 1.4.4.4.9.7 1.5.9.6.2 1.2.3 1.9.3s1.3-.1 1.9-.3c.6-.2 1.1-.5 1.5-.9.4-.4.7-.9 1-1.4 0-.1.1-.2.1-.2V16H18v-3.4h.9l1.8 3.4H23l-2.2-3.5zM5.4 10.7c-.1.2-.2.3-.3.3-.2.1-.3.1-.5.1H2.9V9.2h1.7c.2 0 .3.1.5.1.1.1.3.2.3.3.1.1.1.3.1.5.1.3 0 .5-.1.6zm8.8 2.3c-.1.3-.3.6-.5.9-.2.2-.5.4-.8.6-.3.1-.7.2-1.1.2-.4 0-.8-.1-1.1-.2-.3-.1-.6-.3-.8-.6-.2-.2-.4-.5-.5-.9-.1-.3-.2-.7-.2-1.1 0-.4.1-.8.2-1.1s.3-.6.5-.9c.2-.2.5-.4.8-.6.3-.1.7-.2 1.1-.2.4 0 .8.1 1.1.2.3.1.6.3.8.6.2.2.4.5.5.9.1.3.2.7.2 1.1 0 .4 0 .7-.2 1.1zm6.4-2.3c-.1.1-.2.2-.4.3-.2.1-.3.1-.5.1H18V9.2h1.7c.2 0 .3.1.5.1.1.1.3.2.3.3.1.1.1.3.1.5.1.3.1.5 0 .6z"
  }));
}
var ForwardRef54 = React84.forwardRef(RorIcon);
var RorIcon_default = ForwardRef54;

// ../../packages/myst-to-react/dist/links/ror.js
var fetcher3 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function RORChild({ ror }) {
  var _a, _b, _c, _d;
  const { data, error } = useSWR(`https://api.ror.org/organizations/${ror}`, fetcher3);
  if (!data && !error) {
    return (0, import_jsx_runtime40.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  if (error) {
    return (0, import_jsx_runtime40.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: ["Error loading ", ror, "."] });
  }
  const country_name = (_a = data === null || data === void 0 ? void 0 : data.country) === null || _a === void 0 ? void 0 : _a.country_name;
  const basicLinks = (_b = data === null || data === void 0 ? void 0 : data.links.map((url) => ({ url }))) !== null && _b !== void 0 ? _b : [];
  const wikiLink = data.wikipedia_url ? [{ text: "Wikipedia", url: data.wikipedia_url }] : [];
  const links = [...basicLinks, ...wikiLink];
  return (0, import_jsx_runtime40.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] p-3", children: [(0, import_jsx_runtime40.jsxs)("p", { className: "flex items-stretch gap-2 text-sm font-light", children: [(0, import_jsx_runtime40.jsx)(RorIcon_default, { width: "1.25rem", height: "1.25rem", className: "self-center inline-block" }), (0, import_jsx_runtime40.jsx)("a", { href: `https://ror.org/${ror}`, className: "self-center", target: "_blank", rel: "noopener noreferrer", children: (0, import_jsx_runtime40.jsx)("code", { children: ror }) })] }), (0, import_jsx_runtime40.jsx)("div", { className: "mb-4 text-xl font-bold", children: data.name }), (0, import_jsx_runtime40.jsxs)("dl", { className: "mb-4 text-sm", children: [(0, import_jsx_runtime40.jsx)("dt", { children: "Country" }), (0, import_jsx_runtime40.jsx)("dd", { children: country_name }), links.length > 0 && (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, { children: [(0, import_jsx_runtime40.jsx)("dt", { children: "Links" }), links.map(({ url, text }) => (0, import_jsx_runtime40.jsx)("dd", { children: (0, import_jsx_runtime40.jsx)("a", { href: url, children: text || url }) }))] }), ((_c = data.acronyms) === null || _c === void 0 ? void 0 : _c.length) > 0 && (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, { children: [(0, import_jsx_runtime40.jsx)("dt", { children: "Acronyms" }), data.acronyms.map((text) => (0, import_jsx_runtime40.jsx)("dd", { children: text }))] }), ((_d = data.labels) === null || _d === void 0 ? void 0 : _d.length) > 0 && (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, { children: [(0, import_jsx_runtime40.jsx)("dt", { children: "Labels" }), data.labels.map(({ label, iso639 }) => (0, import_jsx_runtime40.jsxs)("dd", { children: [label, iso639 ? ` (${iso639})` : null] }))] })] })] });
}
function RORLink({ node, ror, className }) {
  return (0, import_jsx_runtime40.jsx)(HoverPopover, { card: (0, import_jsx_runtime40.jsx)(RORChild, { ror }), children: (0, import_jsx_runtime40.jsx)("a", { href: `https://ror.org/${ror}`, target: "_blank", rel: "noopener noreferrer", className, children: (0, import_jsx_runtime40.jsx)(MyST, { ast: node.children }) }) });
}

// ../../packages/myst-to-react/dist/links/github.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_classnames18 = __toESM(require_classnames(), 1);
var fetcher4 = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.text();
  throw new Error(`Content returned with status ${res.status}.`);
});
var jsonFetcher = (...args) => fetch(...args).then((res) => {
  if (res.status === 200)
    return res.json();
  throw new Error(`Content returned with status ${res.status}.`);
});
function extToLanguage(ext) {
  var _a;
  return (_a = {
    ts: "typescript",
    js: "javascript",
    py: "python",
    md: "markdown",
    yml: "yaml"
  }[ext !== null && ext !== void 0 ? ext : ""]) !== null && _a !== void 0 ? _a : ext;
}
function useLoadWhenOpen(open, url, loader2) {
  const [cached, setCached] = (0, import_react25.useState)();
  const { data, error } = useSWR(open ? url : null, loader2);
  (0, import_react25.useEffect)(() => {
    setCached(cached || data);
  }, [cached, url, data]);
  return { data: cached, error };
}
function GithubFilePreview({ url, raw, org, repo, file, from, to, open, className }) {
  const { data, error } = useLoadWhenOpen(open, raw, fetcher4);
  let code3 = data;
  if (error) {
    return (0, import_jsx_runtime41.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px]", children: [(0, import_jsx_runtime41.jsx)("a", { href: url, className: (0, import_classnames18.default)("block text-inherit hover:text-inherit", className), target: "_blank", rel: "noreferrer", children: (0, import_jsx_runtime41.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1rem", height: "1rem", className: "float-right" }) }), (0, import_jsx_runtime41.jsxs)("div", { className: "mt-2", children: ['Error loading "', file, '" from GitHub.'] })] });
  }
  const lang = extToLanguage(file === null || file === void 0 ? void 0 : file.split(".").pop());
  let startingLineNumber = 1;
  let emphasizeLines = [];
  const offset4 = 5;
  if (code3 && from && to) {
    startingLineNumber = from;
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(from - 1, to).join("\n");
  } else if (code3 && from) {
    startingLineNumber = from + 1 - offset4;
    emphasizeLines = [from];
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(Math.max(0, from - offset4), from + offset4).join("\n");
  } else {
    code3 = code3 === null || code3 === void 0 ? void 0 : code3.split("\n").slice(0, 10).join("\n");
  }
  const description = code3 ? (0, import_jsx_runtime41.jsx)(import_jsx_runtime41.Fragment, { children: (0, import_jsx_runtime41.jsx)(CodeBlock, { value: code3, lang, filename: file, showLineNumbers: true, startingLineNumber, emphasizeLines, showCopy: false }) }) : null;
  return (0, import_jsx_runtime41.jsx)(LinkCard, { loading: !code3, url, title: `GitHub - ${org}/${repo}`, description, className: "hover-document article max-w-[80vw]" });
}
function useWhiteTextColor(bgColor) {
  const color2 = bgColor.charAt(0) === "#" ? bgColor.substring(1, 7) : bgColor;
  const r4 = parseInt(color2.substring(0, 2), 16);
  const g4 = parseInt(color2.substring(2, 4), 16);
  const b2 = parseInt(color2.substring(4, 6), 16);
  return r4 * 0.299 + g4 * 0.587 + b2 * 0.114 <= 186;
}
function GithubIssuePreview({ url, org, repo, issue_number, open, className }) {
  var _a, _b;
  const { data, error } = useLoadWhenOpen(open, `https://api.github.com/repos/${org}/${repo}/issues/${issue_number}`, jsonFetcher);
  if (!data && !error) {
    return (0, import_jsx_runtime41.jsx)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] animate-pulse", children: "Loading..." });
  }
  const resp = data;
  if (error) {
    return (0, import_jsx_runtime41.jsxs)("div", { className: "hover-document article", children: [(0, import_jsx_runtime41.jsx)("a", { href: url, className: (0, import_classnames18.default)("block text-inherit hover:text-inherit", className), target: "_blank", rel: "noreferrer", children: (0, import_jsx_runtime41.jsx)(ArrowTopRightOnSquareIcon_default, { className: "float-right w-4 h-4" }) }), (0, import_jsx_runtime41.jsx)("div", { className: "mt-2", children: "Error loading from GitHub." })] });
  }
  const dateString = new Date(resp.created_at).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric"
  });
  return (0, import_jsx_runtime41.jsxs)("div", { className: "hover-document article w-[400px] sm:max-w-[400px] p-3", children: [(0, import_jsx_runtime41.jsxs)("div", { className: "text-xs font-light", children: [org, "/", repo] }), (0, import_jsx_runtime41.jsxs)("div", { className: "my-2 text-lg font-bold dark:text-white", children: [resp.state === "open" && (0, import_jsx_runtime41.jsx)(PlusCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block mr-2 text-green-700 -translate-y-px dark:text-green-500" }), resp.state === "closed" && (0, import_jsx_runtime41.jsx)(CheckCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block mr-2 text-purple-700 -translate-y-px dark:text-purple-500" }), resp.title] }), (0, import_jsx_runtime41.jsxs)("div", { className: "text-xs font-light", children: ["#", issue_number, " opened on ", dateString, " by", " ", (0, import_jsx_runtime41.jsxs)("span", { className: "font-normal", children: ["@", resp.user.login] })] }), (0, import_jsx_runtime41.jsx)("p", { className: "text-md max-h-[4rem] overflow-hidden", children: resp.body }), ((_a = resp.labels) === null || _a === void 0 ? void 0 : _a.length) > 0 && (0, import_jsx_runtime41.jsx)("div", { className: "flex flex-wrap", children: (_b = resp.labels) === null || _b === void 0 ? void 0 : _b.map((label) => (0, import_jsx_runtime41.jsx)("span", { className: (0, import_classnames18.default)("mr-1 text-xs inline-flex items-center px-2 py-0.5 rounded-full", {
    "text-white": useWhiteTextColor(label.color)
  }), style: { backgroundColor: `#${label.color}` }, children: label.name }, label.id)) })] });
}
function GithubLink({ kind, children, url, org, repo, raw, file, from, to, issue_number, className }) {
  return (0, import_jsx_runtime41.jsx)(HoverPopover, { card: ({ load: load2 }) => {
    if (kind === "file") {
      return (0, import_jsx_runtime41.jsx)(GithubFilePreview, { url, raw, file, from, to, open: load2, org, repo, className });
    }
    if (kind === "issue") {
      return (0, import_jsx_runtime41.jsx)(GithubIssuePreview, { url, open: load2, org, issue_number, repo, className });
    }
  }, children: (0, import_jsx_runtime41.jsx)("a", { href: url, className: (0, import_classnames18.default)("italic", className), target: "_blank", rel: "noreferrer", children }) });
}

// ../../packages/myst-to-react/dist/links/index.js
var import_classnames19 = __toESM(require_classnames(), 1);
function getPageInfo(site, path) {
  var _a;
  if (!site)
    return void 0;
  const [projectSlug, pageSlug] = path.replace(/^\//, "").split("/");
  const project = (_a = site.projects) === null || _a === void 0 ? void 0 : _a.find((p3) => p3.slug === projectSlug || !p3.slug && !pageSlug);
  if (!project)
    return void 0;
  return project.pages.find((p3) => p3.slug === (pageSlug || projectSlug));
}
function InternalLink({ url, children, className }) {
  const Link2 = useLinkProvider();
  const site = useSiteManifest();
  const page = getPageInfo(site, url);
  const baseurl = useBaseurl();
  const skipPreview = !page || !page.description && !page.thumbnail;
  if (!page || skipPreview) {
    return (0, import_jsx_runtime42.jsx)(Link2, { to: withBaseurl(url, baseurl), prefetch: "intent", className, children });
  }
  return (0, import_jsx_runtime42.jsx)(HoverPopover, { card: (0, import_jsx_runtime42.jsx)(LinkCard, { internal: true, url, title: page.title, description: page.description, thumbnail: page.thumbnailOptimized || page.thumbnail }), children: (0, import_jsx_runtime42.jsx)(Link2, { to: withBaseurl(url, baseurl), prefetch: "intent", className, children }) });
}
var WikiLinkRenderer = ({ node, className }) => {
  var _a, _b;
  return (0, import_jsx_runtime42.jsx)(WikiLink, { url: node.url, page: (_a = node.data) === null || _a === void 0 ? void 0 : _a.page, wiki: (_b = node.data) === null || _b === void 0 ? void 0 : _b.wiki, className: (0, import_classnames19.default)(node.class, className), children: (0, import_jsx_runtime42.jsx)(MyST, { ast: node.children }) });
};
var GithubLinkRenderer = ({ node, className }) => {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  return (0, import_jsx_runtime42.jsx)(GithubLink, { kind: (_a = node.data) === null || _a === void 0 ? void 0 : _a.kind, url: node.url, org: (_b = node.data) === null || _b === void 0 ? void 0 : _b.org, repo: (_c = node.data) === null || _c === void 0 ? void 0 : _c.repo, raw: (_d = node.data) === null || _d === void 0 ? void 0 : _d.raw, file: (_e2 = node.data) === null || _e2 === void 0 ? void 0 : _e2.file, from: (_f = node.data) === null || _f === void 0 ? void 0 : _f.from, to: (_g = node.data) === null || _g === void 0 ? void 0 : _g.to, issue_number: (_h = node.data) === null || _h === void 0 ? void 0 : _h.issue_number, className: (0, import_classnames19.default)(node.class, className), children: (0, import_jsx_runtime42.jsx)(MyST, { ast: node.children }) });
};
var RRIDLinkRenderer = ({ node, className }) => {
  var _a;
  return (0, import_jsx_runtime42.jsx)(RRIDLink, { rrid: (_a = node.data) === null || _a === void 0 ? void 0 : _a.rrid, className: (0, import_classnames19.default)(node.class, className) });
};
var RORLinkRenderer = ({ node, className }) => {
  var _a;
  return (0, import_jsx_runtime42.jsx)(RORLink, { node, ror: (_a = node.data) === null || _a === void 0 ? void 0 : _a.ror, className: (0, import_classnames19.default)(node.class, className) });
};
var SimpleLink = ({ node, className }) => {
  var _a;
  const internal = (_a = node.internal) !== null && _a !== void 0 ? _a : false;
  if (internal) {
    return (0, import_jsx_runtime42.jsx)(InternalLink, { url: node.url, className: (0, import_classnames19.default)(node.class, className), children: (0, import_jsx_runtime42.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime42.jsx)("a", { target: "_blank", rel: "noreferrer", href: node.url, className: (0, import_classnames19.default)(node.class, className), children: (0, import_jsx_runtime42.jsx)(MyST, { ast: node.children }) });
};
var linkBlock = ({ node, className }) => {
  var _a;
  const iconClass5 = "self-center transition-transform flex-none ml-3";
  const containerClass = "flex-1 p-4 my-5 block border font-normal hover:border-blue-500 dark:hover:border-blue-400 no-underline hover:text-blue-600 dark:hover:text-blue-400 text-gray-600 dark:text-gray-100 border-gray-200 dark:border-gray-500 rounded shadow-sm hover:shadow-lg dark:shadow-neutral-700";
  const internal = (_a = node.internal) !== null && _a !== void 0 ? _a : false;
  const nested = (0, import_jsx_runtime42.jsxs)("div", { className: "flex h-full align-middle", children: [(0, import_jsx_runtime42.jsxs)("div", { className: "flex-grow", children: [node.title, (0, import_jsx_runtime42.jsx)("div", { className: "text-xs text-gray-500 dark:text-gray-400", children: (0, import_jsx_runtime42.jsx)(MyST, { ast: node.children }) })] }), internal && (0, import_jsx_runtime42.jsx)(LinkIcon_default, { width: "1.5rem", height: "1.5rem", className: iconClass5 }), !internal && (0, import_jsx_runtime42.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.5rem", height: "1.5rem", className: iconClass5 })] });
  if (internal) {
    return (0, import_jsx_runtime42.jsx)("a", { href: node.url, className: (0, import_classnames19.default)(containerClass, className), children: nested });
  }
  return (0, import_jsx_runtime42.jsx)("a", { className: (0, import_classnames19.default)(containerClass, className), target: "_blank", rel: "noopener noreferrer", href: node.url, children: nested });
};
var LINK_RENDERERS = {
  link: {
    base: SimpleLink,
    // Then duplicate the renderers for protocols
    "link[protocol=github]": GithubLinkRenderer,
    "link[protocol=wiki]": WikiLinkRenderer,
    "link[protocol=rrid]": RRIDLinkRenderer,
    "link[protocol=ror]": RORLinkRenderer,
    // Put the kinds last as they will match first in the future
    "link[kind=github]": GithubLinkRenderer,
    "link[kind=wiki]": WikiLinkRenderer,
    "link[kind=rrid]": RRIDLinkRenderer,
    "link[kind=ror]": RORLinkRenderer
  },
  linkBlock
};
var links_default = LINK_RENDERERS;

// ../../packages/myst-to-react/dist/heading.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
var import_classnames20 = __toESM(require_classnames(), 1);
var Heading = ({ node, className }) => {
  const { enumerator, depth, key, identifier, html_id } = node;
  const id = html_id || identifier || key;
  const textContent = (0, import_jsx_runtime43.jsxs)(import_jsx_runtime43.Fragment, { children: [enumerator && (0, import_jsx_runtime43.jsx)("span", { className: "mr-3 select-none", children: enumerator }), (0, import_jsx_runtime43.jsx)("span", { className: "heading-text", children: (0, import_jsx_runtime43.jsx)(MyST, { ast: node.children }) }), (0, import_jsx_runtime43.jsx)(HashLink, { id, kind: "Section", className: "font-normal", hover: true, hideInPopup: true, noWidth: true })] });
  return (0, import_react26.createElement)(`h${depth}`, {
    id,
    className: (0, import_classnames20.default)("relative group", className)
  }, textContent);
};
var HEADING_RENDERERS = {
  heading: Heading
};
var heading_default = HEADING_RENDERERS;

// ../../packages/myst-to-react/dist/crossReference.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_classnames21 = __toESM(require_classnames(), 1);

// ../../node_modules/myst-migrate/dist/v1_footnotes.js
var v1_footnotes_exports = {};
__export(v1_footnotes_exports, {
  DATE: () => DATE,
  DESCRIPTION: () => DESCRIPTION,
  VERSION: () => VERSION,
  downgrade: () => downgrade,
  upgrade: () => upgrade
});
var VERSION = 1;
var DATE = new Date(Date.parse("2025-02-07"));
var DESCRIPTION = `
Footnotes have dropped backwards compatibility with \`number\`,
instead using \`enumerator\` on both the \`FootnoteReference\` and \`FootnoteDefinition\` nodes.

Previous versions of the AST had both of these defined.
The \`enumerator\` property is used in all other numberings of figures, sections, equations, etc.
`;
function maybeParseInt(value) {
  if (value === void 0) {
    return void 0;
  }
  const result2 = Number.parseInt(value, 10);
  if (String(result2) === value) {
    return result2;
  } else {
    return void 0;
  }
}
function upgrade(file) {
  const { version: version3, mdast } = file;
  if (!(version3 === 0 || version3 === null)) {
    throw new Error(`Version must be 0`);
  }
  const nodes = selectAll("footnoteDefinition,footnoteReference", mdast);
  nodes.forEach((node) => {
    if (node.number !== void 0 && node.enumerator == null) {
      node.enumerator = String(node.number);
    }
    delete node.number;
  });
  return file;
}
function downgrade(file) {
  const { version: version3, mdast } = file;
  if (version3 !== VERSION) {
    throw new Error(`Version must be ${VERSION}`);
  }
  const nodes = selectAll("footnoteDefinition,footnoteReference", mdast);
  nodes.forEach((node) => {
    const maybeNumber = maybeParseInt(node.enumerator);
    if (maybeNumber !== void 0) {
      node.number = maybeNumber;
    }
    if (node.number !== void 0 && node.enumerator == null) {
      node.enumerator = String(node.number);
    }
    delete node.enumerator;
  });
  return file;
}

// ../../node_modules/myst-migrate/dist/v2_blockClasses.js
var v2_blockClasses_exports = {};
__export(v2_blockClasses_exports, {
  DATE: () => DATE2,
  DESCRIPTION: () => DESCRIPTION2,
  VERSION: () => VERSION2,
  downgrade: () => downgrade2,
  upgrade: () => upgrade2
});
var VERSION2 = 2;
var DATE2 = new Date(Date.parse("2025-03-05"));
var DESCRIPTION2 = `
Blocks could previously define class on \`block.data?.class\`, this has been explicitly moved to \`block.class\`.
`;
function upgrade2(file) {
  const { version: version3, mdast } = file;
  if (version3 !== 1) {
    throw new Error(`Version must be 1`);
  }
  const nodes = selectAll("block", mdast);
  nodes.forEach((node) => {
    if (typeof node.data?.class === "string") {
      node.class = `${node.class ?? ""} ${node.data.class}`.trim();
      delete node.data.class;
      if (Object.keys(node.data).length === 0)
        delete node.data;
    }
  });
  return file;
}
function downgrade2(file) {
  const { version: version3 } = file;
  if (version3 !== VERSION2) {
    throw new Error(`Version must be ${VERSION2}`);
  }
  return file;
}

// ../../node_modules/myst-migrate/dist/v3_outputs.js
var v3_outputs_exports = {};
__export(v3_outputs_exports, {
  DATE: () => DATE3,
  DESCRIPTION: () => DESCRIPTION3,
  VERSION: () => VERSION3,
  downgrade: () => downgrade3,
  upgrade: () => upgrade3
});
var VERSION3 = 3;
var DATE3 = new Date(Date.parse("2025-12-03"));
var DESCRIPTION3 = `
\`Output\` nodes previously could not represent AST trees for each output. 
Now, the \`Outputs\` node has \`Output\` children with a 1:1 correspondence to \`IOutput\` bundles.

Existing identifiers for the \`Output\` / \`Outputs\` nodes are not modified, as these are considered "content".
`;
function upgrade3(file) {
  const { version: version3, mdast } = file;
  if (version3 !== 2) {
    throw new Error(`Version must be 2`);
  }
  const nodes = selectAll("output", mdast);
  nodes.forEach((node) => {
    const numOutputs = node.data?.length ?? 0;
    const children = node.children ?? [];
    const placeholders = children.filter((child) => !!child.placeholder);
    const notPlaceholders = numOutputs === 1 ? children.filter((child) => !child.placeholder) : [];
    const outputsChildren = (node.data ?? []).map((outputData) => {
      const result2 = {
        type: "output",
        jupyter_data: outputData,
        // The first output gets all of the non-placeholders
        children: notPlaceholders.slice()
      };
      notPlaceholders.length = 0;
      return result2;
    });
    outputsChildren.push(...placeholders);
    if (node.data !== void 0) {
      delete node.data;
    }
    node.type = "outputs";
    node.children = outputsChildren;
  });
  return file;
}
function downgrade3(file) {
  const { version: version3, mdast } = file;
  if (version3 !== VERSION3) {
    throw new Error(`Version must be ${VERSION3}`);
  }
  const nodes = selectAll("outputs", mdast);
  nodes.forEach((node) => {
    const data = node.children.filter((output) => output.type === "output").map((output) => output.jupyter_data).filter((datum) => !!datum);
    const notPlaceholders = node.children.filter((child) => !child.placeholder);
    const children = notPlaceholders.map((output) => output.children ?? []).flat();
    const placeholders = node.children.filter((child) => !!child.placeholder);
    children.push(...placeholders);
    node.data = data;
    node.type = "output";
    node.children = children;
  });
  return file;
}

// ../../node_modules/myst-migrate/dist/migrations.js
var MIGRATIONS = [v1_footnotes_exports, v2_blockClasses_exports, v3_outputs_exports];

// ../../node_modules/myst-migrate/dist/index.js
async function migrate(src, opts) {
  if (opts?.to === void 0) {
    opts?.log?.warn(`Calling migrate with no version is deprecated and will be removed in future.`);
  }
  const to = opts?.to ?? MIGRATIONS.length;
  let currentVersion = src.version || 0;
  if (currentVersion === to) {
    opts?.log?.debug(`Already at version ${to}. No migration needed.`);
    return src;
  }
  while (currentVersion < to) {
    if (currentVersion >= MIGRATIONS.length) {
      throw new Error(`No migration available to go from version ${currentVersion} to ${currentVersion + 1}`);
    }
    const migration = MIGRATIONS[currentVersion];
    opts?.log?.debug(`Upgrading from v${currentVersion} to v${currentVersion + 1}...`);
    await migration.upgrade(src);
    currentVersion++;
    src.version = currentVersion;
  }
  while (currentVersion > to) {
    if (currentVersion - 1 >= MIGRATIONS.length) {
      throw new Error(`No migration available to go from version ${currentVersion} down to ${currentVersion - 1}`);
    }
    const migration = MIGRATIONS[currentVersion - 1];
    opts?.log?.debug(`Downgrading from v${currentVersion} to v${currentVersion - 1}...`);
    await migration.downgrade(src);
    currentVersion--;
    src.version = currentVersion;
  }
  return src;
}

// ../../packages/myst-to-react/dist/crossReference.js
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var fetcher5 = (...args) => fetch(...args).then((res) => __awaiter2(void 0, void 0, void 0, function* () {
  var _a;
  if (res.status === 200) {
    let data = yield res.json();
    try {
      data = yield migrate(Object.assign({ version: (_a = data.version) !== null && _a !== void 0 ? _a : 0 }, data), { to: MYST_SPEC_VERSION });
    } catch (error) {
      console.error(`Error migrating content for ${args[0]} (aborted):`, error);
    }
    return data;
  }
  throw new Error(`Content returned with status ${res.status}.`);
}));
function XrefChildren({ load: load2, identifier }) {
  const data = useSelectNodes({ load: load2, identifier });
  if (!data)
    return null;
  if (data.loading) {
    return (0, import_jsx_runtime44.jsx)(import_jsx_runtime44.Fragment, { children: "Loading..." });
  }
  if (data.error) {
    return (0, import_jsx_runtime44.jsx)(import_jsx_runtime44.Fragment, { children: "Error loading remote page." });
  }
  if (!data.nodes || data.nodes.length === 0) {
    return (0, import_jsx_runtime44.jsx)(import_jsx_runtime44.Fragment, { children: (0, import_jsx_runtime44.jsx)(InlineError, { value: identifier || "No Label", message: "Cross Reference Not Found" }) });
  }
  return (0, import_jsx_runtime44.jsx)(MyST, { ast: data === null || data === void 0 ? void 0 : data.nodes });
}
function createRemoteBaseUrl(url, remoteBaseUrl) {
  if (remoteBaseUrl && (url === null || url === void 0 ? void 0 : url.startsWith(remoteBaseUrl))) {
    return url;
  }
  return `${remoteBaseUrl || ""}${url || ""}`;
}
function createExternalUrl({ url, remoteBaseUrl, dataUrl, baseurl }) {
  if (!!remoteBaseUrl || // The parent reference is external
  (dataUrl === null || dataUrl === void 0 ? void 0 : dataUrl.startsWith("http"))) {
    if (!dataUrl) {
      console.error("Expected external URL to provide a dataUrl");
      return null;
    }
    return createRemoteBaseUrl(dataUrl, remoteBaseUrl);
  }
  if (dataUrl) {
    return withBaseurl(dataUrl, baseurl);
  }
  return `${withBaseurl(url, baseurl)}.json`;
}
function useFetchMdast({ remote, url, remoteBaseUrl, dataUrl }) {
  const baseurl = useBaseurl();
  const lookupUrl = createExternalUrl({ url, remoteBaseUrl, dataUrl, baseurl });
  return useSWR(remote ? lookupUrl : null, fetcher5);
}
function useSelectNodes({ load: load2, identifier }) {
  var _a;
  const references = useReferences();
  const frontmatter = useFrontmatter();
  const { remote, url, remoteBaseUrl, dataUrl } = useXRefState();
  if (!load2)
    return;
  const { data, error } = useFetchMdast({ remote, url, remoteBaseUrl, dataUrl });
  const mdast = data ? data.mdast : references === null || references === void 0 ? void 0 : references.article;
  const parts = data ? (_a = data.frontmatter) === null || _a === void 0 ? void 0 : _a.parts : frontmatter === null || frontmatter === void 0 ? void 0 : frontmatter.parts;
  let nodes = [];
  let htmlId;
  [{ mdast }, ...Object.values(parts !== null && parts !== void 0 ? parts : {})].forEach(({ mdast: tree }) => {
    if (!tree || nodes.length > 0)
      return;
    const selected = selectMdastNodes(tree, identifier, 3);
    nodes = selected.nodes;
    htmlId = selected.htmlId;
  });
  return { htmlId, nodes, loading: remote && !data, error: remote && error };
}
function CrossReferenceHover({ url: urlIn, dataUrl: dataUrlIn, remote: remoteIn, remoteBaseUrl: remoteBaseUrlIn, children, identifier, className, htmlId = "" }) {
  var _a;
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const parent = useXRefState();
  const remoteBaseUrl = remoteBaseUrlIn !== null && remoteBaseUrlIn !== void 0 ? remoteBaseUrlIn : parent.remoteBaseUrl;
  const remote = !!remoteBaseUrl || parent.remote || remoteIn;
  const url = parent.remote ? urlIn !== null && urlIn !== void 0 ? urlIn : parent.url : urlIn;
  const dataUrl = parent.remote ? dataUrlIn !== null && dataUrlIn !== void 0 ? dataUrlIn : parent.dataUrl : dataUrlIn;
  const external = !!remoteBaseUrl || ((_a = url === null || url === void 0 ? void 0 : url.startsWith("http")) !== null && _a !== void 0 ? _a : false);
  const scroll = (e3) => {
    e3.preventDefault();
    if (!htmlId)
      return;
    const el = document.getElementById(htmlId);
    scrollToElement(el, { htmlId });
  };
  const isButtonLike = (className !== null && className !== void 0 ? className : "").split(" ").includes("button");
  return (0, import_jsx_runtime44.jsx)(HoverPopover, { card: ({ load: load2 }) => (0, import_jsx_runtime44.jsx)(XRefProvider, { remote, remoteBaseUrl, url, dataUrl, children: (0, import_jsx_runtime44.jsxs)("div", { className: "hover-document article w-[500px] sm:max-w-[500px] overflow-auto", children: [remoteBaseUrl && (0, import_jsx_runtime44.jsxs)("div", { className: "px-3 py-1 w-full text-xs bg-gray-50 border-b", children: [(0, import_jsx_runtime44.jsx)("strong", { className: "text-gray-700", children: "Source: " }), (0, import_jsx_runtime44.jsx)("a", { className: (0, import_classnames21.default)("text-gray-700", className), href: `${createRemoteBaseUrl(url, remoteBaseUrl)}${htmlId ? `#${htmlId}` : ""}`, target: "_blank", children: remoteBaseUrl })] }), (0, import_jsx_runtime44.jsx)("div", { className: "px-3", children: (0, import_jsx_runtime44.jsx)(XrefChildren, { load: load2, identifier }) })] }) }), children: (0, import_jsx_runtime44.jsxs)("span", { children: [remote && external && (0, import_jsx_runtime44.jsx)("a", { href: `${createRemoteBaseUrl(url, remoteBaseUrl)}${htmlId ? `#${htmlId}` : ""}`, target: "_blank", className: (0, import_classnames21.default)({ "hover-link": !isButtonLike }, className), children }), remote && !external && (0, import_jsx_runtime44.jsx)(Link2, { to: `${withBaseurl(url, baseurl)}${htmlId ? `#${htmlId}` : ""}`, prefetch: "intent", className: (0, import_classnames21.default)({ "hover-link": !isButtonLike }, className), children }), !remote && (0, import_jsx_runtime44.jsx)("a", { href: `#${htmlId}`, onClick: scroll, className: (0, import_classnames21.default)({ "hover-link": !isButtonLike }, className), children })] }) });
}
var CrossReferenceNode = ({ node, className }) => {
  if (!node.children) {
    return (0, import_jsx_runtime44.jsx)(InlineError, { value: node.label || node.identifier || "No Label", message: "Cross Reference Not Found", className });
  }
  const { remote, url, dataUrl, remoteBaseUrl, identifier, html_id, class: nodeClass } = node;
  return (0, import_jsx_runtime44.jsxs)(CrossReferenceHover, { identifier, htmlId: html_id, remote, url, dataUrl, remoteBaseUrl, className: (0, import_classnames21.default)(nodeClass, className), children: [node.prefix && (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [node.prefix, " "] }), (0, import_jsx_runtime44.jsx)(MyST, { ast: node.children }), node.suffix || null] });
};
var CROSS_REFERENCE_RENDERERS = {
  crossReference: CrossReferenceNode
};
var crossReference_default = CROSS_REFERENCE_RENDERERS;

// ../../packages/myst-to-react/dist/tabs.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_classnames22 = __toESM(require_classnames(), 1);
var import_react27 = __toESM(require_react(), 1);
var TabSetContext = (0, import_react27.createContext)(void 0);
function TabSetStateProvider({ active, children }) {
  return (0, import_jsx_runtime45.jsx)(TabSetContext.Provider, { value: active, children });
}
function TabSet({ tabs, children, className }) {
  var _a, _b, _c, _d;
  const [lastClickedTab, onClickSyncedTab] = (_a = useTabSet()) !== null && _a !== void 0 ? _a : [];
  const [active, setActive] = (0, import_react27.useState)((_c = (_b = tabs.find((t11) => t11.selected)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : (_d = tabs === null || tabs === void 0 ? void 0 : tabs[0]) === null || _d === void 0 ? void 0 : _d.id);
  const onClick = (tab) => {
    setActive(tab.id);
    if (tab.sync) {
      if (!onClickSyncedTab) {
        console.error("TabStateProvider is not defined, synced tabs will not work.");
      }
      onClickSyncedTab === null || onClickSyncedTab === void 0 ? void 0 : onClickSyncedTab(tab.sync);
    }
  };
  (0, import_react27.useEffect)(() => {
    if (!lastClickedTab)
      return;
    const tab = tabs.find((item) => item.sync === lastClickedTab);
    if (!tab)
      return;
    setActive(tab === null || tab === void 0 ? void 0 : tab.id);
  }, [tabs, lastClickedTab, setActive]);
  return (0, import_jsx_runtime45.jsx)(TabSetStateProvider, { active, children: (0, import_jsx_runtime45.jsxs)("div", { className: (0, import_classnames22.default)("myst-tab-set my-5", className), children: [(0, import_jsx_runtime45.jsx)("div", { className: "myst-tab-set-row flex flex-row flex-wrap overflow-x-auto border-b border-b-gray-100", children: tabs.map((tab) => {
    return (0, import_jsx_runtime45.jsx)("div", { className: (0, import_classnames22.default)("myst-tab-item-header flex-none px-3 py-1 font-semibold cursor-pointer", {
      "myst-tab-item-header-active text-blue-600 border-b-2 border-b-blue-600 dark:border-b-white dark:text-white": active === tab.id,
      "myst-tab-item-header-inactive text-gray-500 dark:text-gray-300 hover:text-gray-700 dark:hover:text-gray-100": active !== tab.id
    }), onClick: () => onClick(tab), children: tab.title }, tab.id);
  }) }), (0, import_jsx_runtime45.jsx)("div", { className: "myst-tab-item-body flex shadow", children: (0, import_jsx_runtime45.jsx)("div", { className: "myst-tab-item-text w-full px-6", children }) })] }) });
}
function TabItem({ id, children, className }) {
  const active = (0, import_react27.useContext)(TabSetContext);
  const open = active === id;
  return (0, import_jsx_runtime45.jsx)("div", { className: (0, import_classnames22.default)({ hidden: !open }, className), children });
}
var TabSetRenderer = ({ node, className }) => {
  const tabs = selectAll("tabItem", node).map((tab) => ({
    title: tab.title,
    id: tab.key,
    sync: tab.sync
  }));
  return (0, import_jsx_runtime45.jsx)(TabSet, { tabs, className, children: (0, import_jsx_runtime45.jsx)(MyST, { ast: node.children }) });
};
var TabItemRenderer = ({ node, className }) => {
  return (0, import_jsx_runtime45.jsx)(TabItem, { id: node.key, className, children: (0, import_jsx_runtime45.jsx)(MyST, { ast: node.children }) });
};
var TAB_RENDERERS = {
  tabSet: TabSetRenderer,
  tabItem: TabItemRenderer
};
var tabs_default = TAB_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/chemicalFormula.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_classnames23 = __toESM(require_classnames(), 1);
function parseFormula(formula) {
  return [...formula !== null && formula !== void 0 ? formula : ""].reduce((acc, current) => {
    const last2 = acc.pop();
    const letter = current === "+" ? "\u207A" : current === "-" ? "\u207B" : current;
    const isNumber = letter.match(/[0-9]/);
    const lastIsNumber = last2 === null || last2 === void 0 ? void 0 : last2.match(/[0-9]/);
    if (isNumber) {
      if (lastIsNumber) {
        return [...acc, `${last2 !== null && last2 !== void 0 ? last2 : ""}${letter}`];
      }
      return [...acc, last2, letter].filter((v4) => !!v4);
    }
    if (lastIsNumber) {
      return [...acc, last2, letter].filter((v4) => !!v4);
    }
    return [...acc, `${last2 !== null && last2 !== void 0 ? last2 : ""}${letter}`];
  }, []);
}
var ChemicalFormula = ({ node, className }) => {
  const parts = parseFormula(node.value);
  return (0, import_jsx_runtime46.jsx)("span", { className: (0, import_classnames23.default)("text-inherit", className), "aria-roledescription": "Chemical Formula", children: parts.map((letter, index2) => {
    if (letter.match(/[0-9]/))
      return (0, import_jsx_runtime46.jsx)("sub", { children: letter }, index2);
    return (0, import_jsx_runtime46.jsx)("span", { children: letter }, index2);
  }) });
};
var CHEM_RENDERERS = {
  chemicalFormula: ChemicalFormula
};
var chemicalFormula_default = CHEM_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/siunits.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var SIUnits = ({ node, className }) => {
  var _a;
  const space = node.number == null ? "" : " ";
  const title = `${(_a = node.number) !== null && _a !== void 0 ? _a : ""}${space}${node.alt}`;
  return (0, import_jsx_runtime47.jsx)("span", { title, className, children: node.value });
};
var SI_RENDERERS = {
  si: SIUnits
};
var siunits_default = SI_RENDERERS;

// ../../packages/myst-to-react/dist/extensions/index.js
var EXT_RENDERERS = Object.assign(Object.assign({}, chemicalFormula_default), siunits_default);
var extensions_default = EXT_RENDERERS;

// ../../packages/myst-to-react/dist/inlineExpression.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_classnames24 = __toESM(require_classnames(), 1);
var InlineExpression = ({ node, className }) => {
  var _a, _b, _c;
  if (!node.result) {
    return (0, import_jsx_runtime48.jsx)(InlineError, { value: `Unexecuted inline expression for: ${node.value}`, className });
  }
  if (((_a = node.result) === null || _a === void 0 ? void 0 : _a.status) !== "ok") {
    return (0, import_jsx_runtime48.jsx)(InlineError, { value: `${(_b = node.result) === null || _b === void 0 ? void 0 : _b.ename}: ${(_c = node.result) === null || _c === void 0 ? void 0 : _c.evalue}`, className });
  }
  return (0, import_jsx_runtime48.jsx)(Tooltip, { title: (0, import_jsx_runtime48.jsx)("code", { children: node.value }), children: (0, import_jsx_runtime48.jsx)("span", { className: (0, import_classnames24.default)("border-b border-dotted cursor-help", className), children: (0, import_jsx_runtime48.jsx)(MyST, { ast: node.children }) }) });
};
var INLINE_EXPRESSION_RENDERERS = {
  inlineExpression: InlineExpression
};
var inlineExpression_default = INLINE_EXPRESSION_RENDERERS;

// ../../packages/myst-to-react/dist/proof.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_classnames25 = __toESM(require_classnames(), 1);
var ProofKind;
(function(ProofKind2) {
  ProofKind2["proof"] = "proof";
  ProofKind2["axiom"] = "axiom";
  ProofKind2["lemma"] = "lemma";
  ProofKind2["definition"] = "definition";
  ProofKind2["criterion"] = "criterion";
  ProofKind2["remark"] = "remark";
  ProofKind2["conjecture"] = "conjecture";
  ProofKind2["corollary"] = "corollary";
  ProofKind2["algorithm"] = "algorithm";
  ProofKind2["example"] = "example";
  ProofKind2["property"] = "property";
  ProofKind2["observation"] = "observation";
  ProofKind2["proposition"] = "proposition";
  ProofKind2["assumption"] = "assumption";
  ProofKind2["theorem"] = "theorem";
})(ProofKind || (ProofKind = {}));
function getClasses2(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s8) => s8.trim().toLowerCase()).filter((s8) => !!s8)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function capitalize(kind) {
  if (!kind)
    return "";
  return kind.slice(0, 1).toUpperCase() + kind.slice(1);
}
function getColor({ kind }) {
  switch (kind) {
    case ProofKind.proof:
    case ProofKind.algorithm:
      return { color: "gray" };
    case ProofKind.lemma:
    case ProofKind.conjecture:
    case ProofKind.theorem:
      return { color: "purple" };
    case ProofKind.observation:
    case ProofKind.assumption:
    case ProofKind.axiom:
      return { color: "yellow" };
    case ProofKind.criterion:
    case ProofKind.corollary:
    case ProofKind.property:
      return { color: "orange" };
    case ProofKind.example:
      return { color: "green" };
    case ProofKind.remark:
      return { color: "red" };
    case ProofKind.definition:
    case ProofKind.proposition:
    default:
      return { color: "blue" };
  }
}
var WrapperElement2 = ({ id, dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime49.jsx)("details", { id, className, children });
  return (0, import_jsx_runtime49.jsx)("aside", { id, className, children });
};
var HeaderElement2 = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime49.jsx)("summary", { className, children });
  return (0, import_jsx_runtime49.jsx)("div", { className, children });
};
var iconClass3 = "inline-block pl-2 mr-2 self-center flex-none";
function Proof({ title, kind, color: color2, dropdown, children, identifier, enumerator, className }) {
  return (0, import_jsx_runtime49.jsxs)(WrapperElement2, { id: identifier, dropdown, className: (0, import_classnames25.default)("myst-proof my-5 shadow dark:bg-stone-800 overflow-hidden", "dark:border-l-4 border-slate-400", {
    "dark:border-gray-500/60": !color2 || color2 === "gray",
    "dark:border-blue-500/60": color2 === "blue",
    "dark:border-green-500/60": color2 === "green",
    "dark:border-amber-500/70": color2 === "yellow",
    "dark:border-orange-500/60": color2 === "orange",
    "dark:border-red-500/60": color2 === "red",
    "dark:border-purple-500/60": color2 === "purple"
  }, className), children: [(0, import_jsx_runtime49.jsxs)(HeaderElement2, { dropdown, className: (0, import_classnames25.default)("myst-proof-header m-0 font-medium py-2 flex min-w-0", "text-md", "border-y dark:border-y-0", {
    "bg-gray-50/80 dark:bg-slate-900": !color2 || color2 === "gray",
    "bg-blue-50/80 dark:bg-slate-900": color2 === "blue",
    "bg-green-50/80 dark:bg-slate-900": color2 === "green",
    "bg-amber-50/80 dark:bg-slate-900": color2 === "yellow",
    "bg-orange-50/80 dark:bg-slate-900": color2 === "orange",
    "bg-red-50/80 dark:bg-slate-900": color2 === "red",
    "bg-purple-50/80 dark:bg-slate-900": color2 === "purple",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [(0, import_jsx_runtime49.jsxs)("div", { className: (0, import_classnames25.default)("myst-proof-title text-neutral-900 dark:text-white grow self-center overflow-hidden break-words", "ml-4"), children: [(0, import_jsx_runtime49.jsxs)(HashLink, { id: identifier, kind: capitalize(kind), children: [capitalize(kind), " ", enumerator] }), " ", title && (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: ["(", title, ")"] })] }), dropdown && (0, import_jsx_runtime49.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime49.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames25.default)(iconClass3, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime49.jsx)("div", { className: (0, import_classnames25.default)("myst-proof-body px-4", { "details-body": dropdown }), children })] });
}
var ProofRenderer = ({ node, className }) => {
  const [title, ...rest2] = node.children;
  const classes = getClasses2(node.class);
  const { color: color2 } = getColor({ kind: node.kind, classes });
  const isDropdown = classes.includes("dropdown");
  const useTitle = (title === null || title === void 0 ? void 0 : title.type) === "admonitionTitle";
  return (0, import_jsx_runtime49.jsx)(Proof, { identifier: node.html_id, title: useTitle ? (0, import_jsx_runtime49.jsx)(MyST, { ast: [title] }) : void 0, kind: node.kind, enumerator: node.enumerator, color: color2, dropdown: isDropdown, className, children: useTitle ? (0, import_jsx_runtime49.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime49.jsx)(MyST, { ast: node.children }) });
};
var PROOF_RENDERERS = {
  proof: ProofRenderer
};
var proof_default = PROOF_RENDERERS;

// ../../packages/myst-to-react/dist/exercise.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_classnames26 = __toESM(require_classnames(), 1);
function getClasses3(className) {
  var _a;
  const classes = (_a = className === null || className === void 0 ? void 0 : className.split(" ").map((s8) => s8.trim().toLowerCase()).filter((s8) => !!s8)) !== null && _a !== void 0 ? _a : [];
  return [...new Set(classes)];
}
function getColor2({ classes = [] }, defaultColor = "blue") {
  if (classes.includes("gray"))
    return { color: "gray" };
  if (classes.includes("purple"))
    return { color: "purple" };
  if (classes.includes("yellow"))
    return { color: "yellow" };
  if (classes.includes("orange"))
    return { color: "orange" };
  if (classes.includes("green"))
    return { color: "green" };
  if (classes.includes("red"))
    return { color: "red" };
  if (classes.includes("blue"))
    return { color: "blue" };
  return { color: defaultColor };
}
var WrapperElement3 = ({ id, dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime50.jsx)("details", { id, className, children });
  return (0, import_jsx_runtime50.jsx)("aside", { id, className, children });
};
var HeaderElement3 = ({ dropdown, className, children }) => {
  if (dropdown)
    return (0, import_jsx_runtime50.jsx)("summary", { className, children });
  return (0, import_jsx_runtime50.jsx)("div", { className, children });
};
var iconClass4 = "inline-block pl-2 mr-2 self-center flex-none";
function Callout({ title, color: color2, dropdown, children, identifier, className, Icon }) {
  return (0, import_jsx_runtime50.jsxs)(WrapperElement3, { id: identifier, dropdown, className: (0, import_classnames26.default)("myst-exercise my-5 shadow dark:bg-stone-800 overflow-hidden", "dark:border-l-4 border-slate-400", {
    "dark:border-gray-500/60": !color2 || color2 === "gray",
    "dark:border-blue-500/60": color2 === "blue",
    "dark:border-green-500/60": color2 === "green",
    "dark:border-amber-500/70": color2 === "yellow",
    "dark:border-orange-500/60": color2 === "orange",
    "dark:border-red-500/60": color2 === "red",
    "dark:border-purple-500/60": color2 === "purple"
  }, className), children: [(0, import_jsx_runtime50.jsxs)(HeaderElement3, { dropdown, className: (0, import_classnames26.default)("myst-exercise-header m-0 font-medium py-2 flex min-w-0", "text-md", "border-y dark:border-y-0", {
    "bg-gray-50/80 dark:bg-slate-900": !color2 || color2 === "gray",
    "bg-blue-50/80 dark:bg-slate-900": color2 === "blue",
    "bg-green-50/80 dark:bg-slate-900": color2 === "green",
    "bg-amber-50/80 dark:bg-slate-900": color2 === "yellow",
    "bg-orange-50/80 dark:bg-slate-900": color2 === "orange",
    "bg-red-50/80 dark:bg-slate-900": color2 === "red",
    "bg-purple-50/80 dark:bg-slate-900": color2 === "purple",
    "cursor-pointer hover:shadow-[inset_0_0_0px_30px_#00000003] dark:hover:shadow-[inset_0_0_0px_30px_#FFFFFF03]": dropdown
  }), children: [Icon && (0, import_jsx_runtime50.jsx)(Icon, { width: "2rem", height: "2rem", className: (0, import_classnames26.default)("myst-exercise-header-icon inline-block pl-2 mr-2 self-center flex-none", (0, import_classnames26.default)({
    "text-gray-600": !color2 || color2 === "gray",
    "text-blue-600": color2 === "blue",
    "text-green-600": color2 === "green",
    "text-amber-600": color2 === "yellow",
    "text-orange-600": color2 === "orange",
    "text-red-600": color2 === "red",
    "text-purple-600": color2 === "purple"
  })) }), (0, import_jsx_runtime50.jsx)("div", { className: (0, import_classnames26.default)(
    "myst-exercise-title text-neutral-900 dark:text-white grow self-center overflow-hidden break-words",
    { "ml-4": !Icon },
    // No icon!
    "group"
  ), children: title }), dropdown && (0, import_jsx_runtime50.jsx)("div", { className: "self-center flex-none text-sm font-thin text-neutral-700 dark:text-neutral-200", children: (0, import_jsx_runtime50.jsx)(ChevronRightIcon_default, { width: "1.5rem", height: "1.5rem", className: (0, import_classnames26.default)(iconClass4, "transition-transform details-toggle") }) })] }), (0, import_jsx_runtime50.jsx)("div", { className: (0, import_classnames26.default)("myst-exercise-body px-4", { "details-body": dropdown }), children })] });
}
var ExerciseRenderer = ({ node, className }) => {
  var _a, _b, _c;
  if (node.hidden)
    return null;
  const [title, ...rest2] = (_a = node.children) !== null && _a !== void 0 ? _a : [];
  const classes = getClasses3(node.class);
  const { color: color2 } = getColor2({ classes });
  const isDropdown = classes.includes("dropdown");
  const useTitle = ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === "admonitionTitle";
  const identifier = node.html_id;
  const enumerator = node.enumerator;
  const titleNode = (0, import_jsx_runtime50.jsxs)(import_jsx_runtime50.Fragment, { children: [(0, import_jsx_runtime50.jsxs)(HashLink, { id: identifier, kind: "Exercise", children: [node.gate === "start" && "Start of ", node.gate === "end" && "End of ", "Exercise", enumerator != null && (0, import_jsx_runtime50.jsxs)(import_jsx_runtime50.Fragment, { children: [" ", enumerator] })] }), useTitle && (0, import_jsx_runtime50.jsxs)(import_jsx_runtime50.Fragment, { children: [" ", "(", (0, import_jsx_runtime50.jsx)(MyST, { ast: [title] }), ")"] })] });
  return (0, import_jsx_runtime50.jsx)(Callout, { identifier, title: titleNode, color: color2, dropdown: isDropdown, className, children: useTitle ? (0, import_jsx_runtime50.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime50.jsx)(MyST, { ast: node.children }) });
};
var SolutionRenderer = ({ node, className }) => {
  var _a, _b, _c;
  if (node.hidden)
    return null;
  const [title, ...rest2] = (_a = node.children) !== null && _a !== void 0 ? _a : [];
  const classes = getClasses3(node.class);
  const { color: color2 } = getColor2({ classes }, "gray");
  const isDropdown = classes.includes("dropdown");
  const useTitle = ((_c = (_b = node.children) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === "admonitionTitle";
  const identifier = node.html_id;
  const titleNode = (0, import_jsx_runtime50.jsxs)(import_jsx_runtime50.Fragment, { children: [node.gate === "start" && "Start of ", node.gate === "end" && "End of ", (0, import_jsx_runtime50.jsx)(MyST, { ast: [title] }), (0, import_jsx_runtime50.jsx)(HashLink, { id: identifier, kind: "Solution", hover: true, hideInPopup: true, children: " #" })] });
  return (0, import_jsx_runtime50.jsx)(Callout, { identifier, title: useTitle ? titleNode : void 0, color: color2, dropdown: isDropdown, className, children: useTitle ? (0, import_jsx_runtime50.jsx)(MyST, { ast: rest2 }) : (0, import_jsx_runtime50.jsx)(MyST, { ast: node.children }) });
};
var EXERCISE_RENDERERS = {
  exercise: ExerciseRenderer,
  solution: SolutionRenderer
};
var exercise_default = EXERCISE_RENDERERS;

// ../../packages/myst-to-react/dist/aside.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_classnames27 = __toESM(require_classnames(), 1);
function getAsideClass(kind) {
  switch (kind) {
    case "topic":
      return {
        container: "myst-aside myst-aside-${kind} my-5 shadow dark:bg-stone-800 overflow-hidden dark:border-l-4 border-slate-400",
        title: "myst-aside-title m-0 font-medium py-2 px-4 flex min-w-0 text-md border-y dark:border-y-0 bg-gray-50/80 dark:bg-slate-900",
        body: "myst-aside-body px-4"
      };
    case "margin":
    case "sidebar":
    default:
      return {
        container: "myst-aside myst-aside-${kind} text-sm lg:h-0 col-margin-right",
        title: "myst-aside-title text-base font-semibold",
        body: "myst-aside-body"
      };
  }
}
var AsideRenderer = ({ node, className }) => {
  const [title, ...rest2] = node.children;
  const classes = getAsideClass(node.kind);
  if (title.type !== "admonitionTitle") {
    return (0, import_jsx_runtime51.jsx)("aside", { className: (0, import_classnames27.default)(classes.container, node.class, className), children: (0, import_jsx_runtime51.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime51.jsxs)("aside", { className: (0, import_classnames27.default)(classes.container, node.class, className), children: [(0, import_jsx_runtime51.jsx)("div", { className: classes.title, children: (0, import_jsx_runtime51.jsx)(MyST, { ast: title }) }), (0, import_jsx_runtime51.jsx)("div", { className: classes.body, children: (0, import_jsx_runtime51.jsx)(MyST, { ast: rest2 }) })] });
};
var ASIDE_RENDERERS = {
  aside: AsideRenderer
};
var aside_default = ASIDE_RENDERERS;

// ../../packages/myst-to-react/dist/unknown.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var UnknownDirective = ({ node, className }) => {
  const titleNode = (0, import_jsx_runtime52.jsxs)(import_jsx_runtime52.Fragment, { children: [(0, import_jsx_runtime52.jsx)("code", { children: node.name }), " - Unknown Directive"] });
  return (0, import_jsx_runtime52.jsx)(Callout, { title: titleNode, color: "red", dropdown: true, Icon: ExclamationTriangleIcon_default, className, children: (0, import_jsx_runtime52.jsx)("pre", { children: node.value }) });
};
var UNKNOWN_MYST_RENDERERS = {
  mystDirective: UnknownDirective
};
var unknown_default = UNKNOWN_MYST_RENDERERS;

// ../../packages/myst-to-react/dist/index.js
var DEFAULT_RENDERERS = mergeRenderers([
  basic_default,
  unknown_default,
  block_default,
  image_default,
  links_default,
  code_default,
  math_default,
  cite_default,
  tabs_default,
  iframe_default,
  footnotes_default,
  admonitions_default,
  reactive_default,
  heading_default,
  crossReference_default,
  dropdown_default,
  card_default,
  grid_default,
  inlineExpression_default,
  extensions_default,
  proof_default,
  exercise_default,
  aside_default
], true);

// ../../packages/site/src/components/DocumentOutline.tsx
var import_classnames28 = __toESM(require_classnames(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var import_react29 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-collapsible/dist/index.mjs
var React86 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-id/dist/index.mjs
var React85 = __toESM(require_react(), 1);
var useReactId = React85[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React85.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId)
      setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/@radix-ui/react-collapsible/dist/index.mjs
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
"use client";
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible = React86.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: COLLAPSIBLE_NAME
    });
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId(),
        open,
        onOpenToggle: React86.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
          Primitive.div,
          {
            "data-state": getState(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME2 = "CollapsibleTrigger";
var CollapsibleTrigger = React86.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME2, __scopeCollapsible);
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME2;
var CONTENT_NAME3 = "CollapsibleContent";
var CollapsibleContent = React86.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME3, props.__scopeCollapsible);
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(Presence, { present: forceMount || context.open, children: ({ present }) => /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME3;
var CollapsibleContentImpl = React86.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME3, __scopeCollapsible);
  const [isPresent, setIsPresent] = React86.useState(present);
  const ref = React86.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = React86.useRef(0);
  const height = heightRef.current;
  const widthRef = React86.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React86.useRef(isOpen);
  const originalStylesRef = React86.useRef(void 0);
  React86.useEffect(() => {
    const rAF2 = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF2);
  }, []);
  useLayoutEffect2(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
    Primitive.div,
    {
      "data-state": getState(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState(open) {
  return open ? "open" : "closed";
}
var Root3 = Collapsible;
var Trigger2 = CollapsibleTrigger;
var Content3 = CollapsibleContent;

// ../../packages/site/src/components/DocumentOutline.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
var SELECTOR = [1, 2, 3, 4].map((n5) => `main h${n5}`).join(", ");
var onClient = typeof document !== "undefined";
var Headings = ({ headings, activeId }) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("ul", { className: "myst-outline-list text-sm leading-6 text-slate-400", children: headings.map((heading) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
  "li",
  {
    className: (0, import_classnames28.default)("myst-outline-item border-l-2 hover:border-l-blue-500", {
      "text-blue-600": heading.id === activeId,
      "border-l-gray-300 dark:border-l-gray-50": heading.id !== activeId,
      "border-l-blue-500": heading.id === activeId,
      "bg-blue-50 dark:bg-slate-800": heading.id === activeId,
      "myst-outline-item-active": heading.id === activeId
    }),
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
      "a",
      {
        className: (0, import_classnames28.default)("block p-1", {
          "text-slate-900 dark:text-slate-50": heading.level < 2 && heading.id !== activeId,
          "text-slate-500 dark:text-slate-300": heading.level >= 2 && heading.id !== activeId,
          "text-blue-600 dark:text-white font-bold": heading.id === activeId,
          "pr-2": heading.id !== activeId,
          // Allows for bold to change length
          "pl-2": heading.level === 1,
          "pl-4": heading.level === 2,
          "pl-8 text-xs": heading.level === 3,
          "pl-10 text-xs font-light": heading.level === 4,
          "pl-12 text-xs font-extralight": heading.level === 5
        }),
        href: `#${heading.id}`,
        onClick: (e3) => {
          e3.preventDefault();
          const el = document.querySelector(`#${heading.id}`);
          if (!el)
            return;
          el.scrollIntoView({ behavior: "smooth" });
          history.replaceState(void 0, "", `#${heading.id}`);
          if (el.tabIndex === -1)
            el.tabIndex = -1;
          el.focus({ preventScroll: true });
        },
        dangerouslySetInnerHTML: { __html: heading.titleHTML }
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/DocumentOutline.tsx",
        lineNumber: 50,
        columnNumber: 9
      },
      this
    )
  },
  heading.id,
  false,
  {
    fileName: "../../packages/site/src/components/DocumentOutline.tsx",
    lineNumber: 40,
    columnNumber: 7
  },
  this
)) }, void 0, false, {
  fileName: "../../packages/site/src/components/DocumentOutline.tsx",
  lineNumber: 38,
  columnNumber: 3
}, this);
function cloneHeadingElement(originalElement) {
  const clonedElement = originalElement.cloneNode(true);
  const abbrElements = clonedElement.getElementsByTagName("abbr");
  for (let i6 = 0; i6 < abbrElements.length; i6++) {
    const abbr = abbrElements[i6];
    const parent = abbr.parentNode;
    while (abbr.firstChild) {
      parent.insertBefore(abbr.firstChild, abbr);
    }
    parent.removeChild(abbr);
  }
  return clonedElement;
}
function getHeaders(selector) {
  const headers = Array.from(document.querySelectorAll(selector)).filter((e3) => {
    const parent = e3.closest(".exclude-from-outline");
    return !(e3.classList.contains("title") || parent);
  });
  return headers;
}
function useMutationObserver(targetRef, callback, options) {
  const [observer, setObserver] = (0, import_react29.useState)(null);
  if (!onClient)
    return { observer };
  (0, import_react29.useEffect)(() => {
    const obs = new MutationObserver(callback);
    setObserver(obs);
  }, [callback, setObserver]);
  (0, import_react29.useEffect)(() => {
    if (!observer || !targetRef.current) {
      return;
    }
    try {
      observer.observe(targetRef.current, options);
    } catch (e3) {
      console.error(e3);
    }
    return () => {
      if (observer) {
        observer.disconnect();
      }
    };
  }, [observer]);
}
var useIntersectionObserver = (elements, options) => {
  const [observer, setObserver] = (0, import_react29.useState)(null);
  const [intersecting, setIntersecting] = (0, import_react29.useState)([]);
  if (!onClient)
    return { observer };
  (0, import_react29.useEffect)(() => {
    const cb2 = (entries) => {
      setIntersecting(entries.filter((e3) => e3.isIntersecting).map((e3) => e3.target));
    };
    const o11 = new IntersectionObserver(cb2, options != null ? options : {});
    setObserver(o11);
    return () => o11.disconnect();
  }, []);
  (0, import_react29.useEffect)(() => {
    if (!observer) {
      return;
    }
    const toWatch = elements;
    toWatch.map((e3) => observer.observe(e3));
    return () => {
      toWatch.map((e3) => observer.unobserve(e3));
    };
  }, [elements]);
  return { observer, intersecting };
};
function useHeaders(selector, maxdepth) {
  if (!onClient)
    return { activeId: "", headings: [] };
  const mainElementRef = (0, import_react29.useRef)(null);
  (0, import_react29.useEffect)(() => {
    mainElementRef.current = document.querySelector("main");
  }, []);
  const [elements, setElements] = (0, import_react29.useState)([]);
  const onMutation = (0, import_react29.useCallback)(
    (0, import_lodash.default)(
      () => {
        setElements(getHeaders(selector));
      },
      500,
      { trailing: false }
    ),
    [selector]
  );
  useMutationObserver(mainElementRef, onMutation, {
    attributes: true,
    childList: true,
    subtree: true
  });
  (0, import_react29.useEffect)(onMutation, []);
  const { intersecting } = useIntersectionObserver(elements);
  const [activeId, setActiveId] = (0, import_react29.useState)();
  (0, import_react29.useEffect)(() => {
    const highlighted = intersecting.reduce(
      (a3, b2) => {
        if (a3)
          return a3;
        if (b2.classList.contains("highlight"))
          return b2.id;
        return null;
      },
      null
    );
    const active = [...intersecting].sort(
      (a3, b2) => a3.offsetTop - b2.offsetTop
    )[0];
    if (highlighted || active)
      setActiveId(highlighted || active.id);
  }, [intersecting]);
  const [headings, setHeadings] = (0, import_react29.useState)([]);
  (0, import_react29.useEffect)(() => {
    let minLevel = 10;
    const thisHeadings = elements.map((element2) => {
      return {
        element: element2,
        level: Number(element2.tagName.slice(1)),
        id: element2.id,
        text: element2.querySelector(".heading-text")
      };
    }).filter((h4) => !!h4.text).map(({ element: element2, level, text, id }) => {
      const { innerText: title, innerHTML: titleHTML } = cloneHeadingElement(
        text
      );
      minLevel = Math.min(minLevel, level);
      return { element: element2, title, titleHTML, id, level };
    }).filter((heading) => {
      heading.level = heading.level - minLevel + 1;
      return heading.level < maxdepth + 1;
    });
    setHeadings(thisHeadings);
  }, [elements]);
  return { activeId, headings };
}
function useOutlineHeight(existingContainer) {
  const container = (0, import_react29.useRef)(null);
  const outline = (0, import_react29.useRef)(null);
  const transitionState = useNavigation().state;
  const setHeight = () => {
    if (!container.current || !outline.current)
      return;
    const height = container.current.offsetHeight - window.scrollY + container.current.offsetTop;
    outline.current.style.display = height < 50 ? "none" : "";
    outline.current.style.height = height > window.innerHeight ? "" : `${height}px`;
    outline.current.style.opacity = height && height > 300 ? "" : "0";
    outline.current.style.pointerEvents = height && height > 300 ? "" : "none";
  };
  (0, import_react29.useEffect)(() => {
    setHeight();
    setTimeout(setHeight, 100);
    const handleScroll2 = () => setHeight();
    window.addEventListener("scroll", handleScroll2);
    return () => {
      window.removeEventListener("scroll", handleScroll2);
    };
  }, [container.current, outline.current, transitionState]);
  (0, import_react29.useEffect)(() => {
    if (!existingContainer || !existingContainer.current)
      return;
    container.current = existingContainer.current;
  }, [existingContainer == null ? void 0 : existingContainer.current]);
  return { container, outline };
}
function useMarginOccluder() {
  const [occluded, setOccluded] = (0, import_react29.useState)(false);
  const [elements, setElements] = (0, import_react29.useState)([]);
  const mainElementRef = (0, import_react29.useRef)(null);
  (0, import_react29.useEffect)(() => {
    mainElementRef.current = document.querySelector("main");
  }, []);
  const onMutation = (0, import_react29.useCallback)(
    (0, import_lodash.default)(
      () => {
        if (!mainElementRef.current) {
          return;
        }
        const classes = [
          "col-margin-right",
          "col-margin-right-inset",
          "col-gutter-outset-right",
          "col-screen-right",
          "col-screen-inset-right",
          "col-page-right",
          "col-page-inset-right",
          "col-body-outset-right",
          "col-gutter-page-right",
          // 'col-screen', // This is on everything!
          "col-page",
          "col-page-inset",
          "col-body-outset"
        ];
        const selector = classes.map((cls) => [`.${cls}`, `.${cls} > *`]).flat().join(", ");
        const marginElements = mainElementRef.current.querySelectorAll(selector);
        setElements(Array.from(marginElements));
      },
      500,
      { trailing: false }
    ),
    []
  );
  useMutationObserver(mainElementRef, onMutation, {
    attributes: true,
    childList: true,
    subtree: true
  });
  (0, import_react29.useEffect)(onMutation, []);
  const { intersecting } = useIntersectionObserver(elements, { rootMargin: "0px 0px -33% 0px" });
  (0, import_react29.useEffect)(() => {
    setOccluded(intersecting.length > 0);
  }, [intersecting]);
  return { occluded };
}
var DocumentOutline = ({
  outlineRef,
  title = "Contents",
  top = 0,
  className,
  selector = SELECTOR,
  children,
  maxdepth = 4,
  isMargin
}) => {
  const { activeId, headings } = useHeaders(selector, maxdepth);
  const [open, setOpen] = (0, import_react29.useState)(false);
  const { occluded } = useMarginOccluder();
  (0, import_react29.useEffect)(() => {
    setOpen(true);
  }, [isMargin]);
  (0, import_react29.useEffect)(() => {
    if (isMargin) {
      setOpen(!occluded);
    }
  }, [occluded, isMargin]);
  if (headings.length <= 1 || !onClient) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("nav", { suppressHydrationWarning: true, children }, void 0, false, {
      fileName: "../../packages/site/src/components/DocumentOutline.tsx",
      lineNumber: 393,
      columnNumber: 12
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Root3, { open, onOpenChange: setOpen, className: "myst-outline-section", children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
    "nav",
    {
      ref: outlineRef,
      "aria-label": "Document Outline",
      className: (0, import_classnames28.default)(
        "myst-outline not-prose overflow-y-auto",
        "transition-opacity duration-700",
        // Animation on load
        className
      ),
      style: {
        top,
        maxHeight: `calc(100vh - ${top + 100}px)`
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", { className: "myst-outline-header flex flex-row gap-2 mb-4 text-sm leading-6 uppercase rounded-lg text-slate-900 dark:text-slate-100", children: [
          title,
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Trigger2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
            "button",
            {
              className: "myst-outline-collapsible self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2",
              "aria-label": "Open Contents",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
                ChevronRightIcon_default,
                {
                  className: "transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100",
                  height: "1.5rem",
                  width: "1.5rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/DocumentOutline.tsx",
                  lineNumber: 418,
                  columnNumber: 15
                },
                this
              )
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/DocumentOutline.tsx",
              lineNumber: 414,
              columnNumber: 13
            },
            this
          ) }, void 0, false, {
            fileName: "../../packages/site/src/components/DocumentOutline.tsx",
            lineNumber: 413,
            columnNumber: 11
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/DocumentOutline.tsx",
          lineNumber: 411,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Content3, { className: "CollapsibleContent", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Headings, { headings, activeId }, void 0, false, {
            fileName: "../../packages/site/src/components/DocumentOutline.tsx",
            lineNumber: 427,
            columnNumber: 11
          }, this),
          children
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/DocumentOutline.tsx",
          lineNumber: 426,
          columnNumber: 9
        }, this)
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/DocumentOutline.tsx",
      lineNumber: 398,
      columnNumber: 7
    },
    this
  ) }, void 0, false, {
    fileName: "../../packages/site/src/components/DocumentOutline.tsx",
    lineNumber: 397,
    columnNumber: 5
  }, this);
};

// ../../packages/site/src/components/FooterLinksBlock.tsx
var import_classnames29 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
var FooterLink = ({
  title,
  short_title,
  url,
  group: group2,
  right
}) => {
  const baseurl = useBaseurl();
  const Link2 = useLinkProvider();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
    Link2,
    {
      prefetch: "intent",
      className: (0, import_classnames29.default)(
        "myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700",
        { "myst-footer-link-prev": right, "myst-footer-link-next": !right }
      ),
      to: withBaseurl(url, baseurl),
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "flex h-full align-middle", children: [
        right && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
          ArrowLeftIcon_default,
          {
            width: "1.5rem",
            height: "1.5rem",
            className: "myst-footer-link-icon self-center transition-transform group-hover:-translate-x-1 shrink-0"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 26,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: (0, import_classnames29.default)("flex-grow", { "text-right": right }), children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "myst-footer-link-group text-xs text-gray-500 dark:text-gray-400", children: group2 || " " }, void 0, false, {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 33,
            columnNumber: 11
          }, this),
          short_title || title
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
          lineNumber: 32,
          columnNumber: 9
        }, this),
        !right && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
          ArrowRightIcon_default,
          {
            width: "1.5rem",
            height: "1.5rem",
            className: "myst-footer-link-icon self-center transition-transform group-hover:translate-x-1 shrink-0"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
            lineNumber: 39,
            columnNumber: 11
          },
          this
        )
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
        lineNumber: 24,
        columnNumber: 7
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 16,
      columnNumber: 5
    },
    this
  );
};
function FooterLinksBlock({ links }) {
  var _a, _b, _c, _d, _e2, _f;
  if (!links || !((_a = links.navigation) == null ? void 0 : _a.prev) && !((_b = links.navigation) == null ? void 0 : _b.next))
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { className: "myst-footer-links flex pt-10 mb-10 space-x-4", children: [
    ((_c = links.navigation) == null ? void 0 : _c.prev) && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(FooterLink, { ...(_d = links.navigation) == null ? void 0 : _d.prev, right: true }, void 0, false, {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 54,
      columnNumber: 34
    }, this),
    ((_e2 = links.navigation) == null ? void 0 : _e2.next) && /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(FooterLink, { ...(_f = links.navigation) == null ? void 0 : _f.next }, void 0, false, {
      fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
      lineNumber: 55,
      columnNumber: 34
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/FooterLinksBlock.tsx",
    lineNumber: 53,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/ContentReload.tsx
var import_react30 = __toESM(require_react(), 1);
var STORAGE_KEY = "myst";
async function mystLiveReloadConnect(config) {
  if (!config.port || window.mystLiveReloadConnected)
    return;
  window.mystLiveReloadConnected = true;
  setTimeout(() => {
    const myst = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "{}");
    if (myst.scroll) {
      window.scrollTo(0, myst.scroll);
      sessionStorage.removeItem(STORAGE_KEY);
    }
  }, 30);
  console.log(`\u{1F50A} Listening to live content changes on port ${config.port}`);
  const protocol = location.protocol === "https:" ? "wss:" : "ws:";
  const host = location.hostname;
  const socketPath = `${protocol}//${host}:${config.port}/socket`;
  const ws = new WebSocket(socketPath);
  ws.onmessage = (message) => {
    const event = JSON.parse(message.data);
    if (event.type === "LOG") {
      console.log(event.message);
    }
    if (event.type === "RELOAD") {
      console.log("\u{1F680} Reloading window ...");
      console.log(`\u{1F4CC} Keeping scroll for page at ${window.scrollY}`);
      const myst = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "{}");
      myst.scroll = window.scrollY;
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify(myst));
      window.location.reload();
    }
  };
  ws.onopen = () => {
    if (config && typeof config.onOpen === "function") {
      config.onOpen();
    }
  };
  ws.onclose = () => {
    console.log("MyST content server web socket closed. Reconnecting...");
    setTimeout(
      () => mystLiveReloadConnect({
        ...config,
        onOpen: () => window.location.reload()
      }),
      1e3
    );
  };
  ws.onerror = (error) => {
    console.log("MyST content server web socket error:");
    console.error(error);
  };
}
function ContentReload({ port }) {
  (0, import_react30.useEffect)(() => {
    mystLiveReloadConnect({ port });
  }, []);
  return null;
}

// ../../packages/site/src/components/Bibliography.tsx
var import_classnames30 = __toESM(require_classnames(), 1);
var import_react31 = __toESM(require_react(), 1);
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime(), 1);
function Bibliography({
  containerClassName,
  innerClassName,
  hideLongBibliography = 15
}) {
  var _a;
  const references = useReferences();
  const grid = useGridSystemProvider();
  const { order, data } = (_a = references == null ? void 0 : references.cite) != null ? _a : {};
  const filtered = order == null ? void 0 : order.filter((l7) => l7);
  const [hidden, setHidden] = (0, import_react31.useState)(true);
  if (!filtered || !data || filtered.length === 0)
    return null;
  const refs = hidden && hideLongBibliography ? filtered.slice(0, hideLongBibliography) : filtered;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
    "section",
    {
      id: "references",
      className: (0, import_classnames30.default)(
        "myst-bibliography",
        grid,
        "subgrid-gap col-screen",
        containerClassName
      ),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { className: innerClassName, children: [
          !!hideLongBibliography && filtered.length > hideLongBibliography && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
            "button",
            {
              onClick: () => setHidden(!hidden),
              className: "myst-bibliography-toggle float-right p-1 px-2 text-xs border rounded hover:border-blue-500 dark:hover:border-blue-400",
              children: hidden ? "Show All" : "Collapse"
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Bibliography.tsx",
              lineNumber: 34,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("header", { className: "myst-bibliography-header text-lg font-semibold text-stone-900 dark:text-white group", children: [
            "References",
            /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(HashLink, { id: "references", title: "Link to References", hover: true, className: "ml-2" }, void 0, false, {
              fileName: "../../packages/site/src/components/Bibliography.tsx",
              lineNumber: 43,
              columnNumber: 11
            }, this)
          ] }, void 0, true, {
            fileName: "../../packages/site/src/components/Bibliography.tsx",
            lineNumber: 41,
            columnNumber: 9
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/Bibliography.tsx",
          lineNumber: 32,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          "div",
          {
            className: (0, import_classnames30.default)(
              "myst-bibliography-list pl-3 mb-8 text-xs text-stone-500 dark:text-stone-300",
              innerClassName
            ),
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("ol", { children: [
              refs.map((label) => {
                const { html } = data[label];
                return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
                  "li",
                  {
                    className: "myst-bibliography-item break-words",
                    id: `cite-${label}`,
                    dangerouslySetInnerHTML: { __html: html || "" }
                  },
                  label,
                  false,
                  {
                    fileName: "../../packages/site/src/components/Bibliography.tsx",
                    lineNumber: 56,
                    columnNumber: 15
                  },
                  this
                );
              }),
              !!hideLongBibliography && filtered.length > hideLongBibliography && /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("li", { className: "text-center list-none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
                "button",
                {
                  onClick: () => setHidden(!hidden),
                  className: "myst-bibliography-toggle p-2 border rounded hover:border-blue-500 dark:hover:border-blue-400",
                  children: hidden ? `Show all ${filtered.length} references` : "Collapse references"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Bibliography.tsx",
                  lineNumber: 66,
                  columnNumber: 15
                },
                this
              ) }, void 0, false, {
                fileName: "../../packages/site/src/components/Bibliography.tsx",
                lineNumber: 65,
                columnNumber: 13
              }, this)
            ] }, void 0, true, {
              fileName: "../../packages/site/src/components/Bibliography.tsx",
              lineNumber: 52,
              columnNumber: 9
            }, this)
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Bibliography.tsx",
            lineNumber: 46,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Bibliography.tsx",
      lineNumber: 23,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Footnotes.tsx
var import_classnames31 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime(), 1);
function Footnotes({
  containerClassName,
  innerClassName
}) {
  const references = useReferences();
  const grid = useGridSystemProvider();
  const defs = selectAll("footnoteDefinition", references == null ? void 0 : references.article);
  const refs = selectAll("footnoteReference", references == null ? void 0 : references.article);
  if (defs.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
    "section",
    {
      id: "footnotes",
      className: (0, import_classnames31.default)("myst-footnotes", grid, "subgrid-gap col-screen", containerClassName),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: innerClassName, children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("header", { className: "myst-footnotes-header text-lg font-semibold text-stone-900 dark:text-white group", children: [
          "Footnotes",
          /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(HashLink, { id: "footnotes", title: "Link to Footnotes", hover: true, className: "ml-2" }, void 0, false, {
            fileName: "../../packages/site/src/components/Footnotes.tsx",
            lineNumber: 28,
            columnNumber: 11
          }, this)
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/Footnotes.tsx",
          lineNumber: 26,
          columnNumber: 9
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/components/Footnotes.tsx",
          lineNumber: 25,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
          "div",
          {
            className: (0, import_classnames31.default)(
              "myst-footnotes-list pl-3 mb-8 text-xs text-stone-500 dark:text-stone-300",
              innerClassName
            ),
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("ol", { children: defs.map((fn) => {
              return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
                "li",
                {
                  id: `fn-${fn.identifier}`,
                  className: "myst-footnotes-item group",
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "flex flex-row", children: [
                    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "myst-footnote-content break-words grow", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(MyST, { ast: fn.children }, void 0, false, {
                      fileName: "../../packages/site/src/components/Footnotes.tsx",
                      lineNumber: 47,
                      columnNumber: 21
                    }, this) }, void 0, false, {
                      fileName: "../../packages/site/src/components/Footnotes.tsx",
                      lineNumber: 46,
                      columnNumber: 19
                    }, this),
                    /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { className: "myst-footnote-backlinks flex flex-col grow-0", children: refs.filter((ref) => ref.identifier === fn.identifier).map((ref) => /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
                      HashLink,
                      {
                        id: `fnref-${ref.key}`,
                        title: "Link to Content",
                        hover: "desktop",
                        className: "p-1",
                        children: "\u21A9",
                        scrollBehavior: "instant"
                      },
                      ref.key,
                      false,
                      {
                        fileName: "../../packages/site/src/components/Footnotes.tsx",
                        lineNumber: 53,
                        columnNumber: 25
                      },
                      this
                    )) }, void 0, false, {
                      fileName: "../../packages/site/src/components/Footnotes.tsx",
                      lineNumber: 49,
                      columnNumber: 19
                    }, this)
                  ] }, void 0, true, {
                    fileName: "../../packages/site/src/components/Footnotes.tsx",
                    lineNumber: 45,
                    columnNumber: 17
                  }, this)
                },
                fn.key,
                false,
                {
                  fileName: "../../packages/site/src/components/Footnotes.tsx",
                  lineNumber: 40,
                  columnNumber: 15
                },
                this
              );
            }) }, void 0, false, {
              fileName: "../../packages/site/src/components/Footnotes.tsx",
              lineNumber: 37,
              columnNumber: 9
            }, this)
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Footnotes.tsx",
            lineNumber: 31,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Footnotes.tsx",
      lineNumber: 21,
      columnNumber: 5
    },
    this
  );
}

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react32 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/env.js
var i = Object.defineProperty;
var d = (t11, e3, n5) => e3 in t11 ? i(t11, e3, { enumerable: true, configurable: true, writable: true, value: n5 }) : t11[e3] = n5;
var r = (t11, e3, n5) => (d(t11, typeof e3 != "symbol" ? e3 + "" : e3, n5), n5);
var o = class {
  constructor() {
    r(this, "current", this.detect());
    r(this, "handoffState", "pending");
    r(this, "currentId", 0);
  }
  set(e3) {
    this.current !== e3 && (this.handoffState = "pending", this.currentId = 0, this.current = e3);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s = new o();

// ../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var l = (e3, f6) => {
  s.isServer ? (0, import_react32.useEffect)(e3, f6) : (0, import_react32.useLayoutEffect)(e3, f6);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react33 = __toESM(require_react(), 1);
function s2(e3) {
  let r4 = (0, import_react33.useRef)(e3);
  return l(() => {
    r4.current = e3;
  }, [e3]), r4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react34 = __toESM(require_react(), 1);
var o2 = function(t11) {
  let e3 = s2(t11);
  return import_react34.default.useCallback((...r4) => e3.current(...r4), [e3]);
};

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react35 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/micro-task.js
function t3(e3) {
  typeof queueMicrotask == "function" ? queueMicrotask(e3) : Promise.resolve().then(e3).catch((o11) => setTimeout(() => {
    throw o11;
  }));
}

// ../../node_modules/@headlessui/react/dist/utils/disposables.js
function o3() {
  let n5 = [], r4 = { addEventListener(e3, t11, s8, a3) {
    return e3.addEventListener(t11, s8, a3), r4.add(() => e3.removeEventListener(t11, s8, a3));
  }, requestAnimationFrame(...e3) {
    let t11 = requestAnimationFrame(...e3);
    return r4.add(() => cancelAnimationFrame(t11));
  }, nextFrame(...e3) {
    return r4.requestAnimationFrame(() => r4.requestAnimationFrame(...e3));
  }, setTimeout(...e3) {
    let t11 = setTimeout(...e3);
    return r4.add(() => clearTimeout(t11));
  }, microTask(...e3) {
    let t11 = { current: true };
    return t3(() => {
      t11.current && e3[0]();
    }), r4.add(() => {
      t11.current = false;
    });
  }, style(e3, t11, s8) {
    let a3 = e3.style.getPropertyValue(t11);
    return Object.assign(e3.style, { [t11]: s8 }), this.add(() => {
      Object.assign(e3.style, { [t11]: a3 });
    });
  }, group(e3) {
    let t11 = o3();
    return e3(t11), this.add(() => t11.dispose());
  }, add(e3) {
    return n5.push(e3), () => {
      let t11 = n5.indexOf(e3);
      if (t11 >= 0)
        for (let s8 of n5.splice(t11, 1))
          s8();
    };
  }, dispose() {
    for (let e3 of n5.splice(0))
      e3();
  } };
  return r4;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
  let [e3] = (0, import_react35.useState)(o3);
  return (0, import_react35.useEffect)(() => () => e3.dispose(), [e3]), e3;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react36 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var t4 = __toESM(require_react(), 1);
function s4() {
  let r4 = typeof document == "undefined";
  return "useSyncExternalStore" in t4 ? ((o11) => o11.useSyncExternalStore)(t4)(() => () => {
  }, () => false, () => !r4) : false;
}
function l2() {
  let r4 = s4(), [e3, n5] = t4.useState(s.isHandoffComplete);
  return e3 && s.isHandoffComplete === false && n5(false), t4.useEffect(() => {
    e3 !== true && n5(true);
  }, [e3]), t4.useEffect(() => s.handoff(), []), r4 ? false : e3;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-id.js
var o5;
var I = (o5 = import_react36.default.useId) != null ? o5 : function() {
  let n5 = l2(), [e3, u6] = import_react36.default.useState(n5 ? () => s.nextId() : null);
  return l(() => {
    e3 === null && u6(s.nextId());
  }, [e3]), e3 != null ? "" + e3 : void 0;
};

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react39 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/match.js
function u(r4, n5, ...a3) {
  if (r4 in n5) {
    let e3 = n5[r4];
    return typeof e3 == "function" ? e3(...a3) : e3;
  }
  let t11 = new Error(`Tried to handle "${r4}" but there is no handler defined. Only defined handlers are: ${Object.keys(n5).map((e3) => `"${e3}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t11, u), t11;
}

// ../../node_modules/@headlessui/react/dist/utils/owner.js
function o6(r4) {
  return s.isServer ? null : r4 instanceof Node ? r4.ownerDocument : r4 != null && r4.hasOwnProperty("current") && r4.current instanceof Node ? r4.current.ownerDocument : document;
}

// ../../node_modules/@headlessui/react/dist/utils/focus-management.js
var c2 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e3) => `${e3}:not([tabindex='-1'])`).join(",");
var M = ((n5) => (n5[n5.First = 1] = "First", n5[n5.Previous = 2] = "Previous", n5[n5.Next = 4] = "Next", n5[n5.Last = 8] = "Last", n5[n5.WrapAround = 16] = "WrapAround", n5[n5.NoScroll = 32] = "NoScroll", n5))(M || {});
var N = ((o11) => (o11[o11.Error = 0] = "Error", o11[o11.Overflow = 1] = "Overflow", o11[o11.Success = 2] = "Success", o11[o11.Underflow = 3] = "Underflow", o11))(N || {});
var F = ((t11) => (t11[t11.Previous = -1] = "Previous", t11[t11.Next = 1] = "Next", t11))(F || {});
function f(e3 = document.body) {
  return e3 == null ? [] : Array.from(e3.querySelectorAll(c2)).sort((r4, t11) => Math.sign((r4.tabIndex || Number.MAX_SAFE_INTEGER) - (t11.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T = ((t11) => (t11[t11.Strict = 0] = "Strict", t11[t11.Loose = 1] = "Loose", t11))(T || {});
function h2(e3, r4 = 0) {
  var t11;
  return e3 === ((t11 = o6(e3)) == null ? void 0 : t11.body) ? false : u(r4, { [0]() {
    return e3.matches(c2);
  }, [1]() {
    let l7 = e3;
    for (; l7 !== null; ) {
      if (l7.matches(c2))
        return true;
      l7 = l7.parentElement;
    }
    return false;
  } });
}
function D(e3) {
  let r4 = o6(e3);
  o3().nextFrame(() => {
    r4 && !h2(r4.activeElement, 0) && y(e3);
  });
}
var w = ((t11) => (t11[t11.Keyboard = 0] = "Keyboard", t11[t11.Mouse = 1] = "Mouse", t11))(w || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e3) => {
  e3.metaKey || e3.altKey || e3.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e3) => {
  e3.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e3.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function y(e3) {
  e3 == null || e3.focus({ preventScroll: true });
}
var S = ["textarea", "input"].join(",");
function H(e3) {
  var r4, t11;
  return (t11 = (r4 = e3 == null ? void 0 : e3.matches) == null ? void 0 : r4.call(e3, S)) != null ? t11 : false;
}
function I2(e3, r4 = (t11) => t11) {
  return e3.slice().sort((t11, l7) => {
    let o11 = r4(t11), i6 = r4(l7);
    if (o11 === null || i6 === null)
      return 0;
    let n5 = o11.compareDocumentPosition(i6);
    return n5 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n5 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _(e3, r4) {
  return O(f(), r4, { relativeTo: e3 });
}
function O(e3, r4, { sorted: t11 = true, relativeTo: l7 = null, skipElements: o11 = [] } = {}) {
  let i6 = Array.isArray(e3) ? e3.length > 0 ? e3[0].ownerDocument : document : e3.ownerDocument, n5 = Array.isArray(e3) ? t11 ? I2(e3) : e3 : f(e3);
  o11.length > 0 && n5.length > 1 && (n5 = n5.filter((s8) => !o11.includes(s8))), l7 = l7 != null ? l7 : i6.activeElement;
  let E3 = (() => {
    if (r4 & 5)
      return 1;
    if (r4 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x2 = (() => {
    if (r4 & 1)
      return 0;
    if (r4 & 2)
      return Math.max(0, n5.indexOf(l7)) - 1;
    if (r4 & 4)
      return Math.max(0, n5.indexOf(l7)) + 1;
    if (r4 & 8)
      return n5.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p3 = r4 & 32 ? { preventScroll: true } : {}, d6 = 0, a3 = n5.length, u6;
  do {
    if (d6 >= a3 || d6 + a3 <= 0)
      return 0;
    let s8 = x2 + d6;
    if (r4 & 16)
      s8 = (s8 + a3) % a3;
    else {
      if (s8 < 0)
        return 3;
      if (s8 >= a3)
        return 1;
    }
    u6 = n5[s8], u6 == null || u6.focus(p3), d6 += E3;
  } while (u6 !== i6.activeElement);
  return r4 & 6 && H(u6) && u6.select(), 2;
}

// ../../node_modules/@headlessui/react/dist/utils/platform.js
function t6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i2() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n() {
  return t6() || i2();
}

// ../../node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react37 = __toESM(require_react(), 1);
function d2(e3, r4, n5) {
  let o11 = s2(r4);
  (0, import_react37.useEffect)(() => {
    function t11(u6) {
      o11.current(u6);
    }
    return document.addEventListener(e3, t11, n5), () => document.removeEventListener(e3, t11, n5);
  }, [e3, n5]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react38 = __toESM(require_react(), 1);
function s5(e3, r4, n5) {
  let o11 = s2(r4);
  (0, import_react38.useEffect)(() => {
    function t11(i6) {
      o11.current(i6);
    }
    return window.addEventListener(e3, t11, n5), () => window.removeEventListener(e3, t11, n5);
  }, [e3, n5]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js
function y2(s8, m5, a3 = true) {
  let i6 = (0, import_react39.useRef)(false);
  (0, import_react39.useEffect)(() => {
    requestAnimationFrame(() => {
      i6.current = a3;
    });
  }, [a3]);
  function c6(e3, r4) {
    if (!i6.current || e3.defaultPrevented)
      return;
    let t11 = r4(e3);
    if (t11 === null || !t11.getRootNode().contains(t11) || !t11.isConnected)
      return;
    let E3 = function u6(n5) {
      return typeof n5 == "function" ? u6(n5()) : Array.isArray(n5) || n5 instanceof Set ? n5 : [n5];
    }(s8);
    for (let u6 of E3) {
      if (u6 === null)
        continue;
      let n5 = u6 instanceof HTMLElement ? u6 : u6.current;
      if (n5 != null && n5.contains(t11) || e3.composed && e3.composedPath().includes(n5))
        return;
    }
    return !h2(t11, T.Loose) && t11.tabIndex !== -1 && e3.preventDefault(), m5(e3, t11);
  }
  let o11 = (0, import_react39.useRef)(null);
  d2("pointerdown", (e3) => {
    var r4, t11;
    i6.current && (o11.current = ((t11 = (r4 = e3.composedPath) == null ? void 0 : r4.call(e3)) == null ? void 0 : t11[0]) || e3.target);
  }, true), d2("mousedown", (e3) => {
    var r4, t11;
    i6.current && (o11.current = ((t11 = (r4 = e3.composedPath) == null ? void 0 : r4.call(e3)) == null ? void 0 : t11[0]) || e3.target);
  }, true), d2("click", (e3) => {
    n() || o11.current && (c6(e3, () => o11.current), o11.current = null);
  }, true), d2("touchend", (e3) => c6(e3, () => e3.target instanceof HTMLElement ? e3.target : null), true), s5("blur", (e3) => c6(e3, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react40 = __toESM(require_react(), 1);
function n2(...e3) {
  return (0, import_react40.useMemo)(() => o6(...e3), [...e3]);
}

// ../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react41 = __toESM(require_react(), 1);
function i3(t11) {
  var n5;
  if (t11.type)
    return t11.type;
  let e3 = (n5 = t11.as) != null ? n5 : "button";
  if (typeof e3 == "string" && e3.toLowerCase() === "button")
    return "button";
}
function T2(t11, e3) {
  let [n5, u6] = (0, import_react41.useState)(() => i3(t11));
  return l(() => {
    u6(i3(t11));
  }, [t11.type, t11.as]), l(() => {
    n5 || e3.current && e3.current instanceof HTMLButtonElement && !e3.current.hasAttribute("type") && u6("button");
  }, [n5, e3]), n5;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react42 = __toESM(require_react(), 1);
var u2 = Symbol();
function y3(...t11) {
  let n5 = (0, import_react42.useRef)(t11);
  (0, import_react42.useEffect)(() => {
    n5.current = t11;
  }, [t11]);
  let c6 = o2((e3) => {
    for (let o11 of n5.current)
      o11 != null && (typeof o11 == "function" ? o11(e3) : o11.current = e3);
  });
  return t11.every((e3) => e3 == null || (e3 == null ? void 0 : e3[u2])) ? void 0 : c6;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react43 = __toESM(require_react(), 1);
function t8(e3) {
  return [e3.screenX, e3.screenY];
}
function u3() {
  let e3 = (0, import_react43.useRef)([-1, -1]);
  return { wasMoved(r4) {
    let n5 = t8(r4);
    return e3.current[0] === n5[0] && e3.current[1] === n5[1] ? false : (e3.current = n5, true);
  }, update(r4) {
    e3.current = t8(r4);
  } };
}

// ../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react44 = __toESM(require_react(), 1);
function F2({ container: e3, accept: t11, walk: r4, enabled: c6 = true }) {
  let o11 = (0, import_react44.useRef)(t11), l7 = (0, import_react44.useRef)(r4);
  (0, import_react44.useEffect)(() => {
    o11.current = t11, l7.current = r4;
  }, [t11, r4]), l(() => {
    if (!e3 || !c6)
      return;
    let n5 = o6(e3);
    if (!n5)
      return;
    let f6 = o11.current, p3 = l7.current, d6 = Object.assign((i6) => f6(i6), { acceptNode: f6 }), u6 = n5.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, d6, false);
    for (; u6.nextNode(); )
      p3(u6.currentNode);
  }, [e3, c6, o11, l7]);
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var import_react45 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/class-names.js
function t9(...r4) {
  return Array.from(new Set(r4.flatMap((n5) => typeof n5 == "string" ? n5.split(" ") : []))).filter(Boolean).join(" ");
}

// ../../node_modules/@headlessui/react/dist/utils/render.js
var O2 = ((n5) => (n5[n5.None = 0] = "None", n5[n5.RenderStrategy = 1] = "RenderStrategy", n5[n5.Static = 2] = "Static", n5))(O2 || {});
var v = ((e3) => (e3[e3.Unmount = 0] = "Unmount", e3[e3.Hidden = 1] = "Hidden", e3))(v || {});
function C({ ourProps: r4, theirProps: t11, slot: e3, defaultTag: n5, features: o11, visible: a3 = true, name: f6, mergeRefs: l7 }) {
  l7 = l7 != null ? l7 : k;
  let s8 = R(t11, r4);
  if (a3)
    return m3(s8, e3, n5, f6, l7);
  let y4 = o11 != null ? o11 : 0;
  if (y4 & 2) {
    let { static: u6 = false, ...d6 } = s8;
    if (u6)
      return m3(d6, e3, n5, f6, l7);
  }
  if (y4 & 1) {
    let { unmount: u6 = true, ...d6 } = s8;
    return u(u6 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return m3({ ...d6, hidden: true, style: { display: "none" } }, e3, n5, f6, l7);
    } });
  }
  return m3(s8, e3, n5, f6, l7);
}
function m3(r4, t11 = {}, e3, n5, o11) {
  let { as: a3 = e3, children: f6, refName: l7 = "ref", ...s8 } = F3(r4, ["unmount", "static"]), y4 = r4.ref !== void 0 ? { [l7]: r4.ref } : {}, u6 = typeof f6 == "function" ? f6(t11) : f6;
  "className" in s8 && s8.className && typeof s8.className == "function" && (s8.className = s8.className(t11));
  let d6 = {};
  if (t11) {
    let i6 = false, c6 = [];
    for (let [T3, p3] of Object.entries(t11))
      typeof p3 == "boolean" && (i6 = true), p3 === true && c6.push(T3);
    i6 && (d6["data-headlessui-state"] = c6.join(" "));
  }
  if (a3 === import_react45.Fragment && Object.keys(x(s8)).length > 0) {
    if (!(0, import_react45.isValidElement)(u6) || Array.isArray(u6) && u6.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${n5} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(s8).map((p3) => `  - ${p3}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((p3) => `  - ${p3}`).join(`
`)].join(`
`));
    let i6 = u6.props, c6 = typeof (i6 == null ? void 0 : i6.className) == "function" ? (...p3) => t9(i6 == null ? void 0 : i6.className(...p3), s8.className) : t9(i6 == null ? void 0 : i6.className, s8.className), T3 = c6 ? { className: c6 } : {};
    return (0, import_react45.cloneElement)(u6, Object.assign({}, R(u6.props, x(F3(s8, ["ref"]))), d6, y4, { ref: o11(u6.ref, y4.ref) }, T3));
  }
  return (0, import_react45.createElement)(a3, Object.assign({}, F3(s8, ["ref"]), a3 !== import_react45.Fragment && y4, a3 !== import_react45.Fragment && d6), u6);
}
function k(...r4) {
  return r4.every((t11) => t11 == null) ? void 0 : (t11) => {
    for (let e3 of r4)
      e3 != null && (typeof e3 == "function" ? e3(t11) : e3.current = t11);
  };
}
function R(...r4) {
  var n5;
  if (r4.length === 0)
    return {};
  if (r4.length === 1)
    return r4[0];
  let t11 = {}, e3 = {};
  for (let o11 of r4)
    for (let a3 in o11)
      a3.startsWith("on") && typeof o11[a3] == "function" ? ((n5 = e3[a3]) != null || (e3[a3] = []), e3[a3].push(o11[a3])) : t11[a3] = o11[a3];
  if (t11.disabled || t11["aria-disabled"])
    return Object.assign(t11, Object.fromEntries(Object.keys(e3).map((o11) => [o11, void 0])));
  for (let o11 in e3)
    Object.assign(t11, { [o11](a3, ...f6) {
      let l7 = e3[o11];
      for (let s8 of l7) {
        if ((a3 instanceof Event || (a3 == null ? void 0 : a3.nativeEvent) instanceof Event) && a3.defaultPrevented)
          return;
        s8(a3, ...f6);
      }
    } });
  return t11;
}
function U(r4) {
  var t11;
  return Object.assign((0, import_react45.forwardRef)(r4), { displayName: (t11 = r4.displayName) != null ? t11 : r4.name });
}
function x(r4) {
  let t11 = Object.assign({}, r4);
  for (let e3 in t11)
    t11[e3] === void 0 && delete t11[e3];
  return t11;
}
function F3(r4, t11 = []) {
  let e3 = Object.assign({}, r4);
  for (let n5 of t11)
    n5 in e3 && delete e3[n5];
  return e3;
}

// ../../node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react46 = __toESM(require_react(), 1);
var n3 = (0, import_react46.createContext)(null);
n3.displayName = "OpenClosedContext";
var d5 = ((e3) => (e3[e3.Open = 1] = "Open", e3[e3.Closed = 2] = "Closed", e3[e3.Closing = 4] = "Closing", e3[e3.Opening = 8] = "Opening", e3))(d5 || {});
function u4() {
  return (0, import_react46.useContext)(n3);
}
function s6({ value: o11, children: r4 }) {
  return import_react46.default.createElement(n3.Provider, { value: o11 }, r4);
}

// ../../node_modules/@headlessui/react/dist/utils/bugs.js
function r2(n5) {
  let e3 = n5.parentElement, l7 = null;
  for (; e3 && !(e3 instanceof HTMLFieldSetElement); )
    e3 instanceof HTMLLegendElement && (l7 = e3), e3 = e3.parentElement;
  let t11 = (e3 == null ? void 0 : e3.getAttribute("disabled")) === "";
  return t11 && i5(l7) ? false : t11;
}
function i5(n5) {
  if (!n5)
    return false;
  let e3 = n5.previousElementSibling;
  for (; e3 !== null; ) {
    if (e3 instanceof HTMLLegendElement)
      return false;
    e3 = e3.previousElementSibling;
  }
  return true;
}

// ../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function u5(l7) {
  throw new Error("Unexpected object: " + l7);
}
var c3 = ((i6) => (i6[i6.First = 0] = "First", i6[i6.Previous = 1] = "Previous", i6[i6.Next = 2] = "Next", i6[i6.Last = 3] = "Last", i6[i6.Specific = 4] = "Specific", i6[i6.Nothing = 5] = "Nothing", i6))(c3 || {});
function f3(l7, n5) {
  let t11 = n5.resolveItems();
  if (t11.length <= 0)
    return null;
  let r4 = n5.resolveActiveIndex(), s8 = r4 != null ? r4 : -1;
  switch (l7.focus) {
    case 0: {
      for (let e3 = 0; e3 < t11.length; ++e3)
        if (!n5.resolveDisabled(t11[e3], e3, t11))
          return e3;
      return r4;
    }
    case 1: {
      for (let e3 = s8 - 1; e3 >= 0; --e3)
        if (!n5.resolveDisabled(t11[e3], e3, t11))
          return e3;
      return r4;
    }
    case 2: {
      for (let e3 = s8 + 1; e3 < t11.length; ++e3)
        if (!n5.resolveDisabled(t11[e3], e3, t11))
          return e3;
      return r4;
    }
    case 3: {
      for (let e3 = t11.length - 1; e3 >= 0; --e3)
        if (!n5.resolveDisabled(t11[e3], e3, t11))
          return e3;
      return r4;
    }
    case 4: {
      for (let e3 = 0; e3 < t11.length; ++e3)
        if (n5.resolveId(t11[e3], e3, t11) === l7.id)
          return e3;
      return r4;
    }
    case 5:
      return null;
    default:
      u5(l7);
  }
}

// ../../node_modules/@headlessui/react/dist/components/keyboard.js
var o9 = ((r4) => (r4.Space = " ", r4.Enter = "Enter", r4.Escape = "Escape", r4.Backspace = "Backspace", r4.Delete = "Delete", r4.ArrowLeft = "ArrowLeft", r4.ArrowUp = "ArrowUp", r4.ArrowRight = "ArrowRight", r4.ArrowDown = "ArrowDown", r4.Home = "Home", r4.End = "End", r4.PageUp = "PageUp", r4.PageDown = "PageDown", r4.Tab = "Tab", r4))(o9 || {});

// ../../node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react47 = __toESM(require_react(), 1);
function f4() {
  let e3 = (0, import_react47.useRef)(false);
  return l(() => (e3.current = true, () => {
    e3.current = false;
  }), []), e3;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
var import_react48 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/get-text-value.js
var a2 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o10(e3) {
  var r4, i6;
  let n5 = (r4 = e3.innerText) != null ? r4 : "", t11 = e3.cloneNode(true);
  if (!(t11 instanceof HTMLElement))
    return n5;
  let u6 = false;
  for (let f6 of t11.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    f6.remove(), u6 = true;
  let l7 = u6 ? (i6 = t11.innerText) != null ? i6 : "" : n5;
  return a2.test(l7) && (l7 = l7.replace(a2, "")), l7;
}
function g2(e3) {
  let n5 = e3.getAttribute("aria-label");
  if (typeof n5 == "string")
    return n5.trim();
  let t11 = e3.getAttribute("aria-labelledby");
  if (t11) {
    let u6 = t11.split(" ").map((l7) => {
      let r4 = document.getElementById(l7);
      if (r4) {
        let i6 = r4.getAttribute("aria-label");
        return typeof i6 == "string" ? i6.trim() : o10(r4).trim();
      }
      return null;
    }).filter(Boolean);
    if (u6.length > 0)
      return u6.join(", ");
  }
  return o10(e3).trim();
}

// ../../node_modules/@headlessui/react/dist/hooks/use-text-value.js
function s7(c6) {
  let t11 = (0, import_react48.useRef)(""), r4 = (0, import_react48.useRef)("");
  return o2(() => {
    let e3 = c6.current;
    if (!e3)
      return "";
    let u6 = e3.innerText;
    if (t11.current === u6)
      return r4.current;
    let n5 = g2(e3).trim().toLowerCase();
    return t11.current = u6, r4.current = n5, n5;
  });
}

// ../../node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react49 = __toESM(require_react(), 1);
var me = ((r4) => (r4[r4.Open = 0] = "Open", r4[r4.Closed = 1] = "Closed", r4))(me || {});
var de = ((r4) => (r4[r4.Pointer = 0] = "Pointer", r4[r4.Other = 1] = "Other", r4))(de || {});
var fe = ((a3) => (a3[a3.OpenMenu = 0] = "OpenMenu", a3[a3.CloseMenu = 1] = "CloseMenu", a3[a3.GoToItem = 2] = "GoToItem", a3[a3.Search = 3] = "Search", a3[a3.ClearSearch = 4] = "ClearSearch", a3[a3.RegisterItem = 5] = "RegisterItem", a3[a3.UnregisterItem = 6] = "UnregisterItem", a3))(fe || {});
function w2(e3, u6 = (r4) => r4) {
  let r4 = e3.activeItemIndex !== null ? e3.items[e3.activeItemIndex] : null, s8 = I2(u6(e3.items.slice()), (t11) => t11.dataRef.current.domRef.current), i6 = r4 ? s8.indexOf(r4) : null;
  return i6 === -1 && (i6 = null), { items: s8, activeItemIndex: i6 };
}
var Te = { [1](e3) {
  return e3.menuState === 1 ? e3 : { ...e3, activeItemIndex: null, menuState: 1 };
}, [0](e3) {
  return e3.menuState === 0 ? e3 : { ...e3, __demoMode: false, menuState: 0 };
}, [2]: (e3, u6) => {
  var i6;
  let r4 = w2(e3), s8 = f3(u6, { resolveItems: () => r4.items, resolveActiveIndex: () => r4.activeItemIndex, resolveId: (t11) => t11.id, resolveDisabled: (t11) => t11.dataRef.current.disabled });
  return { ...e3, ...r4, searchQuery: "", activeItemIndex: s8, activationTrigger: (i6 = u6.trigger) != null ? i6 : 1 };
}, [3]: (e3, u6) => {
  let s8 = e3.searchQuery !== "" ? 0 : 1, i6 = e3.searchQuery + u6.value.toLowerCase(), o11 = (e3.activeItemIndex !== null ? e3.items.slice(e3.activeItemIndex + s8).concat(e3.items.slice(0, e3.activeItemIndex + s8)) : e3.items).find((l7) => {
    var m5;
    return ((m5 = l7.dataRef.current.textValue) == null ? void 0 : m5.startsWith(i6)) && !l7.dataRef.current.disabled;
  }), a3 = o11 ? e3.items.indexOf(o11) : -1;
  return a3 === -1 || a3 === e3.activeItemIndex ? { ...e3, searchQuery: i6 } : { ...e3, searchQuery: i6, activeItemIndex: a3, activationTrigger: 1 };
}, [4](e3) {
  return e3.searchQuery === "" ? e3 : { ...e3, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e3, u6) => {
  let r4 = w2(e3, (s8) => [...s8, { id: u6.id, dataRef: u6.dataRef }]);
  return { ...e3, ...r4 };
}, [6]: (e3, u6) => {
  let r4 = w2(e3, (s8) => {
    let i6 = s8.findIndex((t11) => t11.id === u6.id);
    return i6 !== -1 && s8.splice(i6, 1), s8;
  });
  return { ...e3, ...r4, activationTrigger: 1 };
} };
var U2 = (0, import_react49.createContext)(null);
U2.displayName = "MenuContext";
function C2(e3) {
  let u6 = (0, import_react49.useContext)(U2);
  if (u6 === null) {
    let r4 = new Error(`<${e3} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r4, C2), r4;
  }
  return u6;
}
function ye(e3, u6) {
  return u(u6.type, Te, e3, u6);
}
var Ie = import_react49.Fragment;
function Me(e3, u6) {
  let { __demoMode: r4 = false, ...s8 } = e3, i6 = (0, import_react49.useReducer)(ye, { __demoMode: r4, menuState: r4 ? 0 : 1, buttonRef: (0, import_react49.createRef)(), itemsRef: (0, import_react49.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: t11, itemsRef: o11, buttonRef: a3 }, l7] = i6, m5 = y3(u6);
  y2([a3, o11], (g4, R2) => {
    var p3;
    l7({ type: 1 }), h2(R2, T.Loose) || (g4.preventDefault(), (p3 = a3.current) == null || p3.focus());
  }, t11 === 0);
  let I4 = o2(() => {
    l7({ type: 1 });
  }), A = (0, import_react49.useMemo)(() => ({ open: t11 === 0, close: I4 }), [t11, I4]), f6 = { ref: m5 };
  return import_react49.default.createElement(U2.Provider, { value: i6 }, import_react49.default.createElement(s6, { value: u(t11, { [0]: d5.Open, [1]: d5.Closed }) }, C({ ourProps: f6, theirProps: s8, slot: A, defaultTag: Ie, name: "Menu" })));
}
var ge = "button";
function Re(e3, u6) {
  var R2;
  let r4 = I(), { id: s8 = `headlessui-menu-button-${r4}`, ...i6 } = e3, [t11, o11] = C2("Menu.Button"), a3 = y3(t11.buttonRef, u6), l7 = p(), m5 = o2((p3) => {
    switch (p3.key) {
      case o9.Space:
      case o9.Enter:
      case o9.ArrowDown:
        p3.preventDefault(), p3.stopPropagation(), o11({ type: 0 }), l7.nextFrame(() => o11({ type: 2, focus: c3.First }));
        break;
      case o9.ArrowUp:
        p3.preventDefault(), p3.stopPropagation(), o11({ type: 0 }), l7.nextFrame(() => o11({ type: 2, focus: c3.Last }));
        break;
    }
  }), I4 = o2((p3) => {
    switch (p3.key) {
      case o9.Space:
        p3.preventDefault();
        break;
    }
  }), A = o2((p3) => {
    if (r2(p3.currentTarget))
      return p3.preventDefault();
    e3.disabled || (t11.menuState === 0 ? (o11({ type: 1 }), l7.nextFrame(() => {
      var M4;
      return (M4 = t11.buttonRef.current) == null ? void 0 : M4.focus({ preventScroll: true });
    })) : (p3.preventDefault(), o11({ type: 0 })));
  }), f6 = (0, import_react49.useMemo)(() => ({ open: t11.menuState === 0 }), [t11]), g4 = { ref: a3, id: s8, type: T2(e3, t11.buttonRef), "aria-haspopup": "menu", "aria-controls": (R2 = t11.itemsRef.current) == null ? void 0 : R2.id, "aria-expanded": t11.menuState === 0, onKeyDown: m5, onKeyUp: I4, onClick: A };
  return C({ ourProps: g4, theirProps: i6, slot: f6, defaultTag: ge, name: "Menu.Button" });
}
var Ae = "div";
var be = O2.RenderStrategy | O2.Static;
function Ee(e3, u6) {
  var M4, b2;
  let r4 = I(), { id: s8 = `headlessui-menu-items-${r4}`, ...i6 } = e3, [t11, o11] = C2("Menu.Items"), a3 = y3(t11.itemsRef, u6), l7 = n2(t11.itemsRef), m5 = p(), I4 = u4(), A = (() => I4 !== null ? (I4 & d5.Open) === d5.Open : t11.menuState === 0)();
  (0, import_react49.useEffect)(() => {
    let n5 = t11.itemsRef.current;
    n5 && t11.menuState === 0 && n5 !== (l7 == null ? void 0 : l7.activeElement) && n5.focus({ preventScroll: true });
  }, [t11.menuState, t11.itemsRef, l7]), F2({ container: t11.itemsRef.current, enabled: t11.menuState === 0, accept(n5) {
    return n5.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : n5.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(n5) {
    n5.setAttribute("role", "none");
  } });
  let f6 = o2((n5) => {
    var E3, x2;
    switch (m5.dispose(), n5.key) {
      case o9.Space:
        if (t11.searchQuery !== "")
          return n5.preventDefault(), n5.stopPropagation(), o11({ type: 3, value: n5.key });
      case o9.Enter:
        if (n5.preventDefault(), n5.stopPropagation(), o11({ type: 1 }), t11.activeItemIndex !== null) {
          let { dataRef: S4 } = t11.items[t11.activeItemIndex];
          (x2 = (E3 = S4.current) == null ? void 0 : E3.domRef.current) == null || x2.click();
        }
        D(t11.buttonRef.current);
        break;
      case o9.ArrowDown:
        return n5.preventDefault(), n5.stopPropagation(), o11({ type: 2, focus: c3.Next });
      case o9.ArrowUp:
        return n5.preventDefault(), n5.stopPropagation(), o11({ type: 2, focus: c3.Previous });
      case o9.Home:
      case o9.PageUp:
        return n5.preventDefault(), n5.stopPropagation(), o11({ type: 2, focus: c3.First });
      case o9.End:
      case o9.PageDown:
        return n5.preventDefault(), n5.stopPropagation(), o11({ type: 2, focus: c3.Last });
      case o9.Escape:
        n5.preventDefault(), n5.stopPropagation(), o11({ type: 1 }), o3().nextFrame(() => {
          var S4;
          return (S4 = t11.buttonRef.current) == null ? void 0 : S4.focus({ preventScroll: true });
        });
        break;
      case o9.Tab:
        n5.preventDefault(), n5.stopPropagation(), o11({ type: 1 }), o3().nextFrame(() => {
          _(t11.buttonRef.current, n5.shiftKey ? M.Previous : M.Next);
        });
        break;
      default:
        n5.key.length === 1 && (o11({ type: 3, value: n5.key }), m5.setTimeout(() => o11({ type: 4 }), 350));
        break;
    }
  }), g4 = o2((n5) => {
    switch (n5.key) {
      case o9.Space:
        n5.preventDefault();
        break;
    }
  }), R2 = (0, import_react49.useMemo)(() => ({ open: t11.menuState === 0 }), [t11]), p3 = { "aria-activedescendant": t11.activeItemIndex === null || (M4 = t11.items[t11.activeItemIndex]) == null ? void 0 : M4.id, "aria-labelledby": (b2 = t11.buttonRef.current) == null ? void 0 : b2.id, id: s8, onKeyDown: f6, onKeyUp: g4, role: "menu", tabIndex: 0, ref: a3 };
  return C({ ourProps: p3, theirProps: i6, slot: R2, defaultTag: Ae, features: be, visible: A, name: "Menu.Items" });
}
var Se = import_react49.Fragment;
function xe(e3, u6) {
  let r4 = I(), { id: s8 = `headlessui-menu-item-${r4}`, disabled: i6 = false, ...t11 } = e3, [o11, a3] = C2("Menu.Item"), l7 = o11.activeItemIndex !== null ? o11.items[o11.activeItemIndex].id === s8 : false, m5 = (0, import_react49.useRef)(null), I4 = y3(u6, m5);
  l(() => {
    if (o11.__demoMode || o11.menuState !== 0 || !l7 || o11.activationTrigger === 0)
      return;
    let T3 = o3();
    return T3.requestAnimationFrame(() => {
      var P2, B;
      (B = (P2 = m5.current) == null ? void 0 : P2.scrollIntoView) == null || B.call(P2, { block: "nearest" });
    }), T3.dispose;
  }, [o11.__demoMode, m5, l7, o11.menuState, o11.activationTrigger, o11.activeItemIndex]);
  let A = s7(m5), f6 = (0, import_react49.useRef)({ disabled: i6, domRef: m5, get textValue() {
    return A();
  } });
  l(() => {
    f6.current.disabled = i6;
  }, [f6, i6]), l(() => (a3({ type: 5, id: s8, dataRef: f6 }), () => a3({ type: 6, id: s8 })), [f6, s8]);
  let g4 = o2(() => {
    a3({ type: 1 });
  }), R2 = o2((T3) => {
    if (i6)
      return T3.preventDefault();
    a3({ type: 1 }), D(o11.buttonRef.current);
  }), p3 = o2(() => {
    if (i6)
      return a3({ type: 2, focus: c3.Nothing });
    a3({ type: 2, focus: c3.Specific, id: s8 });
  }), M4 = u3(), b2 = o2((T3) => M4.update(T3)), n5 = o2((T3) => {
    M4.wasMoved(T3) && (i6 || l7 || a3({ type: 2, focus: c3.Specific, id: s8, trigger: 0 }));
  }), E3 = o2((T3) => {
    M4.wasMoved(T3) && (i6 || l7 && a3({ type: 2, focus: c3.Nothing }));
  }), x2 = (0, import_react49.useMemo)(() => ({ active: l7, disabled: i6, close: g4 }), [l7, i6, g4]);
  return C({ ourProps: { id: s8, ref: I4, role: "menuitem", tabIndex: i6 === true ? void 0 : -1, "aria-disabled": i6 === true ? true : void 0, disabled: void 0, onClick: R2, onFocus: p3, onPointerEnter: b2, onMouseEnter: b2, onPointerMove: n5, onMouseMove: n5, onPointerLeave: E3, onMouseLeave: E3 }, theirProps: t11, slot: x2, defaultTag: Se, name: "Menu.Item" });
}
var Pe = U(Me);
var ve = U(Re);
var he = U(Ee);
var De = U(xe);
var qe = Object.assign(Pe, { Button: ve, Items: he, Item: De });

// ../../node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react50 = __toESM(require_react(), 1);
function c4(a3 = 0) {
  let [l7, r4] = (0, import_react50.useState)(a3), t11 = f4(), o11 = (0, import_react50.useCallback)((e3) => {
    t11.current && r4((u6) => u6 | e3);
  }, [l7, t11]), m5 = (0, import_react50.useCallback)((e3) => Boolean(l7 & e3), [l7]), s8 = (0, import_react50.useCallback)((e3) => {
    t11.current && r4((u6) => u6 & ~e3);
  }, [r4, t11]), g4 = (0, import_react50.useCallback)((e3) => {
    t11.current && r4((u6) => u6 ^ e3);
  }, [r4]);
  return { flags: l7, addFlag: o11, hasFlag: m5, removeFlag: s8, toggleFlag: g4 };
}

// ../../node_modules/@headlessui/react/dist/components/transitions/transition.js
var import_react51 = __toESM(require_react(), 1);

// ../../node_modules/@headlessui/react/dist/utils/once.js
function l6(r4) {
  let e3 = { called: false };
  return (...t11) => {
    if (!e3.called)
      return e3.called = true, r4(...t11);
  };
}

// ../../node_modules/@headlessui/react/dist/components/transitions/utils/transition.js
function g3(t11, ...e3) {
  t11 && e3.length > 0 && t11.classList.add(...e3);
}
function v3(t11, ...e3) {
  t11 && e3.length > 0 && t11.classList.remove(...e3);
}
function b(t11, e3) {
  let n5 = o3();
  if (!t11)
    return n5.dispose;
  let { transitionDuration: m5, transitionDelay: a3 } = getComputedStyle(t11), [u6, p3] = [m5, a3].map((l7) => {
    let [r4 = 0] = l7.split(",").filter(Boolean).map((i6) => i6.includes("ms") ? parseFloat(i6) : parseFloat(i6) * 1e3).sort((i6, T3) => T3 - i6);
    return r4;
  }), o11 = u6 + p3;
  if (o11 !== 0) {
    n5.group((r4) => {
      r4.setTimeout(() => {
        e3(), r4.dispose();
      }, o11), r4.addEventListener(t11, "transitionrun", (i6) => {
        i6.target === i6.currentTarget && r4.dispose();
      });
    });
    let l7 = n5.addEventListener(t11, "transitionend", (r4) => {
      r4.target === r4.currentTarget && (e3(), l7());
    });
  } else
    e3();
  return n5.add(() => e3()), n5.dispose;
}
function M2(t11, e3, n5, m5) {
  let a3 = n5 ? "enter" : "leave", u6 = o3(), p3 = m5 !== void 0 ? l6(m5) : () => {
  };
  a3 === "enter" && (t11.removeAttribute("hidden"), t11.style.display = "");
  let o11 = u(a3, { enter: () => e3.enter, leave: () => e3.leave }), l7 = u(a3, { enter: () => e3.enterTo, leave: () => e3.leaveTo }), r4 = u(a3, { enter: () => e3.enterFrom, leave: () => e3.leaveFrom });
  return v3(t11, ...e3.base, ...e3.enter, ...e3.enterTo, ...e3.enterFrom, ...e3.leave, ...e3.leaveFrom, ...e3.leaveTo, ...e3.entered), g3(t11, ...e3.base, ...o11, ...r4), u6.nextFrame(() => {
    v3(t11, ...e3.base, ...o11, ...r4), g3(t11, ...e3.base, ...o11, ...l7), b(t11, () => (v3(t11, ...e3.base, ...o11), g3(t11, ...e3.base, ...e3.entered), p3()));
  }), u6.dispose;
}

// ../../node_modules/@headlessui/react/dist/hooks/use-transition.js
function D2({ immediate: t11, container: s8, direction: n5, classes: u6, onStart: a3, onStop: c6 }) {
  let l7 = f4(), d6 = p(), e3 = s2(n5);
  l(() => {
    t11 && (e3.current = "enter");
  }, [t11]), l(() => {
    let r4 = o3();
    d6.add(r4.dispose);
    let i6 = s8.current;
    if (i6 && e3.current !== "idle" && l7.current)
      return r4.dispose(), a3.current(e3.current), r4.add(M2(i6, u6.current, e3.current === "enter", () => {
        r4.dispose(), c6.current(e3.current);
      })), r4.dispose;
  }, [n5]);
}

// ../../node_modules/@headlessui/react/dist/components/transitions/transition.js
function S3(t11 = "") {
  return t11.split(/\s+/).filter((n5) => n5.length > 1);
}
var I3 = (0, import_react51.createContext)(null);
I3.displayName = "TransitionContext";
var Se2 = ((r4) => (r4.Visible = "visible", r4.Hidden = "hidden", r4))(Se2 || {});
function ye2() {
  let t11 = (0, import_react51.useContext)(I3);
  if (t11 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t11;
}
function xe2() {
  let t11 = (0, import_react51.useContext)(M3);
  if (t11 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t11;
}
var M3 = (0, import_react51.createContext)(null);
M3.displayName = "NestingContext";
function U3(t11) {
  return "children" in t11 ? U3(t11.children) : t11.current.filter(({ el: n5 }) => n5.current !== null).filter(({ state: n5 }) => n5 === "visible").length > 0;
}
function se(t11, n5) {
  let r4 = s2(t11), s8 = (0, import_react51.useRef)([]), R2 = f4(), D3 = p(), p3 = o2((i6, e3 = v.Hidden) => {
    let a3 = s8.current.findIndex(({ el: o11 }) => o11 === i6);
    a3 !== -1 && (u(e3, { [v.Unmount]() {
      s8.current.splice(a3, 1);
    }, [v.Hidden]() {
      s8.current[a3].state = "hidden";
    } }), D3.microTask(() => {
      var o11;
      !U3(s8) && R2.current && ((o11 = r4.current) == null || o11.call(r4));
    }));
  }), x2 = o2((i6) => {
    let e3 = s8.current.find(({ el: a3 }) => a3 === i6);
    return e3 ? e3.state !== "visible" && (e3.state = "visible") : s8.current.push({ el: i6, state: "visible" }), () => p3(i6, v.Unmount);
  }), h4 = (0, import_react51.useRef)([]), v4 = (0, import_react51.useRef)(Promise.resolve()), u6 = (0, import_react51.useRef)({ enter: [], leave: [], idle: [] }), g4 = o2((i6, e3, a3) => {
    h4.current.splice(0), n5 && (n5.chains.current[e3] = n5.chains.current[e3].filter(([o11]) => o11 !== i6)), n5 == null || n5.chains.current[e3].push([i6, new Promise((o11) => {
      h4.current.push(o11);
    })]), n5 == null || n5.chains.current[e3].push([i6, new Promise((o11) => {
      Promise.all(u6.current[e3].map(([f6, N4]) => N4)).then(() => o11());
    })]), e3 === "enter" ? v4.current = v4.current.then(() => n5 == null ? void 0 : n5.wait.current).then(() => a3(e3)) : a3(e3);
  }), d6 = o2((i6, e3, a3) => {
    Promise.all(u6.current[e3].splice(0).map(([o11, f6]) => f6)).then(() => {
      var o11;
      (o11 = h4.current.shift()) == null || o11();
    }).then(() => a3(e3));
  });
  return (0, import_react51.useMemo)(() => ({ children: s8, register: x2, unregister: p3, onStart: g4, onStop: d6, wait: v4, chains: u6 }), [x2, p3, s8, g4, d6, u6, v4]);
}
function Ne() {
}
var Pe2 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(t11) {
  var r4;
  let n5 = {};
  for (let s8 of Pe2)
    n5[s8] = (r4 = t11[s8]) != null ? r4 : Ne;
  return n5;
}
function Re2(t11) {
  let n5 = (0, import_react51.useRef)(ae(t11));
  return (0, import_react51.useEffect)(() => {
    n5.current = ae(t11);
  }, [t11]), n5;
}
var De2 = "div";
var le = O2.RenderStrategy;
function He(t11, n5) {
  var Q, Y;
  let { beforeEnter: r4, afterEnter: s8, beforeLeave: R2, afterLeave: D3, enter: p3, enterFrom: x2, enterTo: h4, entered: v4, leave: u6, leaveFrom: g4, leaveTo: d6, ...i6 } = t11, e3 = (0, import_react51.useRef)(null), a3 = y3(e3, n5), o11 = (Q = i6.unmount) == null || Q ? v.Unmount : v.Hidden, { show: f6, appear: N4, initial: T3 } = ye2(), [l7, j2] = (0, import_react51.useState)(f6 ? "visible" : "hidden"), z2 = xe2(), { register: L, unregister: O3 } = z2;
  (0, import_react51.useEffect)(() => L(e3), [L, e3]), (0, import_react51.useEffect)(() => {
    if (o11 === v.Hidden && e3.current) {
      if (f6 && l7 !== "visible") {
        j2("visible");
        return;
      }
      return u(l7, { ["hidden"]: () => O3(e3), ["visible"]: () => L(e3) });
    }
  }, [l7, e3, L, O3, f6, o11]);
  let k2 = s2({ base: S3(i6.className), enter: S3(p3), enterFrom: S3(x2), enterTo: S3(h4), entered: S3(v4), leave: S3(u6), leaveFrom: S3(g4), leaveTo: S3(d6) }), V = Re2({ beforeEnter: r4, afterEnter: s8, beforeLeave: R2, afterLeave: D3 }), G2 = l2();
  (0, import_react51.useEffect)(() => {
    if (G2 && l7 === "visible" && e3.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [e3, l7, G2]);
  let Te2 = T3 && !N4, K2 = N4 && f6 && T3, de2 = (() => !G2 || Te2 ? "idle" : f6 ? "enter" : "leave")(), H3 = c4(0), fe2 = o2((C3) => u(C3, { enter: () => {
    H3.addFlag(d5.Opening), V.current.beforeEnter();
  }, leave: () => {
    H3.addFlag(d5.Closing), V.current.beforeLeave();
  }, idle: () => {
  } })), me2 = o2((C3) => u(C3, { enter: () => {
    H3.removeFlag(d5.Opening), V.current.afterEnter();
  }, leave: () => {
    H3.removeFlag(d5.Closing), V.current.afterLeave();
  }, idle: () => {
  } })), w3 = se(() => {
    j2("hidden"), O3(e3);
  }, z2), B = (0, import_react51.useRef)(false);
  D2({ immediate: K2, container: e3, classes: k2, direction: de2, onStart: s2((C3) => {
    B.current = true, w3.onStart(e3, C3, fe2);
  }), onStop: s2((C3) => {
    B.current = false, w3.onStop(e3, C3, me2), C3 === "leave" && !U3(w3) && (j2("hidden"), O3(e3));
  }) });
  let P2 = i6, ce = { ref: a3 };
  return K2 ? P2 = { ...P2, className: t9(i6.className, ...k2.current.enter, ...k2.current.enterFrom) } : B.current && (P2.className = t9(i6.className, (Y = e3.current) == null ? void 0 : Y.className), P2.className === "" && delete P2.className), import_react51.default.createElement(M3.Provider, { value: w3 }, import_react51.default.createElement(s6, { value: u(l7, { ["visible"]: d5.Open, ["hidden"]: d5.Closed }) | H3.flags }, C({ ourProps: ce, theirProps: P2, defaultTag: De2, features: le, visible: l7 === "visible", name: "Transition.Child" })));
}
function Fe(t11, n5) {
  let { show: r4, appear: s8 = false, unmount: R2 = true, ...D3 } = t11, p3 = (0, import_react51.useRef)(null), x2 = y3(p3, n5);
  l2();
  let h4 = u4();
  if (r4 === void 0 && h4 !== null && (r4 = (h4 & d5.Open) === d5.Open), ![true, false].includes(r4))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [v4, u6] = (0, import_react51.useState)(r4 ? "visible" : "hidden"), g4 = se(() => {
    u6("hidden");
  }), [d6, i6] = (0, import_react51.useState)(true), e3 = (0, import_react51.useRef)([r4]);
  l(() => {
    d6 !== false && e3.current[e3.current.length - 1] !== r4 && (e3.current.push(r4), i6(false));
  }, [e3, r4]);
  let a3 = (0, import_react51.useMemo)(() => ({ show: r4, appear: s8, initial: d6 }), [r4, s8, d6]);
  (0, import_react51.useEffect)(() => {
    if (r4)
      u6("visible");
    else if (!U3(g4))
      u6("hidden");
    else {
      let T3 = p3.current;
      if (!T3)
        return;
      let l7 = T3.getBoundingClientRect();
      l7.x === 0 && l7.y === 0 && l7.width === 0 && l7.height === 0 && u6("hidden");
    }
  }, [r4, g4]);
  let o11 = { unmount: R2 }, f6 = o2(() => {
    var T3;
    d6 && i6(false), (T3 = t11.beforeEnter) == null || T3.call(t11);
  }), N4 = o2(() => {
    var T3;
    d6 && i6(false), (T3 = t11.beforeLeave) == null || T3.call(t11);
  });
  return import_react51.default.createElement(M3.Provider, { value: g4 }, import_react51.default.createElement(I3.Provider, { value: a3 }, C({ ourProps: { ...o11, as: import_react51.Fragment, children: import_react51.default.createElement(ue, { ref: x2, ...o11, ...D3, beforeEnter: f6, beforeLeave: N4 }) }, theirProps: {}, defaultTag: import_react51.Fragment, features: le, visible: v4 === "visible", name: "Transition" })));
}
function _e(t11, n5) {
  let r4 = (0, import_react51.useContext)(I3) !== null, s8 = u4() !== null;
  return import_react51.default.createElement(import_react51.default.Fragment, null, !r4 && s8 ? import_react51.default.createElement(q2, { ref: n5, ...t11 }) : import_react51.default.createElement(ue, { ref: n5, ...t11 }));
}
var q2 = U(Fe);
var ue = U(He);
var Le = U(_e);
var qe2 = Object.assign(q2, { Child: Le, Root: q2 });

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React88 = __toESM(require_react(), 1);
"use client";
var count2 = 0;
function useFocusGuards() {
  React88.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element2 = document.createElement("span");
  element2.setAttribute("data-radix-focus-guard", "");
  element2.tabIndex = 0;
  element2.style.outline = "none";
  element2.style.opacity = "0";
  element2.style.position = "fixed";
  element2.style.pointerEvents = "none";
  return element2;
}

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React89 = __toESM(require_react(), 1);
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
"use client";
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React89.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React89.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React89.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React89.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React89.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container)
          return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null)
          return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body)
          return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0)
            focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container)
        mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React89.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React89.useCallback(
    (event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first2, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first2 && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop)
              focus(first2, { select: true });
          } else if (event.shiftKey && focusedElement === first2) {
            event.preventDefault();
            if (loop)
              focus(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select: select2 = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select: select2 });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first2 = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first2, last2];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element2 of elements) {
    if (!isHidden(element2, { upTo: container }))
      return element2;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}
function focus(element2, { select: select2 = false } = {}) {
  if (element2 && element2.focus) {
    const previouslyFocusedElement = document.activeElement;
    element2.focus({ preventScroll: true });
    if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select2)
      element2.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e3) {
          console.error("aria-hidden: cannot operate on ", node, e3);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
init_tslib_es6();
var React96 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
init_tslib_es6();
var React92 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react52 = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react52.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React90 = __toESM(require_react());
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React90.useLayoutEffect : React90.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../../node_modules/use-sidecar/dist/es2015/medium.js
init_tslib_es6();
function ItoI(a3) {
  return a3;
}
function innerCreateMedium(defaults, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
init_tslib_es6();
var React91 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest2 = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React91.createElement(Target, __assign({}, rest2));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React92.forwardRef(function(props, parentRef) {
  var ref = React92.useRef(null);
  var _a = React92.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest2 = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest2), callbacks);
  return React92.createElement(
    React92.Fragment,
    null,
    enabled && React92.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React92.cloneElement(React92.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React92.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_tslib_es6();
var React95 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React94 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var React93 = __toESM(require_react());

// ../../node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter2 = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter2 == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter2++;
    },
    remove: function() {
      counter2--;
      if (!counter2 && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React93.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter2 = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter2) ? counter2 : 0;
};
var useLockAttribute = function() {
  React94.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React94.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React94.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y4) {
  return x2[0] === y4[0] && x2[1] === y4[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React95.useRef([]);
  var touchStartRef = React95.useRef([0, 0]);
  var activeAxis = React95.useRef();
  var id = React95.useState(idCounter++)[0];
  var Style2 = React95.useState(styleSingleton)[0];
  var lastProps = React95.useRef(props);
  React95.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React95.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React95.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React95.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && (e3.target === event.target || event.target === e3.shadowParent) && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React95.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React95.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React95.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React95.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React95.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React95.createElement(
    React95.Fragment,
    null,
    inert ? React95.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React95.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React96.forwardRef(function(props, ref) {
  return React96.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../packages/site/src/components/Navigation/ThemeButton.tsx
var import_classnames32 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime(), 1);
function ThemeButton({ className = "w-10 h-10 mx-3" }) {
  const { nextTheme } = useThemeSwitcher();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
    "button",
    {
      className: (0, import_classnames32.default)(
        "myst-theme-button theme rounded-full aspect-square border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800",
        className
      ),
      title: `Toggle theme between light and dark mode`,
      "aria-label": `Toggle theme between light and dark mode`,
      onClick: nextTheme,
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(MoonIcon_default, { className: "myst-theme-moon-icon h-full w-full p-0.5 hidden dark:block" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
          lineNumber: 18,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(SunIcon_default, { className: "myst-theme-sun-icon h-full w-full p-0.5 dark:hidden" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
          lineNumber: 19,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Navigation/ThemeButton.tsx",
      lineNumber: 9,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/TopNav.tsx
var import_react59 = __toESM(require_react(), 1);
var import_classnames37 = __toESM(require_classnames(), 1);

// ../../packages/site/src/components/Navigation/Search.tsx
var import_react53 = __toESM(require_react(), 1);
var import_classnames33 = __toESM(require_classnames(), 1);

// ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
var React97 = __toESM(require_react(), 1);
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
"use client";
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React97.useRef(null);
  const contentRef = React97.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React97.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME3 = "DialogTrigger";
var DialogTrigger = React97.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME3;
var PORTAL_NAME3 = "DialogPortal";
var [PortalProvider2, usePortalContext2] = createDialogContext(PORTAL_NAME3, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME3, __scopeDialog);
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(PortalProvider2, { scope: __scopeDialog, forceMount, children: React97.Children.map(children, (child) => /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME3;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React97.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot = createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = React97.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
        Primitive.div,
        {
          "data-state": getState2(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME4 = "DialogContent";
var DialogContent = React97.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext2(CONTENT_NAME4, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME4, props.__scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME4;
var DialogContentModal = React97.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME4, props.__scopeDialog);
    const contentRef = React97.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React97.useEffect(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick)
            event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React97.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME4, props.__scopeDialog);
    const hasInteractedOutsideRef = React97.useRef(false);
    const hasPointerDownOutsideRef = React97.useRef(false);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current)
              context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger)
            event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React97.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME4, __scopeDialog);
    const contentRef = React97.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState2(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React97.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React97.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React97.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME4,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React97.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle)
        console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React97.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription)
        console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root4 = Dialog;
var Trigger3 = DialogTrigger;
var Portal3 = DialogPortal;
var Overlay = DialogOverlay;
var Content4 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;

// ../../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React100 = __toESM(require_react(), 1);

// ../../node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React99 = __toESM(require_react(), 1);
var ReactDOM4 = __toESM(require_react_dom(), 1);

// ../../node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-slot/dist/index.mjs
var React98 = __toESM(require_react(), 1);
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use3 = React98[" use ".trim().toString()];
function isPromiseLike2(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element2) {
  return element2 != null && typeof element2 === "object" && "$$typeof" in element2 && element2.$$typeof === REACT_LAZY_TYPE && "_payload" in element2 && isPromiseLike2(element2._payload);
}
function createSlot2(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone2(ownerName);
  const Slot2 = React98.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use3 === "function") {
      children = use3(children._payload);
    }
    const childrenArray = React98.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React98.Children.count(newElement) > 1)
            return React98.Children.only(null);
          return React98.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React98.isValidElement(newElement) ? React98.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
function createSlotClone2(ownerName) {
  const SlotClone = React98.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use3 === "function") {
      children = use3(children._payload);
    }
    if (React98.isValidElement(children)) {
      const childrenRef = getElementRef3(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React98.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React98.cloneElement(children, props2);
    }
    return React98.Children.count(children) > 1 ? React98.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = Symbol("radix.slottable");
function isSlottable2(child) {
  return React98.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result2 = childPropValue(...args);
          slotPropValue(...args);
          return result2;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef3(element2) {
  let getter = Object.getOwnPropertyDescriptor(element2.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element2, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element2.props.ref;
  }
  return element2.props.ref || element2.ref;
}

// ../../node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var NODES2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive2 = NODES2.reduce((primitive, node) => {
  const Slot2 = createSlot2(`Primitive.${node}`);
  const Node2 = React99.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});

// ../../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME2 = "VisuallyHidden";
var VisuallyHidden = React100.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
      Primitive2.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME2;
var Root5 = VisuallyHidden;

// ../../packages/search/dist/types.js
var SEARCH_ATTRIBUTES_ORDERED = [
  "hierarchy.lvl1",
  "hierarchy.lvl2",
  "hierarchy.lvl3",
  "hierarchy.lvl4",
  "hierarchy.lvl5",
  "hierarchy.lvl6",
  "content"
];

// ../../packages/search/dist/search.js
var SPACE_OR_PUNCTUATION = /[\n\r\p{Z}\p{P}]+/gu;
function extractField(document2, fieldName) {
  return fieldName.split(".").reduce((doc, key) => doc && doc[key], document2);
}

// ../../packages/search/dist/rank.js
var POSITIONAL_SEARCH_ATTRIBUTES = ["content"];
var TYPE_WEIGHTS = /* @__PURE__ */ new Map([
  ["lvl1", 90],
  ["lvl2", 80],
  ["lvl3", 70],
  ["lvl4", 60],
  ["lvl5", 50],
  ["lvl6", 40],
  ["content", 0]
]);
function cmp(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  } else {
    return 0;
  }
}
function buildRegExpToken(token) {
  return new RegExp(`(?:(?:${SPACE_OR_PUNCTUATION.source})|^)${token}(?:(?:${SPACE_OR_PUNCTUATION.source})|$)`, `${SPACE_OR_PUNCTUATION.flags}i`);
}
function queryPairProximity(record, left, right, bound) {
  let bestProximity = bound;
  for (const [leftTerm, leftFields] of Object.entries(left.matches)) {
    const leftPattern = buildRegExpToken(leftTerm);
    for (const leftField of leftFields) {
      const content = extractField(record, leftField);
      for (const [rightTerm, rightFields] of Object.entries(right.matches)) {
        const rightPattern = buildRegExpToken(rightTerm);
        for (const rightField of rightFields) {
          if (leftField !== rightField) {
            continue;
          }
          const leftMatches = content.matchAll(leftPattern);
          const rightMatches = content.matchAll(rightPattern);
          for (const leftMatch of leftMatches) {
            for (const rightMatch of rightMatches) {
              const [start, stop] = leftMatch.index < rightMatch.index ? [leftMatch.index, rightMatch.index] : [rightMatch.index, leftMatch.index];
              const numSeparators = Array.from(content.slice(start, stop).matchAll(SPACE_OR_PUNCTUATION)).length;
              if (numSeparators === 1) {
                return 1;
              }
              if (numSeparators < bestProximity) {
                bestProximity = numSeparators;
              }
            }
          }
        }
      }
    }
  }
  return bestProximity;
}
function wordsProximity(result2, bound) {
  const { queries } = result2;
  let proximity = 0;
  for (let i6 = 0; i6 < queries.length - 1; i6++) {
    const left = queries[i6];
    const right = queries[i6 + 1];
    proximity += queryPairProximity(result2, left, right, bound);
  }
  return Math.min(proximity, bound);
}
function matchedAttributePosition(result2) {
  const fieldToTerms = /* @__PURE__ */ new Map();
  result2.queries.forEach((query) => {
    Object.entries(query.matches).forEach(([term, fields]) => {
      fields.forEach((field) => {
        let terms = fieldToTerms.get(field);
        if (!terms) {
          terms = [];
          fieldToTerms.set(field, terms);
        }
        terms.push(term);
      });
    });
  });
  const attribute = SEARCH_ATTRIBUTES_ORDERED.find((field) => fieldToTerms.has(field));
  let position;
  if (POSITIONAL_SEARCH_ATTRIBUTES.includes(attribute)) {
    const attributeTerms = fieldToTerms.get(attribute);
    const value = extractField(result2, attribute);
    const matchPositions = attributeTerms.flatMap((term) => Array.from(value.matchAll(buildRegExpToken(term)))).map((match) => match.index);
    position = Math.min(...matchPositions);
  } else {
    position = void 0;
  }
  return { attribute, position };
}
function matchedExactWords(result2) {
  const allMatches = result2.queries.flatMap(
    // For each query (foo bar baz -> foo, then bar, then baz)
    (query) => Object.entries(query.matches).flatMap(
      // For each (match, matched fields) pair in the query matches
      ([match, fields]) => {
        const pattern = buildRegExpToken(match);
        return fields.flatMap(
          // For each matched field
          (field) => {
            const value = extractField(result2, field);
            return Array.from(value.matchAll(pattern)).map((m5) => m5 ? query.term : void 0);
          }
        );
      }
    ).filter((item) => item)
  );
  const uniqueMatches = new Set(allMatches);
  return uniqueMatches.size;
}
function numberOfTypos(result2) {
  return result2.queries.map((query) => {
    const typoTerms = Object.keys(query.matches).filter((match) => match !== query.term);
    return typoTerms.length;
  }).reduce((sum, value) => sum + value);
}
function rankSearchResult(result2) {
  return {
    ...result2,
    ranking: {
      typos: numberOfTypos(result2),
      ...matchedAttributePosition(result2),
      proximity: wordsProximity(result2, 8),
      // TODO
      exact: matchedExactWords(result2),
      level: TYPE_WEIGHTS.get(result2.type),
      appearance: result2.position
    }
  };
}
function cmpRankedSearchResults(left, right) {
  const leftRank = left.ranking;
  const rightRank = right.ranking;
  if (leftRank.typos !== rightRank.typos) {
    return cmp(leftRank.typos, rightRank.typos);
  }
  if (leftRank.attribute !== rightRank.attribute) {
    const i6 = SEARCH_ATTRIBUTES_ORDERED.findIndex((item) => item === leftRank.attribute);
    const j2 = SEARCH_ATTRIBUTES_ORDERED.findIndex((item) => item === rightRank.attribute);
    return cmp(i6, j2);
  }
  if (leftRank.position != null && rightRank.position != null && leftRank.position !== rightRank.position) {
    return cmp(leftRank.position, rightRank.position);
  }
  if (leftRank.proximity !== rightRank.proximity) {
    return cmp(leftRank.proximity, rightRank.proximity);
  }
  if (leftRank.exact !== rightRank.exact) {
    return cmp(rightRank.exact, leftRank.exact);
  }
  if (leftRank.level !== rightRank.level) {
    return cmp(rightRank.level, leftRank.level);
  }
  if (leftRank.appearance !== rightRank.appearance) {
    return cmp(leftRank.appearance, rightRank.appearance);
  }
  return 0;
}
function rankResults(results) {
  return results.map(rankSearchResult).sort(cmpRankedSearchResults);
}

// ../../packages/site/src/components/Navigation/Search.tsx
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime(), 1);
function matchAll(text, pattern) {
  const matches2 = [];
  let match;
  while (match = pattern.exec(text)) {
    matches2.push(match);
  }
  return matches2;
}
function MarkedText({
  text,
  matches: matches2,
  limit,
  className
}) {
  const splits = matchAll(text, SPACE_OR_PUNCTUATION);
  const tokens = [];
  let start = 0;
  for (const splitMatch of splits) {
    tokens.push(text.slice(start, splitMatch.index));
    tokens.push(splitMatch[0]);
    start = splitMatch.index + splitMatch[0].length;
  }
  tokens.push(text.slice(start));
  const allTerms = matches2.join("|");
  const pattern = new RegExp(`^(${allTerms})`, "i");
  const renderToken = (token) => pattern.test(token) ? /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(import_jsx_dev_runtime6.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("mark", { className: "text-blue-600 bg-inherit dark:text-blue-400 group-aria-selected:text-white group-aria-selected:underline", children: token }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 85,
    columnNumber: 9
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 84,
    columnNumber: 7
  }, this) : token;
  let firstIndex;
  let lastIndex;
  const hasLimit = limit !== void 0;
  if (!hasLimit) {
    firstIndex = 0;
    lastIndex = tokens.length;
  } else {
    firstIndex = tokens.findIndex((token) => pattern.test(token));
    let numChars = 0;
    for (lastIndex = firstIndex + 1; lastIndex < tokens.length - 1 && numChars + tokens[lastIndex].length <= limit; lastIndex++) {
      numChars += tokens[lastIndex].length;
    }
  }
  if (tokens.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("span", { className, children: [
      ...tokens
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 112,
      columnNumber: 12
    }, this);
  } else {
    const firstRenderer = renderToken(tokens[firstIndex]);
    const remainingTokens = tokens.slice(firstIndex + 1, lastIndex);
    const remainingRenderers = remainingTokens.map((token) => renderToken(token));
    return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
      "span",
      {
        className: (0, import_classnames33.default)(
          className,
          {
            "before:content-['..._']": hasLimit,
            "after:content-['_...']": hasLimit
          },
          "truncate",
          "w-full"
        ),
        children: [
          firstRenderer,
          ...remainingRenderers
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 119,
        columnNumber: 7
      },
      this
    );
  }
}
function isMac() {
  var _a, _b;
  if (typeof window === "undefined") {
    return void 0;
  } else {
    const hostIsMac = /mac/i.test(
      (_b = (_a = window.navigator.userAgentData) == null ? void 0 : _a.platform) != null ? _b : window.navigator.userAgent
    );
    return hostIsMac;
  }
}
var clientThemeCode = `
;(() => {
const script = document.currentScript;
const root = script.parentElement;

const isMac = /mac/i.test(
      window.navigator.userAgentData?.platform ?? window.navigator.userAgent,
    );
root.querySelectorAll(".hide-mac").forEach(node => {node.classList.add(isMac ? "hidden" : "block")});
root.querySelectorAll(".show-mac").forEach(node => {node.classList.add(!isMac ? "hidden" : "block")});
})()`;
function BlockingPlatformLoader() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("script", { dangerouslySetInnerHTML: { __html: clientThemeCode } }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 166,
    columnNumber: 10
  }, this);
}
function SearchShortcut() {
  const hostIsMac = isMac();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "div",
    {
      "aria-hidden": true,
      className: "myst-search-shortcut items-center hidden mx-1 font-mono text-sm text-gray-600 sm:flex gap-x-1",
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
          "kbd",
          {
            className: (0, import_classnames33.default)(
              "px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md",
              "shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none",
              "hide-mac",
              { hidden: hostIsMac === true },
              { block: hostIsMac === false }
            ),
            children: "CTRL"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/Search.tsx",
            lineNumber: 179,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
          "kbd",
          {
            className: (0, import_classnames33.default)(
              "px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md",
              "shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none",
              "show-mac",
              { hidden: hostIsMac === false },
              { block: hostIsMac === true }
            ),
            children: "\u2318"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/Search.tsx",
            lineNumber: 190,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("kbd", { className: "px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none ", children: "K" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 201,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(BlockingPlatformLoader, {}, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 204,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 175,
      columnNumber: 5
    },
    this
  );
}
function SearchResultItem({
  result: result2,
  closeSearch,
  charLimit
}) {
  const { hierarchy, type, url, queries } = result2;
  const baseurl = useBaseurl();
  const Link2 = useLinkProvider();
  const iconProps = (0, import_react53.useMemo)(() => {
    return { className: "myst-search-result-icon inline-block w-6 mx-2 shrink-0" };
  }, []);
  const iconRenderer = (0, import_react53.createElement)(
    type === "lvl1" ? DocumentIcon_default : type === "content" ? Bars3BottomLeftIcon_default : HashtagIcon_default,
    iconProps
  );
  const title = result2.type === "content" ? result2["content"] : hierarchy[type];
  const matches2 = (0, import_react53.useMemo)(() => queries.flatMap((query) => Object.keys(query.matches)), [queries]);
  const titleRenderer = /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    MarkedText,
    {
      text: title,
      matches: matches2,
      limit: type === "content" ? charLimit : void 0,
      className: "myst-search-result-highlight text-sm"
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 240,
      columnNumber: 5
    },
    this
  );
  let subtitleRenderer;
  if (result2.type === "lvl1") {
    subtitleRenderer = void 0;
  } else {
    const subtitle = result2.hierarchy.lvl1;
    subtitleRenderer = /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(MarkedText, { text: subtitle, matches: matches2, className: "text-xs" }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 254,
      columnNumber: 24
    }, this);
  }
  const enterIconRenderer = /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(ArrowTurnDownLeftIcon_default, { className: "invisible w-6 mx-2 group-aria-selected:visible" }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 258,
    columnNumber: 5
  }, this);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    Link2,
    {
      className: "block px-1 py-2 text-gray-700 rounded shadow-md dark:text-white group-aria-selected:bg-blue-600 group-aria-selected:text-white dark:shadow-none dark:bg-stone-800",
      to: withBaseurl(url, baseurl),
      onClick: closeSearch,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { className: "flex flex-row h-11", children: [
        iconRenderer,
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { className: "flex flex-col justify-center truncate grow", children: [
          titleRenderer,
          subtitleRenderer
        ] }, void 0, true, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 270,
          columnNumber: 9
        }, this),
        enterIconRenderer
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 268,
        columnNumber: 7
      }, this)
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 262,
      columnNumber: 5
    },
    this
  );
}
function SearchResults({
  searchResults,
  searchListID,
  searchLabelID,
  charLimit,
  className,
  selectedIndex,
  onHoverSelect,
  closeSearch
}) {
  const itemsRef = (0, import_react53.useRef)([]);
  const setItemRef = (0, import_react53.useCallback)(
    (elem) => {
      if (!elem) {
        return;
      }
      const index2 = parseInt(elem.dataset.index);
      itemsRef.current[index2] = elem;
    },
    [itemsRef]
  );
  const activeDescendent = (0, import_react53.useMemo)(() => {
    const item = itemsRef.current[selectedIndex];
    if (!item) {
      return "";
    } else {
      return item.id;
    }
  }, [selectedIndex, itemsRef]);
  (0, import_react53.useEffect)(() => {
    const item = itemsRef.current[selectedIndex];
    item == null ? void 0 : item.scrollIntoView({ block: "nearest" });
  }, [selectedIndex]);
  const handleMouseMove = (0, import_react53.useCallback)(
    (event) => {
      const index2 = parseInt(event.currentTarget.dataset.index);
      onHoverSelect(index2);
    },
    [onHoverSelect]
  );
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { className: "myst-search-results mt-4 overflow-y-scroll", children: searchResults.length ? /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "ul",
    {
      role: "listbox",
      id: searchListID,
      "aria-label": "Search results",
      "aria-labelledby": searchLabelID,
      "aria-orientation": "vertical",
      "aria-activedescendant": activeDescendent,
      className: (0, import_classnames33.default)("flex flex-col gap-y-2 px-1", className),
      children: searchResults.map((result2, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
        "li",
        {
          ref: setItemRef,
          "data-index": index2,
          role: "option",
          "aria-selected": selectedIndex === index2,
          className: "myst-search-result-item group",
          onMouseMove: handleMouseMove,
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(SearchResultItem, { result: result2, closeSearch, charLimit }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/Search.tsx",
            lineNumber: 370,
            columnNumber: 15
          }, this)
        },
        result2.id,
        false,
        {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 356,
          columnNumber: 13
        },
        this
      ))
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 343,
      columnNumber: 9
    },
    this
  ) : /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("span", { className: "myst-search-no-results", children: "No results found." }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 375,
    columnNumber: 9
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 341,
    columnNumber: 5
  }, this);
}
function useSearch() {
  const baseURL = useBaseurl();
  const fetcher7 = useFetcher();
  const [enabled, setEnabled] = (0, import_react53.useState)(true);
  (0, import_react53.useEffect)(() => {
    if (fetcher7.state === "idle" && fetcher7.data == null) {
      const searchURL = withBaseurl("/myst.search.json", baseURL);
      fetcher7.load(searchURL);
    }
  }, [fetcher7, baseURL]);
  const searchFactory = useSearchFactory();
  const search = (0, import_react53.useMemo)(() => {
    var _a, _b;
    if (!fetcher7.data || !searchFactory) {
      return void 0;
    } else {
      if (((_a = fetcher7.data) == null ? void 0 : _a.version) && ((_b = fetcher7.data) == null ? void 0 : _b.records)) {
        return searchFactory(fetcher7.data);
      }
      setEnabled(false);
      return void 0;
    }
  }, [searchFactory, fetcher7.data, setEnabled]);
  return { search, enabled };
}
function SearchForm({
  debounceTime,
  searchResults,
  setSearchResults,
  searchInputID,
  searchListID,
  searchLabelID,
  selectedIndex,
  setSelectedIndex,
  closeSearch
}) {
  const [query, setQuery] = (0, import_react53.useState)("");
  const { search: doSearch, enabled } = useSearch();
  (0, import_react53.useEffect)(() => {
    const timeoutId = setTimeout(() => {
      if (query != void 0 && !!doSearch) {
        doSearch(query).then((rawResults) => {
          setSearchResults(
            rawResults && rankResults(rawResults).filter((result2, index2, array) => {
              var _a;
              return result2.url !== ((_a = array[index2 - 1]) == null ? void 0 : _a.url);
            })
          );
        });
      }
    }, debounceTime);
    return () => clearTimeout(timeoutId);
  }, [doSearch, query, debounceTime]);
  const handleSearchChange = (0, import_react53.useCallback)((event) => {
    setQuery(event.target.value);
  }, []);
  const navigate = useNavigateProvider();
  const baseurl = useBaseurl();
  const handleSearchKeyPress = (0, import_react53.useCallback)(
    (event) => {
      var _a;
      if (event.ctrlKey || event.altKey || event.shiftKey) {
        return;
      }
      if (!searchResults) {
        return;
      }
      if (event.key === "Enter") {
        event.preventDefault();
        const url = (_a = searchResults[selectedIndex]) == null ? void 0 : _a.url;
        if (url) {
          navigate(withBaseurl(url, baseurl));
          closeSearch == null ? void 0 : closeSearch();
        }
      } else if (event.key === "ArrowUp" || event.key === "ArrowDown") {
        event.preventDefault();
        if (event.key === "ArrowUp") {
          setSelectedIndex(selectedIndex > 0 ? selectedIndex - 1 : 0);
        } else {
          setSelectedIndex(
            selectedIndex < searchResults.length - 1 ? selectedIndex + 1 : searchResults.length - 1
          );
        }
      }
    },
    [searchResults, selectedIndex]
  );
  const onSubmit = (0, import_react53.useCallback)((event) => {
    event.preventDefault();
  }, []);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(import_jsx_dev_runtime6.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("form", { onSubmit, children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { className: "relative flex w-full h-10 flow-row gap-x-1 ", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("label", { id: searchLabelID, htmlFor: searchInputID, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(MagnifyingGlassIcon_default, { className: "absolute text-gray-600 inset-y-0 start-0 h-10 w-10 p-2.5 aspect-square flex items-center pointer-events-none" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 510,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("span", { className: "hidden", children: "Search query" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 511,
          columnNumber: 13
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 509,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
        "input",
        {
          autoComplete: "off",
          spellCheck: "false",
          disabled: !enabled,
          autoCapitalize: "false",
          className: (0, import_classnames33.default)(
            "myst-search-input block flex-grow p-2 ps-10 placeholder-gray-400",
            "border border-gray-300 dark:border-gray-600",
            "rounded-lg bg-gray-50 dark:bg-gray-700",
            "focus:ring-blue-500 dark:focus:ring-blue-500",
            "focus:border-blue-500 dark:focus:border-blue-500",
            "dark:placeholder-gray-400",
            { "border-red-500": !enabled }
          ),
          id: searchInputID,
          "aria-labelledby": searchLabelID,
          "aria-controls": searchListID,
          placeholder: "Search",
          type: "search",
          required: true,
          onChange: handleSearchChange,
          onKeyDown: handleSearchKeyPress
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 513,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Close, { asChild: true, className: "block grow-0 sm:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("button", { "aria-label": "Close", children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(XCircleIcon_default, { className: "flex items-center w-10 h-10 aspect-square" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 538,
        columnNumber: 15
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 537,
        columnNumber: 13
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 536,
        columnNumber: 11
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 508,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 507,
      columnNumber: 7
    }, this),
    !enabled && /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { className: "myst-search-no-results mx-2 mt-4 text-sm text-gray-500", children: "Search is not enabled for this site. :(" }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 544,
      columnNumber: 9
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 506,
    columnNumber: 5
  }, this);
}
var SearchPlaceholderButton = (0, import_react53.forwardRef)(({ className, disabled, ...props }, ref) => {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "button",
    {
      ...props,
      className: (0, import_classnames33.default)(
        "myst-search-bar",
        className,
        "flex items-center h-10 aspect-square sm:w-64 text-left text-gray-600",
        "border border-gray-300 dark:border-gray-600",
        "rounded-lg bg-gray-50 dark:bg-gray-700",
        {
          "myst-search-bar-disabled hover:ring-blue-500": !disabled,
          "dark:hover:ring-blue-500": !disabled,
          "hover:border-blue-500": !disabled,
          "dark:hover:border-blue-500": !disabled
        }
      ),
      disabled: !!disabled,
      ref,
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(MagnifyingGlassIcon_default, { className: "p-2.5 h-10 w-10 aspect-square" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 579,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("span", { className: "myst-search-text-placeholder hidden sm:block grow", children: "Search" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 580,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(SearchShortcut, {}, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 581,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 561,
      columnNumber: 5
    },
    this
  );
});
function Search({ debounceTime = 500, charLimit = 64 }) {
  const [open, setOpen] = (0, import_react53.useState)(false);
  const [searchResults, setSearchResults] = (0, import_react53.useState)();
  const [selectedIndex, setSelectedIndex] = (0, import_react53.useState)(0);
  const top = useThemeTop();
  (0, import_react53.useEffect)(() => {
    if (!open) {
      setSearchResults(void 0);
      setSelectedIndex(0);
    }
  }, [open]);
  const handleDocumentKeyPress = (0, import_react53.useCallback)((event) => {
    if (event.key === "k" && (isMac() ? event.metaKey : event.ctrlKey)) {
      setOpen(true);
      event.preventDefault();
    }
  }, []);
  (0, import_react53.useEffect)(() => {
    document.addEventListener("keydown", handleDocumentKeyPress);
    return () => {
      document.removeEventListener("keydown", handleDocumentKeyPress);
    };
  }, [handleDocumentKeyPress]);
  const triggerClose = (0, import_react53.useCallback)(() => setOpen(false), [setOpen]);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Root4, { open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Trigger3, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(SearchPlaceholderButton, {}, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 630,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 629,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Portal3, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Overlay, { className: "fixed inset-0 bg-[#656c85cc] z-[1000]" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/Search.tsx",
        lineNumber: 633,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
        Content4,
        {
          className: "myst-search-dialog fixed flex flex-col top-0 bg-white dark:bg-stone-900 z-[1001] h-screen w-screen sm:left-1/2 sm:-translate-x-1/2 sm:w-[90vw] sm:max-w-screen-sm sm:h-auto sm:max-h-[var(--content-max-height)] sm:top-[var(--content-top)] sm:rounded-md p-4 text-gray-900 dark:text-white",
          style: {
            "--content-top": `${top}px`,
            "--content-max-height": `calc(90vh - var(--content-top))`
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Root5, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Title, { children: "Search Website" }, void 0, false, {
              fileName: "../../packages/site/src/components/Navigation/Search.tsx",
              lineNumber: 645,
              columnNumber: 13
            }, this) }, void 0, false, {
              fileName: "../../packages/site/src/components/Navigation/Search.tsx",
              lineNumber: 644,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Root5, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Description, { children: "Search articles and their contents using fuzzy-search and prefix-matching" }, void 0, false, {
              fileName: "../../packages/site/src/components/Navigation/Search.tsx",
              lineNumber: 648,
              columnNumber: 13
            }, this) }, void 0, false, {
              fileName: "../../packages/site/src/components/Navigation/Search.tsx",
              lineNumber: 647,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
              SearchForm,
              {
                searchListID: "search-list",
                searchLabelID: "search-label",
                searchInputID: "search-input",
                debounceTime,
                searchResults,
                setSearchResults,
                selectedIndex,
                setSelectedIndex,
                closeSearch: triggerClose
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/Search.tsx",
                lineNumber: 652,
                columnNumber: 11
              },
              this
            ),
            searchResults && /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
              SearchResults,
              {
                searchListID: "search-list",
                searchLabelID: "search-label",
                className: "mt-4",
                searchResults,
                selectedIndex,
                onHoverSelect: setSelectedIndex,
                closeSearch: triggerClose,
                charLimit
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/Search.tsx",
                lineNumber: 664,
                columnNumber: 13
              },
              this
            )
          ]
        },
        void 0,
        true,
        {
          fileName: "../../packages/site/src/components/Navigation/Search.tsx",
          lineNumber: 634,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/Search.tsx",
      lineNumber: 632,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/Search.tsx",
    lineNumber: 628,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/Loading.tsx
var import_react56 = __toESM(require_react(), 1);
var import_classnames34 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime(), 1);
function useLoading() {
  const transitionState = useNavigation().state;
  const ref = (0, import_react56.useMemo)(() => ({}), []);
  const [showLoading, setShowLoading] = (0, import_react56.useState)(false);
  (0, import_react56.useEffect)(() => {
    if (transitionState === "loading") {
      ref.start = setTimeout(() => {
        setShowLoading(true);
      }, 150);
    } else {
      if (ref.start) {
        clearTimeout(ref.start);
        delete ref.start;
        setShowLoading(false);
        return;
      }
      ref.finish = setTimeout(() => {
        setShowLoading(false);
      }, 150);
    }
    return () => {
      if (ref.start) {
        clearTimeout(ref.start);
        delete ref.start;
      }
      if (ref.finish) {
        clearTimeout(ref.finish);
        delete ref.finish;
      }
    };
  }, [transitionState]);
  return { showLoading, isLoading: transitionState === "loading" };
}
function LoadingBar() {
  const { isLoading, showLoading } = useLoading();
  if (!showLoading)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
    "div",
    {
      className: (0, import_classnames34.default)(
        "myst-loading-bar w-screen h-[2px] bg-blue-500 absolute left-0 bottom-0 transition-transform",
        {
          "myst-loading-bar-progress animate-load scale-x-40": isLoading,
          "scale-x-100": !isLoading
        }
      )
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Loading.tsx",
      lineNumber: 49,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/HomeLink.tsx
var import_classnames35 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime(), 1);
function HomeLink({
  logo,
  logoDark,
  logoText,
  name,
  url
}) {
  const Link2 = useLinkProvider();
  const baseurl = useBaseurl();
  const nothingSet = !logo && !logoText;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
    Link2,
    {
      className: "myst-home-link flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7",
      to: url ? url : withBaseurl("/", baseurl),
      prefetch: "intent",
      children: [
        logo && /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
          "div",
          {
            className: (0, import_classnames35.default)("myst-home-link-logo mr-3 flex items-center", {
              "dark:bg-white dark:rounded px-1": !logoDark
            }),
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
                "img",
                {
                  src: logo,
                  className: (0, import_classnames35.default)("h-9", { "dark:hidden": !!logoDark }),
                  alt: logoText || name,
                  height: "2.25rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
                  lineNumber: 32,
                  columnNumber: 11
                },
                this
              ),
              logoDark && /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
                "img",
                {
                  src: logoDark,
                  className: "hidden h-9 dark:block",
                  alt: logoText || name,
                  height: "2.25rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
                  lineNumber: 39,
                  columnNumber: 13
                },
                this
              )
            ]
          },
          void 0,
          true,
          {
            fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
            lineNumber: 27,
            columnNumber: 9
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
          "span",
          {
            className: (0, import_classnames35.default)("text-md sm:text-xl tracking-tight sm:mr-5", {
              "sr-only": !(logoText || nothingSet)
            }),
            children: logoText || "Made with MyST"
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
            lineNumber: 48,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Navigation/HomeLink.tsx",
      lineNumber: 21,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/site/src/components/Navigation/ActionMenu.tsx
var import_react57 = __toESM(require_react(), 1);
var import_classnames36 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime(), 1);
function ActionMenu({ actions }) {
  if (!actions || actions.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(qe, { as: "div", className: "myst-action-menu relative", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(qe.Button, { className: "myst-action-menu-button flex text-sm bg-transparent rounded-full focus:outline-none", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("span", { className: "sr-only", children: "Open Menu" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 13,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("div", { className: "flex items-center text-stone-200 hover:text-white", children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(EllipsisVerticalIcon_default, { width: "2rem", height: "2rem", className: "p-1" }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 15,
        columnNumber: 13
      }, this) }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 14,
        columnNumber: 11
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
      lineNumber: 12,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
      lineNumber: 11,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
      qe2,
      {
        as: import_react57.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(qe.Items, { className: "myst-action-menu-dropdown absolute right-0 w-48 py-1 mt-2 origin-top-right bg-white rounded-sm shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none", children: actions == null ? void 0 : actions.map((action) => /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(qe.Item, { children: ({ active }) => /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(
          "a",
          {
            href: action.url,
            className: (0, import_classnames36.default)(
              "myst-action-menu-item",
              active ? "bg-gray-100" : "",
              "block px-4 py-2 text-sm text-gray-700"
            ),
            children: action.title
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
            lineNumber: 32,
            columnNumber: 17
          },
          this
        ) }, action.url, false, {
          fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
          lineNumber: 30,
          columnNumber: 13
        }, this)) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
          lineNumber: 28,
          columnNumber: 9
        }, this)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
        lineNumber: 19,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/ActionMenu.tsx",
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/Link.tsx
var import_jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime(), 1);
function ExternalOrInternalLink2({
  to,
  className,
  children,
  nav,
  onClick,
  prefetch = "intent"
}) {
  const Link2 = useLinkProvider();
  const NavLink2 = useNavLinkProvider();
  const staticClass = typeof className === "function" ? className({ isActive: false }) : className;
  if (to.startsWith("http") || to.startsWith("mailto:")) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
      "a",
      {
        href: to,
        target: "_blank",
        rel: "noopener noreferrer",
        className: staticClass,
        onClick,
        children
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/Link.tsx",
        lineNumber: 24,
        columnNumber: 7
      },
      this
    );
  }
  if (nav) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(NavLink2, { prefetch, to, className, onClick, children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Link.tsx",
      lineNumber: 37,
      columnNumber: 7
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(Link2, { prefetch, to, className: staticClass, onClick, children }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/Link.tsx",
    lineNumber: 43,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/TopNav.tsx
var import_jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime(), 1);
var DEFAULT_NAV_HEIGHT = 60;
function NavItem({ item }) {
  var _a, _b;
  const NavLink2 = useNavLinkProvider();
  const baseurl = useBaseurl();
  if (!("children" in item)) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "myst-top-nav-item relative inline-block mx-2 grow-0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
      ExternalOrInternalLink2,
      {
        nav: true,
        to: (_a = withBaseurl(item.url, baseurl)) != null ? _a : "",
        className: ({ isActive }) => (0, import_classnames37.default)(
          "inline-flex items-center justify-center w-full mx-2 py-1 text-md font-medium dark:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75",
          {
            "border-b border-stone-200": isActive
          }
        ),
        children: item.title
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 28,
        columnNumber: 9
      },
      this
    ) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 27,
      columnNumber: 7
    }, this);
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(qe, { as: "div", className: "myst-top-nav-dropdown relative inline-block mx-2 grow-0", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "inline-block", children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(qe.Button, { className: "inline-flex items-center justify-center w-full py-1 mx-2 font-medium rounded-md text-md text-stone-900 dark:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("span", { children: item.title }, void 0, false, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 49,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
        ChevronDownIcon_default,
        {
          width: "1.25rem",
          height: "1.25rem",
          className: "ml-2 -mr-1 text-violet-200 hover:text-violet-100"
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 50,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 48,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 47,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
      qe2,
      {
        as: import_react59.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "transform opacity-0 scale-95",
        enterTo: "transform opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "transform opacity-100 scale-100",
        leaveTo: "transform opacity-0 scale-95",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(qe.Items, { className: "myst-top-nav-dropdown-items absolute w-48 py-1 mt-2 origin-top-left bg-white rounded-sm shadow-lg left-4 ring-1 ring-black ring-opacity-5 focus:outline-none", children: (_b = item.children) == null ? void 0 : _b.map((action) => {
          var _a2;
          const url = withBaseurl(action.url, baseurl) || "";
          return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(qe.Item, { children: ((_a2 = action.url) == null ? void 0 : _a2.startsWith("http")) ? /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
            "a",
            {
              href: url,
              className: "myst-top-nav-dropdown-item block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-black",
              target: "_blank",
              rel: "noopener noreferrer",
              children: action.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
              lineNumber: 73,
              columnNumber: 19
            },
            this
          ) : /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
            NavLink2,
            {
              to: url,
              className: ({ isActive }) => (0, import_classnames37.default)(
                "myst-top-nav-dropdown-item block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-black",
                {
                  "text-black font-bold": isActive
                }
              ),
              children: action.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
              lineNumber: 82,
              columnNumber: 19
            },
            this
          ) }, action.url, false, {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 70,
            columnNumber: 15
          }, this);
        }) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 66,
          columnNumber: 9
        }, this)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 57,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 46,
    columnNumber: 5
  }, this);
}
function NavItems({ nav }) {
  if (!nav)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "flex-grow hidden text-md lg:block", children: nav.map((item) => {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(NavItem, { item }, "url" in item ? item.url : item.title, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 110,
      columnNumber: 16
    }, this);
  }) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 108,
    columnNumber: 5
  }, this);
}
function TopNav({ hideToc, hideSearch }) {
  var _a;
  const [open, setOpen] = useNavOpen();
  const config = useSiteManifest();
  const { title, nav, actions } = config != null ? config : {};
  const { logo, logo_dark, logo_text, logo_url } = (_a = config == null ? void 0 : config.options) != null ? _a : {};
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "myst-top-nav bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 sticky w-screen top-0 z-30 h-[60px]", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("nav", { className: "myst-top-nav-bar flex items-center justify-between flex-nowrap max-w-[1440px] mx-auto", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center shrink-0", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
          "div",
          {
            className: (0, import_classnames37.default)("block", {
              "lg:hidden": nav && hideToc,
              "xl:hidden": !(nav && hideToc)
            }),
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
              "button",
              {
                className: "myst-top-nav-menu-button flex items-center justify-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100 w-10 h-10",
                onClick: () => {
                  setOpen(!open);
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Bars3Icon_default, { width: "1.5rem", height: "1.5rem" }, void 0, false, {
                    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                    lineNumber: 138,
                    columnNumber: 17
                  }, this),
                  /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("span", { className: "sr-only", children: "Open Menu" }, void 0, false, {
                    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                    lineNumber: 139,
                    columnNumber: 17
                  }, this)
                ]
              },
              void 0,
              true,
              {
                fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
                lineNumber: 132,
                columnNumber: 15
              },
              this
            )
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 126,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
          HomeLink,
          {
            name: title,
            logo,
            logoDark: logo_dark,
            logoText: logo_text,
            url: logo_url
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 143,
            columnNumber: 11
          },
          this
        )
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 124,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "flex items-center flex-grow w-auto", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(NavItems, { nav }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 152,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "flex-grow block" }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 153,
          columnNumber: 11
        }, this),
        !hideSearch && /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Search, {}, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 154,
          columnNumber: 27
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(ThemeButton, {}, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 155,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "block sm:hidden", children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(ActionMenu, { actions }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 157,
          columnNumber: 13
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 156,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "hidden sm:block", children: actions == null ? void 0 : actions.map((action, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(
          ExternalOrInternalLink2,
          {
            className: "inline-block px-4 py-2 mx-1 mt-0 leading-none border rounded text-md border-stone-700 dark:border-white text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 hover:bg-neutral-100",
            to: action.url,
            children: action.title
          },
          action.url || index2,
          false,
          {
            fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
            lineNumber: 161,
            columnNumber: 15
          },
          this
        )) }, void 0, false, {
          fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
          lineNumber: 159,
          columnNumber: 11
        }, this)
      ] }, void 0, true, {
        fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
        lineNumber: 151,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 123,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(LoadingBar, {}, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
      lineNumber: 172,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TopNav.tsx",
    lineNumber: 122,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Navigation/PrimarySidebar.tsx
var import_react63 = __toESM(require_react(), 1);
var import_classnames39 = __toESM(require_classnames(), 1);

// ../../packages/site/src/components/Navigation/TableOfContentsItems.tsx
var import_react61 = __toESM(require_react(), 1);
var import_classnames38 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime12 = __toESM(require_jsx_dev_runtime(), 1);
function nestToc(toc) {
  const items = [];
  const stack = [];
  toc.forEach((tocItem, id) => {
    const item = tocItem;
    item.children = [];
    item.id = String(id);
    if (item.level === "index") {
      while (stack.length)
        stack.pop();
      items.push(item);
      return;
    }
    while (stack.length && stack[stack.length - 1].level >= item.level) {
      stack.pop();
    }
    const top = stack[stack.length - 1];
    if (top) {
      top.children.push(item);
    } else {
      items.push(item);
    }
    stack.push(item);
  });
  return items;
}
function pathnameMatchesHeading(pathname, heading, baseurl) {
  const headingPath = withBaseurl(heading.path, baseurl);
  const normedPath = pathname.endsWith("/") ? pathname.slice(0, -1) : pathname;
  if (normedPath && headingPath === `${normedPath}/index`)
    return true;
  return headingPath === normedPath;
}
function childrenOpen(headings, pathname, baseurl) {
  return headings.map((heading) => {
    if (pathnameMatchesHeading(pathname, heading, baseurl))
      return [heading.id];
    const open = childrenOpen(heading.children, pathname, baseurl);
    if (open.length === 0)
      return [];
    return [heading.id, ...open];
  }).flat();
}
var Toc = ({ headings }) => {
  const nested = nestToc(headings);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("div", { className: "myst-toc w-full px-1 dark:text-white", children: nested.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(NestedToc, { heading: item }, item.id, false, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 70,
    columnNumber: 9
  }, this)) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 68,
    columnNumber: 5
  }, this);
};
function LinkItem({
  className,
  heading,
  onClick
}) {
  const Link2 = useLinkProvider();
  const NavLink2 = useNavLinkProvider();
  const baseurl = useBaseurl();
  const [, setOpen] = useNavOpen();
  if (heading.url) {
    const target = heading.open_in_same_tab ? "_self" : "_blank";
    return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      Link2,
      {
        title: `${heading.enumerator ? `${heading.enumerator} ` : ""}${heading.title}`,
        className: (0, import_classnames38.default)(
          "myst-toc-heading block break-words focus:outline outline-blue-200 outline-2 rounded",
          className
        ),
        to: heading.url,
        onClick: () => {
          onClick == null ? void 0 : onClick();
          setOpen(false);
        },
        target,
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("span", { className: "inline align-middle", children: `${heading.enumerator ? `${heading.enumerator} ` : ""}${heading.title}` }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
            lineNumber: 106,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(ArrowTopRightOnSquareIcon_default2, { className: "inline h-4 w-4 align-middle ml-[0.2rem]" }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
            lineNumber: 109,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 93,
        columnNumber: 7
      },
      this
    );
  }
  if (!heading.path) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "div",
      {
        title: `${heading.enumerator ? `${heading.enumerator} ` : ""}${heading.title}`,
        className: (0, import_classnames38.default)("block break-words rounded", className),
        onClick: () => {
          onClick == null ? void 0 : onClick();
        },
        children: `${heading.enumerator ? `${heading.enumerator} ` : ""}${heading.short_title || heading.title}`
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 115,
        columnNumber: 7
      },
      this
    );
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
    NavLink2,
    {
      prefetch: "intent",
      title: `${heading.enumerator ? `${heading.enumerator} ` : ""}${heading.title}`,
      className: (0, import_classnames38.default)(
        "block break-words focus:outline outline-blue-200 outline-2 rounded",
        className
      ),
      to: withBaseurl(heading.path, baseurl),
      onClick: () => {
        onClick == null ? void 0 : onClick();
        setOpen(false);
      },
      children: `${heading.enumerator ? `${heading.enumerator} ` : ""}${heading.short_title || heading.title}`
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 129,
      columnNumber: 5
    },
    this
  );
}
var NestedToc = ({ heading }) => {
  const { pathname } = useLocation();
  const baseurl = useBaseurl();
  const startOpen = childrenOpen([heading], pathname, baseurl).includes(heading.id);
  const nav = useNavigation();
  const [open, setOpen] = import_react61.default.useState(startOpen);
  (0, import_react61.useEffect)(() => {
    if (nav.state === "idle")
      setOpen(startOpen);
  }, [nav.state]);
  const exact = pathnameMatchesHeading(pathname, heading, baseurl);
  if (!heading.children || heading.children.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      LinkItem,
      {
        className: (0, import_classnames38.default)("myst-toc-item p-2 my-1 rounded-lg", {
          "myst-toc-item-exact bg-blue-300/30": exact,
          "hover:bg-slate-300/30": !exact,
          "font-bold": heading.level === "index"
        }),
        heading
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 161,
        columnNumber: 7
      },
      this
    );
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(Root3, { className: "w-full", open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "div",
      {
        className: (0, import_classnames38.default)(
          "myst-toc-item flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none",
          {
            "myst-toc-item-exact bg-blue-300/30": exact,
            "hover:bg-slate-300/30": !exact
          }
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
            LinkItem,
            {
              className: (0, import_classnames38.default)("py-2 grow", {
                "font-semibold text-blue-800 dark:text-blue-200": startOpen,
                "cursor-pointer": !heading.path
              }),
              heading,
              onClick: () => setOpen(heading.path ? true : !open)
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
              lineNumber: 182,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(Trigger2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
            "button",
            {
              className: "self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2",
              "aria-label": "Open Folder",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
                ChevronRightIcon_default,
                {
                  className: "transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100",
                  height: "1.5rem",
                  width: "1.5rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
                  lineNumber: 195,
                  columnNumber: 13
                },
                this
              )
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
              lineNumber: 191,
              columnNumber: 11
            },
            this
          ) }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
            lineNumber: 190,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
        lineNumber: 173,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(Content3, { className: "pl-3 pr-[2px] collapsible-content", children: heading.children.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(NestedToc, { heading: item }, item.id, false, {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 205,
      columnNumber: 11
    }, this)) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
      lineNumber: 203,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/TableOfContentsItems.tsx",
    lineNumber: 172,
    columnNumber: 5
  }, this);
};

// ../../packages/site/src/components/Navigation/PrimarySidebar.tsx
var import_jsx_dev_runtime13 = __toESM(require_jsx_dev_runtime(), 1);
function SidebarNavItem({ item }) {
  var _a, _b, _c;
  const baseurl = useBaseurl();
  if (!((_a = item.children) == null ? void 0 : _a.length)) {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
      ExternalOrInternalLink2,
      {
        nav: true,
        to: (_b = withBaseurl(item.url, baseurl)) != null ? _b : "",
        className: (0, import_classnames39.default)(
          "myst-primary-sidebar-item-short",
          "p-2 my-1 rounded-lg",
          "hover:bg-slate-300/30",
          "block break-words focus:outline outline-blue-200 outline-2 rounded"
        ),
        children: item.title
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
        lineNumber: 25,
        columnNumber: 7
      },
      this
    );
  }
  const [open, setOpen] = import_react63.default.useState(false);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(Root3, { className: "w-full", open, onOpenChange: setOpen, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
      "div",
      {
        className: (0, import_classnames39.default)(
          "myst-primary-sidebar-item",
          "flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none",
          "hover:bg-slate-300/30"
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
            ExternalOrInternalLink2,
            {
              nav: true,
              to: (_c = withBaseurl(item.url, baseurl)) != null ? _c : "",
              className: (0, import_classnames39.default)("myst-primary-sidebar-item-title py-2 grow", {}),
              onClick: () => setOpen(!open),
              children: item.title
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
              lineNumber: 49,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(Trigger2, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
            "button",
            {
              className: "myst-primary-sidebar-item-child self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2",
              "aria-label": "Open Folder",
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
                ChevronRightIcon_default,
                {
                  className: "myst-primary-sidebar-item-icon transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100",
                  height: "1.5rem",
                  width: "1.5rem"
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                  lineNumber: 62,
                  columnNumber: 13
                },
                this
              )
            },
            void 0,
            false,
            {
              fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
              lineNumber: 58,
              columnNumber: 11
            },
            this
          ) }, void 0, false, {
            fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
            lineNumber: 57,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      true,
      {
        fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
        lineNumber: 42,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(Content3, { className: "myst-primary-sidebar-item-content pl-3 pr-[2px] collapsible-content", children: item.children.map((action) => /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
      ExternalOrInternalLink2,
      {
        nav: true,
        to: withBaseurl(action.url, baseurl) || "",
        className: (0, import_classnames39.default)(
          "myst-primary-sidebar-item-link",
          "p-2 my-1 rounded-lg",
          "hover:bg-slate-300/30",
          "block break-words focus:outline outline-blue-200 outline-2 rounded"
        ),
        children: action.title
      },
      action.url,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
        lineNumber: 72,
        columnNumber: 11
      },
      this
    )) }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
      lineNumber: 70,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
    lineNumber: 41,
    columnNumber: 5
  }, this);
}
function SidebarNav({ nav }) {
  if (!nav)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("div", { className: "w-full px-1 dark:text-white font-medium", children: nav.map((item) => {
    return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(SidebarNavItem, { item }, "url" in item ? item.url : item.title, false, {
      fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
      lineNumber: 96,
      columnNumber: 16
    }, this);
  }) }, void 0, false, {
    fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
    lineNumber: 94,
    columnNumber: 5
  }, this);
}
function useSidebarHeight(top = 0, inset = 0) {
  const container = (0, import_react63.useRef)(null);
  const toc = (0, import_react63.useRef)(null);
  const transitionState = useNavigation().state;
  const wide = useIsWide();
  const { bannerState } = useBannerState();
  const totalTop = top + bannerState.height;
  const setHeight = () => {
    if (!container.current || !toc.current)
      return;
    const height = container.current.offsetHeight - window.scrollY;
    const div = toc.current.firstChild;
    if (div)
      div.style.height = wide ? `min(calc(100vh - ${totalTop}px), ${height + inset}px)` : `calc(100vh - ${totalTop}px)`;
    if (div)
      div.style.height = `min(calc(100vh - ${totalTop}px), ${height + inset}px)`;
    const nav = toc.current.querySelector("nav");
    if (nav)
      nav.style.opacity = height > 150 ? "1" : "0";
  };
  (0, import_react63.useEffect)(() => {
    setHeight();
    setTimeout(setHeight, 100);
    const handleScroll2 = () => setHeight();
    window.addEventListener("scroll", handleScroll2);
    return () => {
      window.removeEventListener("scroll", handleScroll2);
    };
  }, [container, toc, transitionState, wide, totalTop]);
  return { container, toc };
}
var PrimarySidebar = ({
  sidebarRef,
  nav,
  footer,
  headings,
  hide_toc,
  mobileOnly
}) => {
  const top = useThemeTop();
  const { bannerState } = useBannerState();
  const grid = useGridSystemProvider();
  const footerRef = (0, import_react63.useRef)(null);
  const [open] = useNavOpen();
  const config = useSiteManifest();
  (0, import_react63.useEffect)(() => {
    setTimeout(() => {
      if (!footerRef.current)
        return;
      footerRef.current.style.opacity = "1";
      footerRef.current.style.transform = "none";
    }, 500);
  }, [footerRef]);
  if (!config)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
    "div",
    {
      ref: sidebarRef,
      className: (0, import_classnames39.default)(
        "myst-primary-sidebar",
        "fixed",
        `xl:${grid}`,
        // for example, xl:article-grid
        "grid-gap xl:w-screen xl:pointer-events-none overflow-auto max-xl:min-w-[300px]",
        { "lg:hidden": nav && hide_toc },
        { hidden: !open, "z-30": open, "z-10": !open }
      ),
      style: { top: top + bannerState.height },
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
        "div",
        {
          className: (0, import_classnames39.default)(
            "myst-primary-sidebar-pointer",
            "pointer-events-auto",
            "xl:col-margin-left flex-col",
            "overflow-hidden",
            {
              flex: open,
              "bg-white dark:bg-stone-900": open,
              // just apply when open, so that theme can transition
              "hidden xl:flex": !open && !mobileOnly,
              hidden: !open && mobileOnly,
              "lg:hidden": mobileOnly && !headings
            }
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("div", { className: "myst-primary-sidebar-nav flex-grow py-6 overflow-y-auto primary-scrollbar", children: [
              nav && /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
                "nav",
                {
                  "aria-label": "Navigation",
                  className: "myst-primary-sidebar-topnav overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px] lg:hidden",
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(SidebarNav, { nav }, void 0, false, {
                    fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                    lineNumber: 199,
                    columnNumber: 15
                  }, this)
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                  lineNumber: 195,
                  columnNumber: 13
                },
                this
              ),
              nav && headings && /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("div", { className: "my-3 border-b-2 lg:hidden" }, void 0, false, {
                fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                lineNumber: 202,
                columnNumber: 31
              }, this),
              headings && /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
                "nav",
                {
                  "aria-label": "Table of Contents",
                  className: "myst-primary-sidebar-toc flex-grow overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px]",
                  children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(Toc, { headings }, void 0, false, {
                    fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                    lineNumber: 208,
                    columnNumber: 15
                  }, this)
                },
                void 0,
                false,
                {
                  fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                  lineNumber: 204,
                  columnNumber: 13
                },
                this
              )
            ] }, void 0, true, {
              fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
              lineNumber: 193,
              columnNumber: 9
            }, this),
            footer && /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
              "div",
              {
                className: "myst-primary-sidebar-footer flex-none py-6 transition-all duration-700 translate-y-6 opacity-0",
                ref: footerRef,
                children: footer
              },
              void 0,
              false,
              {
                fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
                lineNumber: 213,
                columnNumber: 11
              },
              this
            )
          ]
        },
        void 0,
        true,
        {
          fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
          lineNumber: 178,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/PrimarySidebar.tsx",
      lineNumber: 166,
      columnNumber: 5
    },
    this
  );
};

// ../../packages/site/src/components/Navigation/Navigation.tsx
var import_jsx_dev_runtime14 = __toESM(require_jsx_dev_runtime(), 1);
var PrimaryNavigation = ({
  children,
  projectSlug,
  sidebarRef,
  hide_toc,
  mobileOnly,
  footer
}) => {
  const config = useSiteManifest();
  if (!config)
    return null;
  const headings = getProjectHeadings(config, projectSlug, {
    addGroups: false
  });
  const { nav } = config;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
    ConfigurablePrimaryNavigation,
    {
      children,
      sidebarRef,
      hide_toc,
      mobileOnly,
      nav,
      headings,
      footer
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
      lineNumber: 36,
      columnNumber: 5
    },
    this
  );
};
var ConfigurablePrimaryNavigation = ({
  children,
  sidebarRef,
  hide_toc,
  mobileOnly,
  nav,
  headings,
  footer
}) => {
  const [open, setOpen] = useNavOpen();
  const top = useThemeTop();
  if (children)
    console.warn(
      `Including children in Navigation can break keyboard accessibility and is deprecated. Please move children to the page component.`
    );
  if (!nav && hide_toc)
    return children ? null : /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(import_jsx_dev_runtime14.Fragment, { children }, void 0, false, {
      fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
      lineNumber: 85,
      columnNumber: 50
    }, this);
  if (nav && hide_toc) {
    headings = void 0;
    footer = null;
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(import_jsx_dev_runtime14.Fragment, { children: [
    open && !mobileOnly && headings && /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
      "div",
      {
        className: "myst-navigation-overlay fixed inset-0 z-30 bg-black opacity-50",
        style: { marginTop: top },
        onClick: () => setOpen(false)
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
        lineNumber: 94,
        columnNumber: 9
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
      PrimarySidebar,
      {
        sidebarRef,
        nav,
        headings,
        footer,
        hide_toc,
        mobileOnly
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
        lineNumber: 100,
        columnNumber: 7
      },
      this
    ),
    children
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Navigation/Navigation.tsx",
    lineNumber: 92,
    columnNumber: 5
  }, this);
};

// ../../packages/site/src/components/Abstract.tsx
var import_classnames40 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime15 = __toESM(require_jsx_dev_runtime(), 1);
function Abstract({
  content,
  title = "Abstract",
  id = "abstract",
  className
}) {
  if (!content)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("div", { className: (0, import_classnames40.default)("myst-abstract", className), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("h2", { id, className: "myst-abstract-title mb-3 text-base font-semibold group", children: [
      title,
      /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(HashLink, { id, title: `Link to ${title}`, hover: true, className: "ml-2" }, void 0, false, {
        fileName: "../../packages/site/src/components/Abstract.tsx",
        lineNumber: 21,
        columnNumber: 9
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 19,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("div", { className: "myst-abstract-box px-6 py-1 mb-3 rounded-sm bg-slate-50 dark:bg-slate-800", children: /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(MyST, { ast: content, className: "myst-abstract-content col-body" }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 24,
      columnNumber: 9
    }, this) }, void 0, false, {
      fileName: "../../packages/site/src/components/Abstract.tsx",
      lineNumber: 23,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Abstract.tsx",
    lineNumber: 18,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/Keywords.tsx
var import_classnames41 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime16 = __toESM(require_jsx_dev_runtime(), 1);
function Keywords({
  keywords,
  hideKeywords,
  className
}) {
  if (hideKeywords || !keywords || keywords.length === 0)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("div", { className: (0, import_classnames41.default)("myst-keywords mb-10 group", className), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("span", { className: "myst-keywords-label mr-2 font-semibold", children: "Keywords:" }, void 0, false, {
      fileName: "../../packages/site/src/components/Keywords.tsx",
      lineNumber: 16,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("span", { className: "myst-keywords-list", children: keywords.map((k2, i6) => /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
      "span",
      {
        className: (0, import_classnames41.default)("myst-keywords-item", {
          "after:content-[','] after:mr-1": i6 < keywords.length - 1
        }),
        children: k2
      },
      k2,
      false,
      {
        fileName: "../../packages/site/src/components/Keywords.tsx",
        lineNumber: 19,
        columnNumber: 11
      },
      this
    )) }, void 0, false, {
      fileName: "../../packages/site/src/components/Keywords.tsx",
      lineNumber: 17,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(HashLink, { id: "keywords", title: "Link to Keywords", hover: true, className: "ml-2" }, void 0, false, {
      fileName: "../../packages/site/src/components/Keywords.tsx",
      lineNumber: 29,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Keywords.tsx",
    lineNumber: 15,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/components/FrontmatterParts.tsx
var import_classnames42 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime17 = __toESM(require_jsx_dev_runtime(), 1);
function FrontmatterParts({
  parts,
  keywords,
  hideKeywords,
  containerClassName,
  innerClassName
}) {
  if (!parts.abstract && !parts.keypoints && !parts.summary)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("div", { className: (0, import_classnames42.default)("myst-fm-parts", containerClassName), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
      Abstract,
      {
        className: (0, import_classnames42.default)("myst-fm-section", innerClassName),
        content: parts.abstract
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
        lineNumber: 22,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
      Abstract,
      {
        className: (0, import_classnames42.default)("myst-fm-section", innerClassName),
        content: parts.keypoints,
        title: "Key Points",
        id: "keypoints"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
        lineNumber: 26,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
      Abstract,
      {
        className: (0, import_classnames42.default)("myst-fm-section", innerClassName),
        content: parts.summary,
        title: "Plain Language Summary",
        id: "summary"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
        lineNumber: 32,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
      Keywords,
      {
        className: (0, import_classnames42.default)("myst-fm-section", innerClassName),
        keywords,
        hideKeywords
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
        lineNumber: 38,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/FrontmatterParts.tsx",
    lineNumber: 21,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/utils.ts
function extractKnownParts(tree, parts) {
  const abstract = extractPart(tree, "abstract");
  const summary = extractPart(tree, "summary", { requireExplicitPart: true });
  const keypoints = extractPart(tree, ["keypoints"], { requireExplicitPart: true });
  const data_availability = extractPart(tree, ["data_availability", "data availability"]);
  const acknowledgments = extractPart(tree, ["acknowledgments", "acknowledgements"]);
  const otherParts = Object.fromEntries(
    Object.entries(parts != null ? parts : {}).map(([k2, v4]) => {
      return [k2, v4.mdast];
    })
  );
  return { abstract, summary, keypoints, data_availability, acknowledgments, ...otherParts };
}
function getChildren(content) {
  var _a;
  if ((content == null ? void 0 : content.type) === "root" && ((_a = content.children) == null ? void 0 : _a.length) === 1 && content.children[0].type === "block") {
    return content.children[0].children;
  }
  return content;
}

// ../../packages/site/src/components/Backmatter.tsx
var import_classnames43 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime18 = __toESM(require_jsx_dev_runtime(), 1);
function BackmatterParts({
  parts,
  containerClassName,
  innerClassName
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)("div", { className: (0, import_classnames43.default)("myst-backmatter-parts", containerClassName), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
      Backmatter,
      {
        className: innerClassName,
        title: "Acknowledgments",
        id: "acknowledgments",
        content: parts.acknowledgments
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 17,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
      Backmatter,
      {
        className: innerClassName,
        title: "Data Availability",
        id: "data-availability",
        content: parts.data_availability
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/components/Backmatter.tsx",
        lineNumber: 23,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, true, {
    fileName: "../../packages/site/src/components/Backmatter.tsx",
    lineNumber: 16,
    columnNumber: 5
  }, this);
}
function Backmatter({
  title,
  id,
  content,
  className
}) {
  if (!content)
    return null;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
    "div",
    {
      className: (0, import_classnames43.default)(
        "myst-backmatter flex flex-col w-full md:flex-row group/backmatter",
        className
      ),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(
          "h2",
          {
            id,
            className: "myst-backmatter-title mt-5 text-base font-semibold group md:w-[200px] self-start md:flex-none opacity-90 group-hover/backmatter:opacity-100",
            children: [
              title,
              /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(HashLink, { id, title: `Link to ${title}`, hover: true, className: "ml-2" }, void 0, false, {
                fileName: "../../packages/site/src/components/Backmatter.tsx",
                lineNumber: 57,
                columnNumber: 9
              }, this)
            ]
          },
          void 0,
          true,
          {
            fileName: "../../packages/site/src/components/Backmatter.tsx",
            lineNumber: 52,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)("div", { className: "myst-backmatter-content grow opacity-90 group-hover/backmatter:opacity-100 col-screen", children: /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(MyST, { ast: getChildren(content) }, void 0, false, {
          fileName: "../../packages/site/src/components/Backmatter.tsx",
          lineNumber: 60,
          columnNumber: 9
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/components/Backmatter.tsx",
          lineNumber: 59,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    true,
    {
      fileName: "../../packages/site/src/components/Backmatter.tsx",
      lineNumber: 46,
      columnNumber: 5
    },
    this
  );
}

// ../../packages/myst-demo/dist/index.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);

// ../../packages/myst-demo/node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        propertiesFactory(
          /** @type {Props} */
          test
        )
      );
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propertiesFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all);
  function all(node) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// ../../packages/myst-demo/node_modules/unist-util-remove/lib/index.js
function remove(tree, options, test) {
  const is2 = convert(test || options);
  let cascade = true;
  if (options && typeof options === "object" && "cascade" in options && typeof options.cascade === "boolean") {
    cascade = options.cascade;
  }
  preorder(tree);
  function preorder(node, index2, parent) {
    if (node !== tree && is2(node, index2, parent)) {
      return false;
    }
    if ("children" in node && Array.isArray(node.children)) {
      const nodeAsParent = (
        /** @type {Parent} */
        node
      );
      const children = nodeAsParent.children;
      let oldChildIndex = -1;
      let newChildIndex = 0;
      if (children.length > 0) {
        while (++oldChildIndex < children.length) {
          if (preorder(children[oldChildIndex], oldChildIndex, nodeAsParent)) {
            children[newChildIndex++] = children[oldChildIndex];
          }
        }
        if (node !== tree && cascade && !newChildIndex) {
          return false;
        }
        children.length = newChildIndex;
      }
    }
    return true;
  }
}

// ../../packages/myst-demo/dist/index.js
var import_react65 = __toESM(require_react(), 1);
var import_classnames44 = __toESM(require_classnames(), 1);
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest4 = function(s8, e3) {
  var t11 = {};
  for (var p3 in s8)
    if (Object.prototype.hasOwnProperty.call(s8, p3) && e3.indexOf(p3) < 0)
      t11[p3] = s8[p3];
  if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p3 = Object.getOwnPropertySymbols(s8); i6 < p3.length; i6++) {
      if (e3.indexOf(p3[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p3[i6]))
        t11[p3[i6]] = s8[p3[i6]];
    }
  return t11;
};
function downloadBlob(filename, blob) {
  const a3 = document.createElement("a");
  const url = URL.createObjectURL(blob);
  a3.href = url;
  a3.download = filename;
  a3.click();
}
function saveDocxFile(filename, mdast) {
  return __awaiter3(this, void 0, void 0, function* () {
    const { unified } = yield import("/build/_shared/unified-WRWGV356.js");
    const { mystToDocx, fetchImagesAsBuffers } = yield import("/build/_shared/dist-5Q6NXYLZ.js");
    const tree = JSON.parse(JSON.stringify(mdast));
    const opts = yield fetchImagesAsBuffers(tree);
    const docxBlob = yield unified().use(mystToDocx, opts).stringify(tree).result;
    downloadBlob(filename, docxBlob);
  });
}
function getFrontmatter(vfile, tree) {
  var _a, _b;
  const firstParent = ((_a = tree.children[0]) === null || _a === void 0 ? void 0 : _a.type) === "block" ? tree.children[0] : tree;
  const firstNode = (_b = firstParent.children) === null || _b === void 0 ? void 0 : _b[0];
  let frontmatter = {};
  const firstIsYaml = (firstNode === null || firstNode === void 0 ? void 0 : firstNode.type) === "code" && (firstNode === null || firstNode === void 0 ? void 0 : firstNode.lang) === "yaml";
  if (firstIsYaml) {
    try {
      frontmatter = load(firstNode.value) || {};
      firstNode.type = "__delete__";
    } catch (err) {
      fileError(vfile, "Invalid YAML frontmatter", {
        note: err.message,
        ruleId: RuleId.frontmatterIsYaml
      });
    }
  }
  const possibleNull = remove(tree, "__delete__");
  if (possibleNull === null) {
    remove(tree, { cascade: false }, "__delete__");
  }
  return frontmatter;
}
function parse2(text, defaultFrontmatter, options) {
  return __awaiter3(this, void 0, void 0, function* () {
    var _a, _b, _c;
    const { visit } = yield import("/build/_shared/unist-util-visit-O7D3UJFN.js");
    const { unified } = yield import("/build/_shared/unified-WRWGV356.js");
    const { mystParse } = yield import("/build/_shared/dist-LXYLGOUT.js");
    const { mathPlugin, footnotesPlugin, keysPlugin, htmlPlugin, reconstructHtmlPlugin, basicTransformationsPlugin, enumerateTargetsPlugin, resolveReferencesPlugin, WikiTransformer, GithubTransformer, DOITransformer, RRIDTransformer, RORTransformer, linksPlugin, ReferenceState, abbreviationPlugin, glossaryPlugin, joinGatesPlugin } = yield import("/build/_shared/dist-FDKBWCQ6.js");
    const { default: mystToTex } = yield import("/build/_shared/dist-K6SQELBU.js");
    const { default: mystToTypst } = yield import("/build/_shared/dist-XPT4CEBR.js");
    const { default: mystToJats } = yield import("/build/_shared/dist-QKOOMYAF.js").catch(() => ({ default: null }));
    const { mystToHtml } = yield import("/build/_shared/dist-C3BJ2CXQ.js");
    const { buttonRole } = yield import("/build/_shared/dist-JBJC3W4I.js");
    const { cardDirective } = yield import("/build/_shared/dist-CG3I3ZBM.js");
    const { gridDirective } = yield import("/build/_shared/dist-GWMOJ7IX.js");
    const { tabDirectives } = yield import("/build/_shared/dist-4TCTIEL4.js");
    const { proofDirective } = yield import("/build/_shared/dist-CHBDMFYC.js");
    const { exerciseDirectives } = yield import("/build/_shared/dist-WH5IDONK.js");
    const vfile = new VFile();
    const parseMyst = (content) => mystParse(content, {
      markdownit: { linkify: true },
      directives: [
        cardDirective,
        gridDirective,
        ...tabDirectives,
        proofDirective,
        ...exerciseDirectives
      ],
      roles: [buttonRole],
      vfile
    });
    const mdast = parseMyst(text);
    const linkTransforms = [
      new WikiTransformer(),
      new GithubTransformer(),
      new DOITransformer(),
      new RRIDTransformer(),
      new RORTransformer()
    ];
    const mdastPre = JSON.parse(JSON.stringify(mdast));
    visit(mdastPre, (n5) => delete n5.position);
    const htmlString = mystToHtml(JSON.parse(JSON.stringify(mdast)));
    const references = {
      cite: { order: [], data: {} }
    };
    const frontmatterRaw = getFrontmatter(vfile, mdast);
    const frontmatter = validatePageFrontmatter(frontmatterRaw, {
      property: "frontmatter",
      messages: {}
    });
    const state = new ReferenceState("", {
      frontmatter: Object.assign(Object.assign({}, frontmatter), { numbering: (_a = frontmatter.numbering) !== null && _a !== void 0 ? _a : defaultFrontmatter === null || defaultFrontmatter === void 0 ? void 0 : defaultFrontmatter.numbering }),
      vfile
    });
    visit(mdast, (n5) => {
      if (n5.type === "cite") {
        n5.error = true;
      }
    });
    unified().use(reconstructHtmlPlugin).use(htmlPlugin).use(basicTransformationsPlugin, { parser: parseMyst }).use(mathPlugin, { macros: (_b = frontmatter === null || frontmatter === void 0 ? void 0 : frontmatter.math) !== null && _b !== void 0 ? _b : {} }).use(glossaryPlugin).use(abbreviationPlugin, { abbreviations: frontmatter.abbreviations }).use(enumerateTargetsPlugin, { state }).use(linksPlugin, { transformers: linkTransforms }).use(footnotesPlugin).use(joinGatesPlugin).use(resolveReferencesPlugin, { state }).use(keysPlugin).runSync(mdast, vfile);
    const mdastPost = JSON.parse(JSON.stringify(mdast));
    visit(mdastPost, (n5) => {
      delete n5.position;
      delete n5.key;
    });
    const texFile = new VFile();
    const tex = unified().use(mystToTex, { references }).stringify(mdast, texFile).result;
    const typstFile = new VFile();
    let typst;
    try {
      typst = unified().use(mystToTypst).stringify(mdast, typstFile).result;
    } catch (error) {
      console.error(error);
      typst = {
        value: `Problem with typst conversion: ${error.message || "Unknown Error"}`,
        macros: [],
        commands: {}
      };
    }
    const jatsFile = new VFile();
    const jats = mystToJats ? unified().use(mystToJats, SourceFileKind.Article, frontmatter, void 0, "", {
      format: 2,
      writeFullArticle: (_c = options === null || options === void 0 ? void 0 : options.jats) === null || _c === void 0 ? void 0 : _c.fullArticle
    }).stringify(mdast, jatsFile).result : "Problem loading myst-to-jats";
    return {
      frontmatter,
      mdastPre,
      mdastPost,
      references: Object.assign(Object.assign({}, references), { article: mdast }),
      html: htmlString,
      tex: tex.value,
      texWarnings: texFile.messages,
      typst: typst.value,
      typstWarnings: typstFile.messages,
      jats,
      jatsWarnings: jatsFile.messages,
      warnings: vfile.messages
    };
  });
}
function MySTRenderer({ id, value, column, fullscreen, numbering, TitleBlock, captureTab, className }) {
  const area = (0, import_react65.useRef)(null);
  const [text, setText] = (0, import_react65.useState)(value.trim());
  const [references, setReferences] = (0, import_react65.useState)({});
  const [frontmatter, setFrontmatter] = (0, import_react65.useState)({});
  const [mdastPre, setMdastPre] = (0, import_react65.useState)("Loading...");
  const [mdastPost, setMdastPost] = (0, import_react65.useState)("Loading...");
  const [html, setHtml] = (0, import_react65.useState)("Loading...");
  const [tex, setTex] = (0, import_react65.useState)("Loading...");
  const [texWarnings, setTexWarnings] = (0, import_react65.useState)([]);
  const [typst, setTypst] = (0, import_react65.useState)("Loading...");
  const [typstWarnings, setTypstWarnings] = (0, import_react65.useState)([]);
  const [jats, setJats] = (0, import_react65.useState)("Loading...");
  const [jatsWarnings, setJatsWarnings] = (0, import_react65.useState)([]);
  const [warnings, setWarnings] = (0, import_react65.useState)([]);
  const [previewType, setPreviewType] = (0, import_react65.useState)("DEMO");
  const [astLang, setAstLang] = (0, import_react65.useState)("yaml");
  const [astStage, setAstStage] = (0, import_react65.useState)("pre");
  (0, import_react65.useEffect)(() => {
    const ref = { current: true };
    parse2(text, { numbering }, { removeHeading: !!TitleBlock, jats: { fullArticle: !!TitleBlock } }).then((result2) => {
      if (!ref.current)
        return;
      setFrontmatter(result2.frontmatter);
      setMdastPre(result2.mdastPre);
      setMdastPost(result2.mdastPost);
      setReferences(result2.references);
      setHtml(result2.html);
      setTex(result2.tex);
      setTexWarnings(result2.texWarnings);
      setTypst(result2.typst);
      setTypstWarnings(result2.typstWarnings);
      setJats(result2.jats);
      setJatsWarnings(result2.jatsWarnings);
      setWarnings(result2.warnings);
    });
    return () => {
      ref.current = false;
    };
  }, [text]);
  (0, import_react65.useEffect)(() => {
    if (!area.current)
      return;
    if (column) {
      area.current.style.height = "";
      return;
    }
    area.current.style.height = "auto";
    area.current.style.height = `${area.current.scrollHeight}px`;
  }, [text, column]);
  (0, import_react65.useEffect)(() => {
    if (!area.current || !captureTab)
      return;
    area.current.addEventListener("keydown", (ev) => {
      if (ev.key !== "Tab")
        return;
      ev.preventDefault();
      ev.stopPropagation();
    });
  }, [area, captureTab]);
  let currentWarnings = [];
  switch (previewType) {
    case "DEMO":
      currentWarnings = warnings;
      break;
    case "LaTeX":
      currentWarnings = texWarnings;
      break;
    case "Typst":
      currentWarnings = typstWarnings;
      break;
    case "JATS":
      currentWarnings = jatsWarnings;
      break;
    default:
      break;
  }
  const demoMenu = (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [(0, import_jsx_runtime59.jsx)("div", { className: "self-center text-sm border cursor-pointer dark:border-slate-600", children: ["DEMO", "AST", "HTML", "LaTeX", "Typst", "JATS", "DOCX"].map((show) => (0, import_jsx_runtime59.jsx)("button", { className: (0, import_classnames44.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": previewType !== show,
    "bg-blue-800 text-white": previewType === show
  }), title: `Show the ${show}`, "aria-label": `Show the ${show}`, "aria-pressed": previewType === show ? "true" : "false", onClick: () => setPreviewType(show), children: show }, show)) }), previewType === "AST" && (0, import_jsx_runtime59.jsxs)("div", { className: "self-center text-sm border cursor-pointer w-fit dark:border-slate-600", children: [["yaml", "json"].map((show) => (0, import_jsx_runtime59.jsx)("button", { className: (0, import_classnames44.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": astLang !== show,
    "bg-blue-800 text-white": astLang === show
  }), title: `Show the AST as ${show.toUpperCase()}`, "aria-pressed": astLang === show ? "true" : "false", onClick: () => setAstLang(show), children: show.toUpperCase() }, show)), ["pre", "post"].map((show) => (0, import_jsx_runtime59.jsx)("button", { className: (0, import_classnames44.default)("px-2 py-1", {
    "bg-white hover:bg-slate-200 dark:bg-slate-500 dark:hover:bg-slate-700": astStage !== show,
    "bg-blue-800 text-white": astStage === show
  }), title: `Show the AST Stage ${show.toUpperCase()}`, "aria-pressed": astStage === show ? "true" : "false", onClick: () => setAstStage(show), children: show.toUpperCase() }, show))] })] });
  const mdastStage = astStage === "pre" ? mdastPre : mdastPost;
  const { downloads, exports, parts } = frontmatter, reducedFrontmatter = __rest4(frontmatter, ["downloads", "exports", "parts"]);
  return (0, import_jsx_runtime59.jsxs)("figure", { id, className: (0, import_classnames44.default)("relative", {
    "grid grid-cols-2 gap-0 grid-rows-[3rem_1fr]": column,
    "rounded shadow-lg": !fullscreen,
    "m-0": fullscreen
  }, className), children: [column && (0, import_jsx_runtime59.jsxs)("div", { className: "flex flex-row items-stretch h-full col-span-2 px-2 border dark:border-slate-600", children: [(0, import_jsx_runtime59.jsx)("div", { className: "flex-grow" }), demoMenu] }), (0, import_jsx_runtime59.jsxs)("div", { className: (0, import_classnames44.default)("relative myst", { "overflow-auto": column }), children: [(0, import_jsx_runtime59.jsx)(CopyIcon, { text, className: "absolute right-0 p-1" }), (0, import_jsx_runtime59.jsxs)("label", { children: [(0, import_jsx_runtime59.jsx)("span", { className: "sr-only", children: "Edit the MyST Markdown text" }), (0, import_jsx_runtime59.jsx)("textarea", { ref: area, value: text, className: (0, import_classnames44.default)("block p-6 w-full font-mono shadow-inner outline-none resize-none bg-slate-50/50 dark:bg-slate-800/50", { "text-sm": !column }, { "h-full": column }), onChange: (e3) => setText(e3.target.value) })] })] }), (0, import_jsx_runtime59.jsxs)("div", { className: (0, import_classnames44.default)("relative exclude-from-outline min-h-1 dark:bg-slate-900", {
    "overflow-auto": column
  }), children: [!column && (0, import_jsx_runtime59.jsx)("div", { className: "absolute top-0 left-0", children: demoMenu }), (0, import_jsx_runtime59.jsxs)("div", { className: (0, import_classnames44.default)("px-6 pb-6", {
    "pt-[40px]": !column && previewType !== "AST",
    "pt-[80px]": !column && previewType === "AST",
    "pt-4": column
  }), children: [previewType === "DEMO" && (0, import_jsx_runtime59.jsx)(import_jsx_runtime59.Fragment, { children: (0, import_jsx_runtime59.jsx)(ArticleProvider, { kind: SourceFileKind.Article, references, frontmatter: reducedFrontmatter, children: (0, import_jsx_runtime59.jsxs)(GridSystemProvider, { gridSystem: "demo-grid", children: [TitleBlock && (0, import_jsx_runtime59.jsx)(TitleBlock, { frontmatter }), (0, import_jsx_runtime59.jsx)(MyST, { ast: references.article })] }) }) }), previewType === "AST" && (0, import_jsx_runtime59.jsx)(import_jsx_runtime59.Fragment, { children: (0, import_jsx_runtime59.jsx)(CodeBlock, { lang: astLang, value: astLang === "yaml" ? dump(mdastStage) : JSON.stringify(mdastStage, null, 2) }) }), previewType === "HTML" && (0, import_jsx_runtime59.jsx)(CodeBlock, { lang: "xml", value: html, showCopy: false }), previewType === "LaTeX" && (0, import_jsx_runtime59.jsx)(CodeBlock, { lang: "latex", value: tex, showCopy: false }), previewType === "Typst" && (0, import_jsx_runtime59.jsx)(CodeBlock, { lang: "typst", value: typst, showCopy: false }), previewType === "JATS" && (0, import_jsx_runtime59.jsx)(CodeBlock, { lang: "xml", value: jats, showCopy: false }), previewType === "DOCX" && (0, import_jsx_runtime59.jsx)("div", { children: (0, import_jsx_runtime59.jsxs)("button", { className: "p-3 border rounded", onClick: () => saveDocxFile("demo.docx", references.article), title: `Download Micorsoft Word`, "aria-label": `Download Micorsoft Word`, children: [(0, import_jsx_runtime59.jsx)(ArrowDownTrayIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), " ", "Download as Microsoft Word"] }) })] }), currentWarnings.length > 0 && (0, import_jsx_runtime59.jsx)("div", { className: (0, import_classnames44.default)("w-full", { "absolute bottom-0": column }), children: currentWarnings.map((m5, i6) => (0, import_jsx_runtime59.jsxs)("div", { className: (0, import_classnames44.default)("p-1 shadow-inner text-white not-prose", {
    "bg-red-500 dark:bg-red-800": m5.fatal === true,
    "bg-orange-500 dark:bg-orange-700": m5.fatal === false,
    "bg-slate-500 dark:bg-slate-800": m5.fatal === null
  }), children: [m5.fatal === true && (0, import_jsx_runtime59.jsx)(ExclamationCircleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), m5.fatal === false && (0, import_jsx_runtime59.jsx)(ExclamationTriangleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), m5.fatal === null && (0, import_jsx_runtime59.jsx)(InformationCircleIcon_default, { width: "1.3rem", height: "1.3rem", className: "inline mr-1" }), (0, import_jsx_runtime59.jsx)("code", { children: m5.ruleId || m5.source }), ": ", m5.message] }, i6)) })] })] });
}
var MystDemoRenderer = ({ node, className }) => {
  return (0, import_jsx_runtime59.jsx)(MySTRenderer, { id: node.html_id || node.identifier, value: node.value, numbering: node.numbering, className: (0, import_classnames44.default)(node.class, className) });
};

// ../../packages/diagrams/dist/index.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var import_classnames45 = __toESM(require_classnames(), 1);
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _mermaid = void 0;
function loadMermaid() {
  return __awaiter4(this, void 0, void 0, function* () {
    if (_mermaid === void 0) {
      const module = yield import("/build/_shared/mermaid.core-BRCSVNUK.js");
      _mermaid = module.default;
      _mermaid.initialize({ startOnLoad: false });
    }
    return _mermaid;
  });
}
function MermaidRenderer({ id, value, className }) {
  const key = (0, import_react66.useId)();
  const [graph, setGraph] = (0, import_react66.useState)();
  const [error, setError] = (0, import_react66.useState)();
  (0, import_react66.useEffect)(() => {
    const render = () => __awaiter4(this, void 0, void 0, function* () {
      try {
        const mermaidID = `mermaid-${key.replace(/:/g, "")}`;
        const mermaid = yield loadMermaid();
        const { svg } = yield mermaid.render(mermaidID, value);
        setGraph(svg);
        setError(void 0);
      } catch (err) {
        setGraph(void 0);
        setError(err);
      }
    });
    render();
  }, []);
  return (0, import_jsx_runtime60.jsxs)("figure", { id, className, children: [graph && (0, import_jsx_runtime60.jsx)("div", { dangerouslySetInnerHTML: { __html: graph } }), error && (0, import_jsx_runtime60.jsxs)("pre", { children: ["Error parsing mermaid graph.", "\n\n", error.message, "\n\n", value] })] });
}
var MermaidNodeRenderer = ({ node, className }) => {
  return (0, import_jsx_runtime60.jsx)(MermaidRenderer, { id: node.html_id || node.identifier, value: node.value, className: (0, import_classnames45.default)(node.class, className) });
};

// ../../packages/site/src/components/renderers.ts
var renderers = {
  ...DEFAULT_RENDERERS,
  myst: MystDemoRenderer,
  mermaid: MermaidNodeRenderer
};

// ../../packages/site/src/components/SkipToArticle.tsx
var import_react67 = __toESM(require_react(), 1);
var import_jsx_dev_runtime19 = __toESM(require_jsx_dev_runtime(), 1);
function makeSkipClickHandler(hash) {
  return (e3) => {
    e3.preventDefault();
    const el = document.querySelector(`#${hash}`);
    if (!el)
      return;
    el.nextSibling.focus();
    history.replaceState(void 0, "", `#${hash}`);
    if (el.tabIndex === -1)
      el.tabIndex = -1;
    el.focus({ preventScroll: true });
  };
}
var SkipTo = import_react67.default.memo(({ targets }) => {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(
    "div",
    {
      className: "myst-skip-to-article fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1",
      "aria-label": "skip to content options",
      children: targets.map(({ id, title }) => /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(
        "a",
        {
          href: `#${id}`,
          className: "myst-skip-to-link block px-2 py-1 text-black underline",
          onClick: makeSkipClickHandler(id),
          children: title
        },
        id,
        false,
        {
          fileName: "../../packages/site/src/components/SkipToArticle.tsx",
          lineNumber: 69,
          columnNumber: 9
        },
        this
      ))
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/components/SkipToArticle.tsx",
      lineNumber: 64,
      columnNumber: 5
    },
    this
  );
});

// ../../packages/site/src/hooks/theme.tsx
var import_react68 = __toESM(require_react(), 1);

// ../../packages/site/src/actions/theme.ts
function postThemeToAPI(theme) {
  const xmlhttp = new XMLHttpRequest();
  xmlhttp.open("POST", "/api/theme");
  xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
  xmlhttp.send(JSON.stringify({ theme }));
}

// ../../packages/site/src/hooks/theme.tsx
var PREFERS_LIGHT_MQ = "(prefers-color-scheme: light)";
var THEME_LOCALSTORAGE_KEY = "myst:theme";
function getPreferredTheme() {
  if (typeof window !== "object") {
    return null;
  }
  const mediaQuery = window.matchMedia(PREFERS_LIGHT_MQ);
  return mediaQuery.matches ? Theme.light : Theme.dark;
}
function usePreferredTheme({ setTheme }) {
  (0, import_react68.useEffect)(() => {
    const mediaQuery = window.matchMedia(PREFERS_LIGHT_MQ);
    const handleChange = () => {
      setTheme(mediaQuery.matches ? Theme.light : Theme.dark);
    };
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);
}
function useTheme({
  ssrTheme,
  useLocalStorage
}) {
  const [theme, setTheme] = import_react68.default.useState(() => {
    if (isTheme(ssrTheme)) {
      return ssrTheme;
    }
    if (typeof window !== "object") {
      return null;
    }
    const preferredTheme = getPreferredTheme();
    const savedTheme = localStorage.getItem(THEME_LOCALSTORAGE_KEY);
    return useLocalStorage && isTheme(savedTheme) ? savedTheme : preferredTheme;
  });
  usePreferredTheme({ setTheme });
  const mountRun = (0, import_react68.useRef)(false);
  (0, import_react68.useEffect)(() => {
    if (!mountRun.current) {
      mountRun.current = true;
      return;
    }
    if (!isTheme(theme)) {
      return;
    }
    if (useLocalStorage) {
      localStorage.setItem(THEME_LOCALSTORAGE_KEY, theme);
    } else {
      postThemeToAPI(theme);
    }
  }, [theme]);
  return [theme, setTheme];
}

// ../../packages/site/src/components/theme.tsx
var import_jsx_dev_runtime20 = __toESM(require_jsx_dev_runtime(), 1);
function BlockingThemeLoader({ useLocalStorage }) {
  const LOCAL_STORAGE_SOURCE = `localStorage.getItem(${JSON.stringify(THEME_LOCALSTORAGE_KEY)})`;
  const CLIENT_THEME_SOURCE = `
  const savedTheme = ${useLocalStorage ? LOCAL_STORAGE_SOURCE : "null"};
  const theme = window.matchMedia(${JSON.stringify(PREFERS_LIGHT_MQ)}).matches ? 'light' : 'dark';
  const classes = document.documentElement.classList;
  const hasAnyTheme = classes.contains('light') || classes.contains('dark');
  if (!hasAnyTheme) classes.add(savedTheme ?? theme);
`;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("script", { dangerouslySetInnerHTML: { __html: CLIENT_THEME_SOURCE } }, void 0, false, {
    fileName: "../../packages/site/src/components/theme.tsx",
    lineNumber: 18,
    columnNumber: 10
  }, this);
}

// ../../packages/site/src/seo/analytics.tsx
var import_jsx_dev_runtime21 = __toESM(require_jsx_dev_runtime(), 1);
var getGoogleAnalyticsScript = (tag) => `window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', '${tag}');`;
function Analytics({ analytics_google, analytics_plausible }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(import_jsx_dev_runtime21.Fragment, { children: [
    analytics_plausible && /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(
      "script",
      {
        defer: true,
        "data-domain": analytics_plausible,
        src: "https://plausible.io/js/plausible.js"
      },
      void 0,
      false,
      {
        fileName: "../../packages/site/src/seo/analytics.tsx",
        lineNumber: 13,
        columnNumber: 9
      },
      this
    ),
    analytics_google && /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(import_jsx_dev_runtime21.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(
        "script",
        {
          async: true,
          src: `https://www.googletagmanager.com/gtag/js?id=${analytics_google}`
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/seo/analytics.tsx",
          lineNumber: 21,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(
        "script",
        {
          dangerouslySetInnerHTML: {
            __html: getGoogleAnalyticsScript(analytics_google)
          }
        },
        void 0,
        false,
        {
          fileName: "../../packages/site/src/seo/analytics.tsx",
          lineNumber: 25,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, true, {
      fileName: "../../packages/site/src/seo/analytics.tsx",
      lineNumber: 20,
      columnNumber: 9
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/seo/analytics.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/seo/meta.ts
function getMetaTagsForSite({
  title,
  description,
  twitter
}) {
  const meta = [
    { title },
    { property: "og:title", content: title },
    { name: "generator", content: "mystmd" }
  ];
  if (description) {
    meta.push({ name: "description", content: description });
    meta.push({ property: "og:description", content: description });
  }
  if (twitter)
    meta.push({ name: "twitter:site", content: `@${twitter.replace("@", "")}` });
  return meta;
}
function getMetaTagsForArticle({
  origin,
  url,
  title,
  description,
  image,
  twitter,
  keywords
}) {
  const meta = [
    { title },
    { property: "og:title", content: title },
    { name: "generator", content: "mystmd" }
  ];
  if (description) {
    meta.push({ name: "description", content: description });
    meta.push({ property: "og:description", content: description });
  }
  if (keywords)
    meta.push({ name: "keywords", content: keywords.join(", ") });
  if (origin && url)
    meta.push({ property: "og:url", content: `${origin}${url}` });
  if (image) {
    meta.push({ name: "image", content: image });
    meta.push({ property: "og:image", content: image });
  }
  if (twitter) {
    meta.push({ name: "twitter:card", content: image ? "summary_large_image" : "summary" });
    meta.push({ name: "twitter:creator", content: `@${twitter.replace("@", "")}` });
    meta.push({ name: "twitter:title", content: title });
    if (description)
      meta.push({ name: "twitter:description", content: description });
    if (image)
      meta.push({ name: "twitter:image", content: image });
    meta.push({ name: "twitter:alt", content: title });
  }
  return meta;
}

// ../../packages/site/src/pages/Error404.tsx
var import_jsx_dev_runtime22 = __toESM(require_jsx_dev_runtime(), 1);
function Error404() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(import_jsx_dev_runtime22.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)("h1", { children: "No Site Found - 404" }, void 0, false, {
      fileName: "../../packages/site/src/pages/Error404.tsx",
      lineNumber: 4,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)("p", { children: "No website is available at this url, or an error occurred. Please double check the url." }, void 0, false, {
      fileName: "../../packages/site/src/pages/Error404.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/Error404.tsx",
    lineNumber: 3,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/ErrorUnhandled.tsx
var import_jsx_dev_runtime23 = __toESM(require_jsx_dev_runtime(), 1);
function ErrorUnhandled({ error }) {
  var _a, _b;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)(import_jsx_dev_runtime23.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)("h1", { children: "Unexpected Error Occurred" }, void 0, false, {
      fileName: "../../packages/site/src/pages/ErrorUnhandled.tsx",
      lineNumber: 9,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)("p", { children: [
      "Status: ",
      error.status
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/ErrorUnhandled.tsx",
      lineNumber: 10,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)("p", { children: (_b = (_a = error.data) == null ? void 0 : _a.message) != null ? _b : "" }, void 0, false, {
      fileName: "../../packages/site/src/pages/ErrorUnhandled.tsx",
      lineNumber: 11,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/ErrorUnhandled.tsx",
    lineNumber: 8,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/Root.tsx
var import_classnames46 = __toESM(require_classnames(), 1);
var import_jsx_dev_runtime24 = __toESM(require_jsx_dev_runtime(), 1);
function Document2({
  children,
  scripts,
  theme: ssrTheme,
  config,
  title,
  staticBuild,
  baseurl,
  top = DEFAULT_NAV_HEIGHT,
  renderers: renderers2 = renderers,
  head
}) {
  const navigate = useNavigate();
  const links = staticBuild ? {
    Link: (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Link, { ...{ ...props, reloadDocument: true } }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 62,
      columnNumber: 31
    }, this),
    NavLink: (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(NavLink, { ...{ ...props, reloadDocument: true } }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 63,
      columnNumber: 34
    }, this)
  } : {
    Link,
    NavLink,
    navigate
  };
  const [theme, setTheme] = useTheme({ ssrTheme, useLocalStorage: staticBuild });
  const headAndLoader = /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(import_jsx_dev_runtime24.Fragment, { children: [
    head,
    ssrTheme ? void 0 : /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(BlockingThemeLoader, { useLocalStorage: !!staticBuild }, void 0, false, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 78,
      columnNumber: 31
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 76,
    columnNumber: 5
  }, this);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(ThemeProvider, { theme, setTheme, renderers: renderers2, ...links, top, children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(
    DocumentWithoutProviders,
    {
      children,
      scripts,
      head: headAndLoader,
      config,
      title,
      liveReloadListener: !staticBuild,
      baseurl,
      top
    },
    void 0,
    false,
    {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 84,
      columnNumber: 7
    },
    this
  ) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 83,
    columnNumber: 5
  }, this);
}
function DocumentWithoutProviders({
  children,
  scripts,
  head,
  config,
  title,
  baseurl,
  top = DEFAULT_NAV_HEIGHT,
  liveReloadListener
}) {
  var _a, _b;
  const { theme } = useThemeSwitcher();
  return (
    // Set the theme during SSR if possible, otherwise leave it up to the BlockingThemeLoader
    /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("html", { lang: "en", className: (0, import_classnames46.default)(theme), style: { scrollPadding: top }, children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("head", { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("meta", { charSet: "utf-8" }, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 134,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("meta", { name: "viewport", content: "width=device-width,initial-scale=1" }, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 135,
          columnNumber: 9
        }, this),
        title && /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("title", { children: title }, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 136,
          columnNumber: 19
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Meta, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 137,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Links, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 138,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(
          Analytics,
          {
            analytics_google: (_a = config == null ? void 0 : config.options) == null ? void 0 : _a.analytics_google,
            analytics_plausible: (_b = config == null ? void 0 : config.options) == null ? void 0 : _b.analytics_plausible
          },
          void 0,
          false,
          {
            fileName: "../../packages/site/src/pages/Root.tsx",
            lineNumber: 139,
            columnNumber: 9
          },
          this
        ),
        head
      ] }, void 0, true, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 133,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("body", { className: "m-0 transition-colors duration-500 bg-white dark:bg-stone-900", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(BaseUrlProvider, { baseurl, children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(SiteProvider, { config, children }, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 147,
          columnNumber: 11
        }, this) }, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 146,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(ScrollRestoration, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 149,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Scripts, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 150,
          columnNumber: 9
        }, this),
        liveReloadListener && /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(LiveReload, {}, void 0, false, {
          fileName: "../../packages/site/src/pages/Root.tsx",
          lineNumber: 151,
          columnNumber: 32
        }, this),
        scripts
      ] }, void 0, true, {
        fileName: "../../packages/site/src/pages/Root.tsx",
        lineNumber: 145,
        columnNumber: 7
      }, this)
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/Root.tsx",
      lineNumber: 132,
      columnNumber: 5
    }, this)
  );
}
function AppErrorBoundary() {
  const error = useRouteError();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Document2, { theme: Theme.light, children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("main", { className: "article-grid subgrid-gap col-screen", children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("article", { className: "article", children: isRouteErrorResponse(error) ? /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Error404, {}, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 173,
    columnNumber: 42
  }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(ErrorUnhandled, { error }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 173,
    columnNumber: 57
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 172,
    columnNumber: 9
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 171,
    columnNumber: 7
  }, this) }, void 0, false, {
    fileName: "../../packages/site/src/pages/Root.tsx",
    lineNumber: 170,
    columnNumber: 5
  }, this);
}

// ../../packages/site/src/pages/ErrorDocumentNotFound.tsx
var import_jsx_dev_runtime25 = __toESM(require_jsx_dev_runtime(), 1);
function ErrorDocumentNotFound() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(import_jsx_dev_runtime25.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("h1", { children: "Document Not Found" }, void 0, false, {
      fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
      lineNumber: 4,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("p", { children: [
      "Take me ",
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("a", { href: "/", children: "home" }, void 0, false, {
        fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
        lineNumber: 6,
        columnNumber: 17
      }, this),
      "."
    ] }, void 0, true, {
      fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "../../packages/site/src/pages/ErrorDocumentNotFound.tsx",
    lineNumber: 3,
    columnNumber: 5
  }, this);
}

// ../../packages/jupyter/dist/providers.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/utils.js
function isObject(maybeObject) {
  return typeof maybeObject === "object" && maybeObject !== null;
}
function thebeFrontmatterToOptions(fm) {
  if (fm === void 0)
    return void 0;
  const { binder, server, lite, kernelName, disableSessionSaving, mathjaxConfig, mathjaxUrl } = fm !== null && fm !== void 0 ? fm : {};
  const thebeOptions = { mathjaxConfig, mathjaxUrl };
  if (disableSessionSaving) {
    thebeOptions.savedSessionOptions = { enabled: false };
  }
  if (kernelName) {
    thebeOptions.kernelOptions = {
      kernelName
    };
  }
  if (binder) {
    thebeOptions.useBinder = true;
    const { repo, ref, url, provider } = binder;
    thebeOptions.binderOptions = { repo, ref, binderUrl: url, repoProvider: provider };
  }
  if (lite === true) {
    thebeOptions.useJupyterLite = true;
  }
  if (isObject(server)) {
    const { url, token } = server;
    thebeOptions.serverSettings = {};
    if (url)
      thebeOptions.serverSettings.baseUrl = url;
    if (token)
      thebeOptions.serverSettings.token = token;
  }
  return thebeOptions;
}

// ../../packages/jupyter/dist/providers.js
var import_thebe_react = __toESM(require_dist3(), 1);
var ComputeOptionsContext = import_react70.default.createContext(void 0);
function ComputeOptionsProvider({ features, optionOverrideFn, customRepoProviders, children }) {
  const project = useProjectManifest();
  const options = import_react70.default.useMemo(() => {
    if (!project)
      return;
    const thebeFrontmatter = project === null || project === void 0 ? void 0 : project.thebe;
    const githubBadgeUrl = project === null || project === void 0 ? void 0 : project.github;
    const binderBadgeUrl = project === null || project === void 0 ? void 0 : project.binder;
    const optionsFromFrontmatter = thebeFrontmatterToOptions(thebeFrontmatter);
    const optionsWithOverrides = optionOverrideFn ? optionOverrideFn(optionsFromFrontmatter) : optionsFromFrontmatter;
    return {
      enabled: !!optionsWithOverrides,
      thebe: optionsWithOverrides,
      githubBadgeUrl,
      binderBadgeUrl,
      features,
      customRepoProviders
    };
  }, [project, optionOverrideFn]);
  return (0, import_jsx_runtime61.jsx)(ComputeOptionsContext.Provider, { value: options, children });
}
function useComputeOptions() {
  return (0, import_react70.useContext)(ComputeOptionsContext);
}
function ThebeLoaderAndServer({ baseurl, connect, children }) {
  var _a, _b, _c, _d, _e2, _f, _g;
  const compute = useComputeOptions();
  return (0, import_jsx_runtime61.jsx)(import_thebe_react.ThebeBundleLoaderProvider, { loadThebeLite: (_b = (_a = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _a === void 0 ? void 0 : _a.useJupyterLite) !== null && _b !== void 0 ? _b : false, publicPath: baseurl, children: (0, import_jsx_runtime61.jsx)(import_thebe_react.ThebeServerProvider, { connect: connect !== null && connect !== void 0 ? connect : false, options: compute === null || compute === void 0 ? void 0 : compute.thebe, useBinder: (_d = (_c = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _c === void 0 ? void 0 : _c.useBinder) !== null && _d !== void 0 ? _d : false, useJupyterLite: (_f = (_e2 = compute === null || compute === void 0 ? void 0 : compute.thebe) === null || _e2 === void 0 ? void 0 : _e2.useJupyterLite) !== null && _f !== void 0 ? _f : false, customRepoProviders: (_g = compute === null || compute === void 0 ? void 0 : compute.customRepoProviders) !== null && _g !== void 0 ? _g : [], children }) });
}
var OutputsContext = import_react70.default.createContext(null);
function useOutputsContext() {
  const context = (0, import_react70.useContext)(OutputsContext);
  if (context === null)
    return { outputsId: void 0 };
  return context;
}
function OutputsContextProvider({ outputsId, children }) {
  return (0, import_jsx_runtime61.jsx)(OutputsContext.Provider, { value: { outputsId }, children });
}

// ../../packages/jupyter/dist/embed.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/decoration.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/hooks.js
var import_react75 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/provider.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/execute/actions.js
function isNavigatePayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.slug === "string" && typeof maybePayload.location === "string" && typeof maybePayload.mdast === "object" && Array.isArray(maybePayload.dependencies) && Array.isArray(maybePayload.computables);
}
function isSlugPayload(payload) {
  return typeof payload.slug === "string";
}
function isBuildStatusPayload(payload) {
  return typeof payload.status === "string" && isSlugPayload(payload);
}
function isAddMdastPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.slug === "string" && typeof maybePayload.mdast === "object";
}
function isAddNotebookPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.pageSlug === "string" && typeof maybePayload.notebookSlug === "string" && typeof maybePayload.notebook === "object" && typeof maybePayload.rendermime === "object";
}
function isAddSessionPayload(payload) {
  const maybePayload = payload;
  return typeof maybePayload.pageSlug === "string" && typeof maybePayload.notebookSlug === "string" && typeof maybePayload.session === "object";
}

// ../../packages/jupyter/dist/execute/reducer.js
var __rest5 = function(s8, e3) {
  var t11 = {};
  for (var p3 in s8)
    if (Object.prototype.hasOwnProperty.call(s8, p3) && e3.indexOf(p3) < 0)
      t11[p3] = s8[p3];
  if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p3 = Object.getOwnPropertySymbols(s8); i6 < p3.length; i6++) {
      if (e3.indexOf(p3[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p3[i6]))
        t11[p3[i6]] = s8[p3[i6]];
    }
  return t11;
};
function reducer(state, action) {
  var _a;
  switch (action.type) {
    case "NAVIGATE": {
      if (!isNavigatePayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid NAVIGATE payload");
      }
      const { kind, slug, location: location2, mdast, dependencies, computables } = action.payload;
      if (state.pages[slug])
        return state;
      return Object.assign(Object.assign({}, state), { mdast: Object.assign(Object.assign({}, state.mdast), { [slug]: { root: mdast } }), pages: Object.assign(Object.assign({}, state.pages), { [slug]: {
        kind,
        slug,
        location: location2,
        dependencies,
        computables,
        computable: computables.length > 0 || kind === SourceFileKind.Notebook,
        ready: false,
        scopes: {}
      } }) });
    }
    case "ADD_MDAST": {
      if (!isAddMdastPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_MDAST payload");
      }
      const { slug, mdast } = action.payload;
      if (state.mdast[slug])
        return state;
      return Object.assign(Object.assign({}, state), { mdast: Object.assign(Object.assign({}, state.mdast), { [slug]: { root: mdast } }) });
    }
    case "REQUEST_BUILD": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid REQUEST_BUILD payload");
      }
      const { slug } = action.payload;
      if (!!state.builds[slug] && state.builds[slug].status === "pending")
        return state;
      return Object.assign(Object.assign({}, state), { builds: Object.assign(Object.assign({}, state.builds), { [slug]: {
        status: "pending"
      } }) });
    }
    case "BUILD_STATUS": {
      if (!isBuildStatusPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid BUILD_STATUS payload");
      }
      const { slug } = action.payload;
      if (!state.builds[slug]) {
        console.error(state, action.payload);
        throw new Error("Trying to set build status when there is no build state");
      }
      if (state.builds[slug].status === action.payload.status)
        return state;
      return Object.assign(Object.assign({}, state), { builds: Object.assign(Object.assign({}, state.builds), { [slug]: Object.assign(Object.assign({}, state.builds[slug]), { status: action.payload.status }) }) });
    }
    case "CLEAR_BUILD": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid CLEAR_BUILD payload");
      }
      const { slug } = action.payload;
      if (!state.builds[slug])
        return state;
      const _b = state.builds, _c = slug, _4 = _b[_c], builds = __rest5(_b, [typeof _c === "symbol" ? _c : _c + ""]);
      return Object.assign(Object.assign({}, state), { builds });
    }
    case "SET_RENDERING_READY": {
      if (!isSlugPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid SET_READY payload");
      }
      const { slug } = action.payload;
      if (state.pages[slug].ready)
        return state;
      const _d = state.builds, _e2 = slug, _4 = _d[_e2], builds = __rest5(_d, [typeof _e2 === "symbol" ? _e2 : _e2 + ""]);
      const newState = Object.assign(Object.assign({}, state), { builds, pages: Object.assign(Object.assign({}, state.pages), { [slug]: Object.assign(Object.assign({}, state.pages[slug]), { ready: true }) }) });
      return newState;
    }
    case "ADD_NOTEBOOK": {
      if (!isAddNotebookPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_NOTEBOOK payload");
      }
      const { pageSlug, notebookSlug, notebook, rendermime } = action.payload;
      if (!state.pages[pageSlug]) {
        console.error(state, action.payload);
        throw new Error("Trying to add notebook when there is no rendering state");
      }
      if (state.pages[pageSlug].scopes[notebookSlug]) {
        console.warn("Trying to add notebook scope when rendering already has one", action.payload);
        return state;
      }
      return Object.assign(Object.assign({}, state), { pages: Object.assign(Object.assign({}, state.pages), { [pageSlug]: Object.assign(Object.assign({}, state.pages[pageSlug]), { scopes: Object.assign(Object.assign({}, state.pages[pageSlug].scopes), { [notebookSlug]: {
        notebook,
        rendermime
      } }) }) }) });
    }
    case "ADD_SESSION": {
      if (!isAddSessionPayload(action.payload)) {
        console.error(action.payload);
        throw new Error("invalid ADD_SESSION payload");
      }
      const { pageSlug, notebookSlug, session } = action.payload;
      if (!state.pages[pageSlug]) {
        console.error(state, action.payload);
        throw new Error("Trying to add session when there is no rendering state");
      }
      if ((_a = state.pages[pageSlug].scopes[notebookSlug]) === null || _a === void 0 ? void 0 : _a.session) {
        console.warn("Trying to add session scope when rendering already has one", action.payload);
        return state;
      }
      return Object.assign(Object.assign({}, state), { pages: Object.assign(Object.assign({}, state.pages), { [pageSlug]: Object.assign(Object.assign({}, state.pages[pageSlug]), { scopes: Object.assign(Object.assign({}, state.pages[pageSlug].scopes), { [notebookSlug]: Object.assign(Object.assign({}, state.pages[pageSlug].scopes[notebookSlug]), { session }) }) }) }) });
    }
  }
  return state;
}

// ../../packages/jupyter/dist/execute/selectors.js
function selectNotebookForPage(state, pageSlug, notebookSlug) {
  var _a, _b;
  return (_b = (_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug]) === null || _b === void 0 ? void 0 : _b.notebook;
}
function selectIsComputable(state, slug) {
  var _a, _b;
  return (_b = (_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.computable) !== null && _b !== void 0 ? _b : false;
}
function selectAreExecutionScopesBuilding(state, slug) {
  var _a;
  return !((_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.ready) && !!state.builds[slug];
}
function selectExecutionScopeStatus(state, slug) {
  var _a, _b, _c;
  return ((_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.ready) ? "ready" : (_c = (_b = state.builds[slug]) === null || _b === void 0 ? void 0 : _b.status) !== null && _c !== void 0 ? _c : "unknown";
}
function selectDependenciesToFetch(state) {
  return Object.entries(state.builds).filter(([, { status }]) => status === "fetching").reduce((targets, [slug]) => [
    ...targets,
    ...state.pages[slug].dependencies.filter((d6) => {
      var _a;
      return !state.mdast[(_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url];
    }).map((d6) => {
      var _a;
      return {
        slug: (_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url,
        url: d6.url
      };
    })
  ], []);
}
function makeSelectScopeEventStatus(statusName) {
  return (state) => {
    return Object.entries(state.builds).filter(([, { status }]) => status === statusName).reduce((all, [slug]) => {
      const targets = [];
      if (state.pages[slug].kind === SourceFileKind.Notebook)
        targets.push({
          pageSlug: slug,
          notebookSlug: slug,
          location: state.pages[slug].location
        });
      targets.push(...state.pages[slug].dependencies.map((d6) => {
        var _a;
        return {
          pageSlug: slug,
          notebookSlug: (_a = d6.slug) !== null && _a !== void 0 ? _a : d6.url,
          location: d6.location
        };
      }));
      return [...all, ...targets];
    }, []);
  };
}
var selectScopeNotebooksToBuild = makeSelectScopeEventStatus("build-notebooks");
var selectSessionsToStart = makeSelectScopeEventStatus("start-session");
function selectAreAllDependenciesReady(state, slug) {
  var _a;
  return (_a = state.pages[slug]) === null || _a === void 0 ? void 0 : _a.dependencies.every((dep) => {
    var _a2;
    return !!state.mdast[(_a2 = dep.slug) !== null && _a2 !== void 0 ? _a2 : dep.url];
  });
}
function selectAreAllNotebookScopesBuilt(state, slug) {
  const rendering = state.pages[slug];
  return rendering === null || rendering === void 0 ? void 0 : rendering.dependencies.every((dep) => {
    var _a;
    return !!rendering.scopes[(_a = dep.slug) !== null && _a !== void 0 ? _a : dep.url];
  });
}
function selectAreAllSessionsStarted(state, slug) {
  const rendering = state.pages[slug];
  return rendering === null || rendering === void 0 ? void 0 : rendering.dependencies.every((dep) => {
    var _a, _b;
    return !!((_b = rendering.scopes[(_a = dep.slug) !== null && _a !== void 0 ? _a : dep.url]) === null || _b === void 0 ? void 0 : _b.session);
  });
}

// ../../packages/jupyter/dist/execute/leaf.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);
var import_thebe_react2 = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/execute/utils.js
function executableNodesFromBlock(block) {
  if (!block || block.type !== "block")
    return;
  let target = block;
  if (block.children && block.children.length === 1 && block.children[0].type === "container") {
    target = block.children[0];
  }
  if (target.children && target.children.length >= 2 && target.children[0].type === "code") {
    return { codeCell: target.children[0], output: target.children[1] };
  }
}
function notebookFromMdast(core, config, pageSlug, notebookSlug, mdast, idkmap, rendermime) {
  const notebook = new core.ThebeNotebook(notebookSlug, config, rendermime);
  notebook.cells = mdast.children.map((block) => {
    var _a, _b, _c, _d;
    if (block.type !== "block")
      console.warn(`Unexpected block type ${block.type}`);
    const executableNodes = executableNodesFromBlock(block);
    if (executableNodes) {
      const { codeCell, output } = executableNodes;
      const target = {
        pageSlug,
        notebookSlug,
        cellId: block.key
      };
      idkmap[block.key] = target;
      idkmap[(_a = output.id) !== null && _a !== void 0 ? _a : output.key] = target;
      if (block.identifier)
        idkmap[block.identifier] = target;
      if (codeCell.identifier)
        idkmap[codeCell.identifier] = target;
      if (output.identifier)
        idkmap[output.identifier] = target;
      return new core.ThebeCodeCell(target.cellId, notebook.id, (_b = codeCell.value) !== null && _b !== void 0 ? _b : "", config, (_c = block.data) !== null && _c !== void 0 ? _c : {}, notebook.rendermime);
    } else {
      const cell = new core.ThebeMarkdownCell(block.key, notebook.id, block.children.reduce((acc, child) => {
        var _a2;
        return acc + "\n" + ((_a2 = child.value) !== null && _a2 !== void 0 ? _a2 : "");
      }, ""), (_d = block.data) !== null && _d !== void 0 ? _d : {}, notebook.rendermime);
      return cell;
    }
  });
  return notebook;
}

// ../../packages/jupyter/dist/plotly.js
var import_react71 = __toESM(require_react(), 1);
function useLoadPlotly() {
  const [plotly, setPlotly] = (0, import_react71.useState)();
  (0, import_react71.useEffect)(() => {
    if (plotly)
      return;
    import("/build/_shared/plotly-renderer-MVA6RQ6V.js").then((module) => {
      console.debug("Jupyter: Adding plotly renderer factory to rendermime registry", {
        module
      });
      setPlotly(module);
    });
  }, [plotly]);
  return { plotly };
}
var PLOTLY_MIMETYPE = "application/vnd.plotly.v1+json";
function isPlotly(outputs) {
  return outputs.some((output) => {
    var _a;
    return Object.keys((_a = output.data) !== null && _a !== void 0 ? _a : []).includes(PLOTLY_MIMETYPE);
  });
}
function usePlotlyPassively(rendermime, outputs) {
  const isPlotlyOutput = isPlotly(outputs);
  const [loaded, setLoaded] = (0, import_react71.useState)(!isPlotlyOutput);
  (0, import_react71.useEffect)(() => {
    if (loaded || !isPlotlyOutput)
      return;
    import("/build/_shared/plotly-renderer-MVA6RQ6V.js").then((module) => {
      console.debug("Jupyter: Adding plotly renderer factory to rendermime registry", {
        module
      });
      rendermime.addFactory(module.rendererFactory, 41);
      setLoaded(true);
    });
  }, [loaded, isPlotlyOutput]);
  return { loaded };
}

// ../../packages/jupyter/dist/execute/leaf.js
function MdastFetcher({ slug, url, dispatch }) {
  const { data, error } = useFetchMdast({ remote: true, dataUrl: `${url}.json` });
  (0, import_react72.useEffect)(() => {
    if (!data)
      return;
    dispatch({ type: "ADD_MDAST", payload: { slug, mdast: data.mdast } });
  }, [data]);
  if (error) {
    return (0, import_jsx_runtime62.jsxs)("div", { children: ["error: ", slug, error.message] });
  }
  return null;
}
function NotebookBuilder({ pageSlug, notebookSlug, idkmap, state, dispatch }) {
  var _a;
  const { core } = (0, import_thebe_react2.useThebeLoader)();
  const { config } = (0, import_thebe_react2.useThebeConfig)();
  const lock = (0, import_react72.useRef)(false);
  const scopeHasNotebook = !!((_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug]);
  const { plotly } = useLoadPlotly();
  (0, import_react72.useEffect)(() => {
    var _a2;
    if (!core || !config || !plotly || scopeHasNotebook || lock.current)
      return;
    lock.current = true;
    console.debug(`Jupyter: NotebookBuilder - ${notebookSlug} being added to scope ${pageSlug}`);
    const rendermime = core === null || core === void 0 ? void 0 : core.makeRenderMimeRegistry(config === null || config === void 0 ? void 0 : config.mathjax);
    if (plotly)
      rendermime.addFactory(plotly.rendererFactory, 41);
    const notebook = notebookFromMdast(core, config, pageSlug, notebookSlug, state.mdast[notebookSlug].root, idkmap, rendermime);
    const computables = (_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.computables;
    computables === null || computables === void 0 ? void 0 : computables.forEach((c6) => {
      if (idkmap[c6.label]) {
        idkmap[c6.outputKey] = idkmap[c6.label];
        idkmap[c6.embedKey] = idkmap[c6.label];
      }
    });
    dispatch({
      type: "ADD_NOTEBOOK",
      payload: { pageSlug, notebookSlug, rendermime, notebook }
    });
  }, [core, config, pageSlug, notebookSlug, scopeHasNotebook, lock, plotly]);
  const allNotebooksAreBuilt = plotly && selectAreAllNotebookScopesBuilt(state, pageSlug);
  (0, import_react72.useEffect)(() => {
    if (!allNotebooksAreBuilt)
      return;
    dispatch({ type: "BUILD_STATUS", payload: { slug: pageSlug, status: "wait-for-server" } });
  }, [allNotebooksAreBuilt]);
  return null;
}
function SessionStarter({ pageSlug, notebookSlug, location: location2, state, dispatch }) {
  var _a;
  const { core } = (0, import_thebe_react2.useThebeLoader)();
  const { config, server } = (0, import_thebe_react2.useThebeServer)();
  const lock = (0, import_react72.useRef)(false);
  const scope = (_a = state.pages[pageSlug]) === null || _a === void 0 ? void 0 : _a.scopes[notebookSlug];
  (0, import_react72.useEffect)(() => {
    if (!core || !server || (scope === null || scope === void 0 ? void 0 : scope.session) || lock.current)
      return;
    lock.current = true;
    console.debug(`Jupyter: Starting session for ${pageSlug}-${notebookSlug} at ${location2}`);
    if (location2 === void 0) {
      console.warn("Article/Notebook json is missing the location field, this maybe break notebook execution when located outside of the root folder");
    }
    server.listRunningSessions().then((sessions) => {
      var _a2;
      console.debug("Jupyter: running sessions", sessions);
      let path = `/${pageSlug}-${notebookSlug}.ipynb`;
      console.debug("session starter path:", path);
      const match = (_a2 = location2 === null || location2 === void 0 ? void 0 : location2.match(/(.*)\/.*/)) !== null && _a2 !== void 0 ? _a2 : null;
      if (match) {
        console.debug("session starter match:", match);
        path = `${match[1]}/${pageSlug}-${notebookSlug}.ipynb`;
        console.debug("session starter path (modified):", path);
      }
      const existing = sessions.find((s8) => s8.path === path);
      if (existing) {
        console.debug(`session already exists for ${path}`, existing);
        server.connectToExistingSession(existing, scope.rendermime).then((sesh) => {
          var _a3;
          if (sesh == null) {
            console.error(`Could not connect to session for ${path}`);
            return;
          }
          console.debug(`reconnected to session for ${path}`, sesh);
          console.debug("restarting session", sesh);
          (_a3 = sesh.kernel) === null || _a3 === void 0 ? void 0 : _a3.restart().then(() => {
            const notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
            notebook.attachSession(sesh);
            dispatch({ type: "ADD_SESSION", payload: { pageSlug, notebookSlug, session: sesh } });
          });
        });
      } else {
        server.startNewSession(scope.rendermime, Object.assign(Object.assign({}, config === null || config === void 0 ? void 0 : config.kernels), { path })).then((sesh) => {
          if (sesh == null) {
            server === null || server === void 0 ? void 0 : server.getKernelSpecs().then((specs) => {
              console.error(`Could not start session for ${path}`);
              console.debug(`Available kernels: ${Object.keys(specs)}`);
            });
            return;
          }
          console.debug(`session started for ${path}`, sesh);
          const notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
          notebook.attachSession(sesh);
          dispatch({ type: "ADD_SESSION", payload: { pageSlug, notebookSlug, session: sesh } });
        });
      }
    });
  }, [core, config, scope, pageSlug, notebookSlug, lock]);
  const allSessionsAreStarted = selectAreAllSessionsStarted(state, pageSlug);
  (0, import_react72.useEffect)(() => {
    if (!allSessionsAreStarted)
      return;
    dispatch({
      type: "SET_RENDERING_READY",
      payload: { slug: pageSlug }
    });
  }, [allSessionsAreStarted]);
  return null;
}
function ServerMonitor({ state, dispatch }) {
  const { core, load: load2, loading } = (0, import_thebe_react2.useThebeLoader)();
  const { ready, error } = (0, import_thebe_react2.useThebeServer)();
  (0, import_react72.useEffect)(() => {
    if (core || loading)
      return;
    load2();
  }, [core, load2, loading]);
  (0, import_react72.useEffect)(() => {
    if (ready) {
      Object.entries(state.builds).forEach(([slug, { status }]) => {
        if (status === "wait-for-server") {
          dispatch({ type: "BUILD_STATUS", payload: { slug, status: "start-session" } });
        }
      });
    }
  }, [ready, state]);
  (0, import_react72.useEffect)(() => {
    if (!error)
      return;
  }, [error]);
  return null;
}

// ../../packages/jupyter/dist/execute/provider.js
var ExecuteScopeContext = import_react73.default.createContext(void 0);
function useScopeNavigate({ contents: { slug, location: location2, kind, mdast, dependencies }, state, dispatch }) {
  (0, import_react73.useEffect)(() => {
    if (state.pages[slug]) {
      console.debug(`Jupyter: ExecuteScopeProvider - ${slug} is already in scope`);
      return;
    }
    const computables = listComputables(mdast);
    dispatch({
      type: "NAVIGATE",
      payload: {
        kind,
        slug,
        location: location2 !== null && location2 !== void 0 ? location2 : kind === SourceFileKind.Notebook ? "/fallback.ipynb" : "/",
        mdast,
        dependencies: dependencies !== null && dependencies !== void 0 ? dependencies : [],
        computables
      }
    });
  }, [slug]);
}
function useExecutionScopeFetcher({ slug, state, dispatch }) {
  (0, import_react73.useEffect)(() => {
    if (!state.builds[slug])
      return;
    if (state.builds[slug].status === "pending") {
      dispatch({ type: "BUILD_STATUS", payload: { slug, status: "fetching" } });
    }
    if (state.builds[slug].status === "fetching") {
      if (selectAreAllDependenciesReady(state, slug)) {
        dispatch({ type: "BUILD_STATUS", payload: { slug, status: "build-notebooks" } });
      }
    }
  }, [state.builds, state.mdast]);
}
function listComputables(mdast) {
  return selectAll("container[kind=figure]:has(output), embed:has(output)", mdast).map((node) => {
    const { key, label, source } = node;
    const output = selectAll("output", node);
    return { embedKey: key, outputKey: output[0].key, label, source };
  });
}
function ExecuteScopeProvider({ children, enable, contents }) {
  var _a, _b;
  const computables = listComputables(contents.mdast);
  const fallbackLocation = contents.kind === SourceFileKind.Notebook ? "/fallback.ipynb" : "/";
  const initialState = {
    mdast: {
      [contents.slug]: { root: contents.mdast }
    },
    pages: {
      [contents.slug]: {
        computable: computables.length > 0 || contents.kind === SourceFileKind.Notebook,
        kind: contents.kind,
        slug: contents.slug,
        location: (_a = contents.location) !== null && _a !== void 0 ? _a : fallbackLocation,
        dependencies: (_b = contents.dependencies) !== null && _b !== void 0 ? _b : [],
        computables,
        ready: false,
        scopes: {}
      }
    },
    builds: {}
  };
  const [state, dispatch] = (0, import_react73.useReducer)(reducer, initialState);
  const idkmap = (0, import_react73.useRef)({});
  useScopeNavigate({ contents, state, dispatch });
  useExecutionScopeFetcher({ slug: contents.slug, state, dispatch });
  const fetchTargets = selectDependenciesToFetch(state);
  const notebookBuildTargets = selectScopeNotebooksToBuild(state);
  const sessionStartTargets = selectSessionsToStart(state);
  const memo = import_react73.default.useMemo(() => ({
    canCompute: enable,
    slug: contents.slug,
    location: contents.location,
    state,
    dispatch,
    idkmap: idkmap.current
  }), [state, contents.slug, enable]);
  if (typeof window !== "undefined") {
    window.executeScope = memo;
  }
  return (0, import_jsx_runtime63.jsxs)(ExecuteScopeContext.Provider, { value: memo, children: [(0, import_jsx_runtime63.jsxs)("div", { className: "hidden", children: [fetchTargets.length > 0 && (0, import_jsx_runtime63.jsx)("div", { className: "p-1 pl-4", children: fetchTargets.map(({ slug, url }) => (0, import_jsx_runtime63.jsx)(MdastFetcher, { slug, url, dispatch }, `fetch-${slug}`)) }), notebookBuildTargets.length > 0 && (0, import_jsx_runtime63.jsx)("div", { className: "p-1 pl-4", children: notebookBuildTargets.map(({ pageSlug, notebookSlug }) => (0, import_jsx_runtime63.jsx)(NotebookBuilder, { pageSlug, notebookSlug, idkmap: idkmap.current, state, dispatch }, `build-${pageSlug}-${notebookSlug}`)) }), sessionStartTargets.length > 0 && (0, import_jsx_runtime63.jsx)("div", { className: "p-1 pl-4", children: sessionStartTargets.map(({ pageSlug, notebookSlug, location: location2 }) => (0, import_jsx_runtime63.jsx)(SessionStarter, { pageSlug, notebookSlug, location: location2, state, dispatch }, `session-${pageSlug}-${notebookSlug}`)) })] }), (0, import_jsx_runtime63.jsx)(ServerMonitor, { state, dispatch }), children] });
}

// ../../packages/jupyter/dist/execute/busy.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react74 = __toESM(require_react(), 1);
var __rest6 = function(s8, e3) {
  var t11 = {};
  for (var p3 in s8)
    if (Object.prototype.hasOwnProperty.call(s8, p3) && e3.indexOf(p3) < 0)
      t11[p3] = s8[p3];
  if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p3 = Object.getOwnPropertySymbols(s8); i6 < p3.length; i6++) {
      if (e3.indexOf(p3[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p3[i6]))
        t11[p3[i6]] = s8[p3[i6]];
    }
  return t11;
};
var BusyScopeContext = import_react74.default.createContext(void 0);
function isSlugPayload2(payload) {
  return typeof payload.pageSlug === "string" && typeof payload.notebookSlug === "string" && typeof payload.kind === "string";
}
function isCellPayload(payload) {
  return isSlugPayload2(payload) && typeof payload.cellId === "string" && typeof payload.kind === "string";
}
function isNotebookPayload(payload) {
  return isSlugPayload2(payload) && Array.isArray(payload.cellIds) && payload.cellIds.every((id) => typeof id === "string") && typeof payload.kind === "string";
}
function isErrorPayload(payload) {
  var _a, _b;
  return typeof payload.pageSlug === "string" && typeof payload.notebookSlug === "string" && payload.errors === void 0 || ((_b = Array.isArray(payload.errors) && ((_a = payload.errors) === null || _a === void 0 ? void 0 : _a.every((error) => typeof error === "object"))) !== null && _b !== void 0 ? _b : false);
}
function reducer2(state, action) {
  var _a, _b, _c, _d, _e2, _f, _g;
  switch (action.type) {
    case "SET_CELL_BUSY": {
      if (!isCellPayload(action.payload)) {
        console.error("SET_CELL_BUSY payload must be a cell payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellId, kind } = action.payload;
      if ((_b = (_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]) === null || _b === void 0 ? void 0 : _b[cellId])
        return state;
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign(Object.assign({}, state[kind][pageSlug]), { [notebookSlug]: Object.assign(Object.assign({}, (_c = state[kind][pageSlug]) === null || _c === void 0 ? void 0 : _c[notebookSlug]), { [cellId]: true }) }) }) });
    }
    case "CLEAR_CELL_BUSY": {
      if (!isCellPayload(action.payload)) {
        console.error("CLEAR_CELL_BUSY payload must be a cell payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellId, kind } = action.payload;
      const _h = state[kind], _j = pageSlug, renderBusy = _h[_j], otherRenders = __rest6(_h, [typeof _j === "symbol" ? _j : _j + ""]);
      if (!renderBusy)
        return state;
      const _k = renderBusy, _l = notebookSlug, notebookBusy = _k[_l], otherNotebooks = __rest6(_k, [typeof _l === "symbol" ? _l : _l + ""]);
      if (!notebookBusy)
        return state;
      if (!notebookBusy[cellId])
        return state;
      const _m = notebookBusy, _o = cellId, cellBusy = _m[_o], otherCells = __rest6(_m, [typeof _o === "symbol" ? _o : _o + ""]);
      if (Object.keys(otherCells).length === 0 && Object.keys(otherNotebooks).length === 0) {
        return Object.assign(Object.assign({}, state), { [kind]: otherRenders });
      }
      if (Object.keys(otherCells).length === 0) {
        return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
      }
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [action.payload.pageSlug]: Object.assign(Object.assign({}, otherNotebooks), { [notebookSlug]: Object.assign({}, otherCells) }) }) });
    }
    case "SET_NOTEBOOK_BUSY": {
      if (!isNotebookPayload(action.payload)) {
        console.error("SET_NOTEBOOK_BUSY payload must be a notebook payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, cellIds, kind } = action.payload;
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign(Object.assign({}, state[kind][pageSlug]), { [notebookSlug]: Object.assign(Object.assign({}, (_d = state[kind][pageSlug]) === null || _d === void 0 ? void 0 : _d[notebookSlug]), cellIds.reduce((acc, cellId) => Object.assign(Object.assign({}, acc), { [cellId]: true }), {})) }) }) });
    }
    case "CLEAR_NOTEBOOK_BUSY": {
      if (!isSlugPayload2(action.payload)) {
        console.error("CLEAR_NOTEBOOK_BUSY payload must be a notebook payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, kind } = action.payload;
      if (!state[kind][pageSlug])
        return state;
      if (!((_e2 = state[kind][pageSlug]) === null || _e2 === void 0 ? void 0 : _e2[notebookSlug]))
        return state;
      const _p = state[kind][pageSlug], _q = notebookSlug, notebookBusy = _p[_q], otherNotebooks = __rest6(_p, [typeof _q === "symbol" ? _q : _q + ""]);
      if (Object.keys(otherNotebooks).length === 0) {
        const _r = state[kind], _s = pageSlug, renderBusy = _r[_s], otherRenders = __rest6(_r, [typeof _s === "symbol" ? _s : _s + ""]);
        return Object.assign(Object.assign({}, state), { [kind]: otherRenders });
      }
      return Object.assign(Object.assign({}, state), { [kind]: Object.assign(Object.assign({}, state[kind]), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
    }
    case "SET_ERROR": {
      if (!isErrorPayload(action.payload)) {
        console.error("SET_ERROR payload must be an error payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug, errors } = action.payload;
      if (!errors) {
        console.error("SET_ERROR payload must have errors", action.payload);
        return state;
      }
      if (state.error[pageSlug])
        return state;
      if ((_f = state.error[pageSlug]) === null || _f === void 0 ? void 0 : _f[notebookSlug])
        return state;
      return Object.assign(Object.assign({}, state), { error: Object.assign(Object.assign({}, state.error), { [pageSlug]: Object.assign(Object.assign({}, state.error[pageSlug]), { [notebookSlug]: errors }) }) });
    }
    case "CLEAR_ERROR": {
      if (!isErrorPayload(action.payload)) {
        console.error("CLEAR_ERROR payload must be a error payload", action.payload);
        return state;
      }
      const { pageSlug, notebookSlug } = action.payload;
      if (!state.error[pageSlug])
        return state;
      if (!((_g = state.error[pageSlug]) === null || _g === void 0 ? void 0 : _g[notebookSlug]))
        return state;
      const _t = state.error[pageSlug], _u = notebookSlug, notebookErrors = _t[_u], otherNotebooks = __rest6(_t, [typeof _u === "symbol" ? _u : _u + ""]);
      if (Object.keys(otherNotebooks).length > 0) {
        return Object.assign(Object.assign({}, state), { error: Object.assign(Object.assign({}, state.error), { [pageSlug]: Object.assign({}, otherNotebooks) }) });
      }
      const _v = state.error, _w = pageSlug, renderErrors = _v[_w], otherRenders = __rest6(_v, [typeof _w === "symbol" ? _w : _w + ""]);
      return Object.assign(Object.assign({}, state), { error: otherRenders });
    }
  }
  return state;
}
function BusyScopeProvider({ children }) {
  const [state, dispatch] = (0, import_react74.useReducer)(reducer2, { execute: {}, reset: {}, error: {} });
  const memo = import_react74.default.useMemo(() => ({ state, dispatch }), [state]);
  if (typeof window !== "undefined") {
    window.busyScopeState = memo.state;
  }
  return (0, import_jsx_runtime64.jsx)(BusyScopeContext.Provider, { value: memo, children });
}
function useBusyScope() {
  const context = import_react74.default.useContext(BusyScopeContext);
  if (context === void 0) {
    throw new Error("useBusyScope must be used within a BusyScopeProvider");
  }
  const { dispatch, state } = context;
  const cell = (0, import_react74.useCallback)((pageSlug, notebookSlug, cellId, kind) => selectCellIsBusy(state, pageSlug, notebookSlug, cellId, kind), [state]);
  const notebook = (0, import_react74.useCallback)((pageSlug, notebookSlug, kind) => selectNotebookIsBusy(state, pageSlug, notebookSlug, kind), [state]);
  const page = (0, import_react74.useCallback)((pageSlug, kind) => selectPageIsBusy(state, pageSlug, kind), [state]);
  const setCell = (0, import_react74.useCallback)((pageSlug, notebookSlug, cellId, kind) => {
    dispatch({ type: "SET_CELL_BUSY", payload: { pageSlug, notebookSlug, cellId, kind } });
  }, [dispatch]);
  const clearCell = (0, import_react74.useCallback)((pageSlug, notebookSlug, cellId, kind) => dispatch({ type: "CLEAR_CELL_BUSY", payload: { pageSlug, notebookSlug, cellId, kind } }), [dispatch]);
  const setNotebook = (0, import_react74.useCallback)((pageSlug, notebookSlug, cellIds, kind) => dispatch({ type: "SET_NOTEBOOK_BUSY", payload: { pageSlug, notebookSlug, cellIds, kind } }), [dispatch]);
  const clearNotebook = (0, import_react74.useCallback)((pageSlug, notebookSlug, kind) => dispatch({ type: "CLEAR_NOTEBOOK_BUSY", payload: { pageSlug, notebookSlug, kind } }), [dispatch]);
  const setError = (0, import_react74.useCallback)((pageSlug, notebookSlug, errors) => dispatch({ type: "SET_ERROR", payload: { pageSlug, notebookSlug, errors } }), [dispatch]);
  const clearError = (0, import_react74.useCallback)((pageSlug, notebookSlug) => dispatch({ type: "CLEAR_ERROR", payload: { pageSlug, notebookSlug } }), [dispatch]);
  return {
    cell,
    notebook,
    page,
    setCell,
    clearCell,
    setNotebook,
    clearNotebook,
    setError,
    clearError
  };
}
function useBusyErrors(pageSlug) {
  const context = import_react74.default.useContext(BusyScopeContext);
  if (context === void 0) {
    throw new Error("useBusyScope must be used within a BusyScopeProvider");
  }
  const { state, dispatch } = context;
  const clearErrors = () => {
    Object.keys(state.error[pageSlug]).forEach((notebookSlug) => {
      dispatch({ type: "CLEAR_ERROR", payload: { pageSlug, notebookSlug } });
    });
  };
  let items;
  if (Object.keys(state.error).length > 0 && state.error[pageSlug]) {
    items = Object.entries(state.error[pageSlug]).map(([notebookSlug, errors]) => ({
      pageSlug,
      notebookSlug,
      errors
    }));
  }
  return { items, clearErrors };
}
function selectCellIsBusy(state, pageSlug, notebookSlug, cellId, kind) {
  var _a, _b;
  return !!((_b = (_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]) === null || _b === void 0 ? void 0 : _b[cellId]);
}
function selectNotebookIsBusy(state, pageSlug, notebookSlug, kind) {
  var _a;
  return !!((_a = state[kind][pageSlug]) === null || _a === void 0 ? void 0 : _a[notebookSlug]);
}
function selectPageIsBusy(state, pageSlug, kind) {
  return !!state[kind][pageSlug];
}

// ../../packages/jupyter/dist/execute/hooks.js
var import_thebe_react3 = __toESM(require_dist3(), 1);
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function useExecutionScope({ clearOutputsOnExecute = false } = {}) {
  var _a;
  const context = import_react75.default.useContext(ExecuteScopeContext);
  const { config } = (0, import_thebe_react3.useThebeConfig)();
  const busy = useBusyScope();
  if (context === void 0) {
    throw new Error("useExecuteScope must be used within a ExecuteScopeProvider");
  }
  const { state, dispatch } = context;
  const start = (0, import_react75.useCallback)((slug) => {
    console.debug(`Jupyter: Starting ${slug}`);
    dispatch({
      type: "REQUEST_BUILD",
      payload: {
        slug
      }
    });
  }, []);
  const execute = (slug) => {
    Object.entries(state.pages[slug].scopes).forEach(([notebookSlug, { notebook }]) => {
      busy.clearError(slug, notebookSlug);
      busy.setNotebook(slug, notebookSlug, notebook.code.map((c6) => c6.id), "execute");
    });
    if (clearOutputsOnExecute) {
      Object.values(state.pages[slug].scopes).forEach(({ notebook }) => {
        notebook.clear();
      });
    }
    setTimeout(() => __awaiter5(this, void 0, void 0, function* () {
      const handler = (_4, data) => {
        var _a2, _b;
        if (data.subject === "cell" && data.status === "idle") {
          const notebookSlug = (_a2 = data.object.notebookId) !== null && _a2 !== void 0 ? _a2 : "unknown";
          busy.clearCell(slug, notebookSlug, (_b = data.id) !== null && _b !== void 0 ? _b : "unknown", "execute");
        }
      };
      config === null || config === void 0 ? void 0 : config.events.on("status", handler);
      yield Promise.all(Object.entries(state.pages[slug].scopes).map((_a2) => __awaiter5(this, [_a2], void 0, function* ([, { notebook }]) {
        const execReturns = yield notebook.executeAll(true);
        const errs = (0, import_thebe_react3.findErrors)(execReturns);
        if (errs != null) {
          console.error("errors", errs);
          busy.setError(slug, notebook.id, errs);
          busy.clearNotebook(slug, notebook.id, "execute");
        }
      })));
      config === null || config === void 0 ? void 0 : config.events.off("status", handler);
    }), 100);
  };
  const clearAll = (0, import_react75.useCallback)((pageSlug) => {
    var _a2;
    Object.entries((_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.scopes).forEach(([, { notebook }]) => {
      notebook.clear();
    });
  }, [state]);
  const resetAll = (0, import_react75.useCallback)((pageSlug) => {
    var _a2;
    Object.entries((_a2 = state.pages[pageSlug]) === null || _a2 === void 0 ? void 0 : _a2.scopes).forEach(([notebookSlug, { notebook, session }]) => {
      busy.clearError(pageSlug, notebookSlug);
      busy.setNotebook(pageSlug, notebookSlug, notebook.code.map((c6) => c6.id), "reset");
      setTimeout(() => {
        var _a3;
        notebook.reset();
        (_a3 = session === null || session === void 0 ? void 0 : session.kernel) === null || _a3 === void 0 ? void 0 : _a3.restart().finally(() => {
          busy.clearNotebook(pageSlug, notebookSlug, "reset");
        });
      }, 300);
    });
  }, [state]);
  const ready = (_a = context.state.pages[context.slug]) === null || _a === void 0 ? void 0 : _a.ready;
  return Object.assign(Object.assign({}, context), { ready, start, clearAll, resetAll, execute });
}
function useNotebookExecution(id, clearOutputsOnExecute = false) {
  var _a, _b;
  const context = import_react75.default.useContext(ExecuteScopeContext);
  const { config } = (0, import_thebe_react3.useThebeConfig)();
  const busy = useBusyScope();
  if (context === void 0) {
    throw new Error("useNotebookExecution must be used within a ExecuteScopeProvider");
  }
  const { state, dispatch, idkmap } = context;
  const target = (_a = idkmap[id]) !== null && _a !== void 0 ? _a : {};
  const { pageSlug, notebookSlug, cellId } = target;
  const start = (0, import_react75.useCallback)(() => {
    dispatch({
      type: "REQUEST_BUILD",
      payload: {
        slug: context.slug
      }
    });
  }, [target]);
  let cell;
  let notebook;
  if (target && state.pages[pageSlug]) {
    notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
    if (notebook)
      cell = notebook === null || notebook === void 0 ? void 0 : notebook.getCellById(cellId);
  }
  const execute = () => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    busy.clearError(pageSlug, notebookSlug);
    busy.setNotebook(pageSlug, notebookSlug, nb.code.map((c6) => c6.id), "execute");
    if (clearOutputsOnExecute)
      nb.clear();
    setTimeout(() => __awaiter5(this, void 0, void 0, function* () {
      const handler = (_4, data) => {
        var _a2;
        if (data.subject === "cell" && data.status === "idle") {
          busy.clearCell(pageSlug, notebookSlug, (_a2 = data.id) !== null && _a2 !== void 0 ? _a2 : "unknown", "execute");
        }
      };
      config === null || config === void 0 ? void 0 : config.events.on("status", handler);
      const execReturns = yield nb.executeAll(true);
      const errs = (0, import_thebe_react3.findErrors)(execReturns);
      if (errs != null) {
        console.error("an error occurred during notebook execution");
        busy.setError(pageSlug, notebookSlug, errs);
        busy.clearNotebook(pageSlug, notebookSlug, "execute");
      }
      config === null || config === void 0 ? void 0 : config.events.off("status", handler);
    }), 100);
  };
  const clear = (0, import_react75.useCallback)(() => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    nb.clear();
  }, [state]);
  const reset = (0, import_react75.useCallback)(() => {
    const nb = selectNotebookForPage(state, pageSlug, notebookSlug);
    busy.clearError(pageSlug, notebookSlug);
    busy.setNotebook(pageSlug, notebookSlug, nb.code.map((c6) => c6.id), "reset");
    setTimeout(() => {
      var _a2, _b2;
      nb.reset();
      (_b2 = (_a2 = nb.session) === null || _a2 === void 0 ? void 0 : _a2.kernel) === null || _b2 === void 0 ? void 0 : _b2.restart().finally(() => {
        busy.clearNotebook(pageSlug, notebookSlug, "reset");
      });
    }, 300);
  }, [state]);
  const ready = (_b = context.state.pages[context.slug]) === null || _b === void 0 ? void 0 : _b.ready;
  const notebookIsExecuting = busy.notebook(pageSlug, notebookSlug, "execute");
  const notebookIsResetting = busy.notebook(pageSlug, notebookSlug, "reset");
  const notebookIsBusy = notebookIsExecuting || notebookIsResetting;
  return Object.assign(Object.assign({}, context), {
    ready,
    start,
    clear,
    reset,
    execute,
    cellIsExecuting: cell ? busy.cell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute") : false,
    notebookIsExecuting,
    notebookIsResetting,
    notebookIsBusy,
    executionCount: cell === null || cell === void 0 ? void 0 : cell.executionCount
  });
}
function useCellExecution(id, clearOutputsOnExecute = false) {
  var _a, _b, _c, _d;
  const busy = useBusyScope();
  const context = import_react75.default.useContext(ExecuteScopeContext);
  if (context === void 0) {
    throw new Error("useCellExecution must be used within a ExecuteScopeProvider");
  }
  const { state, idkmap } = context;
  const target = (_a = idkmap[id]) !== null && _a !== void 0 ? _a : {};
  const { pageSlug, notebookSlug, cellId } = target;
  let cell;
  let notebook;
  if (target && state.pages[pageSlug]) {
    notebook = selectNotebookForPage(state, pageSlug, notebookSlug);
    if (notebook)
      cell = notebook === null || notebook === void 0 ? void 0 : notebook.getCellById(cellId);
  }
  const ready = (_b = context.state.pages[context.slug]) === null || _b === void 0 ? void 0 : _b.ready;
  const kind = (_d = (_c = context.state.pages[context.slug]) === null || _c === void 0 ? void 0 : _c.kind) !== null && _d !== void 0 ? _d : SourceFileKind.Article;
  const execute = (0, import_react75.useCallback)(() => {
    if (!cell) {
      console.error("no cell found on execute", { pageSlug, notebookSlug, cellId });
      return;
    }
    busy.setCell(pageSlug, notebookSlug, cell.id, "execute");
    if (clearOutputsOnExecute)
      cell.clear();
    setTimeout(() => {
      if (!cell)
        throw new Error("no cell found on execute");
      cell.execute().then(() => {
        if (!cell)
          throw new Error("no cell found after execute");
        busy.clearCell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute");
      });
    }, 100);
  }, [state, cell]);
  const clear = (0, import_react75.useCallback)(() => {
    if (!cell) {
      console.error("no cell found on clear", { pageSlug, notebookSlug, cellId });
      return;
    }
    cell.clear();
  }, [state, cell]);
  const notebookIsExecuting = busy.notebook(pageSlug, notebookSlug, "execute");
  const notebookIsResetting = busy.notebook(pageSlug, notebookSlug, "reset");
  const notebookIsBusy = notebookIsExecuting || notebookIsResetting;
  return {
    canCompute: context.canCompute,
    kind,
    ready,
    execute,
    clear,
    cellIsExecuting: cell ? busy.cell(pageSlug, notebookSlug, cell === null || cell === void 0 ? void 0 : cell.id, "execute") : false,
    notebookIsExecuting,
    notebookIsResetting,
    notebookIsBusy,
    cell
  };
}

// ../../packages/jupyter/dist/controls/ArticleCellControls.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_thebe_react4 = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/controls/Buttons.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_classnames47 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/controls/Spinner.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
function Spinner({ size: size5 }) {
  return (0, import_jsx_runtime65.jsxs)("div", { className: "myst-jp-spinner", role: "status", children: [(0, import_jsx_runtime65.jsxs)("svg", { "aria-hidden": "true", width: size5, height: size5, className: "mr-2 text-gray-200 animate-spin dark:text-gray-600 fill-green-600", viewBox: "0 0 100 101", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime65.jsx)("path", { d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z", fill: "currentColor" }), (0, import_jsx_runtime65.jsx)("path", { d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z", fill: "currentFill" })] }), (0, import_jsx_runtime65.jsx)("span", { className: "sr-only", children: "Loading..." })] });
}

// ../../node_modules/swr/dist/immutable/index.mjs
var immutable = (useSWRNext) => (key, fetcher7, config) => {
  config.revalidateOnFocus = false;
  config.revalidateIfStale = false;
  config.revalidateOnReconnect = false;
  return useSWRNext(key, fetcher7, config);
};
var useSWRImmutable = withMiddleware(useSWR, immutable);

// ../../packages/jupyter/dist/hooks.js
var import_react76 = __toESM(require_react(), 1);
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function fetcher6(url) {
  return __awaiter6(this, void 0, void 0, function* () {
    const resp = yield fetch(url);
    if (resp.status === 200) {
      const content = yield resp.text();
      if (url.endsWith(".json")) {
        try {
          const data = JSON.parse(content);
          const keys2 = Object.keys(data);
          if (keys2.length === 2 && keys2.includes("content") && keys2.includes("content_type")) {
            return data;
          }
        } catch (error) {
        }
      }
      return { content };
    }
    throw new Error(`Content returned with status ${resp.status}.`);
  });
}
function useLongContent(content, url) {
  if (typeof document === "undefined") {
    return url ? {} : { data: { content: content !== null && content !== void 0 ? content : "" } };
  }
  const { data, error } = useSWRImmutable(url || null, fetcher6);
  if (!url)
    return { data: { content: content !== null && content !== void 0 ? content : "" } };
  return { data, error };
}
var arrayFetcher = (urls) => {
  return Promise.all(urls.map((url) => fetcher6(url)));
};
function shallowCloneOutputs(outputs) {
  return outputs.map((output) => {
    if ("data" in output && output.data) {
      const data = output.data;
      return Object.assign(Object.assign({}, output), { data: Object.entries(data).reduce((acc, [mimetype, payload]) => {
        return Object.assign(Object.assign({}, acc), { [mimetype]: Object.assign({}, payload) });
      }, {}) });
    }
    return Object.assign({}, output);
  });
}
function useFetchAnyTruncatedContent(outputs) {
  const itemsWithPaths = [];
  const updated = shallowCloneOutputs(outputs);
  walkOutputs(updated, (obj) => {
    if ("content_type" in obj && obj.content_type.startsWith("image/"))
      return;
    if (obj.path) {
      itemsWithPaths.push(obj);
    }
  });
  const paths = itemsWithPaths.map(({ path }) => path);
  const { data, error } = useSWRImmutable(paths, arrayFetcher);
  data === null || data === void 0 ? void 0 : data.forEach(({ content }, idx) => {
    const obj = itemsWithPaths[idx];
    if ("text" in obj) {
      obj.text = content;
    } else if ("traceback" in obj) {
      obj.traceback = content;
    } else {
      obj.content = content;
    }
    obj.path = void 0;
  });
  return {
    data: itemsWithPaths.length === 0 || data ? updated : void 0,
    error
  };
}

// ../../packages/jupyter/dist/controls/Buttons.js
function SpinnerStatusButton({ ready, busy, modified, onClick }) {
  let title = "Enable compute to make this figure interactive";
  if (ready) {
    title = modified ? "The figure has been modified" : "The figure is in its original state";
  }
  let icon = (0, import_jsx_runtime66.jsx)(PowerIcon_default, { width: "1.5rem", height: "1.5rem" });
  if (ready) {
    if (modified) {
      icon = (0, import_jsx_runtime66.jsx)(BoltIcon_default, { width: "1.5rem", height: "1.5rem", className: "text-green-600" });
    } else {
      icon = (0, import_jsx_runtime66.jsx)(BoltIcon_default2, { width: "1.5rem", height: "1.5rem", className: "text-green-600" });
    }
  }
  return (0, import_jsx_runtime66.jsxs)("div", { className: "myst-jp-btn-spinner-status relative flex text-sm", children: [(0, import_jsx_runtime66.jsx)("button", { className: (0, import_classnames47.default)("cursor-pointer text-gray-700 dark:text-white active:text-green-700 hover:opacity-100", {
    "opacity-10": busy,
    "opacity-70": !busy
  }), disabled: ready, title, "aria-label": `status`, onClick: onClick !== null && onClick !== void 0 ? onClick : () => ({}), children: icon }), busy && (0, import_jsx_runtime66.jsx)("span", { className: "myst-jp-btn-spinner-overlay absolute top-0 left-0 z-10 opacity-100", children: (0, import_jsx_runtime66.jsx)(Spinner, { size: 24 }) })] });
}
function SpinnerButton({ ready, icon, busy, disabled, title, onClick }) {
  return (0, import_jsx_runtime66.jsxs)("div", { className: "myst-jp-btn-spinner relative flex text-sm", children: [(0, import_jsx_runtime66.jsx)("button", { className: (0, import_classnames47.default)(" text-gray-700 dark:text-white active:text-green-700 ", {
    "opacity-10 hover:opacity-10": busy,
    "opacity-70": !busy && !disabled,
    "cursor-pointer hover:opacity-100": !disabled,
    "cursor-not-allowed opacity-10 hover:opacity-10": disabled
  }), disabled: disabled || !ready || busy, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "run all cells", "aria-label": title !== null && title !== void 0 ? title : "run all cells", children: icon }), busy && (0, import_jsx_runtime66.jsx)("span", { className: "myst-jp-btn-spinner-overlay absolute top-0 left-0 z-10 opacity-100", children: (0, import_jsx_runtime66.jsx)(Spinner, { size: 24 }) })] });
}
function Run({ ready, executing, disabled, title, onClick }) {
  return (0, import_jsx_runtime66.jsx)(SpinnerButton, { ready, busy: executing, disabled, title: title !== null && title !== void 0 ? title : "run all cells", onClick, icon: (0, import_jsx_runtime66.jsx)(PlayCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "myst-jp-btn-run inline-block align-top" }) });
}
function Restart({ ready, resetting, disabled, title, onClick }) {
  return (0, import_jsx_runtime66.jsx)(SpinnerButton, { ready, busy: resetting, disabled, title: title !== null && title !== void 0 ? title : "reset notebook", onClick, icon: (0, import_jsx_runtime66.jsx)(ArrowUturnLeftIcon_default, { width: "1.5rem", height: "1.5rem", className: "myst-jp-btn-restart inline-block align-top" }) });
}
function Clear({ ready, disabled, title, onClick }) {
  return (0, import_jsx_runtime66.jsx)("button", { className: (0, import_classnames47.default)("myst-jp-btn-clear flex text-gray-700 dark:text-white", {
    "cursor-not-allowed opacity-10": disabled || !ready,
    "active:text-green-700 opacity-70 hover:opacity-100 cursor-pointer": !disabled
  }), disabled: disabled || !ready, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "clear", "aria-label": title !== null && title !== void 0 ? title : "clear", children: (0, import_jsx_runtime66.jsx)(MinusCircleIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}
function Launch({ ready, disabled, title, onClick }) {
  return (0, import_jsx_runtime66.jsx)("button", { className: "myst-jp-btn-launch flex items-center text-gray-700 cursor-pointer dark:text-white active:text-green-700 opacity-70 hover:opacity-100", disabled: disabled || !ready, onClick: () => onClick(), title: title !== null && title !== void 0 ? title : "launch in jupyter", "aria-label": title !== null && title !== void 0 ? title : "launch in jupyter", children: (0, import_jsx_runtime66.jsx)(ArrowTopRightOnSquareIcon_default, { width: "1.5rem", height: "1.5rem", className: "inline-block align-top" }) });
}

// ../../packages/jupyter/dist/controls/ArticleCellControls.js
function ArticleStatusBadge({ id }) {
  const { connect, connecting } = (0, import_thebe_react4.useThebeServer)();
  const { slug, state, start, ready, executionCount } = useNotebookExecution(id);
  const building = selectAreExecutionScopesBuilding(state, slug);
  const handleStart = () => {
    if (!connect) {
      console.debug("ArticleStatusBadge: Trying to start a connection but connect() isn't defined");
      return;
    }
    connect();
    start();
  };
  return (0, import_jsx_runtime67.jsx)(SpinnerStatusButton, { ready, busy: building || connecting, modified: executionCount != null, onClick: handleStart });
}
function ArticleRunNotebook({ id }) {
  const { ready, cellIsExecuting, notebookIsBusy, execute } = useNotebookExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime67.jsx)(Run, { ready, executing: cellIsExecuting, disabled: notebookIsBusy, onClick: execute, title: "Run the notebook that creates this figure" });
}
function ArticleResetNotebook({ id }) {
  const { ready, notebookIsResetting, notebookIsBusy, reset } = useNotebookExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime67.jsx)(Restart, { ready, resetting: notebookIsResetting, disabled: notebookIsBusy, onClick: reset, title: "Reset the figure to its original state and restart the kernel" });
}

// ../../packages/jupyter/dist/decoration.js
var PlaceholderContext = import_react77.default.createContext({});
function PlaceholderProvider({ placeholder: placeholder2, children }) {
  const value = import_react77.default.useMemo(() => ({ placeholder: placeholder2 }), [placeholder2]);
  return (0, import_jsx_runtime68.jsx)(PlaceholderContext.Provider, { value, children });
}
function usePlaceholder() {
  const context = import_react77.default.useContext(PlaceholderContext);
  return context.placeholder;
}
function OutputDecoration({ outputId, placeholder: placeholder2, children, title = "Jupyter Notebook", url, remoteBaseUrl }) {
  const { kind } = useCellExecution(outputId);
  const compute = useComputeOptions();
  const Link2 = useLinkProvider();
  const top = useThemeTop();
  const baseurl = useBaseurl();
  const { inCrossRef } = useXRefState();
  const showComputeControls = (compute === null || compute === void 0 ? void 0 : compute.enabled) && (compute === null || compute === void 0 ? void 0 : compute.features.figureCompute) && kind === SourceFileKind.Article && !remoteBaseUrl && !inCrossRef;
  if (showComputeControls) {
    return (0, import_jsx_runtime68.jsxs)("div", { "data-name": "output-decoration-with-compute-ctrls", className: "mb-4 shadow myst-jp-output-deco", children: [(0, import_jsx_runtime68.jsx)("div", { className: "myst-jp-output-deco-header sticky z-[2] w-full bg-gray-100/80 backdrop-blur dark:bg-neutral-800/80 py-1 px-2", style: { top }, children: (0, import_jsx_runtime68.jsxs)("div", { className: "flex items-center myst-jp-output-deco-inner", children: [(0, import_jsx_runtime68.jsxs)("div", { className: "flex items-center myst-jp-output-deco-source", children: [(0, import_jsx_runtime68.jsx)(JupyterIcon_default, { width: "1.25rem", height: "1.25rem", className: "inline-block" }), (0, import_jsx_runtime68.jsx)("span", { className: "ml-2 myst-jp-output-deco-label", children: "Source:" }), url && (0, import_jsx_runtime68.jsx)(Link2, { to: withBaseurl(url, remoteBaseUrl !== null && remoteBaseUrl !== void 0 ? remoteBaseUrl : baseurl), className: "ml-2 no-underline myst-jp-output-deco-link text-normal hover:underline", children: title })] }), (0, import_jsx_runtime68.jsx)("div", { className: "flex-grow" }), (0, import_jsx_runtime68.jsx)(ArticleStatusBadge, { id: outputId }), (0, import_jsx_runtime68.jsx)(ArticleRunNotebook, { id: outputId }), (0, import_jsx_runtime68.jsx)(ArticleResetNotebook, { id: outputId })] }) }), (0, import_jsx_runtime68.jsx)(PlaceholderProvider, { placeholder: placeholder2, children })] });
  }
  if (kind === SourceFileKind.Article) {
    return (0, import_jsx_runtime68.jsxs)("div", { "data-name": "output-decoration-article", children: [(0, import_jsx_runtime68.jsxs)("div", { className: "flex justify-end items-center text-xsmyst-jp-output-deco-light", children: [(0, import_jsx_runtime68.jsx)(JupyterIcon_default, { width: "0.75rem", height: "0.75rem", className: "inline-block" }), (0, import_jsx_runtime68.jsx)("div", { className: "ml-1 myst-jp-output-deco-label", children: "Source:" }), url && (0, import_jsx_runtime68.jsx)(Link2, { to: withBaseurl(url, remoteBaseUrl !== null && remoteBaseUrl !== void 0 ? remoteBaseUrl : baseurl), className: "ml-1 no-underline myst-jp-output-deco-link text-normal hover:underline", children: title })] }), (0, import_jsx_runtime68.jsx)(PlaceholderProvider, { placeholder: placeholder2, children })] });
  }
  return (0, import_jsx_runtime68.jsx)("div", { "data-name": "output-decoration-notebook-output", children });
}

// ../../packages/jupyter/dist/embed.js
function Embed({ node }) {
  var _a, _b, _c, _d, _e2, _f, _g;
  const output = (_a = node.children) === null || _a === void 0 ? void 0 : _a.find((child) => child.type === "output");
  const outputs = (_b = node.children) === null || _b === void 0 ? void 0 : _b.find((child) => child.type === "outputs");
  if (outputs) {
    return (0, import_jsx_runtime69.jsx)(OutputDecoration, { outputId: (_c = outputs.id) !== null && _c !== void 0 ? _c : outputs.key, title: (_d = node.source) === null || _d === void 0 ? void 0 : _d.title, url: (_e2 = node.source) === null || _e2 === void 0 ? void 0 : _e2.url, remoteBaseUrl: (_f = node.source) === null || _f === void 0 ? void 0 : _f.remoteBaseUrl, children: (0, import_jsx_runtime69.jsx)(OutputsContextProvider, { outputsId: (_g = outputs.id) !== null && _g !== void 0 ? _g : outputs.key, children: (0, import_jsx_runtime69.jsx)(MyST, { ast: node.children }) }) }, node.key);
  } else if (output) {
    return (0, import_jsx_runtime69.jsx)(OutputsContextProvider, { outputsId: output.key, children: (0, import_jsx_runtime69.jsx)(MyST, { ast: node.children }) });
  }
  return (0, import_jsx_runtime69.jsx)(MyST, { ast: node.children });
}

// ../../packages/jupyter/dist/outputs.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_classnames49 = __toESM(require_classnames(), 1);
var import_react79 = __toESM(require_react(), 1);

// ../../packages/jupyter/dist/active.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react78 = __toESM(require_react(), 1);
var import_classnames48 = __toESM(require_classnames(), 1);
var import_thebe_react5 = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/convertImages.js
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject4) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject4(e3);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function requestImageAsBase64String(src) {
  return __awaiter7(this, void 0, void 0, function* () {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    const base64String = new Promise((resolve, reject4) => {
      img.onload = function ol() {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          console.error("Could not get canvas context");
          return reject4();
        }
        canvas.height = img.naturalHeight;
        canvas.width = img.naturalWidth;
        ctx.drawImage(img, 0, 0);
        const dataURL = canvas.toDataURL("image/png");
        const [, base64] = dataURL.split(";base64,");
        resolve(base64);
      };
      img.src = src;
    });
    return base64String;
  });
}
function fetchAndEncodeOutputImages(outputs) {
  return __awaiter7(this, void 0, void 0, function* () {
    return Promise.all(outputs.map((output) => __awaiter7(this, void 0, void 0, function* () {
      if (!("data" in output))
        return output;
      const imageMimetypes = Object.keys(output.data).filter((mimetype) => mimetype !== "image/svg" && mimetype !== "image/svg+xml" && mimetype.startsWith("image/"));
      if (imageMimetypes.length === 0)
        return output;
      const images = yield Promise.all(imageMimetypes.map((mimetype) => __awaiter7(this, void 0, void 0, function* () {
        const data = output.data[mimetype];
        if (data.path) {
          const base64 = yield requestImageAsBase64String(data.path);
          return Object.assign(Object.assign({}, data), { content: base64 });
        }
        return data;
      })));
      imageMimetypes.forEach((mimetype, i6) => {
        output.data[mimetype] = images[i6];
      });
      return output;
    })));
  });
}

// ../../packages/jupyter/dist/active.js
function ActiveOutputRenderer({ outputsId, initialData, core }) {
  var _a;
  const exec = useCellExecution(outputsId);
  const placeholder2 = usePlaceholder();
  const ref = (0, import_react78.useRef)(null);
  (0, import_react78.useEffect)(() => {
    var _a2, _b, _c;
    if (!ref.current || !(exec === null || exec === void 0 ? void 0 : exec.cell)) {
      console.debug(`Jupyter: No cell ref available for cell ${outputsId}:${(_a2 = exec === null || exec === void 0 ? void 0 : exec.cell) === null || _a2 === void 0 ? void 0 : _a2.id}`);
      return;
    }
    const verb = exec.cell.isAttachedToDOM ? "reattaching" : "attaching";
    console.debug(`${verb} cell ${exec.cell.id} to DOM at:`, {
      el: ref.current,
      connected: ref.current.isConnected,
      data: (_b = core === null || core === void 0 ? void 0 : core.stripWidgets(initialData)) !== null && _b !== void 0 ? _b : initialData
    });
    exec.cell.attachToDOM(ref.current);
    if (exec.cell.executionCount == null) {
      exec.cell.initOutputs((_c = core === null || core === void 0 ? void 0 : core.stripWidgets(initialData, true, placeholder2 ? () => "" : void 0)) !== null && _c !== void 0 ? _c : initialData);
    }
  }, [ref === null || ref === void 0 ? void 0 : ref.current, exec === null || exec === void 0 ? void 0 : exec.cell]);
  const executed = ((_a = exec === null || exec === void 0 ? void 0 : exec.cell) === null || _a === void 0 ? void 0 : _a.executionCount) != null;
  console.debug(`Jupyter: Cell ${outputsId} executed: ${executed}; Show output: ${executed || !placeholder2}`);
  return (0, import_jsx_runtime70.jsxs)("div", { children: [(0, import_jsx_runtime70.jsx)("div", { ref, "data-thebe-active-ref": "true", className: (0, import_classnames48.default)("relative", { "invisible h-0": !executed && placeholder2 }) }), exec.ready && placeholder2 && !executed && (0, import_jsx_runtime70.jsx)(MyST, { ast: placeholder2 })] });
}
function ActiveJupyterCellOutputs({ outputsId, outputs }) {
  const { core, load: load2 } = (0, import_thebe_react5.useThebeLoader)();
  const { inCrossRef } = useXRefState();
  const exec = useCellExecution(outputsId);
  const { data, error } = useFetchAnyTruncatedContent(outputs);
  const [fullOutputs, setFullOutputs] = (0, import_react78.useState)(null);
  (0, import_react78.useEffect)(() => {
    if (core)
      return;
    load2();
  }, [core, load2]);
  (0, import_react78.useEffect)(() => {
    if (!data || fullOutputs != null)
      return;
    fetchAndEncodeOutputImages(data).then((out) => {
      const compactOutputs = convertToIOutputs(out, {});
      setFullOutputs(compactOutputs);
    });
  }, [outputsId, data, fullOutputs]);
  if (error) {
    console.error(error);
    return (0, import_jsx_runtime70.jsxs)("div", { className: "text-red-500", children: ["Error rendering output: ", error.message] });
  }
  if (!inCrossRef && (exec === null || exec === void 0 ? void 0 : exec.ready)) {
    return (0, import_jsx_runtime70.jsxs)("div", { children: [!fullOutputs && (0, import_jsx_runtime70.jsx)("div", { className: "p-2.5", children: "Fetching full output data..." }), core && fullOutputs && (0, import_jsx_runtime70.jsx)(ActiveOutputRenderer, { outputsId, initialData: fullOutputs, core }, outputsId)] });
  }
  return (0, import_jsx_runtime70.jsx)("div", { children: "ActiveJupyterCellOutputs in cross reference" });
}

// ../../packages/jupyter/dist/outputs.js
function Outputs({ node }) {
  var _a;
  const className = (0, import_classnames49.default)({ hidden: node.visibility === "remove" });
  const { children, identifier, align } = node;
  const outputsId = (_a = node.id) !== null && _a !== void 0 ? _a : node.key;
  const cellExecutionContext = useCellExecution(outputsId);
  const { ready } = cellExecutionContext;
  const legacyOutputsArray = (0, import_react79.useMemo)(() => {
    return selectAll("output", node).map((child) => child.jupyter_data);
  }, [children]);
  const atLeastOneChildHasJupyterData = legacyOutputsArray.length > 0;
  const placeholder2 = usePlaceholder();
  if (!ready && placeholder2) {
    return (0, import_jsx_runtime71.jsx)(MyST, { ast: placeholder2 });
  }
  if (!ready) {
    const passiveOutputs = (0, import_jsx_runtime71.jsx)("div", { "data-name": "outputs-container", id: identifier || void 0, "data-mdast-node-id": outputsId, className: (0, import_classnames49.default)("max-w-full overflow-y-visible overflow-x-auto m-0 group not-prose relative", {
      "text-left": !align || align === "left",
      "text-center": align === "center",
      "text-right": align === "right",
      "mb-5": atLeastOneChildHasJupyterData
    }, className), children: (0, import_jsx_runtime71.jsx)(OutputsContextProvider, { outputsId, children: (0, import_jsx_runtime71.jsx)(MyST, { ast: children }) }) });
    if (node.visibility === "hide") {
      return (0, import_jsx_runtime71.jsx)(Details, { title: "Output", children: passiveOutputs });
    }
    return passiveOutputs;
  }
  return (0, import_jsx_runtime71.jsx)(ActiveJupyterCellOutputs, { outputsId, outputs: legacyOutputsArray });
}

// ../../packages/jupyter/dist/output.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/safe.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/stream.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);

// ../../node_modules/@curvenote/ansi-to-react/dist/index.js
var import_anser = __toESM(require_lib4(), 1);
var import_escape_carriage = __toESM(require_escape_carriage(), 1);
var React111 = __toESM(require_react(), 1);
function ansiToJSON(input, use_classes = false) {
  input = (0, import_escape_carriage.escapeCarriageReturn)(fixBackspace(input));
  return import_anser.default.ansiToJson(input, {
    json: true,
    remove_empty: true,
    use_classes
  });
}
function createClass(bundle) {
  let classNames52 = "";
  if (bundle.bg) {
    classNames52 += `${bundle.bg}-bg `;
  }
  if (bundle.fg) {
    classNames52 += `${bundle.fg}-fg `;
  }
  if (bundle.decoration) {
    classNames52 += `ansi-${bundle.decoration} `;
  }
  if (classNames52 === "") {
    return null;
  }
  classNames52 = classNames52.substring(0, classNames52.length - 1);
  return classNames52;
}
function createStyle(bundle) {
  const style = {};
  if (bundle.bg) {
    style.backgroundColor = `rgb(${bundle.bg})`;
  }
  if (bundle.fg) {
    style.color = `rgb(${bundle.fg})`;
  }
  switch (bundle.decoration) {
    case "bold":
      style.fontWeight = "bold";
      break;
    case "dim":
      style.opacity = "0.5";
      break;
    case "italic":
      style.fontStyle = "italic";
      break;
    case "hidden":
      style.visibility = "hidden";
      break;
    case "strikethrough":
      style.textDecoration = "line-through";
      break;
    case "underline":
      style.textDecoration = "underline";
      break;
    case "blink":
      style.textDecoration = "blink";
      break;
    default:
      break;
  }
  return style;
}
function convertBundleIntoReact(linkify, useClasses, bundle, key) {
  const style = useClasses ? null : createStyle(bundle);
  const className = useClasses ? createClass(bundle) : null;
  if (!linkify) {
    return React111.createElement("span", { style, key, className }, bundle.content);
  }
  const content = [];
  const linkRegex = /(\s|^)(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/g;
  let index2 = 0;
  let match;
  while ((match = linkRegex.exec(bundle.content)) !== null) {
    const [, pre, url] = match;
    const startIndex = match.index + pre.length;
    if (startIndex > index2) {
      content.push(bundle.content.substring(index2, startIndex));
    }
    const href = url.startsWith("www.") ? `http://${url}` : url;
    content.push(React111.createElement("a", {
      key: index2,
      href,
      target: "_blank"
    }, `${url}`));
    index2 = linkRegex.lastIndex;
  }
  if (index2 < bundle.content.length) {
    content.push(bundle.content.substring(index2));
  }
  return React111.createElement("span", { style, key, className }, content);
}
function Ansi(props) {
  const { className, useClasses, children, linkify } = props;
  return React111.createElement("code", { className }, ansiToJSON(children !== null && children !== void 0 ? children : "", useClasses !== null && useClasses !== void 0 ? useClasses : false).map(convertBundleIntoReact.bind(null, linkify !== null && linkify !== void 0 ? linkify : false, useClasses !== null && useClasses !== void 0 ? useClasses : false)));
}
function fixBackspace(txt) {
  let tmp = txt;
  do {
    txt = tmp;
    tmp = txt.replace(/[^\n]\x08/gm, "");
  } while (tmp.length < txt.length);
  return txt;
}

// ../../packages/jupyter/dist/components.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react80 = __toESM(require_react(), 1);
var MaybeLongContent = ({ content, path, render }) => {
  const { error, data } = useLongContent(content, path);
  if (error) {
    return (0, import_jsx_runtime72.jsxs)("div", { className: "myst-jp-long-error text-red-500", children: ["Error loading content: ", error.message] });
  }
  if (!data) {
    return (0, import_jsx_runtime72.jsx)("div", { className: "myst-jp-long-loading", children: "Fetching long content...." });
  }
  return (0, import_jsx_runtime72.jsx)("div", { children: render(data.content) });
};

// ../../packages/jupyter/dist/stream.js
function Stream({ output }) {
  return (0, import_jsx_runtime73.jsx)(MaybeLongContent, { content: ensureString(output.text), path: output.path, render: (content) => (0, import_jsx_runtime73.jsx)("pre", { className: "myst-jp-stream-output text-sm font-thin font-system", children: (0, import_jsx_runtime73.jsx)(Ansi, { children: content !== null && content !== void 0 ? content : "" }) }) });
}

// ../../packages/jupyter/dist/error.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
function Error2({ output }) {
  return (0, import_jsx_runtime74.jsx)(MaybeLongContent, { content: ensureString(output.traceback), path: output.path, render: (content) => {
    return (0, import_jsx_runtime74.jsx)("pre", { className: "myst-jp-error-output text-sm font-thin font-system jupyter-error", children: (0, import_jsx_runtime74.jsx)(Ansi, { children: content !== null && content !== void 0 ? content : "" }) });
  } });
}

// ../../packages/jupyter/dist/safe.js
var RENDER_PRIORITY = [
  KnownCellOutputMimeTypes.ImagePng,
  KnownCellOutputMimeTypes.ImageJpeg,
  KnownCellOutputMimeTypes.ImageGif,
  KnownCellOutputMimeTypes.ImageBmp
];
function findSafeMimeOutputs(output) {
  const data = output.data;
  const image = RENDER_PRIORITY.reduce((acc, mimetype) => {
    if (acc)
      return acc;
    if (data && data[mimetype])
      return data[mimetype];
    return void 0;
  }, void 0);
  const text = data && data["text/plain"];
  return { image, text };
}
function OutputImage({ image, text }) {
  var _a;
  return (0, import_jsx_runtime75.jsx)("img", { src: image === null || image === void 0 ? void 0 : image.path, alt: (_a = text === null || text === void 0 ? void 0 : text.content) !== null && _a !== void 0 ? _a : "Image produced in Jupyter" });
}
function SafeOutput({ output }) {
  switch (output.output_type) {
    case "stream":
      return (0, import_jsx_runtime75.jsx)("div", { "data-name": "safe-output-stream", children: (0, import_jsx_runtime75.jsx)(Stream, { output }) });
    case "error":
      return (0, import_jsx_runtime75.jsx)("div", { "data-name": "safe-output-error", children: (0, import_jsx_runtime75.jsx)(Error2, { output }) });
    case "display_data":
    case "execute_result":
    case "update_display_data": {
      const { image, text } = findSafeMimeOutputs(output);
      if (!image && !text)
        return null;
      if (image)
        return (0, import_jsx_runtime75.jsx)("div", { "data-name": "safe-output-image", children: (0, import_jsx_runtime75.jsx)(OutputImage, { image, text }) });
      if (text)
        return (0, import_jsx_runtime75.jsx)("div", { "data-name": "safe-output-text", className: "font-mono text-sm whitespace-pre-wrap myst-jp-safe-output-text", children: (0, import_jsx_runtime75.jsx)(Ansi, { children: text.content }) });
      return null;
    }
    default:
      console.warn(`Unknown output_type ${output["output_type"]}`);
      return null;
  }
}

// ../../packages/jupyter/dist/jupyter.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);
var import_thebe_react6 = __toESM(require_dist3(), 1);

// ../../packages/jupyter/dist/passive.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
function PassiveOutputRenderer({ id, data, core }) {
  const rendermime = core.makeRenderMimeRegistry();
  const cell = (0, import_react81.useRef)(new core.PassiveCellRenderer(id, rendermime, void 0));
  const ref = (0, import_react81.useRef)(null);
  const { loaded } = usePlotlyPassively(rendermime, [data]);
  (0, import_react81.useEffect)(() => {
    var _a, _b;
    if (!ref.current || !loaded)
      return;
    cell.current.attachToDOM((_a = ref.current) !== null && _a !== void 0 ? _a : void 0, true);
    cell.current.render((_b = core === null || core === void 0 ? void 0 : core.stripWidgets([data])) !== null && _b !== void 0 ? _b : data);
  }, [ref, loaded]);
  return (0, import_jsx_runtime76.jsx)("div", { ref, "data-thebe-passive-ref": "true", "data-output-id": id });
}

// ../../packages/jupyter/dist/jupyter.js
var JupyterOutput = import_react82.default.memo(({ outputsId, output }) => {
  const { core, load: load2 } = (0, import_thebe_react6.useThebeLoader)();
  const { data, error } = useFetchAnyTruncatedContent([output]);
  const [fullOutput, setFullOutput] = (0, import_react82.useState)(null);
  (0, import_react82.useEffect)(() => {
    if (core)
      return;
    load2();
  }, [core, load2]);
  (0, import_react82.useEffect)(() => {
    if (!data || fullOutput != null)
      return;
    fetchAndEncodeOutputImages(data).then((out) => {
      const compactOutputs = convertToIOutputs(out, {});
      setFullOutput(compactOutputs[0]);
    });
  }, [outputsId, data, fullOutput]);
  if (error) {
    console.error(error);
    return (0, import_jsx_runtime77.jsxs)("div", { className: "text-red-500", children: ["Error rendering output: ", error.message] });
  }
  return (0, import_jsx_runtime77.jsxs)("div", { children: [!fullOutput && (0, import_jsx_runtime77.jsx)("div", { className: "p-2.5", children: "Loading..." }), fullOutput && core && (0, import_jsx_runtime77.jsx)(PassiveOutputRenderer, { id: outputsId, data: fullOutput, core, kind: SourceFileKind.Notebook })] });
});

// ../../packages/jupyter/dist/output.js
var import_react83 = __toESM(require_react(), 1);
var DIRECT_OUTPUT_TYPES = /* @__PURE__ */ new Set(["stream", "error"]);
var DIRECT_MIME_TYPES = /* @__PURE__ */ new Set([
  KnownCellOutputMimeTypes.TextPlain,
  KnownCellOutputMimeTypes.ImagePng,
  KnownCellOutputMimeTypes.ImageGif,
  KnownCellOutputMimeTypes.ImageJpeg,
  KnownCellOutputMimeTypes.ImageBmp
]);
function isOutputSafe(output, directOutputTypes, directMimeTypes) {
  if (!output)
    return false;
  try {
    if (directOutputTypes.has(output.output_type))
      return true;
    const data = output.data;
    const mimetypes = data ? Object.keys(data) : [];
    return "data" in output && Boolean(output.data) && mimetypes.every((mimetype) => directMimeTypes.has(mimetype));
  } catch (error) {
    console.error(error);
    return false;
  }
}
function validateOutput(output) {
  if (!output || typeof output !== "object") {
    return { isValid: false, reason: "Jupyter output data package is missing or not an object" };
  }
  const outputType = output.output_type;
  if (!("output_type" in output) || typeof outputType !== "string") {
    return { isValid: false, reason: "Missing or invalid output_type property" };
  }
  return { isValid: true };
}
function Output({ node, className }) {
  const { outputsId } = useOutputsContext();
  const { ready } = useCellExecution(outputsId !== null && outputsId !== void 0 ? outputsId : "");
  const maybeSafeOutput = (0, import_react83.useMemo)(() => node.jupyter_data, [node]);
  const isSafe = isOutputSafe(maybeSafeOutput, DIRECT_OUTPUT_TYPES, DIRECT_MIME_TYPES);
  const validation = validateOutput(maybeSafeOutput);
  if (!outputsId || !maybeSafeOutput || !validation.isValid) {
    if (validation.reason) {
      console.error(validation.reason);
    }
    return (0, import_jsx_runtime78.jsx)(Callout, { title: (0, import_jsx_runtime78.jsx)("div", { children: "Cannot render output node" }), color: "red", dropdown: true, Icon: ExclamationTriangleIcon_default, className, children: (0, import_jsx_runtime78.jsxs)("div", { className: "py-2 space-y-1", children: [(0, import_jsx_runtime78.jsx)("div", { children: "Output data package is not compatible with the current renderer." }), validation.reason && (0, import_jsx_runtime78.jsxs)("div", { className: "font-mono text-sm", children: ["Reason: ", validation.reason] })] }) });
  }
  if (isSafe && !ready) {
    return (0, import_jsx_runtime78.jsx)(SafeOutput, { output: maybeSafeOutput });
  }
  return (0, import_jsx_runtime78.jsx)(JupyterOutput, { outputsId, output: maybeSafeOutput });
}

// ../../packages/jupyter/dist/figure.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_classnames50 = __toESM(require_classnames(), 1);
function Figure({ node }) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k;
  const { base: Container } = DEFAULT_RENDERERS["container"];
  const isFromJupyer = ((_a = node.source) === null || _a === void 0 ? void 0 : _a.kind) === SourceFileKind.Notebook;
  const output = (_b = node.children) === null || _b === void 0 ? void 0 : _b.find((child) => child.type === "output");
  const outputs = (_c = node.children) === null || _c === void 0 ? void 0 : _c.find((child) => child.type === "outputs");
  if (isFromJupyer) {
    if (outputs) {
      const placeholder2 = (_d = node.children) === null || _d === void 0 ? void 0 : _d.find((child) => child.type === "image" && child.placeholder);
      const others = (_e2 = node.children) === null || _e2 === void 0 ? void 0 : _e2.filter((child) => !(child.type === "image" && child.placeholder));
      return (0, import_jsx_runtime79.jsx)("figure", { id: node.html_id || node.identifier || node.key, className: (0, import_classnames50.default)("myst-jp-figure", { subcontainer: node.subcontainer }, node.class), children: (0, import_jsx_runtime79.jsx)(OutputDecoration, { outputId: (_f = outputs.id) !== null && _f !== void 0 ? _f : outputs.key, placeholder: placeholder2, title: (_g = node.source) === null || _g === void 0 ? void 0 : _g.title, url: (_h = node.source) === null || _h === void 0 ? void 0 : _h.url, remoteBaseUrl: (_j = node.source) === null || _j === void 0 ? void 0 : _j.remoteBaseUrl, children: (0, import_jsx_runtime79.jsx)(OutputsContextProvider, { outputsId: (_k = outputs.id) !== null && _k !== void 0 ? _k : outputs.key, children: (0, import_jsx_runtime79.jsx)(MyST, { ast: others }) }) }, node.key) });
    } else if (output) {
      return (0, import_jsx_runtime79.jsx)(Callout, { title: (0, import_jsx_runtime79.jsx)("div", { children: "Cannot render embedded output node" }), color: "red", dropdown: true, Icon: ExclamationTriangleIcon_default, className: output.className, children: (0, import_jsx_runtime79.jsx)("div", { className: "py-2", children: "Output data package is not compatible with the current renderer." }) });
    }
  }
  return (0, import_jsx_runtime79.jsx)(Container, { node });
}

// ../../packages/jupyter/dist/block.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_classnames52 = __toESM(require_classnames(), 1);

// ../../packages/jupyter/dist/controls/NotebookCellControls.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
function NotebookRunCell({ id }) {
  const { ready, cellIsExecuting, notebookIsBusy, execute } = useCellExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime80.jsx)(Run, { ready, executing: cellIsExecuting, disabled: notebookIsBusy, onClick: execute, title: "Run cell" });
}
function NotebookRunCellSpinnerOnly({ id }) {
  const { ready, cellIsExecuting } = useCellExecution(id);
  if (!ready || !cellIsExecuting)
    return null;
  return (0, import_jsx_runtime80.jsx)(Run, { ready, executing: cellIsExecuting, disabled: true, onClick: () => ({}), title: "executing cell..." });
}
function NotebookClearCell({ id }) {
  const { ready, notebookIsBusy, clear } = useCellExecution(id);
  if (!ready)
    return null;
  return (0, import_jsx_runtime80.jsx)(Clear, { ready, disabled: notebookIsBusy, onClick: clear, title: "Clear cell outputs" });
}

// ../../packages/jupyter/dist/controls/NotebookToolbar.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_thebe_react7 = __toESM(require_dist3(), 1);
var import_classnames51 = __toESM(require_classnames(), 1);
function NotebookToolbar({ showLaunch = false }) {
  const { slug, ready, state, start, resetAll, clearAll, execute } = useExecutionScope();
  const busy = useBusyScope();
  const { connecting, connect, ready: serverReady, server, error: serverError } = (0, import_thebe_react7.useThebeServer)();
  const computable = selectIsComputable(state, slug);
  const handleStart = () => {
    if (!connect) {
      console.debug("NotebookToolbar: Trying to start a connection but connect() isn't defined");
      return;
    }
    connect();
    start(slug);
  };
  const handleReset = () => resetAll(slug);
  const handleClear = () => clearAll(slug);
  const handleRun = () => execute(slug);
  const handleLaunch = () => {
    if (!serverReady || !(server === null || server === void 0 ? void 0 : server.settings))
      return;
    window.open(`${server.settings.baseUrl}?token=${server.settings.token}`, "_blank");
  };
  const building = selectAreExecutionScopesBuilding(state, slug);
  const status = selectExecutionScopeStatus(state, slug);
  const error = !!serverError;
  let title = "Connect to a compute server";
  if (error) {
    title = "Error connecting to a compute server";
  } else if (building) {
    if (status == "pending") {
      title = "Pending...";
    } else if (status == "fetching") {
      title = "Fetching...";
    } else if (status == "build-notebooks") {
      title = "Building notebooks...";
    } else if (status == "wait-for-server") {
      title = "Waiting for server...";
    } else if (status == "start-session") {
      title = "Starting session...";
    } else if (status == "error") {
      title = "Error";
    } else {
      title = "Unknown";
    }
  }
  if (computable)
    return (0, import_jsx_runtime81.jsx)("div", { className: "myst-jp-nb-toolbar sticky top-[60px] pb-[14px] flex justify-end w-full z-20 pointer-events-none", children: (0, import_jsx_runtime81.jsxs)("div", { className: "myst-jp-nb-toolbar-inner flex p-1 m-1 space-x-1 border rounded-full shadow pointer-events-auto border-stone-300 bg-white/80 dark:bg-stone-900/80 backdrop-blur", children: [!ready && (0, import_jsx_runtime81.jsxs)("div", { className: "myst-jp-nb-toolbar-power rounded", children: [(0, import_jsx_runtime81.jsx)("button", { className: (0, import_classnames51.default)("myst-jp-nb-toolbar-power-btn flex text-center rounded-full cursor-pointer text-stone-800 dark:text-white hover:opacity-100 opacity-60", {
      "opacity-10 text-stone-100 dark:text-stone-700": connecting || building
    }), onClick: handleStart, disabled: building, "aria-label": "start compute environment", children: (0, import_jsx_runtime81.jsx)(PowerIcon_default, { className: "inline-block w-6 h-6 align-top", title: "Launch kernel" }) }), (connecting || building) && !error && (0, import_jsx_runtime81.jsx)("span", { className: "myst-jp-nb-toolbar-spinner absolute top-1 left-1 z-10 w-[22px] h-[22px] opacity-100", title, children: (0, import_jsx_runtime81.jsx)(Spinner, { size: 24 }) })] }), ready && (0, import_jsx_runtime81.jsx)(Run, { ready, executing: busy.page(slug, "execute"), onClick: handleRun, title: "Run all cells" }), ready && (0, import_jsx_runtime81.jsx)(Restart, { ready, resetting: busy.page(slug, "reset"), onClick: handleReset, disabled: busy.page(slug, "execute"), title: "Reset notebook and restart kernel" }), ready && (0, import_jsx_runtime81.jsx)(Clear, { ready, disabled: busy.page(slug, "execute") || busy.page(slug, "reset"), onClick: handleClear, title: "Clear all cells" }), showLaunch && ready && (0, import_jsx_runtime81.jsx)(Launch, { ready, disabled: false, onClick: handleLaunch, title: "Launch notebook in Jupyter" })] }) });
  return null;
}

// ../../packages/jupyter/dist/block.js
function NotebookBlock({ node, className }) {
  var _a, _b, _c, _d;
  const pageKind = usePageKind();
  const block = (0, import_jsx_runtime82.jsxs)("div", { id: (_b = (_a = node.html_id) !== null && _a !== void 0 ? _a : node.identifier) !== null && _b !== void 0 ? _b : node.key, className: (0, import_classnames52.default)("myst-jp-nb-block relative group/block", className, node.class, {
    [(_c = node.data) === null || _c === void 0 ? void 0 : _c.class]: typeof ((_d = node.data) === null || _d === void 0 ? void 0 : _d.class) === "string",
    hidden: node.visibility === "remove"
  }), children: [pageKind === SourceFileKind.Notebook && node.kind === "notebook-code" && (0, import_jsx_runtime82.jsxs)(import_jsx_runtime82.Fragment, { children: [(0, import_jsx_runtime82.jsx)("div", { className: "myst-jp-nb-block-spinner flex sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:hidden", children: (0, import_jsx_runtime82.jsx)("div", { className: "flex absolute top-0 right-0", children: (0, import_jsx_runtime82.jsx)(NotebookRunCellSpinnerOnly, { id: `spinner-${node.key}` }) }) }), (0, import_jsx_runtime82.jsx)("div", { className: "myst-jp-nb-block sticky top-[115px] z-10 opacity-90 group-hover/block:opacity-100 group-hover/block:flex", children: (0, import_jsx_runtime82.jsxs)("div", { className: "absolute -top-[12px] right-0 flex flex-row rounded bg-white dark:bg-slate-800", children: [(0, import_jsx_runtime82.jsx)(NotebookRunCell, { id: `run-${node.key}` }), (0, import_jsx_runtime82.jsx)(NotebookClearCell, { id: `clear-${node.key}` })] }) })] }), (0, import_jsx_runtime82.jsx)(MyST, { ast: node.children })] });
  if (node.visibility === "hide") {
    return (0, import_jsx_runtime82.jsx)(Details, { title: "Notebook Cell", children: block });
  }
  return block;
}
var NOTEBOOK_BLOCK_RENDERERS = {
  block: {
    "block[kind=notebook-code],block[kind=notebook-content]": NotebookBlock
  }
};

// ../../packages/jupyter/dist/renderers.js
var OUTPUT_RENDERERS = {
  outputs: Outputs,
  output: Output,
  embed: Embed,
  container: Figure
};
var JUPYTER_RENDERERS = mergeRenderers([OUTPUT_RENDERERS, NOTEBOOK_BLOCK_RENDERERS]);

// ../../packages/jupyter/dist/BinderBadge.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);

// ../../packages/jupyter/dist/ErrorTray.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react84 = __toESM(require_react(), 1);
var import_thebe_react8 = __toESM(require_dist3(), 1);
function ErrorDecoration({ children, idx }) {
  return (0, import_jsx_runtime84.jsxs)("div", { className: "myst-jp-error-tray-decoration relative py-3 mx-2 my-8 border rounded", children: [(0, import_jsx_runtime84.jsx)("div", { className: "myst-jp-error-tray-cell absolute z-10 flex items-center bg-white -top-3 -left-2", children: idx && (0, import_jsx_runtime84.jsxs)("div", { className: "myst-jp-error-tray-cell-number ml-1 text-sm text-gray-500", children: ["cell #: ", idx + 1] }) }), (0, import_jsx_runtime84.jsx)("div", { className: "myst-jp-error-tray-content mx-3", children })] });
}
function ErrorTrayMessage({ errors }) {
  const { core } = (0, import_thebe_react8.useThebeLoader)();
  const [cells, setCells] = (0, import_react84.useState)([]);
  const [refs, setRefs] = (0, import_react84.useState)([]);
  (0, import_react84.useEffect)(() => {
    if (!core)
      return;
    const cs = errors.map(() => new core.PassiveCellRenderer("any"));
    setRefs(errors.map((_4, idx) => (node) => {
      var _a;
      if (node) {
        cs[idx].attachToDOM(node);
        cs[idx].render((_a = errors[idx].error) !== null && _a !== void 0 ? _a : []);
      }
    }));
    setCells(cells);
  }, [core, errors]);
  if (!core)
    return null;
  return (0, import_jsx_runtime84.jsx)("div", { children: errors.map((error, idx) => (0, import_jsx_runtime84.jsx)("div", { className: "myst-jp-error-tray-item not-prose min-w-[400px]", children: (0, import_jsx_runtime84.jsx)(ErrorDecoration, { idx: error.index, children: (0, import_jsx_runtime84.jsx)("div", { className: "z-100", ref: refs[idx] }, error.id) }) }, `error-${error.id}`)) });
}
function ErrorTray({ pageSlug, index: index2 }) {
  const { items } = useBusyErrors(pageSlug);
  if (!items || items.length === 0)
    return null;
  if (index2 && index2)
    return null;
  return (0, import_jsx_runtime84.jsx)("div", { className: "myst-jp-error-tray relative px-4 pt-3 my-8 text-sm text-red-600 border border-red-400 rounded border-1", children: items.map(({ notebookSlug, errors }, i6) => {
    return (0, import_jsx_runtime84.jsxs)("div", { children: [(0, import_jsx_runtime84.jsxs)("div", { children: [(0, import_jsx_runtime84.jsx)("span", { className: "font-bold", children: "Error" }), " in notebook ", (0, import_jsx_runtime84.jsxs)("span", { children: ['"', notebookSlug, '"'] })] }), (0, import_jsx_runtime84.jsx)(ErrorTrayMessage, { errors })] }, `${notebookSlug}-${i6}`);
  }) });
}

// ../../packages/jupyter/dist/ConnectionStatusTray.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);
var import_thebe_react9 = __toESM(require_dist3(), 1);
function ConnectionStatusTray({ waitForSessions }) {
  var _a, _b, _c;
  const options = useComputeOptions();
  const { connecting, ready: serverReady, error: serverError, events } = (0, import_thebe_react9.useThebeServer)();
  const { slug, ready: scopeReady, state } = useExecutionScope();
  const [show, setShow] = (0, import_react85.useState)(false);
  const [unsub, setUnsub] = (0, import_react85.useState)();
  const [status, setStatus] = (0, import_react85.useState)("[client] Connecting...");
  const error = serverError;
  const ready = serverReady && (!waitForSessions || scopeReady);
  const busy = connecting || selectAreExecutionScopesBuilding(state, slug);
  const handleStatus = (event, data) => {
    setStatus(`[${data.subject}]: ${data.message}`);
  };
  (0, import_react85.useEffect)(() => {
    if (!events)
      return;
    events.on("status", handleStatus);
  }, [events]);
  (0, import_react85.useEffect)(() => {
    if (!(options === null || options === void 0 ? void 0 : options.thebe))
      return;
    if (busy || error) {
      setShow(true);
    } else if (ready) {
      setTimeout(() => {
        setShow(false);
        unsub === null || unsub === void 0 ? void 0 : unsub();
        setUnsub(void 0);
      }, 1e3);
    }
  }, [options, busy, ready, error]);
  const host = ((_a = options === null || options === void 0 ? void 0 : options.thebe) === null || _a === void 0 ? void 0 : _a.useBinder) ? "Jupyter" : ((_b = options === null || options === void 0 ? void 0 : options.thebe) === null || _b === void 0 ? void 0 : _b.useJupyterLite) ? "JupyterLite" : "Local Server";
  if (show && error) {
    return (0, import_jsx_runtime85.jsxs)("div", { className: "myst-jp-connect-status-tray fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime85.jsxs)("div", { className: "myst-jp-connect-status-header mb-2 font-semibold text-center", children: ["\u26D4\uFE0F Error connecting to ", host, " \u26D4\uFE0F"] }), (0, import_jsx_runtime85.jsx)("div", { className: "myst-jp-connect-status-message my-1 max-h-[15rem] mono overflow-hidden text-ellipsis", children: error }), (0, import_jsx_runtime85.jsx)("div", { className: "myst-jp-connect-status-dismiss flex justify-end", children: (0, import_jsx_runtime85.jsx)("div", { className: "myst-jp-connect-status-dismiss-btn text-xs cursor-pointer hover:underline", role: "button", onClick: () => setShow(false), children: "dismiss" }) })] });
  }
  if (show && ((_c = options === null || options === void 0 ? void 0 : options.thebe) === null || _c === void 0 ? void 0 : _c.useJupyterLite)) {
    return (0, import_jsx_runtime85.jsxs)("div", { className: "myst-jp-connect-status-tray fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime85.jsxs)("div", { className: "myst-jp-connect-status-header mb-1 font-semibold text-center", children: ["\u26A1\uFE0F Connecting to ", host, " \u26A1\uFE0F"] }), !ready && (0, import_jsx_runtime85.jsx)("div", { className: "myst-jp-connect-status-notready max-h-[5rem] mono overflow-hidden text-ellipsis", children: status }), ready && (0, import_jsx_runtime85.jsx)("div", { className: "myst-jp-connect-status-message max-h-[15rem] mono overflow-hidden text-ellipsis", children: "The in-browser JupyterLite server is ready, press run anytime." })] });
  }
  if (show) {
    return (0, import_jsx_runtime85.jsxs)("div", { className: "myst-jp-connect-status-tray fixed p-3 z-[11] text-sm text-gray-700 bg-white border rounded shadow-lg bottom-2 sm:right-2 max-w-[90%] md:max-w-[300px] min-w-0", children: [(0, import_jsx_runtime85.jsxs)("div", { className: "myst-jp-connect-status-header mb-1 font-semibold text-center", children: ["\u26A1\uFE0F Connecting to ", host, " \u26A1\uFE0F"] }), (0, import_jsx_runtime85.jsx)("div", { className: "myst-jp-connect-status-message max-h-[15rem] mono overflow-hidden text-ellipsis", children: status })] });
  }
  return null;
}

export {
  require_loaders,
  extractKnownParts,
  useMediaQuery,
  mergeRenderers,
  useThemeTop,
  useGridSystemProvider,
  ArticleProvider,
  useBaseurl,
  UiStateProvider,
  useSiteManifest,
  SearchFactoryProvider,
  TabStateProvider,
  ProjectProvider,
  useProjectManifest,
  BannerStateProvider,
  useBannerState,
  HashLink,
  ArrowDownTrayIcon_default,
  ArrowTopRightOnSquareIcon_default,
  DocumentArrowDownIcon_default,
  DocumentIcon_default,
  PencilSquareIcon_default,
  ScaleIcon_default,
  composeEventHandlers,
  createContextScope,
  useControllableState,
  useComposedRefs,
  createSlot,
  Primitive,
  createPopperScope,
  Root2,
  Anchor,
  Content,
  Arrow2 as Arrow,
  Portal,
  Presence,
  DismissableLayer,
  MyST,
  ChevronRightIcon_default,
  XMarkIcon_default,
  BinderIcon_default,
  CcByIcon_default,
  CcNcIcon_default,
  CcNdIcon_default,
  CcSaIcon_default,
  CcZeroIcon_default,
  CcIcon_default,
  EmailIcon_default,
  GithubIcon_default,
  JupyterIcon_default,
  OpenAccessIcon_default,
  OrcidIcon_default,
  OsiIcon_default,
  RorIcon_default,
  useId,
  useOutlineHeight,
  DocumentOutline,
  FooterLinksBlock,
  ContentReload,
  Bibliography,
  Footnotes,
  qe,
  useFocusGuards,
  FocusScope,
  hideOthers,
  Combination_default,
  SEARCH_ATTRIBUTES_ORDERED,
  extractField,
  TopNav,
  useSidebarHeight,
  PrimaryNavigation,
  FrontmatterParts,
  BackmatterParts,
  renderers,
  SkipTo,
  ErrorDocumentNotFound,
  ErrorUnhandled,
  getMetaTagsForSite,
  getMetaTagsForArticle,
  Document2 as Document,
  AppErrorBoundary,
  BusyScopeProvider,
  ErrorTray,
  ComputeOptionsProvider,
  useComputeOptions,
  ThebeLoaderAndServer,
  ExecuteScopeProvider,
  ConnectionStatusTray,
  NotebookToolbar,
  JUPYTER_RENDERERS
};
/*! Bundled license information:

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)
*/
//# sourceMappingURL=/build/_shared/chunk-DWWK6LOW.js.map
