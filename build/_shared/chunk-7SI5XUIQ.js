import {
  FRONTMATTER_ALIASES,
  PAGE_KNOWN_PARTS,
  SITE_FRONTMATTER_KEYS
} from "/build/_shared/chunk-Q6DHUCUI.js";
import {
  __commonJS,
  __toESM
} from "/build/_shared/chunk-CGOEG7L2.js";

// ../../node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS({
  "../../node_modules/spdx-license-ids/index.json"(exports, module) {
    module.exports = [
      "0BSD",
      "3D-Slicer-1.0",
      "AAL",
      "ADSL",
      "AFL-1.1",
      "AFL-1.2",
      "AFL-2.0",
      "AFL-2.1",
      "AFL-3.0",
      "AGPL-1.0-only",
      "AGPL-1.0-or-later",
      "AGPL-3.0-only",
      "AGPL-3.0-or-later",
      "AMD-newlib",
      "AMDPLPA",
      "AML",
      "AML-glslang",
      "AMPAS",
      "ANTLR-PD",
      "ANTLR-PD-fallback",
      "APAFML",
      "APL-1.0",
      "APSL-1.0",
      "APSL-1.1",
      "APSL-1.2",
      "APSL-2.0",
      "ASWF-Digital-Assets-1.0",
      "ASWF-Digital-Assets-1.1",
      "Abstyles",
      "AdaCore-doc",
      "Adobe-2006",
      "Adobe-Display-PostScript",
      "Adobe-Glyph",
      "Adobe-Utopia",
      "Afmparse",
      "Aladdin",
      "Apache-1.0",
      "Apache-1.1",
      "Apache-2.0",
      "App-s2p",
      "Arphic-1999",
      "Artistic-1.0",
      "Artistic-1.0-Perl",
      "Artistic-1.0-cl8",
      "Artistic-2.0",
      "Artistic-dist",
      "Aspell-RU",
      "BSD-1-Clause",
      "BSD-2-Clause",
      "BSD-2-Clause-Darwin",
      "BSD-2-Clause-Patent",
      "BSD-2-Clause-Views",
      "BSD-2-Clause-first-lines",
      "BSD-2-Clause-pkgconf-disclaimer",
      "BSD-3-Clause",
      "BSD-3-Clause-Attribution",
      "BSD-3-Clause-Clear",
      "BSD-3-Clause-HP",
      "BSD-3-Clause-LBNL",
      "BSD-3-Clause-Modification",
      "BSD-3-Clause-No-Military-License",
      "BSD-3-Clause-No-Nuclear-License",
      "BSD-3-Clause-No-Nuclear-License-2014",
      "BSD-3-Clause-No-Nuclear-Warranty",
      "BSD-3-Clause-Open-MPI",
      "BSD-3-Clause-Sun",
      "BSD-3-Clause-acpica",
      "BSD-3-Clause-flex",
      "BSD-4-Clause",
      "BSD-4-Clause-Shortened",
      "BSD-4-Clause-UC",
      "BSD-4.3RENO",
      "BSD-4.3TAHOE",
      "BSD-Advertising-Acknowledgement",
      "BSD-Attribution-HPND-disclaimer",
      "BSD-Inferno-Nettverk",
      "BSD-Protection",
      "BSD-Source-Code",
      "BSD-Source-beginning-file",
      "BSD-Systemics",
      "BSD-Systemics-W3Works",
      "BSL-1.0",
      "BUSL-1.1",
      "Baekmuk",
      "Bahyph",
      "Barr",
      "Beerware",
      "BitTorrent-1.0",
      "BitTorrent-1.1",
      "Bitstream-Charter",
      "Bitstream-Vera",
      "BlueOak-1.0.0",
      "Boehm-GC",
      "Boehm-GC-without-fee",
      "Borceux",
      "Brian-Gladman-2-Clause",
      "Brian-Gladman-3-Clause",
      "C-UDA-1.0",
      "CAL-1.0",
      "CAL-1.0-Combined-Work-Exception",
      "CATOSL-1.1",
      "CC-BY-1.0",
      "CC-BY-2.0",
      "CC-BY-2.5",
      "CC-BY-2.5-AU",
      "CC-BY-3.0",
      "CC-BY-3.0-AT",
      "CC-BY-3.0-AU",
      "CC-BY-3.0-DE",
      "CC-BY-3.0-IGO",
      "CC-BY-3.0-NL",
      "CC-BY-3.0-US",
      "CC-BY-4.0",
      "CC-BY-NC-1.0",
      "CC-BY-NC-2.0",
      "CC-BY-NC-2.5",
      "CC-BY-NC-3.0",
      "CC-BY-NC-3.0-DE",
      "CC-BY-NC-4.0",
      "CC-BY-NC-ND-1.0",
      "CC-BY-NC-ND-2.0",
      "CC-BY-NC-ND-2.5",
      "CC-BY-NC-ND-3.0",
      "CC-BY-NC-ND-3.0-DE",
      "CC-BY-NC-ND-3.0-IGO",
      "CC-BY-NC-ND-4.0",
      "CC-BY-NC-SA-1.0",
      "CC-BY-NC-SA-2.0",
      "CC-BY-NC-SA-2.0-DE",
      "CC-BY-NC-SA-2.0-FR",
      "CC-BY-NC-SA-2.0-UK",
      "CC-BY-NC-SA-2.5",
      "CC-BY-NC-SA-3.0",
      "CC-BY-NC-SA-3.0-DE",
      "CC-BY-NC-SA-3.0-IGO",
      "CC-BY-NC-SA-4.0",
      "CC-BY-ND-1.0",
      "CC-BY-ND-2.0",
      "CC-BY-ND-2.5",
      "CC-BY-ND-3.0",
      "CC-BY-ND-3.0-DE",
      "CC-BY-ND-4.0",
      "CC-BY-SA-1.0",
      "CC-BY-SA-2.0",
      "CC-BY-SA-2.0-UK",
      "CC-BY-SA-2.1-JP",
      "CC-BY-SA-2.5",
      "CC-BY-SA-3.0",
      "CC-BY-SA-3.0-AT",
      "CC-BY-SA-3.0-DE",
      "CC-BY-SA-3.0-IGO",
      "CC-BY-SA-4.0",
      "CC-PDDC",
      "CC-PDM-1.0",
      "CC-SA-1.0",
      "CC0-1.0",
      "CDDL-1.0",
      "CDDL-1.1",
      "CDL-1.0",
      "CDLA-Permissive-1.0",
      "CDLA-Permissive-2.0",
      "CDLA-Sharing-1.0",
      "CECILL-1.0",
      "CECILL-1.1",
      "CECILL-2.0",
      "CECILL-2.1",
      "CECILL-B",
      "CECILL-C",
      "CERN-OHL-1.1",
      "CERN-OHL-1.2",
      "CERN-OHL-P-2.0",
      "CERN-OHL-S-2.0",
      "CERN-OHL-W-2.0",
      "CFITSIO",
      "CMU-Mach",
      "CMU-Mach-nodoc",
      "CNRI-Jython",
      "CNRI-Python",
      "CNRI-Python-GPL-Compatible",
      "COIL-1.0",
      "CPAL-1.0",
      "CPL-1.0",
      "CPOL-1.02",
      "CUA-OPL-1.0",
      "Caldera",
      "Caldera-no-preamble",
      "Catharon",
      "ClArtistic",
      "Clips",
      "Community-Spec-1.0",
      "Condor-1.1",
      "Cornell-Lossless-JPEG",
      "Cronyx",
      "Crossword",
      "CryptoSwift",
      "CrystalStacker",
      "Cube",
      "D-FSL-1.0",
      "DEC-3-Clause",
      "DL-DE-BY-2.0",
      "DL-DE-ZERO-2.0",
      "DOC",
      "DRL-1.0",
      "DRL-1.1",
      "DSDP",
      "DocBook-DTD",
      "DocBook-Schema",
      "DocBook-Stylesheet",
      "DocBook-XML",
      "Dotseqn",
      "ECL-1.0",
      "ECL-2.0",
      "EFL-1.0",
      "EFL-2.0",
      "EPICS",
      "EPL-1.0",
      "EPL-2.0",
      "EUDatagrid",
      "EUPL-1.0",
      "EUPL-1.1",
      "EUPL-1.2",
      "Elastic-2.0",
      "Entessa",
      "ErlPL-1.1",
      "Eurosym",
      "FBM",
      "FDK-AAC",
      "FSFAP",
      "FSFAP-no-warranty-disclaimer",
      "FSFUL",
      "FSFULLR",
      "FSFULLRSD",
      "FSFULLRWD",
      "FSL-1.1-ALv2",
      "FSL-1.1-MIT",
      "FTL",
      "Fair",
      "Ferguson-Twofish",
      "Frameworx-1.0",
      "FreeBSD-DOC",
      "FreeImage",
      "Furuseth",
      "GCR-docs",
      "GD",
      "GFDL-1.1-invariants-only",
      "GFDL-1.1-invariants-or-later",
      "GFDL-1.1-no-invariants-only",
      "GFDL-1.1-no-invariants-or-later",
      "GFDL-1.1-only",
      "GFDL-1.1-or-later",
      "GFDL-1.2-invariants-only",
      "GFDL-1.2-invariants-or-later",
      "GFDL-1.2-no-invariants-only",
      "GFDL-1.2-no-invariants-or-later",
      "GFDL-1.2-only",
      "GFDL-1.2-or-later",
      "GFDL-1.3-invariants-only",
      "GFDL-1.3-invariants-or-later",
      "GFDL-1.3-no-invariants-only",
      "GFDL-1.3-no-invariants-or-later",
      "GFDL-1.3-only",
      "GFDL-1.3-or-later",
      "GL2PS",
      "GLWTPL",
      "GPL-1.0-only",
      "GPL-1.0-or-later",
      "GPL-2.0-only",
      "GPL-2.0-or-later",
      "GPL-3.0-only",
      "GPL-3.0-or-later",
      "Game-Programming-Gems",
      "Giftware",
      "Glide",
      "Glulxe",
      "Graphics-Gems",
      "Gutmann",
      "HDF5",
      "HIDAPI",
      "HP-1986",
      "HP-1989",
      "HPND",
      "HPND-DEC",
      "HPND-Fenneberg-Livingston",
      "HPND-INRIA-IMAG",
      "HPND-Intel",
      "HPND-Kevlin-Henney",
      "HPND-MIT-disclaimer",
      "HPND-Markus-Kuhn",
      "HPND-Netrek",
      "HPND-Pbmplus",
      "HPND-UC",
      "HPND-UC-export-US",
      "HPND-doc",
      "HPND-doc-sell",
      "HPND-export-US",
      "HPND-export-US-acknowledgement",
      "HPND-export-US-modify",
      "HPND-export2-US",
      "HPND-merchantability-variant",
      "HPND-sell-MIT-disclaimer-xserver",
      "HPND-sell-regexpr",
      "HPND-sell-variant",
      "HPND-sell-variant-MIT-disclaimer",
      "HPND-sell-variant-MIT-disclaimer-rev",
      "HTMLTIDY",
      "HaskellReport",
      "Hippocratic-2.1",
      "IBM-pibs",
      "ICU",
      "IEC-Code-Components-EULA",
      "IJG",
      "IJG-short",
      "IPA",
      "IPL-1.0",
      "ISC",
      "ISC-Veillard",
      "ImageMagick",
      "Imlib2",
      "Info-ZIP",
      "Inner-Net-2.0",
      "InnoSetup",
      "Intel",
      "Intel-ACPI",
      "Interbase-1.0",
      "JPL-image",
      "JPNIC",
      "JSON",
      "Jam",
      "JasPer-2.0",
      "Kastrup",
      "Kazlib",
      "Knuth-CTAN",
      "LAL-1.2",
      "LAL-1.3",
      "LGPL-2.0-only",
      "LGPL-2.0-or-later",
      "LGPL-2.1-only",
      "LGPL-2.1-or-later",
      "LGPL-3.0-only",
      "LGPL-3.0-or-later",
      "LGPLLR",
      "LOOP",
      "LPD-document",
      "LPL-1.0",
      "LPL-1.02",
      "LPPL-1.0",
      "LPPL-1.1",
      "LPPL-1.2",
      "LPPL-1.3a",
      "LPPL-1.3c",
      "LZMA-SDK-9.11-to-9.20",
      "LZMA-SDK-9.22",
      "Latex2e",
      "Latex2e-translated-notice",
      "Leptonica",
      "LiLiQ-P-1.1",
      "LiLiQ-R-1.1",
      "LiLiQ-Rplus-1.1",
      "Libpng",
      "Linux-OpenIB",
      "Linux-man-pages-1-para",
      "Linux-man-pages-copyleft",
      "Linux-man-pages-copyleft-2-para",
      "Linux-man-pages-copyleft-var",
      "Lucida-Bitmap-Fonts",
      "MIPS",
      "MIT",
      "MIT-0",
      "MIT-CMU",
      "MIT-Click",
      "MIT-Festival",
      "MIT-Khronos-old",
      "MIT-Modern-Variant",
      "MIT-Wu",
      "MIT-advertising",
      "MIT-enna",
      "MIT-feh",
      "MIT-open-group",
      "MIT-testregex",
      "MITNFA",
      "MMIXware",
      "MPEG-SSG",
      "MPL-1.0",
      "MPL-1.1",
      "MPL-2.0",
      "MPL-2.0-no-copyleft-exception",
      "MS-LPL",
      "MS-PL",
      "MS-RL",
      "MTLL",
      "Mackerras-3-Clause",
      "Mackerras-3-Clause-acknowledgment",
      "MakeIndex",
      "Martin-Birgmeier",
      "McPhee-slideshow",
      "Minpack",
      "MirOS",
      "Motosoto",
      "MulanPSL-1.0",
      "MulanPSL-2.0",
      "Multics",
      "Mup",
      "NAIST-2003",
      "NASA-1.3",
      "NBPL-1.0",
      "NCBI-PD",
      "NCGL-UK-2.0",
      "NCL",
      "NCSA",
      "NGPL",
      "NICTA-1.0",
      "NIST-PD",
      "NIST-PD-fallback",
      "NIST-Software",
      "NLOD-1.0",
      "NLOD-2.0",
      "NLPL",
      "NOSL",
      "NPL-1.0",
      "NPL-1.1",
      "NPOSL-3.0",
      "NRL",
      "NTIA-PD",
      "NTP",
      "NTP-0",
      "Naumen",
      "NetCDF",
      "Newsletr",
      "Nokia",
      "Noweb",
      "O-UDA-1.0",
      "OAR",
      "OCCT-PL",
      "OCLC-2.0",
      "ODC-By-1.0",
      "ODbL-1.0",
      "OFFIS",
      "OFL-1.0",
      "OFL-1.0-RFN",
      "OFL-1.0-no-RFN",
      "OFL-1.1",
      "OFL-1.1-RFN",
      "OFL-1.1-no-RFN",
      "OGC-1.0",
      "OGDL-Taiwan-1.0",
      "OGL-Canada-2.0",
      "OGL-UK-1.0",
      "OGL-UK-2.0",
      "OGL-UK-3.0",
      "OGTSL",
      "OLDAP-1.1",
      "OLDAP-1.2",
      "OLDAP-1.3",
      "OLDAP-1.4",
      "OLDAP-2.0",
      "OLDAP-2.0.1",
      "OLDAP-2.1",
      "OLDAP-2.2",
      "OLDAP-2.2.1",
      "OLDAP-2.2.2",
      "OLDAP-2.3",
      "OLDAP-2.4",
      "OLDAP-2.5",
      "OLDAP-2.6",
      "OLDAP-2.7",
      "OLDAP-2.8",
      "OLFL-1.3",
      "OML",
      "OPL-1.0",
      "OPL-UK-3.0",
      "OPUBL-1.0",
      "OSET-PL-2.1",
      "OSL-1.0",
      "OSL-1.1",
      "OSL-2.0",
      "OSL-2.1",
      "OSL-3.0",
      "OpenPBS-2.3",
      "OpenSSL",
      "OpenSSL-standalone",
      "OpenVision",
      "PADL",
      "PDDL-1.0",
      "PHP-3.0",
      "PHP-3.01",
      "PPL",
      "PSF-2.0",
      "Parity-6.0.0",
      "Parity-7.0.0",
      "Pixar",
      "Plexus",
      "PolyForm-Noncommercial-1.0.0",
      "PolyForm-Small-Business-1.0.0",
      "PostgreSQL",
      "Python-2.0",
      "Python-2.0.1",
      "QPL-1.0",
      "QPL-1.0-INRIA-2004",
      "Qhull",
      "RHeCos-1.1",
      "RPL-1.1",
      "RPL-1.5",
      "RPSL-1.0",
      "RSA-MD",
      "RSCPL",
      "Rdisc",
      "Ruby",
      "Ruby-pty",
      "SAX-PD",
      "SAX-PD-2.0",
      "SCEA",
      "SGI-B-1.0",
      "SGI-B-1.1",
      "SGI-B-2.0",
      "SGI-OpenGL",
      "SGP4",
      "SHL-0.5",
      "SHL-0.51",
      "SISSL",
      "SISSL-1.2",
      "SL",
      "SMAIL-GPL",
      "SMLNJ",
      "SMPPL",
      "SNIA",
      "SOFA",
      "SPL-1.0",
      "SSH-OpenSSH",
      "SSH-short",
      "SSLeay-standalone",
      "SSPL-1.0",
      "SUL-1.0",
      "SWL",
      "Saxpath",
      "SchemeReport",
      "Sendmail",
      "Sendmail-8.23",
      "Sendmail-Open-Source-1.1",
      "SimPL-2.0",
      "Sleepycat",
      "Soundex",
      "Spencer-86",
      "Spencer-94",
      "Spencer-99",
      "SugarCRM-1.1.3",
      "Sun-PPP",
      "Sun-PPP-2000",
      "SunPro",
      "Symlinks",
      "TAPR-OHL-1.0",
      "TCL",
      "TCP-wrappers",
      "TGPPL-1.0",
      "TMate",
      "TORQUE-1.1",
      "TOSL",
      "TPDL",
      "TPL-1.0",
      "TTWL",
      "TTYP0",
      "TU-Berlin-1.0",
      "TU-Berlin-2.0",
      "TermReadKey",
      "ThirdEye",
      "TrustedQSL",
      "UCAR",
      "UCL-1.0",
      "UMich-Merit",
      "UPL-1.0",
      "URT-RLE",
      "Ubuntu-font-1.0",
      "Unicode-3.0",
      "Unicode-DFS-2015",
      "Unicode-DFS-2016",
      "Unicode-TOU",
      "UnixCrypt",
      "Unlicense",
      "Unlicense-libtelnet",
      "Unlicense-libwhirlpool",
      "VOSTROM",
      "VSL-1.0",
      "Vim",
      "W3C",
      "W3C-19980720",
      "W3C-20150513",
      "WTFPL",
      "Watcom-1.0",
      "Widget-Workshop",
      "Wsuipa",
      "X11",
      "X11-distribute-modifications-variant",
      "X11-swapped",
      "XFree86-1.1",
      "XSkat",
      "Xdebug-1.03",
      "Xerox",
      "Xfig",
      "Xnet",
      "YPL-1.0",
      "YPL-1.1",
      "ZPL-1.1",
      "ZPL-2.0",
      "ZPL-2.1",
      "Zed",
      "Zeeff",
      "Zend-2.0",
      "Zimbra-1.3",
      "Zimbra-1.4",
      "Zlib",
      "any-OSI",
      "any-OSI-perl-modules",
      "bcrypt-Solar-Designer",
      "blessing",
      "bzip2-1.0.6",
      "check-cvs",
      "checkmk",
      "copyleft-next-0.3.0",
      "copyleft-next-0.3.1",
      "curl",
      "cve-tou",
      "diffmark",
      "dtoa",
      "dvipdfm",
      "eGenix",
      "etalab-2.0",
      "fwlw",
      "gSOAP-1.3b",
      "generic-xts",
      "gnuplot",
      "gtkbook",
      "hdparm",
      "iMatix",
      "jove",
      "libpng-1.6.35",
      "libpng-2.0",
      "libselinux-1.0",
      "libtiff",
      "libutil-David-Nugent",
      "lsof",
      "magaz",
      "mailprio",
      "man2html",
      "metamail",
      "mpi-permissive",
      "mpich2",
      "mplus",
      "ngrep",
      "pkgconf",
      "pnmstitch",
      "psfrag",
      "psutils",
      "python-ldap",
      "radvd",
      "snprintf",
      "softSurfer",
      "ssh-keyscan",
      "swrule",
      "threeparttable",
      "ulem",
      "w3m",
      "wwl",
      "xinetd",
      "xkeyboard-config-Zinoviev",
      "xlock",
      "xpp",
      "xzoom",
      "zlib-acknowledgement"
    ];
  }
});

// ../../node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS({
  "../../node_modules/spdx-license-ids/deprecated.json"(exports, module) {
    module.exports = [
      "AGPL-1.0",
      "AGPL-3.0",
      "BSD-2-Clause-FreeBSD",
      "BSD-2-Clause-NetBSD",
      "GFDL-1.1",
      "GFDL-1.2",
      "GFDL-1.3",
      "GPL-1.0",
      "GPL-2.0",
      "GPL-2.0-with-GCC-exception",
      "GPL-2.0-with-autoconf-exception",
      "GPL-2.0-with-bison-exception",
      "GPL-2.0-with-classpath-exception",
      "GPL-2.0-with-font-exception",
      "GPL-3.0",
      "GPL-3.0-with-GCC-exception",
      "GPL-3.0-with-autoconf-exception",
      "LGPL-2.0",
      "LGPL-2.1",
      "LGPL-3.0",
      "Net-SNMP",
      "Nunit",
      "StandardML-NJ",
      "bzip2-1.0.5",
      "eCos-2.0",
      "wxWindows"
    ];
  }
});

// ../../node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS({
  "../../node_modules/spdx-exceptions/index.json"(exports, module) {
    module.exports = [
      "389-exception",
      "Asterisk-exception",
      "Autoconf-exception-2.0",
      "Autoconf-exception-3.0",
      "Autoconf-exception-generic",
      "Autoconf-exception-generic-3.0",
      "Autoconf-exception-macro",
      "Bison-exception-1.24",
      "Bison-exception-2.2",
      "Bootloader-exception",
      "Classpath-exception-2.0",
      "CLISP-exception-2.0",
      "cryptsetup-OpenSSL-exception",
      "DigiRule-FOSS-exception",
      "eCos-exception-2.0",
      "Fawkes-Runtime-exception",
      "FLTK-exception",
      "fmt-exception",
      "Font-exception-2.0",
      "freertos-exception-2.0",
      "GCC-exception-2.0",
      "GCC-exception-2.0-note",
      "GCC-exception-3.1",
      "Gmsh-exception",
      "GNAT-exception",
      "GNOME-examples-exception",
      "GNU-compiler-exception",
      "gnu-javamail-exception",
      "GPL-3.0-interface-exception",
      "GPL-3.0-linking-exception",
      "GPL-3.0-linking-source-exception",
      "GPL-CC-1.0",
      "GStreamer-exception-2005",
      "GStreamer-exception-2008",
      "i2p-gpl-java-exception",
      "KiCad-libraries-exception",
      "LGPL-3.0-linking-exception",
      "libpri-OpenH323-exception",
      "Libtool-exception",
      "Linux-syscall-note",
      "LLGPL",
      "LLVM-exception",
      "LZMA-exception",
      "mif-exception",
      "OCaml-LGPL-linking-exception",
      "OCCT-exception-1.0",
      "OpenJDK-assembly-exception-1.0",
      "openvpn-openssl-exception",
      "PS-or-PDF-font-exception-20170817",
      "QPL-1.0-INRIA-2004-exception",
      "Qt-GPL-exception-1.0",
      "Qt-LGPL-exception-1.1",
      "Qwt-exception-1.0",
      "SANE-exception",
      "SHL-2.0",
      "SHL-2.1",
      "stunnel-exception",
      "SWI-exception",
      "Swift-exception",
      "Texinfo-exception",
      "u-boot-exception-2.0",
      "UBDL-exception",
      "Universal-FOSS-exception-1.0",
      "vsftpd-openssl-exception",
      "WxWindows-exception-3.1",
      "x11vnc-openssl-exception"
    ];
  }
});

// ../../node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS({
  "../../node_modules/spdx-expression-parse/scan.js"(exports, module) {
    "use strict";
    var licenses2 = [].concat(require_spdx_license_ids()).concat(require_deprecated());
    var exceptions = require_spdx_exceptions();
    module.exports = function(source) {
      var index = 0;
      function hasMore() {
        return index < source.length;
      }
      function read(value) {
        if (value instanceof RegExp) {
          var chars = source.slice(index);
          var match = chars.match(value);
          if (match) {
            index += match[0].length;
            return match[0];
          }
        } else {
          if (source.indexOf(value, index) === index) {
            index += value.length;
            return value;
          }
        }
      }
      function skipWhitespace() {
        read(/[ ]*/);
      }
      function operator() {
        var string;
        var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
        for (var i = 0; i < possibilities.length; i++) {
          string = read(possibilities[i]);
          if (string) {
            break;
          }
        }
        if (string === "+" && index > 1 && source[index - 2] === " ") {
          throw new Error("Space before `+`");
        }
        return string && {
          type: "OPERATOR",
          string
        };
      }
      function idstring() {
        return read(/[A-Za-z0-9-.]+/);
      }
      function expectIdstring() {
        var string = idstring();
        if (!string) {
          throw new Error("Expected idstring at offset " + index);
        }
        return string;
      }
      function documentRef() {
        if (read("DocumentRef-")) {
          var string = expectIdstring();
          return { type: "DOCUMENTREF", string };
        }
      }
      function licenseRef() {
        if (read("LicenseRef-")) {
          var string = expectIdstring();
          return { type: "LICENSEREF", string };
        }
      }
      function identifier() {
        var begin = index;
        var string = idstring();
        if (licenses2.indexOf(string) !== -1) {
          return {
            type: "LICENSE",
            string
          };
        } else if (exceptions.indexOf(string) !== -1) {
          return {
            type: "EXCEPTION",
            string
          };
        }
        index = begin;
      }
      function parseToken() {
        return operator() || documentRef() || licenseRef() || identifier();
      }
      var tokens = [];
      while (hasMore()) {
        skipWhitespace();
        if (!hasMore()) {
          break;
        }
        var token = parseToken();
        if (!token) {
          throw new Error("Unexpected `" + source[index] + "` at offset " + index);
        }
        tokens.push(token);
      }
      return tokens;
    };
  }
});

// ../../node_modules/spdx-expression-parse/parse.js
var require_parse = __commonJS({
  "../../node_modules/spdx-expression-parse/parse.js"(exports, module) {
    "use strict";
    module.exports = function(tokens) {
      var index = 0;
      function hasMore() {
        return index < tokens.length;
      }
      function token() {
        return hasMore() ? tokens[index] : null;
      }
      function next() {
        if (!hasMore()) {
          throw new Error();
        }
        index++;
      }
      function parseOperator(operator) {
        var t = token();
        if (t && t.type === "OPERATOR" && operator === t.string) {
          next();
          return t.string;
        }
      }
      function parseWith() {
        if (parseOperator("WITH")) {
          var t = token();
          if (t && t.type === "EXCEPTION") {
            next();
            return t.string;
          }
          throw new Error("Expected exception after `WITH`");
        }
      }
      function parseLicenseRef() {
        var begin = index;
        var string = "";
        var t = token();
        if (t.type === "DOCUMENTREF") {
          next();
          string += "DocumentRef-" + t.string + ":";
          if (!parseOperator(":")) {
            throw new Error("Expected `:` after `DocumentRef-...`");
          }
        }
        t = token();
        if (t.type === "LICENSEREF") {
          next();
          string += "LicenseRef-" + t.string;
          return { license: string };
        }
        index = begin;
      }
      function parseLicense() {
        var t = token();
        if (t && t.type === "LICENSE") {
          next();
          var node2 = { license: t.string };
          if (parseOperator("+")) {
            node2.plus = true;
          }
          var exception = parseWith();
          if (exception) {
            node2.exception = exception;
          }
          return node2;
        }
      }
      function parseParenthesizedExpression() {
        var left = parseOperator("(");
        if (!left) {
          return;
        }
        var expr = parseExpression();
        if (!parseOperator(")")) {
          throw new Error("Expected `)`");
        }
        return expr;
      }
      function parseAtom() {
        return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
      }
      function makeBinaryOpParser(operator, nextParser) {
        return function parseBinaryOp() {
          var left = nextParser();
          if (!left) {
            return;
          }
          if (!parseOperator(operator)) {
            return left;
          }
          var right = parseBinaryOp();
          if (!right) {
            throw new Error("Expected expression");
          }
          return {
            left,
            conjunction: operator.toLowerCase(),
            right
          };
        };
      }
      var parseAnd = makeBinaryOpParser("AND", parseAtom);
      var parseExpression = makeBinaryOpParser("OR", parseAnd);
      var node = parseExpression();
      if (!node || hasMore()) {
        throw new Error("Syntax error");
      }
      return node;
    };
  }
});

// ../../node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS({
  "../../node_modules/spdx-expression-parse/index.js"(exports, module) {
    "use strict";
    var scan = require_scan();
    var parse = require_parse();
    module.exports = function(source) {
      return parse(scan(source));
    };
  }
});

// ../../node_modules/spdx-correct/index.js
var require_spdx_correct = __commonJS({
  "../../node_modules/spdx-correct/index.js"(exports, module) {
    var parse = require_spdx_expression_parse();
    var spdxLicenseIds = require_spdx_license_ids();
    function valid(string) {
      try {
        parse(string);
        return true;
      } catch (error) {
        return false;
      }
    }
    function sortTranspositions(a, b) {
      var length = b[0].length - a[0].length;
      if (length !== 0)
        return length;
      return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
    }
    var transpositions = [
      ["APGL", "AGPL"],
      ["Gpl", "GPL"],
      ["GLP", "GPL"],
      ["APL", "Apache"],
      ["ISD", "ISC"],
      ["GLP", "GPL"],
      ["IST", "ISC"],
      ["Claude", "Clause"],
      [" or later", "+"],
      [" International", ""],
      ["GNU", "GPL"],
      ["GUN", "GPL"],
      ["+", ""],
      ["GNU GPL", "GPL"],
      ["GNU LGPL", "LGPL"],
      ["GNU/GPL", "GPL"],
      ["GNU GLP", "GPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["GNU Lesser General Public License", "LGPL"],
      ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["GNU Lesser General Public License", "LGPL-2.1"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
      ["Lesser General Public License", "LGPL"],
      ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
      ["Lesser General Public License", "LGPL-2.1"],
      ["GNU General Public License", "GPL"],
      ["Gnu public license", "GPL"],
      ["GNU Public License", "GPL"],
      ["GNU GENERAL PUBLIC LICENSE", "GPL"],
      ["MTI", "MIT"],
      ["Mozilla Public License", "MPL"],
      ["Universal Permissive License", "UPL"],
      ["WTH", "WTF"],
      ["WTFGPL", "WTFPL"],
      ["-License", ""]
    ].sort(sortTranspositions);
    var TRANSPOSED = 0;
    var CORRECT = 1;
    var transforms = [
      // e.g. 'mit'
      function(argument) {
        return argument.toUpperCase();
      },
      // e.g. 'MIT '
      function(argument) {
        return argument.trim();
      },
      // e.g. 'M.I.T.'
      function(argument) {
        return argument.replace(/\./g, "");
      },
      // e.g. 'Apache- 2.0'
      function(argument) {
        return argument.replace(/\s+/g, "");
      },
      // e.g. 'CC BY 4.0''
      function(argument) {
        return argument.replace(/\s+/g, "-");
      },
      // e.g. 'LGPLv2.1'
      function(argument) {
        return argument.replace("v", "-");
      },
      // e.g. 'Apache 2.0'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1");
      },
      // e.g. 'GPL 2'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, "-$1.0");
      },
      // e.g. 'Apache Version 2.0'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2");
      },
      // e.g. 'Apache Version 2'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, "-$2.0");
      },
      // e.g. 'ZLIB'
      function(argument) {
        return argument[0].toUpperCase() + argument.slice(1);
      },
      // e.g. 'MPL/2.0'
      function(argument) {
        return argument.replace("/", "-");
      },
      // e.g. 'Apache 2'
      function(argument) {
        return argument.replace(/\s*V\s*(\d)/, "-$1").replace(/(\d)$/, "$1.0");
      },
      // e.g. 'GPL-2.0', 'GPL-3.0'
      function(argument) {
        if (argument.indexOf("3.0") !== -1) {
          return argument + "-or-later";
        } else {
          return argument + "-only";
        }
      },
      // e.g. 'GPL-2.0-'
      function(argument) {
        return argument + "only";
      },
      // e.g. 'GPL2'
      function(argument) {
        return argument.replace(/(\d)$/, "-$1.0");
      },
      // e.g. 'BSD 3'
      function(argument) {
        return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
      },
      // e.g. 'BSD clause 3'
      function(argument) {
        return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
      },
      // e.g. 'New BSD license'
      function(argument) {
        return argument.replace(/\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i, "BSD-3-Clause");
      },
      // e.g. 'Simplified BSD license'
      function(argument) {
        return argument.replace(/\bSimplified(-| )?BSD((-| )License)?/i, "BSD-2-Clause");
      },
      // e.g. 'Free BSD license'
      function(argument) {
        return argument.replace(/\b(Free|Net)(-| )?BSD((-| )License)?/i, "BSD-2-Clause-$1BSD");
      },
      // e.g. 'Clear BSD license'
      function(argument) {
        return argument.replace(/\bClear(-| )?BSD((-| )License)?/i, "BSD-3-Clause-Clear");
      },
      // e.g. 'Old BSD License'
      function(argument) {
        return argument.replace(/\b(Old|Original)(-| )?BSD((-| )License)?/i, "BSD-4-Clause");
      },
      // e.g. 'BY-NC-4.0'
      function(argument) {
        return "CC-" + argument;
      },
      // e.g. 'BY-NC'
      function(argument) {
        return "CC-" + argument + "-4.0";
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "");
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return "CC-" + argument.replace("Attribution", "BY").replace("NonCommercial", "NC").replace("NoDerivatives", "ND").replace(/ (\d)/, "-$1").replace(/ ?International/, "") + "-4.0";
      }
    ];
    var licensesWithVersions = spdxLicenseIds.map(function(id) {
      var match = /^(.*)-\d+\.\d+$/.exec(id);
      return match ? [match[0], match[1]] : [id, null];
    }).reduce(function(objectMap, item) {
      var key = item[1];
      objectMap[key] = objectMap[key] || [];
      objectMap[key].push(item[0]);
      return objectMap;
    }, {});
    var licensesWithOneVersion = Object.keys(licensesWithVersions).map(function makeEntries(key) {
      return [key, licensesWithVersions[key]];
    }).filter(function identifySoleVersions(item) {
      return (
        // Licenses has just one valid version suffix.
        item[1].length === 1 && item[0] !== null && // APL will be considered Apache, rather than APL-1.0
        item[0] !== "APL"
      );
    }).map(function createLastResorts(item) {
      return [item[0], item[1][0]];
    });
    licensesWithVersions = void 0;
    var lastResorts = [
      ["UNLI", "Unlicense"],
      ["WTF", "WTFPL"],
      ["2 CLAUSE", "BSD-2-Clause"],
      ["2-CLAUSE", "BSD-2-Clause"],
      ["3 CLAUSE", "BSD-3-Clause"],
      ["3-CLAUSE", "BSD-3-Clause"],
      ["AFFERO", "AGPL-3.0-or-later"],
      ["AGPL", "AGPL-3.0-or-later"],
      ["APACHE", "Apache-2.0"],
      ["ARTISTIC", "Artistic-2.0"],
      ["Affero", "AGPL-3.0-or-later"],
      ["BEER", "Beerware"],
      ["BOOST", "BSL-1.0"],
      ["BSD", "BSD-2-Clause"],
      ["CDDL", "CDDL-1.1"],
      ["ECLIPSE", "EPL-1.0"],
      ["FUCK", "WTFPL"],
      ["GNU", "GPL-3.0-or-later"],
      ["LGPL", "LGPL-3.0-or-later"],
      ["GPLV1", "GPL-1.0-only"],
      ["GPL-1", "GPL-1.0-only"],
      ["GPLV2", "GPL-2.0-only"],
      ["GPL-2", "GPL-2.0-only"],
      ["GPL", "GPL-3.0-or-later"],
      ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
      ["MIT", "MIT"],
      ["MPL", "MPL-2.0"],
      ["X11", "X11"],
      ["ZLIB", "Zlib"]
    ].concat(licensesWithOneVersion).sort(sortTranspositions);
    var SUBSTRING = 0;
    var IDENTIFIER = 1;
    var validTransformation = function(identifier) {
      for (var i = 0; i < transforms.length; i++) {
        var transformed = transforms[i](identifier).trim();
        if (transformed !== identifier && valid(transformed)) {
          return transformed;
        }
      }
      return null;
    };
    var validLastResort = function(identifier) {
      var upperCased = identifier.toUpperCase();
      for (var i = 0; i < lastResorts.length; i++) {
        var lastResort = lastResorts[i];
        if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
          return lastResort[IDENTIFIER];
        }
      }
      return null;
    };
    var anyCorrection = function(identifier, check) {
      for (var i = 0; i < transpositions.length; i++) {
        var transposition = transpositions[i];
        var transposed = transposition[TRANSPOSED];
        if (identifier.indexOf(transposed) > -1) {
          var corrected = identifier.replace(
            transposed,
            transposition[CORRECT]
          );
          var checked = check(corrected);
          if (checked !== null) {
            return checked;
          }
        }
      }
      return null;
    };
    module.exports = function(identifier, options) {
      options = options || {};
      var upgrade = options.upgrade === void 0 ? true : !!options.upgrade;
      function postprocess(value) {
        return upgrade ? upgradeGPLs(value) : value;
      }
      var validArugment = typeof identifier === "string" && identifier.trim().length !== 0;
      if (!validArugment) {
        throw Error("Invalid argument. Expected non-empty string.");
      }
      identifier = identifier.trim();
      if (valid(identifier)) {
        return postprocess(identifier);
      }
      var noPlus = identifier.replace(/\+$/, "").trim();
      if (valid(noPlus)) {
        return postprocess(noPlus);
      }
      var transformed = validTransformation(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, function(argument) {
        if (valid(argument)) {
          return argument;
        }
        return validTransformation(argument);
      });
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = validLastResort(identifier);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      transformed = anyCorrection(identifier, validLastResort);
      if (transformed !== null) {
        return postprocess(transformed);
      }
      return null;
    };
    function upgradeGPLs(value) {
      if ([
        "GPL-1.0",
        "LGPL-1.0",
        "AGPL-1.0",
        "GPL-2.0",
        "LGPL-2.0",
        "AGPL-2.0",
        "LGPL-2.1"
      ].indexOf(value) !== -1) {
        return value + "-only";
      } else if ([
        "GPL-1.0+",
        "GPL-2.0+",
        "GPL-3.0+",
        "LGPL-2.0+",
        "LGPL-2.1+",
        "LGPL-3.0+",
        "AGPL-1.0+",
        "AGPL-3.0+"
      ].indexOf(value) !== -1) {
        return value.replace(/\+$/, "-or-later");
      } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
        return value + "-or-later";
      } else {
        return value;
      }
    }
  }
});

// ../../node_modules/doi-utils/dist/validatePart.js
var DOI_VALIDATION_PATTERN = /^10\.\d{4,9}\/[-._;()/:A-Z0-9]+$/i;
function validatePart(possibleDOI) {
  if (!possibleDOI)
    return false;
  return possibleDOI.match(DOI_VALIDATION_PATTERN) !== null;
}

// ../../node_modules/doi-utils/dist/resolvers.js
var doiOrg = {
  test(url) {
    return !!url.hostname.match(/(?:dx\.)?(?:www\.)?doi\.org/);
  },
  parse(url) {
    return url.pathname.replace(/^\//, "");
  }
};
var elife = {
  test(url) {
    return url.hostname.endsWith("elifesciences.org") && /^\/(?:articles|reviewed-preprints)\/\d+$/.test(url.pathname);
  },
  parse(url) {
    return `10.7554/eLife.${url.pathname.replace(/^\/(?:articles|reviewed-preprints)\//, "")}`;
  }
};
var zenodo = {
  test(url) {
    return url.hostname.endsWith("zenodo.org") && !!url.pathname.match(/^\/(?:record|badge\/latestdoi)\//);
  },
  parse(url) {
    return `10.5281/zenodo.${url.pathname.replace(/^\/(?:record|badge\/latestdoi)\//, "")}`;
  }
};
var biorxiv = {
  test(url) {
    return url.hostname.endsWith("biorxiv.org") && !!clumpParts(url).find(validatePart);
  },
  parse(url) {
    var _a;
    return (_a = clumpParts(url).find(validatePart)) === null || _a === void 0 ? void 0 : _a.replace(/v\d+(\.[a-zA-Z-]+)?$/, "");
  }
};
function clumpParts(url) {
  const parts = url.pathname.split("/").filter((p) => !!p);
  return parts.slice(0, -1).map((a, i) => `${a}/${parts[i + 1]}`);
}
var pathParts = {
  test(url) {
    return !!clumpParts(url).find(validatePart);
  },
  parse(url) {
    return clumpParts(url).find(validatePart);
  }
};
var idInQuery = {
  test(url) {
    return validatePart(url.searchParams.get("id"));
  },
  parse(url) {
    var _a;
    return (_a = url.searchParams.get("id")) !== null && _a !== void 0 ? _a : void 0;
  }
};
var STRICT_RESOLVERS = [doiOrg];
var DEFAULT_RESOLVERS = [doiOrg, biorxiv, pathParts, elife, zenodo, idInQuery];

// ../../node_modules/doi-utils/dist/index.js
var OPEN_FUNDER_REGISTRY_PREFIX = "10.13039";
function validate(possibleDOI, opts) {
  if (!possibleDOI)
    return false;
  return !!normalize(possibleDOI, opts);
}
function normalize(possibleDOI, opts) {
  let doi2 = void 0;
  if (!possibleDOI)
    return void 0;
  if (validatePart(possibleDOI))
    return possibleDOI;
  if (possibleDOI.startsWith("doi:")) {
    doi2 = possibleDOI.slice(4);
    if (validatePart(doi2))
      return doi2;
  }
  try {
    const url = new URL(possibleDOI.startsWith("http") ? possibleDOI : `http://${possibleDOI}`);
    const strictResolver = STRICT_RESOLVERS.find((r) => r.test(url));
    const nonStrictResolver = DEFAULT_RESOLVERS.find((r) => r.test(url));
    if ((opts === null || opts === void 0 ? void 0 : opts.strict) && !strictResolver)
      return void 0;
    const resolver = strictResolver !== null && strictResolver !== void 0 ? strictResolver : nonStrictResolver;
    if (!resolver)
      return void 0;
    doi2 = resolver.parse(url);
    if (!(opts === null || opts === void 0 ? void 0 : opts.strict) && strictResolver)
      return doi2;
  } catch (error) {
  }
  if (validatePart(doi2))
    return doi2;
  return void 0;
}
function buildUrl(possibleDOI, opts) {
  const doi2 = normalize(possibleDOI, opts);
  if (!doi2)
    return void 0;
  return `https://doi.org/${doi2}`;
}
function isOpenFunderRegistry(possibleDOI) {
  const doi2 = normalize(possibleDOI);
  if (!doi2)
    return false;
  return doi2.startsWith(`${OPEN_FUNDER_REGISTRY_PREFIX}/`);
}
var doi = {
  validatePart,
  validate,
  normalize,
  buildUrl,
  isOpenFunderRegistry
};

// ../../node_modules/credit-roles/dist/index.js
var CREDIT_URL = "https://credit.niso.org/";
var CreditRole;
(function(CreditRole2) {
  CreditRole2["Conceptualization"] = "Conceptualization";
  CreditRole2["DataCuration"] = "Data curation";
  CreditRole2["FormalAnalysis"] = "Formal analysis";
  CreditRole2["FundingAcquisition"] = "Funding acquisition";
  CreditRole2["Investigation"] = "Investigation";
  CreditRole2["Methodology"] = "Methodology";
  CreditRole2["ProjectAdministration"] = "Project administration";
  CreditRole2["Resources"] = "Resources";
  CreditRole2["Software"] = "Software";
  CreditRole2["Supervision"] = "Supervision";
  CreditRole2["Validation"] = "Validation";
  CreditRole2["Visualization"] = "Visualization";
  CreditRole2["WritingOriginalDraft"] = "Writing \u2013 original draft";
  CreditRole2["WritingReviewEditing"] = "Writing \u2013 review & editing";
})(CreditRole || (CreditRole = {}));
var CreditDescriptions = {
  [CreditRole.Conceptualization]: "Ideas; formulation or evolution of overarching research goals and aims.",
  [CreditRole.DataCuration]: "Management activities to annotate (produce metadata), scrub data and maintain research data (including software code, where it is necessary for interpreting the data itself) for initial use and later re-use.",
  [CreditRole.FormalAnalysis]: "Application of statistical, mathematical, computational, or other formal techniques to analyse or synthesize study data.",
  [CreditRole.FundingAcquisition]: "Acquisition of the financial support for the project leading to this publication.",
  [CreditRole.Investigation]: "Conducting a research and investigation process, specifically performing the experiments, or data/evidence collection.",
  [CreditRole.Methodology]: "Development or design of methodology; creation of models.",
  [CreditRole.ProjectAdministration]: "Management and coordination responsibility for the research activity planning and execution.",
  [CreditRole.Resources]: "Provision of study materials, reagents, materials, patients, laboratory samples, animals, instrumentation, computing resources, or other analysis tools.",
  [CreditRole.Software]: "Programming, software development; designing computer programs; implementation of the computer code and supporting algorithms; testing of existing code components.",
  [CreditRole.Supervision]: "Oversight and leadership responsibility for the research activity planning and execution, including mentorship external to the core team.",
  [CreditRole.Validation]: "Verification, whether as a part of the activity or separate, of the overall replication/reproducibility of results/experiments and other research outputs.",
  [CreditRole.Visualization]: "Preparation, creation and/or presentation of the published work, specifically visualization/data presentation.",
  [CreditRole.WritingOriginalDraft]: "Preparation, creation and/or presentation of the published work, specifically writing the initial draft (including substantive translation).",
  [CreditRole.WritingReviewEditing]: "Preparation, creation and/or presentation of the published work by those from the original research group, specifically critical review, commentary or revision \u2013 including pre- or post-publication stages."
};
var ROLES = Object.keys(CreditDescriptions);
var ALIAS_ROLES = {
  writing: CreditRole.WritingOriginalDraft,
  editing: CreditRole.WritingReviewEditing,
  review: CreditRole.WritingReviewEditing,
  analysis: CreditRole.FormalAnalysis,
  funding: CreditRole.FundingAcquisition,
  admin: CreditRole.ProjectAdministration,
  administration: CreditRole.ProjectAdministration
};
function standardize(v) {
  return v.trim().toLowerCase().replaceAll("z", "s").split("").reduce((s, n) => {
    if (n.match(/([a-z])/))
      return [...s, n];
    const last = s[s.length - 1];
    if (!(last === null || last === void 0 ? void 0 : last.match(/([a-z])/)))
      return s;
    return [...s, "-"];
  }, []).join("");
}
var STANDARDIZED_ROLES = Object.fromEntries(ROLES.map((v) => [standardize(v), v]));
function normalize2(value, opts) {
  var _a, _b;
  if (!value)
    return void 0;
  if (ROLES.includes(value))
    return value;
  if (opts === null || opts === void 0 ? void 0 : opts.strict)
    return void 0;
  return (_b = (_a = STANDARDIZED_ROLES[standardize(value)]) !== null && _a !== void 0 ? _a : ALIAS_ROLES[value.toLowerCase().trim()]) !== null && _b !== void 0 ? _b : void 0;
}
function validate2(value, opts) {
  if (!value)
    return false;
  return !!normalize2(value, opts);
}
function buildUrl2(value, opts) {
  const role = normalize2(value, opts);
  if (!role)
    return void 0;
  const url = role.toLowerCase().replace("\u2013 ", "").replace("& ", "").replaceAll(" ", "-");
  return `${CREDIT_URL}contributor-roles/${url}/`;
}
var credit = {
  validate: validate2,
  normalize: normalize2,
  buildUrl: buildUrl2
};

// ../../node_modules/orcid/dist/index.js
var ORCID_URL = "https://orcid.org";
var ORCID_REGEX_STRICT = "^([0-9]{4}-){3}[0-9]{3}[0-9X]$";
var ORCID_REGEX = "^((http(s)?://)?(www.)?orcid.org/)?([0-9]{4}-){3}[0-9]{3}[0-9X]$";
function validate3(value, opts) {
  const match = value === null || value === void 0 ? void 0 : value.match((opts === null || opts === void 0 ? void 0 : opts.strict) ? ORCID_REGEX_STRICT : ORCID_REGEX);
  if (!match)
    return false;
  return true;
}
function normalize3(value, opts) {
  if (!value || !validate3(value, opts))
    return void 0;
  return value.replace(/^(https?:\/\/)?(www\.)?orcid\.org\//, "");
}
function buildUrl3(value, opts) {
  const orcid2 = normalize3(value, opts);
  if (!orcid2)
    return void 0;
  return `${ORCID_URL}/${orcid2}`;
}
var orcid = {
  validate: validate3,
  normalize: normalize3,
  buildUrl: buildUrl3
};

// ../../node_modules/simple-validators/dist/validators.js
function defined(val) {
  return val != null;
}
function locationSuffix(opts) {
  if (opts.file && opts.location)
    return ` (at ${opts.file}#${opts.location})`;
  if (opts.file || opts.location)
    return ` (at ${opts.file || opts.location})`;
  return "";
}
function incrementOptions(property, opts) {
  let location = opts.property;
  if (opts.location)
    location = `${opts.location}.${opts.property}`;
  return { ...opts, property, location };
}
function validationError(message, opts) {
  if (opts.suppressErrors)
    return void 0;
  const { messages } = opts;
  if (!messages.errors)
    messages.errors = [];
  const fullMessage = `'${opts.property}' ${message}${locationSuffix(opts)}`;
  messages.errors.push({
    property: opts.property,
    message: fullMessage
  });
  if (opts.errorLogFn)
    opts.errorLogFn(fullMessage);
  return void 0;
}
function validationWarning(message, opts) {
  if (opts.suppressWarnings)
    return void 0;
  const { messages } = opts;
  if (!messages.warnings)
    messages.warnings = [];
  const fullMessage = `'${opts.property}' ${message}${locationSuffix(opts)}`;
  messages.warnings.push({
    property: opts.property,
    message: fullMessage
  });
  if (opts.warningLogFn)
    opts.warningLogFn(fullMessage);
  return void 0;
}
function validateBoolean(input, opts) {
  if (typeof input === "string") {
    if (input.toLowerCase() === "true")
      return true;
    if (input.toLowerCase() === "false")
      return false;
  }
  if (input === true || input === false)
    return input;
  return validationError("must be boolean", opts);
}
function validateNumber(input, opts) {
  const value = Number(input);
  if (Number.isNaN(value)) {
    return validationError(`must be a number: ${input}`, opts);
  }
  if (defined(opts.min) && value < opts.min) {
    return validationError(`must be greater than or equal to ${opts.min}: ${value}`, opts);
  }
  if (defined(opts.max) && value > opts.max) {
    return validationError(`must be less than or equal to ${opts.max}: ${value}`, opts);
  }
  if (opts.integer && !Number.isInteger(value)) {
    return validationError(`must be an integer: ${value}`, opts);
  }
  return value;
}
function validateString(input, opts) {
  let value = input;
  if (opts.coerceNumber && typeof value === "number") {
    if (Number.isNaN(value))
      validationWarning("is not a number", opts);
    value = String(value);
  }
  if (typeof value !== "string")
    return validationError(`must be string`, opts);
  if (opts.minLength && value.length < opts.minLength) {
    return validationError(`must be greater than ${opts.minLength} chars`, opts);
  }
  if (opts.maxLength && value.length > opts.maxLength) {
    return validationError(`must be less than ${opts.maxLength} chars`, opts);
  }
  if (opts.regex && !value.match(opts.regex)) {
    return validationError(`must match regex ${opts.regex}`, opts);
  }
  if (opts.escapeFn) {
    value = opts.escapeFn(value);
  }
  return value;
}
function validateUrl(input, opts) {
  const value = validateString(input, { ...opts, maxLength: 2048 });
  if (value === void 0)
    return value;
  let url;
  try {
    url = new URL(value);
  } catch {
    return validationError(`must be valid URL: ${value}`, opts);
  }
  if (opts.includes && !url.origin.includes(opts.includes)) {
    return validationError(`must include "${opts.includes}": ${value}`, opts);
  }
  return value;
}
function validateDomain(input, opts) {
  let value = validateString(input, { ...opts, maxLength: 2048 });
  if (value === void 0)
    return value;
  if (!value.startsWith("https://") && !value.startsWith("http://")) {
    value = `http://${value}`;
  }
  let url;
  try {
    url = new URL(value);
  } catch {
    return validationError(`domain must be valid when used as a URL: ${input}`, opts);
  }
  const { hash, host, pathname, protocol, search } = url;
  if (protocol !== "http:" && protocol !== "https:") {
    return validationError(`must have http/https protocol or no protocol: ${input}`, opts);
  }
  if (pathname && pathname !== "/" || hash || search) {
    return validationError(`must not specify path, query, or fragment: ${input}`, opts);
  }
  const numParts = host.split(".").length;
  if (opts.minParts !== void 0 && opts.minParts > numParts)
    return validationError(`must have at least ${opts.minParts} parts: ${input}`, opts);
  if (opts.maxParts !== void 0 && opts.maxParts < numParts)
    return validationError(`must have at most ${opts.minParts} parts: ${input}`, opts);
  return host.toLowerCase();
}
function validateEmail(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return value;
  const valid = value.toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
  if (!valid) {
    return validationError(`must be valid email address: ${value}`, opts);
  }
  return value;
}
function validateChoice(input, opts) {
  if (!opts.choices.includes(input)) {
    return validationError(`invalid value '${input}' - must be one of [${opts.choices.join(", ")}]`, opts);
  }
  return input;
}
function validateEnum(input, opts) {
  if (!Object.values(opts.enum).includes(input)) {
    return validationError(`invalid value '${input}' - must be one of [${Object.values(opts.enum).join(", ")}]`, opts);
  }
  return input;
}
var ISO8601_DATE_PATTERN = /^(\d\d\d\d)(?:-(\d\d))?(?:-(\d\d))?(T.*)?$/;
var RFC2822_DATE_PATTERN = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),)?\s*(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d\d\d)\s*([^\s].*)?$/;
var MONTH_TO_NUMBER = new Map(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"].map((elem, index) => [elem, index + 1]));
function buildISO8601DateString(year, month, day) {
  const paddedMonth = `${month}`.padStart(2, "0");
  const paddedDay = `${day}`.padStart(2, "0");
  return `${year}-${paddedMonth}-${paddedDay}`;
}
function dateErrorString(input) {
  return `invalid date "${input}" - must be a full date "YYYY-MM-DD" (ISO 8601) or calendar date "Sat, 1 Jan 2000" (RFC 2822)`;
}
function revalidateDate(input, result, opts) {
  const validated = validateDate(new Date(result), {
    ...opts,
    suppressErrors: true,
    suppressWarnings: true
  });
  if (validated !== result) {
    return validationError(dateErrorString(input), opts);
  }
  return result;
}
function validateDate(input, opts) {
  if (typeof input === "string") {
    let match = input.match(ISO8601_DATE_PATTERN);
    if (match) {
      const [year, month, day, tail] = match.slice(1, 5);
      if (tail !== void 0) {
        validationWarning(`Date "${input}" should not include a time component ("${tail}"), which has been ignored`, opts);
      }
      const result2 = [year, month !== null && month !== void 0 ? month : "01", day !== null && day !== void 0 ? day : "01"].join("-");
      if (month === void 0 || day === void 0) {
        validationWarning(`non-standard date "${input}": interpreting date as "${result2}".
Please use a full date "YYYY-MM-DD" (ISO 8601).`, opts);
      }
      return revalidateDate(input, result2, opts);
    }
    match = input.match(RFC2822_DATE_PATTERN);
    if (match) {
      const [day, month, year, tail] = match.slice(2, 6);
      if (tail !== void 0) {
        validationWarning(`Date "${input}" should not include a time component ("${tail}"), which has been ignored`, opts);
      }
      const numericYear = parseInt(year);
      const numericMonth = MONTH_TO_NUMBER.get(month);
      const numericDay = parseInt(day);
      const result2 = buildISO8601DateString(numericYear, numericMonth, numericDay);
      return revalidateDate(input, result2, opts);
    }
    const parsed = Date.parse(input);
    if (isNaN(parsed)) {
      return validationError(dateErrorString(input), opts);
    }
    const localDate = new Date(parsed);
    const result = buildISO8601DateString(localDate.getFullYear(), localDate.getMonth() + 1, localDate.getDate());
    validationWarning(`non-standard date "${input}": interpreting date as "${result}".
Please use a full date "YYYY-MM-DD" (ISO 8601).`, opts);
    return result;
  } else if (input instanceof Date) {
    return opts.dateIsLocal ? buildISO8601DateString(input.getFullYear(), input.getMonth() + 1, input.getDate()) : buildISO8601DateString(input.getUTCFullYear(), input.getUTCMonth() + 1, input.getUTCDate());
  } else {
    return validationError(dateErrorString(input), opts);
  }
}
function validateObject(input, opts) {
  if (typeof input !== "object")
    return validationError(`must be object`, opts);
  if (Array.isArray(input))
    return validationError(`must be object, not array`, opts);
  return input;
}
function validateKeys(input, keys, opts) {
  var _a;
  const value = {};
  let required = keys.required || [];
  const optional = keys.optional || [];
  const aliasKeys = Object.entries((_a = keys.alias) !== null && _a !== void 0 ? _a : {}).filter((alias) => required.includes(alias[1]) || optional.includes(alias[1])).map((alias) => alias[0]);
  const ignored = [];
  Object.keys(input).forEach((k) => {
    var _a2;
    if (required.includes(k) || optional.includes(k)) {
      value[k] = input[k];
      required = required.filter((val) => val !== k);
    } else if (aliasKeys.includes(k)) {
      const normalized = (_a2 = keys.alias) === null || _a2 === void 0 ? void 0 : _a2[k];
      if (input[normalized] === void 0) {
        value[normalized] = input[k];
        required = required.filter((val) => val !== normalized);
      } else {
        validationWarning(`both "${normalized}" and "${k}" were provided, "${k}" was ignored.`, opts);
      }
    } else {
      ignored.push(k);
      if (opts.keepExtraKeys)
        value[k] = input[k];
    }
  });
  if (required.length) {
    validationError(`missing required key${required.length > 1 ? "s" : ""}: ${required.join(", ")}`, opts);
    if (!opts.returnInvalidPartial)
      return void 0;
  }
  if (ignored.length) {
    validationWarning(`extra key${ignored.length > 1 ? "s" : ""} ignored: ${ignored.join(", ")}`, opts);
  }
  return value;
}
function validateObjectKeys(input, keys, opts) {
  const value = validateObject(input, opts);
  if (value === void 0)
    return void 0;
  return validateKeys(value, keys, opts);
}
function validateList(input, opts, itemValidator) {
  let value;
  if (Array.isArray(input)) {
    value = input;
  } else if (opts.coerce) {
    value = [input];
  } else {
    return validationError("must be an array", opts);
  }
  return value.map((item, index) => itemValidator(item, index)).filter((item) => item !== void 0);
}
function fillMissingKeys(base, filler, keys) {
  const output = { ...base };
  keys.forEach((key) => {
    if (!defined(output[key]) && defined(filler[key])) {
      const k = key;
      output[k] = filler[k];
    }
  });
  return output;
}

// ../../node_modules/myst-frontmatter/dist/numbering/validators.js
var NUMBERING_OPTIONS = ["enumerator", "all", "headings", "title"];
var HEADING_KEYS = ["heading_1", "heading_2", "heading_3", "heading_4", "heading_5", "heading_6"];
var NUMBERING_KEYS = [
  "figure",
  "subfigure",
  "equation",
  "subequation",
  "table",
  "code",
  ...HEADING_KEYS
];
var NUMBERING_ITEM_KEYS = ["enabled", "start", "enumerator", "template", "continue"];
var CONTINUE_STRINGS = ["continue", "next"];
var NUMBERING_ALIAS = {
  sections: "headings",
  h1: "heading_1",
  h2: "heading_2",
  h3: "heading_3",
  h4: "heading_4",
  h5: "heading_5",
  h6: "heading_6",
  heading1: "heading_1",
  heading2: "heading_2",
  heading3: "heading_3",
  heading4: "heading_4",
  heading5: "heading_5",
  heading6: "heading_6",
  figures: "figure",
  subfigures: "subfigure",
  equations: "equation",
  math: "equation",
  subequations: "subequation",
  tables: "table",
  titles: "title"
};
function isBoolean(input) {
  if (typeof input === "string") {
    return ["true", "false"].includes(input.toLowerCase());
  }
  return typeof input === "boolean";
}
function validateNumberingItem(input, opts) {
  var _a, _b, _c, _d, _e;
  if (isBoolean(input)) {
    input = { enabled: input };
  } else if (typeof input === "number") {
    input = { start: input };
  } else if (CONTINUE_STRINGS.includes(input)) {
    input = { continue: true };
  } else if (typeof input === "string") {
    input = { template: input };
  }
  const value = validateObjectKeys(input, { optional: NUMBERING_ITEM_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.enabled)) {
    const enabled = validateBoolean(value.enabled, incrementOptions("enabled", opts));
    if (defined(enabled))
      output.enabled = enabled;
  }
  if (defined(value.start)) {
    if (CONTINUE_STRINGS.includes(value.start) && !defined(value.continue)) {
      output.continue = true;
      output.enabled = (_a = output.enabled) !== null && _a !== void 0 ? _a : true;
    } else {
      const start = validateNumber(value.start, {
        ...incrementOptions("start", opts),
        integer: true,
        min: 1
      });
      if (start) {
        output.start = start;
        output.enabled = (_b = output.enabled) !== null && _b !== void 0 ? _b : true;
      }
    }
  }
  if (defined(value.template)) {
    const template = validateString(value.template, incrementOptions("template", opts));
    if (defined(template)) {
      output.template = template;
      output.enabled = (_c = output.enabled) !== null && _c !== void 0 ? _c : true;
    }
  }
  if (defined(value.enumerator)) {
    const enumerator = validateString(value.enumerator, incrementOptions("enumerator", opts));
    if (defined(enumerator)) {
      output.enumerator = enumerator;
      output.enabled = (_d = output.enabled) !== null && _d !== void 0 ? _d : true;
    }
  }
  if (defined(value.continue)) {
    const cont = validateBoolean(value.continue, incrementOptions("continue", opts));
    if (defined(cont)) {
      output.continue = cont;
      output.enabled = (_e = output.enabled) !== null && _e !== void 0 ? _e : true;
    }
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}
function validateTitleItem(input, opts) {
  var _a, _b;
  if (isBoolean(input)) {
    input = { enabled: input };
  } else if (typeof input === "number") {
    input = { offset: input };
  }
  const value = validateObjectKeys(input, { optional: ["enabled", "offset", "enumerator"] }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.enabled)) {
    const enabled = validateBoolean(value.enabled, incrementOptions("enabled", opts));
    if (defined(enabled))
      output.enabled = enabled;
  }
  if (defined(value.offset)) {
    const offset = validateNumber(value.offset, {
      integer: true,
      min: 0,
      max: 5,
      ...incrementOptions("offset", opts)
    });
    if (defined(offset)) {
      output.offset = offset;
      output.enabled = (_a = output.enabled) !== null && _a !== void 0 ? _a : true;
    }
  }
  if (defined(value.enumerator)) {
    const enumerator = validateString(value.enumerator, incrementOptions("enumerator", opts));
    if (defined(enumerator)) {
      output.enumerator = enumerator;
      output.enabled = (_b = output.enabled) !== null && _b !== void 0 ? _b : true;
    }
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}
function validateNumbering(input, opts) {
  var _a, _b, _c, _d, _e;
  if (isBoolean(input)) {
    input = { all: input };
  }
  const value = validateObjectKeys(input, { optional: [...NUMBERING_KEYS, ...NUMBERING_OPTIONS], alias: NUMBERING_ALIAS }, { ...opts, suppressWarnings: true, keepExtraKeys: true });
  if (value === void 0)
    return void 0;
  const output = {};
  let headings;
  if (defined(value.enumerator)) {
    const enumeratorOpts = incrementOptions("enumerator", opts);
    if (typeof value.enumerator === "string") {
      value.enumerator = { enumerator: value.enumerator };
    }
    output.enumerator = validateNumberingItem(value.enumerator, enumeratorOpts);
    if (((_a = output.enumerator) === null || _a === void 0 ? void 0 : _a.enabled) != null) {
      if (output.enumerator.enabled !== true) {
        validationWarning("value for 'enabled' is ignored", enumeratorOpts);
      }
      delete output.enumerator.enabled;
    }
    if (((_b = output.enumerator) === null || _b === void 0 ? void 0 : _b.start) != null) {
      validationWarning("value for 'start' is ignored", enumeratorOpts);
      delete output.enumerator.start;
    }
    if (((_c = output.enumerator) === null || _c === void 0 ? void 0 : _c.continue) != null) {
      validationWarning("value for 'continue' is ignored", enumeratorOpts);
      delete output.enumerator.continue;
    }
    if (!output.enumerator || Object.keys(output.enumerator).length === 0) {
      delete output.enumerator;
    }
  }
  if (defined(value.all)) {
    const allOpts = incrementOptions("all", opts);
    output.all = validateNumberingItem(value.all, allOpts);
    if (((_d = output.all) === null || _d === void 0 ? void 0 : _d.template) != null) {
      validationWarning("value for 'template' is ignored", allOpts);
      delete output.all.template;
    }
    if (((_e = output.all) === null || _e === void 0 ? void 0 : _e.start) != null) {
      validationWarning("value for 'start' is ignored", allOpts);
      delete output.all.start;
    }
    if (!output.all || Object.keys(output.all).length === 0) {
      delete output.all;
    }
  }
  if (defined(value.title)) {
    output.title = validateTitleItem(value.title, incrementOptions("title", opts));
  }
  if (defined(value.headings)) {
    headings = validateNumberingItem(value.headings, incrementOptions("headings", opts));
    HEADING_KEYS.forEach((headingKey) => {
      if (headings && !defined(value[headingKey])) {
        value[headingKey] = headings;
      }
    });
  }
  Object.keys(value).filter((key) => !NUMBERING_OPTIONS.includes(key)).forEach((key) => {
    if (defined(value[key])) {
      const item = validateNumberingItem(value[key], incrementOptions(key, opts));
      if (!defined(item))
        return;
      if (headings && HEADING_KEYS.includes(key)) {
        output[key] = { ...headings, ...item };
      } else {
        output[key] = item;
      }
    }
  });
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}
function fillNumbering(base, filler) {
  const output = { ...filler, ...base };
  Object.entries(filler !== null && filler !== void 0 ? filler : {}).filter(([key]) => !NUMBERING_OPTIONS.includes(key)).forEach(([key, val]) => {
    var _a, _b, _c, _d, _e;
    output[key] = fillMissingKeys(
      (_a = base === null || base === void 0 ? void 0 : base[key]) !== null && _a !== void 0 ? _a : {},
      // Enabling/disabling all in base overrides filler
      {
        ...val,
        enabled: (_c = (_b = base === null || base === void 0 ? void 0 : base.all) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : val.enabled,
        continue: (_e = (_d = base === null || base === void 0 ? void 0 : base.all) === null || _d === void 0 ? void 0 : _d.continue) !== null && _e !== void 0 ? _e : val.continue
      },
      NUMBERING_ITEM_KEYS
    );
  });
  return output;
}

// ../../node_modules/myst-frontmatter/dist/utils/normalizeString.js
function normalizeJsonToString(value) {
  return JSON.stringify(Object.entries(value).filter(([, val]) => val !== void 0).sort());
}

// ../../node_modules/myst-frontmatter/dist/utils/referenceStash.js
function pseudoUniqueId(kind, index, file) {
  let suffix = "";
  if (file) {
    const fileParts = file.replace("\\", "/").split("/");
    const nameParts = fileParts[fileParts.length - 1].split(".");
    if (nameParts.length === 1) {
      suffix = `-${nameParts[0]}`;
    } else {
      suffix = `-${nameParts.slice(0, nameParts.length - 1).join("-")}`;
    }
  }
  return `${kind}${suffix}-generated-uid-${index}`;
}
function stashPlaceholder(value) {
  return { id: value, name: value };
}
function isStashPlaceholder(object) {
  var _a;
  if (!object.name || !object.id || object.name !== object.id)
    return false;
  const nKeys = Object.keys(object).length;
  if (nKeys === 2)
    return true;
  return nKeys === 3 && ((_a = object.nameParsed) === null || _a === void 0 ? void 0 : _a.literal) === object.id;
}
function validateAndStashObject(input, stash, kind, validateFn, opts) {
  var _a, _b, _c;
  const lookup = {};
  const lookupNorm2Id = {};
  (_a = stash[kind]) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
    if (item.id) {
      lookup[item.id] = item;
      lookupNorm2Id[normalizeJsonToString({ ...item, id: void 0 })] = item.id;
    }
  });
  if (typeof input === "string" && Object.keys(lookup).includes(input)) {
    return input;
  }
  const value = validateFn(input, opts);
  if (!value)
    return;
  let warnOnDuplicate = !isStashPlaceholder(value);
  if (!value.id) {
    if (lookupNorm2Id[normalizeJsonToString(value)]) {
      value.id = lookupNorm2Id[normalizeJsonToString(value)];
      warnOnDuplicate = false;
    } else {
      value.id = pseudoUniqueId(kind, (_c = (_b = stash[kind]) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0, opts.file);
    }
  }
  if (!Object.keys(lookup).includes(value.id)) {
    lookup[value.id] = value;
  } else if (isStashPlaceholder(lookup[value.id])) {
    lookup[value.id] = value;
  } else if (warnOnDuplicate) {
    validationWarning(`duplicate id for ${kind} found in frontmatter: ${value.id}`, opts);
  }
  stash[kind] = Object.values(lookup);
  return value.id;
}

// ../../node_modules/myst-toc/dist/toc.js
var COMMON_ENTRY_KEYS = ["title", "hidden"];
function validateCommonEntry(entry, opts) {
  const output = {};
  if (defined(entry.title)) {
    output.title = validateString(entry.title, incrementOptions("title", opts));
  }
  if (defined(entry.hidden)) {
    output.hidden = validateBoolean(entry.hidden, incrementOptions("hidden", opts));
  }
  return output;
}
function validateFileEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["file"],
    optional: [...COMMON_ENTRY_KEYS, "children"]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const file = validateString(intermediate.file, incrementOptions("file", opts));
  if (!file) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  let output = { file, ...commonEntry };
  if (defined(entry.children)) {
    const children = validateList(intermediate.children, incrementOptions("children", opts), (item, ind) => validateEntry(item, incrementOptions(`children.${ind}`, opts)));
    output = { children, ...output };
  }
  return output;
}
function validateURLEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["url"],
    optional: [...COMMON_ENTRY_KEYS, "children"]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const url = validateString(intermediate.url, incrementOptions("url", opts));
  if (!url) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  let output = { url, ...commonEntry };
  if (defined(entry.children)) {
    const children = validateList(intermediate.children, incrementOptions("children", opts), (item, ind) => validateEntry(item, incrementOptions(`children.${ind}`, opts)));
    output = { children, ...output };
  }
  return output;
}
function validatePatternEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["pattern"],
    optional: [...COMMON_ENTRY_KEYS]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const pattern = validateString(intermediate.pattern, incrementOptions("pattern", opts));
  if (!pattern) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  return { pattern, ...commonEntry };
}
function validateParentEntry(entry, opts) {
  const intermediate = validateObjectKeys(entry, {
    required: ["title", "children"],
    optional: [...COMMON_ENTRY_KEYS]
  }, opts);
  if (!intermediate) {
    return void 0;
  }
  const title = validateString(intermediate.title, incrementOptions("title", opts));
  if (!title) {
    return void 0;
  }
  const children = validateList(intermediate.children, incrementOptions("children", opts), (item, ind) => validateEntry(item, incrementOptions(`children.${ind}`, opts)));
  if (!children) {
    return void 0;
  }
  const commonEntry = validateCommonEntry(intermediate, opts);
  return {
    children,
    title,
    ...commonEntry
  };
}
function validateEntry(entry, opts) {
  const intermediate = validateObject(entry, opts);
  if (!intermediate) {
    return void 0;
  }
  if (defined(intermediate.file)) {
    return validateFileEntry(intermediate, opts);
  } else if (defined(intermediate.url)) {
    return validateURLEntry(intermediate, opts);
  } else if (defined(intermediate.pattern)) {
    return validatePatternEntry(intermediate, opts);
  } else if (defined(intermediate.title)) {
    return validateParentEntry(intermediate, opts);
  } else {
    return validationError("expected an entry with 'file', 'url', 'pattern', or 'title'", opts);
  }
}
function validateTOC(toc, opts) {
  return validateList(toc, opts, (item, ind) => validateEntry(item, incrementOptions(`${ind}`, opts)));
}

// ../../node_modules/myst-frontmatter/dist/utils/validators.js
var GITHUB_USERNAME_REPO_REGEX = "^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$";
function validateDoi(value, opts) {
  const doiString = validateString(value, opts);
  if (doiString !== void 0) {
    if (doi.validate(doiString, { strict: true })) {
      return doiString;
    } else {
      validationError("must be valid DOI", opts);
    }
  }
  return void 0;
}
function validateGithubUrl(value, opts) {
  let github = value;
  if (typeof github === "string") {
    const repo = github.match(GITHUB_USERNAME_REPO_REGEX);
    if (repo) {
      github = `https://github.com/${repo}`;
    }
  }
  return validateUrl(github, {
    ...incrementOptions("github", opts),
    includes: "github"
  });
}
function validateStringOrNumber(input, opts) {
  if (typeof input === "string")
    return validateString(input, opts);
  if (typeof input === "number")
    return input;
  return validationError("must be string or number", opts);
}

// ../../node_modules/myst-frontmatter/dist/biblio/validators.js
var PUBLICATION_META_KEYS = ["number", "doi", "title", "subject"];
function validatePublicationMeta(input, opts) {
  if (typeof input !== "object") {
    input = { number: input };
  }
  const value = validateObjectKeys(input, { optional: PUBLICATION_META_KEYS, alias: { name: "number" } }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.number)) {
    output.number = validateStringOrNumber(value.number, incrementOptions("number", opts));
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.subject)) {
    output.subject = validateString(value.subject, incrementOptions("subject", opts));
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/project/types.js
var KNOWN_EXTERNAL_IDENTIFIERS = ["arxiv", "pmid", "pmcid", "zenodo"];
var PROJECT_AND_PAGE_FRONTMATTER_KEYS = [
  "date",
  "doi",
  "identifiers",
  "open_access",
  "license",
  "binder",
  "source",
  "subject",
  "volume",
  "issue",
  "first_page",
  "last_page",
  "oxa",
  "numbering",
  "bibliography",
  "math",
  "abbreviations",
  "exports",
  "downloads",
  "settings",
  // We maybe want to move this into site frontmatter in the future
  "edit_url",
  "source_url",
  ...KNOWN_EXTERNAL_IDENTIFIERS,
  // Do not add any project specific keys here!
  ...SITE_FRONTMATTER_KEYS
];
var PROJECT_FRONTMATTER_KEYS = [
  ...PROJECT_AND_PAGE_FRONTMATTER_KEYS,
  // These keys only exist on the project
  "id",
  "references",
  "requirements",
  "resources",
  "thebe",
  "toc"
];

// ../../node_modules/myst-frontmatter/dist/page/types.js
var PAGE_FRONTMATTER_KEYS = [
  ...PROJECT_AND_PAGE_FRONTMATTER_KEYS,
  // These keys only exist on the page
  "label",
  "kernelspec",
  "jupytext",
  "tags",
  "site",
  "enumerator",
  "content_includes_title",
  "skip_execution",
  "execute"
];

// ../../node_modules/myst-frontmatter/dist/exports/types.js
var ExportFormats;
(function(ExportFormats2) {
  ExportFormats2["pdf"] = "pdf";
  ExportFormats2["tex"] = "tex";
  ExportFormats2["pdftex"] = "pdf+tex";
  ExportFormats2["typst"] = "typst";
  ExportFormats2["docx"] = "docx";
  ExportFormats2["xml"] = "xml";
  ExportFormats2["md"] = "md";
  ExportFormats2["meca"] = "meca";
  ExportFormats2["cff"] = "cff";
})(ExportFormats || (ExportFormats = {}));

// ../../node_modules/myst-frontmatter/dist/exports/validators.js
var EXPORT_KEY_OBJECT = {
  required: [],
  optional: [
    "format",
    "template",
    "output",
    "zip",
    "id",
    "name",
    "renderer",
    "articles",
    "top_level",
    "sub_articles"
  ],
  alias: {
    article: "articles",
    sub_article: "sub_articles"
  }
};
var EXPORT_ARTICLE_KEY_OBJECT = {
  optional: [
    "file",
    "title",
    "level",
    ...PAGE_FRONTMATTER_KEYS,
    ...Object.keys(FRONTMATTER_ALIASES)
  ]
};
var EXT_TO_FORMAT = {
  ".pdf": ExportFormats.pdf,
  ".tex": ExportFormats.tex,
  ".doc": ExportFormats.docx,
  ".docx": ExportFormats.docx,
  ".md": ExportFormats.md,
  ".zip": ExportFormats.meca,
  ".meca": ExportFormats.meca,
  ".xml": ExportFormats.xml,
  ".jats": ExportFormats.xml,
  ".typ": ExportFormats.typst,
  ".typst": ExportFormats.typst,
  ".cff": ExportFormats.cff
};
var RESERVED_EXPORT_KEYS = [
  ...EXPORT_KEY_OBJECT.required,
  ...EXPORT_KEY_OBJECT.optional,
  ...Object.keys(EXPORT_KEY_OBJECT.alias),
  ...PROJECT_FRONTMATTER_KEYS,
  ...Object.keys(FRONTMATTER_ALIASES)
];
var MULTI_ARTICLE_EXPORT_FORMATS = [
  ExportFormats.typst,
  ExportFormats.pdf,
  ExportFormats.tex,
  ExportFormats.pdftex
];
function validateExportsList(input, opts) {
  if (input === void 0)
    return void 0;
  const exportsOptions = { coerce: true, ...incrementOptions("exports", opts) };
  const output = validateList(input, exportsOptions, (exp, ind) => {
    return validateExport(exp, incrementOptions(`exports.${ind}`, opts));
  });
  if (!output || output.length === 0)
    return void 0;
  const duplicates = /* @__PURE__ */ new Set();
  output.forEach((exp, ind) => {
    if (exp.id && output.slice(ind + 1).map(({ id }) => id).includes(exp.id)) {
      duplicates.add(exp.id);
    }
  });
  if (duplicates.size) {
    validationError(`duplicate export ids: ${[...duplicates].join(", ")}`, exportsOptions);
  }
  return output;
}
function validateExportFormat(input, opts) {
  if (input === void 0)
    return void 0;
  if (input === "tex+pdf")
    input = "pdf+tex";
  if (input === "jats")
    input = "xml";
  const format = validateEnum(input, { ...opts, enum: ExportFormats });
  return format;
}
function validateExportArticle(input, opts) {
  if (typeof input === "string") {
    input = { file: input };
  }
  const value = validateObjectKeys(input, EXPORT_ARTICLE_KEY_OBJECT, opts);
  if (!value)
    return void 0;
  const output = { ...value };
  if (defined(value.file)) {
    output.file = validateString(value.file, opts);
  }
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.level)) {
    output.level = validateNumber(value.level, {
      min: -1,
      max: 6,
      integer: true,
      ...incrementOptions("level", opts)
    });
  }
  if (!output.title && !output.file) {
    return validationError("export articles must specify file or part/chapter title", opts);
  }
  return output;
}
function articlesWithFile(articles) {
  var _a;
  return (_a = articles === null || articles === void 0 ? void 0 : articles.filter((article) => {
    return !!article.file;
  })) !== null && _a !== void 0 ? _a : [];
}
function singleArticleWithFile(articles) {
  return articlesWithFile(articles)[0];
}
function validateExport(input, opts) {
  if (typeof input === "string") {
    let format2;
    let output2;
    if (input.startsWith(".")) {
      Object.entries(EXT_TO_FORMAT).forEach(([ext, fmt]) => {
        if (input === ext)
          format2 = fmt;
      });
    } else if (input.includes(".")) {
      output2 = input;
    }
    if (!format2 && !output2) {
      format2 = validateExportFormat(input, opts);
      if (!format2)
        return void 0;
    }
    input = { format: format2, output: output2 };
  }
  const value = validateObjectKeys(input, EXPORT_KEY_OBJECT, {
    ...opts,
    suppressWarnings: true,
    keepExtraKeys: true
  });
  if (value === void 0)
    return void 0;
  let format;
  let output;
  let template;
  if (value.template === null) {
    template = null;
  } else if (defined(value.template)) {
    template = validateString(value.template, incrementOptions("template", opts));
  }
  if (defined(value.output)) {
    const outputOpts = incrementOptions("output", opts);
    const outputString = validateString(value.output, outputOpts);
    if (outputString) {
      Object.keys(EXT_TO_FORMAT).forEach((ext) => {
        if (outputString.endsWith(ext))
          output = outputString;
      });
      if (!outputString.slice(1).includes(".")) {
        output = outputString;
      }
      if (!output) {
        return validationError(`unknown export output extension: ${outputString}`, outputOpts);
      }
    }
  }
  if (defined(value.format)) {
    format = validateExportFormat(value.format, incrementOptions("format", opts));
    if (!format)
      return void 0;
  }
  if (!format && !template && !output) {
    return validationError("export must specify one of: format, template, or output", opts);
  }
  const validExport = { ...value, format, output, template };
  if (defined(value.id)) {
    validExport.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.zip)) {
    validExport.zip = validateBoolean(value.zip, incrementOptions("zip", opts));
  }
  if (defined(value.articles)) {
    const articles = validateList(value.articles, { coerce: true, ...incrementOptions("articles", opts) }, (item, ind) => validateExportArticle(item, incrementOptions(`articles.${ind}`, opts)));
    const singleArticle = singleArticleWithFile(articles);
    if (articles === null || articles === void 0 ? void 0 : articles.length) {
      if (!singleArticle) {
        validationError("no files found in export article list", opts);
        validExport.articles = void 0;
      } else if (articles.length > 1 && validExport.format && !MULTI_ARTICLE_EXPORT_FORMATS.includes(validExport.format)) {
        if (validExport.format === ExportFormats.xml && !defined(value.sub_articles)) {
          validationError("multiple articles are not supported for 'jats' export - instead specify one article with additional sub_articles", opts);
        } else {
          validationError("multiple articles are only supported for 'tex', 'typst', and 'pdf' exports", opts);
        }
        validExport.articles = [singleArticle];
      } else {
        validExport.articles = articles;
      }
    } else {
      validExport.articles = void 0;
    }
  }
  if (defined(value.top_level)) {
    validExport.top_level = validateChoice(value.top_level || "sections", {
      ...incrementOptions("top_level", opts),
      choices: ["parts", "chapters", "sections"]
    });
  }
  if (defined(value.sub_articles)) {
    if (validExport.format !== ExportFormats.xml) {
      validationError("sub_articles are only supported for 'jats' export", opts);
      validExport.sub_articles = void 0;
    } else {
      validExport.sub_articles = validateList(value.sub_articles, { coerce: true, ...incrementOptions("sub_articles", opts) }, (file, ind) => {
        return validateString(file, incrementOptions(`sub_articles.${ind}`, opts));
      });
    }
  }
  if (defined(value.toc)) {
    const tocOpts = incrementOptions("toc", opts);
    if (validExport.articles || validExport.sub_articles) {
      validationError("export cannot define both toc and articles/sub_articles; ignoring toc", tocOpts);
      validExport.toc = void 0;
    } else if (typeof value.toc === "string") {
      validExport.tocFile = value.toc;
      validExport.toc = void 0;
    } else {
      validExport.toc = validateTOC(value.toc, tocOpts);
    }
  }
  return validExport;
}

// ../../node_modules/myst-frontmatter/dist/downloads/validators.js
var DOWNLOAD_KEY_OBJECT = {
  required: [],
  optional: ["title", "url", "id", "filename", "format", "static"],
  alias: {
    ref: "id",
    file: "url"
  }
};
function validateDownload(input, opts) {
  if (typeof input === "string") {
    input = { url: input };
  }
  const value = validateObjectKeys(input, DOWNLOAD_KEY_OBJECT, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.url)) {
    output.url = validateString(value.url, incrementOptions("url", opts));
  }
  if (output.url && output.id) {
    return validationError(`download must define only one of id and file/url, not both`, opts);
  }
  if (!output.url && !output.id) {
    return validationError(`download must define either id or file/url`, opts);
  }
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.filename)) {
    output.filename = validateString(value.filename, incrementOptions("filename", opts));
  }
  if (defined(value.format)) {
    output.format = validateExportFormat(value.format, incrementOptions("format", opts));
  }
  if (defined(value.static)) {
    output.static = validateBoolean(value.static, incrementOptions("static", opts));
  }
  return output;
}
function validateDownloadsList(input, opts) {
  if (input === void 0)
    return void 0;
  const downloadOptions = { coerce: true, ...incrementOptions("downloads", opts) };
  const output = validateList(input, downloadOptions, (exp, ind) => {
    return validateDownload(exp, incrementOptions(`downloads.${ind}`, opts));
  });
  if (!output)
    return void 0;
  const duplicateIds = /* @__PURE__ */ new Set();
  const duplicateUrls = /* @__PURE__ */ new Set();
  output.forEach((download, ind) => {
    if (download.id && output.slice(ind + 1).map(({ id }) => id).includes(download.id)) {
      duplicateIds.add(download.id);
    }
    if (download.url && output.slice(ind + 1).map(({ url }) => url).includes(download.url)) {
      duplicateUrls.add(download.url);
    }
  });
  if (duplicateIds.size) {
    validationError(`duplicate download ids: ${[...duplicateIds].join(", ")}`, downloadOptions);
  }
  if (duplicateUrls.size) {
    validationError(`duplicate download urls: ${[...duplicateUrls].join(", ")}`, downloadOptions);
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/licenses/validators.js
var import_spdx_correct = __toESM(require_spdx_correct(), 1);

// ../../node_modules/myst-frontmatter/dist/licenses/licenses.js
var licenses = {
  "0BSD": {
    name: "BSD Zero Clause License",
    osi: true
  },
  "3D-Slicer-1.0": {
    name: "3D Slicer License v1.0"
  },
  AAL: {
    name: "Attribution Assurance License",
    osi: true
  },
  Abstyles: {
    name: "Abstyles License"
  },
  "AdaCore-doc": {
    name: "AdaCore Doc License"
  },
  "Adobe-2006": {
    name: "Adobe Systems Incorporated Source Code License Agreement"
  },
  "Adobe-Display-PostScript": {
    name: "Adobe Display PostScript License"
  },
  "Adobe-Glyph": {
    name: "Adobe Glyph List License"
  },
  "Adobe-Utopia": {
    name: "Adobe Utopia Font License"
  },
  ADSL: {
    name: "Amazon Digital Services License"
  },
  "AFL-1.1": {
    name: "Academic Free License v1.1",
    osi: true,
    free: true
  },
  "AFL-1.2": {
    name: "Academic Free License v1.2",
    osi: true,
    free: true
  },
  "AFL-2.0": {
    name: "Academic Free License v2.0",
    osi: true,
    free: true
  },
  "AFL-2.1": {
    name: "Academic Free License v2.1",
    osi: true,
    free: true
  },
  "AFL-3.0": {
    name: "Academic Free License v3.0",
    osi: true,
    free: true
  },
  Afmparse: {
    name: "Afmparse License"
  },
  "AGPL-1.0-only": {
    name: "Affero General Public License v1.0 only"
  },
  "AGPL-1.0-or-later": {
    name: "Affero General Public License v1.0 or later"
  },
  "AGPL-3.0-only": {
    name: "GNU Affero General Public License v3.0 only",
    osi: true,
    free: true
  },
  "AGPL-3.0-or-later": {
    name: "GNU Affero General Public License v3.0 or later",
    osi: true,
    free: true
  },
  Aladdin: {
    name: "Aladdin Free Public License"
  },
  "AMD-newlib": {
    name: "AMD newlib License"
  },
  AMDPLPA: {
    name: "AMD's plpa_map.c License"
  },
  AML: {
    name: "Apple MIT License"
  },
  "AML-glslang": {
    name: "AML glslang variant License"
  },
  AMPAS: {
    name: "Academy of Motion Picture Arts and Sciences BSD"
  },
  "ANTLR-PD": {
    name: "ANTLR Software Rights Notice"
  },
  "ANTLR-PD-fallback": {
    name: "ANTLR Software Rights Notice with license fallback"
  },
  "any-OSI": {
    name: "Any OSI License"
  },
  "any-OSI-perl-modules": {
    name: "Any OSI License - Perl Modules"
  },
  "Apache-1.0": {
    name: "Apache License 1.0",
    free: true
  },
  "Apache-1.1": {
    name: "Apache License 1.1",
    osi: true,
    free: true
  },
  "Apache-2.0": {
    name: "Apache License 2.0",
    osi: true,
    free: true
  },
  APAFML: {
    name: "Adobe Postscript AFM License"
  },
  "APL-1.0": {
    name: "Adaptive Public License 1.0",
    osi: true
  },
  "App-s2p": {
    name: "App::s2p License"
  },
  "APSL-1.0": {
    name: "Apple Public Source License 1.0",
    osi: true
  },
  "APSL-1.1": {
    name: "Apple Public Source License 1.1",
    osi: true
  },
  "APSL-1.2": {
    name: "Apple Public Source License 1.2",
    osi: true
  },
  "APSL-2.0": {
    name: "Apple Public Source License 2.0",
    osi: true,
    free: true
  },
  "Arphic-1999": {
    name: "Arphic Public License"
  },
  "Artistic-1.0": {
    name: "Artistic License 1.0",
    osi: true
  },
  "Artistic-1.0-cl8": {
    name: "Artistic License 1.0 w/clause 8",
    osi: true
  },
  "Artistic-1.0-Perl": {
    name: "Artistic License 1.0 (Perl)",
    osi: true
  },
  "Artistic-2.0": {
    name: "Artistic License 2.0",
    osi: true,
    free: true
  },
  "Artistic-dist": {
    name: "Artistic License 1.0 (dist)"
  },
  "Aspell-RU": {
    name: "Aspell Russian License"
  },
  "ASWF-Digital-Assets-1.0": {
    name: "ASWF Digital Assets License version 1.0"
  },
  "ASWF-Digital-Assets-1.1": {
    name: "ASWF Digital Assets License 1.1"
  },
  Baekmuk: {
    name: "Baekmuk License"
  },
  Bahyph: {
    name: "Bahyph License"
  },
  Barr: {
    name: "Barr License"
  },
  "bcrypt-Solar-Designer": {
    name: "bcrypt Solar Designer License"
  },
  Beerware: {
    name: "Beerware License"
  },
  "Bitstream-Charter": {
    name: "Bitstream Charter Font License"
  },
  "Bitstream-Vera": {
    name: "Bitstream Vera Font License"
  },
  "BitTorrent-1.0": {
    name: "BitTorrent Open Source License v1.0"
  },
  "BitTorrent-1.1": {
    name: "BitTorrent Open Source License v1.1",
    free: true
  },
  blessing: {
    name: "SQLite Blessing"
  },
  "BlueOak-1.0.0": {
    name: "Blue Oak Model License 1.0.0",
    osi: true
  },
  "Boehm-GC": {
    name: "Boehm-Demers-Weiser GC License"
  },
  "Boehm-GC-without-fee": {
    name: "Boehm-Demers-Weiser GC License (without fee)"
  },
  Borceux: {
    name: "Borceux license"
  },
  "Brian-Gladman-2-Clause": {
    name: "Brian Gladman 2-Clause License"
  },
  "Brian-Gladman-3-Clause": {
    name: "Brian Gladman 3-Clause License"
  },
  "BSD-1-Clause": {
    name: "BSD 1-Clause License",
    osi: true
  },
  "BSD-2-Clause": {
    name: 'BSD 2-Clause "Simplified" License',
    osi: true,
    free: true
  },
  "BSD-2-Clause-Darwin": {
    name: "BSD 2-Clause - Ian Darwin variant"
  },
  "BSD-2-Clause-first-lines": {
    name: "BSD 2-Clause - first lines requirement"
  },
  "BSD-2-Clause-Patent": {
    name: "BSD-2-Clause Plus Patent License",
    osi: true
  },
  "BSD-2-Clause-pkgconf-disclaimer": {
    name: "BSD 2-Clause pkgconf disclaimer variant"
  },
  "BSD-2-Clause-Views": {
    name: "BSD 2-Clause with views sentence"
  },
  "BSD-3-Clause": {
    name: 'BSD 3-Clause "New" or "Revised" License',
    osi: true,
    free: true
  },
  "BSD-3-Clause-acpica": {
    name: "BSD 3-Clause acpica variant"
  },
  "BSD-3-Clause-Attribution": {
    name: "BSD with attribution"
  },
  "BSD-3-Clause-Clear": {
    name: "BSD 3-Clause Clear License",
    free: true
  },
  "BSD-3-Clause-flex": {
    name: "BSD 3-Clause Flex variant"
  },
  "BSD-3-Clause-HP": {
    name: "Hewlett-Packard BSD variant license"
  },
  "BSD-3-Clause-LBNL": {
    name: "Lawrence Berkeley National Labs BSD variant license",
    osi: true
  },
  "BSD-3-Clause-Modification": {
    name: "BSD 3-Clause Modification"
  },
  "BSD-3-Clause-No-Military-License": {
    name: "BSD 3-Clause No Military License"
  },
  "BSD-3-Clause-No-Nuclear-License": {
    name: "BSD 3-Clause No Nuclear License"
  },
  "BSD-3-Clause-No-Nuclear-License-2014": {
    name: "BSD 3-Clause No Nuclear License 2014"
  },
  "BSD-3-Clause-No-Nuclear-Warranty": {
    name: "BSD 3-Clause No Nuclear Warranty"
  },
  "BSD-3-Clause-Open-MPI": {
    name: "BSD 3-Clause Open MPI variant"
  },
  "BSD-3-Clause-Sun": {
    name: "BSD 3-Clause Sun Microsystems"
  },
  "BSD-4-Clause": {
    name: 'BSD 4-Clause "Original" or "Old" License',
    free: true
  },
  "BSD-4-Clause-Shortened": {
    name: "BSD 4 Clause Shortened"
  },
  "BSD-4-Clause-UC": {
    name: "BSD-4-Clause (University of California-Specific)"
  },
  "BSD-4.3RENO": {
    name: "BSD 4.3 RENO License"
  },
  "BSD-4.3TAHOE": {
    name: "BSD 4.3 TAHOE License"
  },
  "BSD-Advertising-Acknowledgement": {
    name: "BSD Advertising Acknowledgement License"
  },
  "BSD-Attribution-HPND-disclaimer": {
    name: "BSD with Attribution and HPND disclaimer"
  },
  "BSD-Inferno-Nettverk": {
    name: "BSD-Inferno-Nettverk"
  },
  "BSD-Protection": {
    name: "BSD Protection License"
  },
  "BSD-Source-beginning-file": {
    name: "BSD Source Code Attribution - beginning of file variant"
  },
  "BSD-Source-Code": {
    name: "BSD Source Code Attribution"
  },
  "BSD-Systemics": {
    name: "Systemics BSD variant license"
  },
  "BSD-Systemics-W3Works": {
    name: "Systemics W3Works BSD variant license"
  },
  "BSL-1.0": {
    name: "Boost Software License 1.0",
    osi: true,
    free: true
  },
  "BUSL-1.1": {
    name: "Business Source License 1.1"
  },
  "bzip2-1.0.6": {
    name: "bzip2 and libbzip2 License v1.0.6"
  },
  "C-UDA-1.0": {
    name: "Computational Use of Data Agreement v1.0"
  },
  "CAL-1.0": {
    name: "Cryptographic Autonomy License 1.0",
    osi: true
  },
  "CAL-1.0-Combined-Work-Exception": {
    name: "Cryptographic Autonomy License 1.0 (Combined Work Exception)",
    osi: true
  },
  Caldera: {
    name: "Caldera License"
  },
  "Caldera-no-preamble": {
    name: "Caldera License (without preamble)"
  },
  Catharon: {
    name: "Catharon License"
  },
  "CATOSL-1.1": {
    name: "Computer Associates Trusted Open Source License 1.1",
    osi: true
  },
  "CC-BY-1.0": {
    name: "Creative Commons Attribution 1.0 Generic",
    CC: true
  },
  "CC-BY-2.0": {
    name: "Creative Commons Attribution 2.0 Generic",
    CC: true
  },
  "CC-BY-2.5": {
    name: "Creative Commons Attribution 2.5 Generic",
    CC: true
  },
  "CC-BY-2.5-AU": {
    name: "Creative Commons Attribution 2.5 Australia",
    CC: true
  },
  "CC-BY-3.0": {
    name: "Creative Commons Attribution 3.0 Unported",
    CC: true
  },
  "CC-BY-3.0-AT": {
    name: "Creative Commons Attribution 3.0 Austria",
    CC: true
  },
  "CC-BY-3.0-AU": {
    name: "Creative Commons Attribution 3.0 Australia",
    CC: true
  },
  "CC-BY-3.0-DE": {
    name: "Creative Commons Attribution 3.0 Germany",
    CC: true
  },
  "CC-BY-3.0-IGO": {
    name: "Creative Commons Attribution 3.0 IGO",
    CC: true
  },
  "CC-BY-3.0-NL": {
    name: "Creative Commons Attribution 3.0 Netherlands",
    CC: true
  },
  "CC-BY-3.0-US": {
    name: "Creative Commons Attribution 3.0 United States",
    CC: true
  },
  "CC-BY-4.0": {
    name: "Creative Commons Attribution 4.0 International",
    free: true,
    CC: true
  },
  "CC-BY-NC-1.0": {
    name: "Creative Commons Attribution Non Commercial 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-2.0": {
    name: "Creative Commons Attribution Non Commercial 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-2.5": {
    name: "Creative Commons Attribution Non Commercial 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-3.0": {
    name: "Creative Commons Attribution Non Commercial 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-4.0": {
    name: "Creative Commons Attribution Non Commercial 4.0 International",
    CC: true
  },
  "CC-BY-NC-ND-1.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-ND-2.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-ND-2.5": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-ND-3.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-ND-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-ND-3.0-IGO": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 3.0 IGO",
    CC: true
  },
  "CC-BY-NC-ND-4.0": {
    name: "Creative Commons Attribution Non Commercial No Derivatives 4.0 International",
    CC: true
  },
  "CC-BY-NC-SA-1.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 1.0 Generic",
    CC: true
  },
  "CC-BY-NC-SA-2.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Generic",
    CC: true
  },
  "CC-BY-NC-SA-2.0-DE": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 Germany",
    CC: true
  },
  "CC-BY-NC-SA-2.0-FR": {
    name: "Creative Commons Attribution-NonCommercial-ShareAlike 2.0 France",
    CC: true
  },
  "CC-BY-NC-SA-2.0-UK": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.0 England and Wales",
    CC: true
  },
  "CC-BY-NC-SA-2.5": {
    name: "Creative Commons Attribution Non Commercial Share Alike 2.5 Generic",
    CC: true
  },
  "CC-BY-NC-SA-3.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Unported",
    CC: true
  },
  "CC-BY-NC-SA-3.0-DE": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 Germany",
    CC: true
  },
  "CC-BY-NC-SA-3.0-IGO": {
    name: "Creative Commons Attribution Non Commercial Share Alike 3.0 IGO",
    CC: true
  },
  "CC-BY-NC-SA-4.0": {
    name: "Creative Commons Attribution Non Commercial Share Alike 4.0 International",
    CC: true
  },
  "CC-BY-ND-1.0": {
    name: "Creative Commons Attribution No Derivatives 1.0 Generic",
    CC: true
  },
  "CC-BY-ND-2.0": {
    name: "Creative Commons Attribution No Derivatives 2.0 Generic",
    CC: true
  },
  "CC-BY-ND-2.5": {
    name: "Creative Commons Attribution No Derivatives 2.5 Generic",
    CC: true
  },
  "CC-BY-ND-3.0": {
    name: "Creative Commons Attribution No Derivatives 3.0 Unported",
    CC: true
  },
  "CC-BY-ND-3.0-DE": {
    name: "Creative Commons Attribution No Derivatives 3.0 Germany",
    CC: true
  },
  "CC-BY-ND-4.0": {
    name: "Creative Commons Attribution No Derivatives 4.0 International",
    CC: true
  },
  "CC-BY-SA-1.0": {
    name: "Creative Commons Attribution Share Alike 1.0 Generic",
    CC: true
  },
  "CC-BY-SA-2.0": {
    name: "Creative Commons Attribution Share Alike 2.0 Generic",
    CC: true
  },
  "CC-BY-SA-2.0-UK": {
    name: "Creative Commons Attribution Share Alike 2.0 England and Wales",
    CC: true
  },
  "CC-BY-SA-2.1-JP": {
    name: "Creative Commons Attribution Share Alike 2.1 Japan",
    CC: true
  },
  "CC-BY-SA-2.5": {
    name: "Creative Commons Attribution Share Alike 2.5 Generic",
    CC: true
  },
  "CC-BY-SA-3.0": {
    name: "Creative Commons Attribution Share Alike 3.0 Unported",
    CC: true
  },
  "CC-BY-SA-3.0-AT": {
    name: "Creative Commons Attribution Share Alike 3.0 Austria",
    CC: true
  },
  "CC-BY-SA-3.0-DE": {
    name: "Creative Commons Attribution Share Alike 3.0 Germany",
    CC: true
  },
  "CC-BY-SA-3.0-IGO": {
    name: "Creative Commons Attribution-ShareAlike 3.0 IGO",
    CC: true
  },
  "CC-BY-SA-4.0": {
    name: "Creative Commons Attribution Share Alike 4.0 International",
    free: true,
    CC: true
  },
  "CC-PDDC": {
    name: "Creative Commons Public Domain Dedication and Certification",
    CC: true
  },
  "CC-PDM-1.0": {
    name: "Creative    Commons Public Domain Mark 1.0 Universal",
    CC: true
  },
  "CC-SA-1.0": {
    name: "Creative Commons Share Alike 1.0 Generic",
    CC: true
  },
  "CC0-1.0": {
    name: "Creative Commons Zero v1.0 Universal",
    free: true,
    CC: true
  },
  "CDDL-1.0": {
    name: "Common Development and Distribution License 1.0",
    osi: true,
    free: true
  },
  "CDDL-1.1": {
    name: "Common Development and Distribution License 1.1"
  },
  "CDL-1.0": {
    name: "Common Documentation License 1.0"
  },
  "CDLA-Permissive-1.0": {
    name: "Community Data License Agreement Permissive 1.0"
  },
  "CDLA-Permissive-2.0": {
    name: "Community Data License Agreement Permissive 2.0"
  },
  "CDLA-Sharing-1.0": {
    name: "Community Data License Agreement Sharing 1.0"
  },
  "CECILL-1.0": {
    name: "CeCILL Free Software License Agreement v1.0"
  },
  "CECILL-1.1": {
    name: "CeCILL Free Software License Agreement v1.1"
  },
  "CECILL-2.0": {
    name: "CeCILL Free Software License Agreement v2.0",
    free: true
  },
  "CECILL-2.1": {
    name: "CeCILL Free Software License Agreement v2.1",
    osi: true
  },
  "CECILL-B": {
    name: "CeCILL-B Free Software License Agreement",
    free: true
  },
  "CECILL-C": {
    name: "CeCILL-C Free Software License Agreement",
    free: true
  },
  "CERN-OHL-1.1": {
    name: "CERN Open Hardware Licence v1.1"
  },
  "CERN-OHL-1.2": {
    name: "CERN Open Hardware Licence v1.2"
  },
  "CERN-OHL-P-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Permissive",
    osi: true
  },
  "CERN-OHL-S-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Strongly Reciprocal",
    osi: true
  },
  "CERN-OHL-W-2.0": {
    name: "CERN Open Hardware Licence Version 2 - Weakly Reciprocal",
    osi: true
  },
  CFITSIO: {
    name: "CFITSIO License"
  },
  "check-cvs": {
    name: "check-cvs License"
  },
  checkmk: {
    name: "Checkmk License"
  },
  ClArtistic: {
    name: "Clarified Artistic License",
    free: true
  },
  Clips: {
    name: "Clips License"
  },
  "CMU-Mach": {
    name: "CMU Mach License"
  },
  "CMU-Mach-nodoc": {
    name: "CMU    Mach - no notices-in-documentation variant"
  },
  "CNRI-Jython": {
    name: "CNRI Jython License"
  },
  "CNRI-Python": {
    name: "CNRI Python License",
    osi: true
  },
  "CNRI-Python-GPL-Compatible": {
    name: "CNRI Python Open Source GPL Compatible License Agreement"
  },
  "COIL-1.0": {
    name: "Copyfree Open Innovation License"
  },
  "Community-Spec-1.0": {
    name: "Community Specification License 1.0"
  },
  "Condor-1.1": {
    name: "Condor Public License v1.1",
    free: true
  },
  "copyleft-next-0.3.0": {
    name: "copyleft-next 0.3.0"
  },
  "copyleft-next-0.3.1": {
    name: "copyleft-next 0.3.1"
  },
  "Cornell-Lossless-JPEG": {
    name: "Cornell Lossless JPEG License"
  },
  "CPAL-1.0": {
    name: "Common Public Attribution License 1.0",
    osi: true,
    free: true
  },
  "CPL-1.0": {
    name: "Common Public License 1.0",
    osi: true,
    free: true
  },
  "CPOL-1.02": {
    name: "Code Project Open License 1.02"
  },
  Cronyx: {
    name: "Cronyx License"
  },
  Crossword: {
    name: "Crossword License"
  },
  CryptoSwift: {
    name: "CryptoSwift License"
  },
  CrystalStacker: {
    name: "CrystalStacker License"
  },
  "CUA-OPL-1.0": {
    name: "CUA Office Public License v1.0",
    osi: true
  },
  Cube: {
    name: "Cube License"
  },
  curl: {
    name: "curl License"
  },
  "cve-tou": {
    name: "Common Vulnerability Enumeration ToU License"
  },
  "D-FSL-1.0": {
    name: "Deutsche Freie Software Lizenz"
  },
  "DEC-3-Clause": {
    name: "DEC 3-Clause License"
  },
  diffmark: {
    name: "diffmark license"
  },
  "DL-DE-BY-2.0": {
    name: "Data licence Germany \u2013 attribution \u2013 version 2.0"
  },
  "DL-DE-ZERO-2.0": {
    name: "Data licence Germany \u2013 zero \u2013 version 2.0"
  },
  DOC: {
    name: "DOC License"
  },
  "DocBook-DTD": {
    name: "DocBook DTD License"
  },
  "DocBook-Schema": {
    name: "DocBook Schema License"
  },
  "DocBook-Stylesheet": {
    name: "DocBook Stylesheet License"
  },
  "DocBook-XML": {
    name: "DocBook XML License"
  },
  Dotseqn: {
    name: "Dotseqn License"
  },
  "DRL-1.0": {
    name: "Detection Rule License 1.0"
  },
  "DRL-1.1": {
    name: "Detection Rule License 1.1"
  },
  DSDP: {
    name: "DSDP License"
  },
  dtoa: {
    name: "David M. Gay dtoa License"
  },
  dvipdfm: {
    name: "dvipdfm License"
  },
  "ECL-1.0": {
    name: "Educational Community License v1.0",
    osi: true
  },
  "ECL-2.0": {
    name: "Educational Community License v2.0",
    osi: true,
    free: true
  },
  "EFL-1.0": {
    name: "Eiffel Forum License v1.0",
    osi: true
  },
  "EFL-2.0": {
    name: "Eiffel Forum License v2.0",
    osi: true,
    free: true
  },
  eGenix: {
    name: "eGenix.com Public License 1.1.0"
  },
  "Elastic-2.0": {
    name: "Elastic License 2.0"
  },
  Entessa: {
    name: "Entessa Public License v1.0",
    osi: true
  },
  EPICS: {
    name: "EPICS Open License"
  },
  "EPL-1.0": {
    name: "Eclipse Public License 1.0",
    osi: true,
    free: true
  },
  "EPL-2.0": {
    name: "Eclipse Public License 2.0",
    osi: true,
    free: true
  },
  "ErlPL-1.1": {
    name: "Erlang Public License v1.1"
  },
  "etalab-2.0": {
    name: "Etalab Open License 2.0"
  },
  EUDatagrid: {
    name: "EU DataGrid Software License",
    osi: true,
    free: true
  },
  "EUPL-1.0": {
    name: "European Union Public License 1.0"
  },
  "EUPL-1.1": {
    name: "European Union Public License 1.1",
    osi: true,
    free: true
  },
  "EUPL-1.2": {
    name: "European Union Public License 1.2",
    osi: true,
    free: true
  },
  Eurosym: {
    name: "Eurosym License"
  },
  Fair: {
    name: "Fair License",
    osi: true
  },
  FBM: {
    name: "Fuzzy Bitmap License"
  },
  "FDK-AAC": {
    name: "Fraunhofer FDK AAC Codec Library"
  },
  "Ferguson-Twofish": {
    name: "Ferguson Twofish License"
  },
  "Frameworx-1.0": {
    name: "Frameworx Open License 1.0",
    osi: true
  },
  "FreeBSD-DOC": {
    name: "FreeBSD Documentation License"
  },
  FreeImage: {
    name: "FreeImage Public License v1.0"
  },
  FSFAP: {
    name: "FSF All Permissive License",
    free: true
  },
  "FSFAP-no-warranty-disclaimer": {
    name: "FSF All Permissive License (without Warranty)"
  },
  FSFUL: {
    name: "FSF Unlimited License"
  },
  FSFULLR: {
    name: "FSF Unlimited License (with License Retention)"
  },
  FSFULLRSD: {
    name: "FSF Unlimited License (with License Retention and Short Disclaimer)"
  },
  FSFULLRWD: {
    name: "FSF Unlimited License (With License Retention and Warranty Disclaimer)"
  },
  "FSL-1.1-ALv2": {
    name: "Functional Source License, Version 1.1, ALv2 Future License"
  },
  "FSL-1.1-MIT": {
    name: "Functional Source License, Version 1.1, MIT Future License"
  },
  FTL: {
    name: "Freetype Project License",
    free: true
  },
  Furuseth: {
    name: "Furuseth License"
  },
  fwlw: {
    name: "fwlw License"
  },
  "Game-Programming-Gems": {
    name: "Game Programming Gems License"
  },
  "GCR-docs": {
    name: "Gnome GCR Documentation License"
  },
  GD: {
    name: "GD License"
  },
  "generic-xts": {
    name: "Generic XTS License"
  },
  "GFDL-1.1-invariants-only": {
    name: "GNU Free Documentation License v1.1 only - invariants"
  },
  "GFDL-1.1-invariants-or-later": {
    name: "GNU Free Documentation License v1.1 or later - invariants"
  },
  "GFDL-1.1-no-invariants-only": {
    name: "GNU Free Documentation License v1.1 only - no invariants"
  },
  "GFDL-1.1-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.1 or later - no invariants"
  },
  "GFDL-1.1-only": {
    name: "GNU Free Documentation License v1.1 only",
    free: true
  },
  "GFDL-1.1-or-later": {
    name: "GNU Free Documentation License v1.1 or later",
    free: true
  },
  "GFDL-1.2-invariants-only": {
    name: "GNU Free Documentation License v1.2 only - invariants"
  },
  "GFDL-1.2-invariants-or-later": {
    name: "GNU Free Documentation License v1.2 or later - invariants"
  },
  "GFDL-1.2-no-invariants-only": {
    name: "GNU Free Documentation License v1.2 only - no invariants"
  },
  "GFDL-1.2-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.2 or later - no invariants"
  },
  "GFDL-1.2-only": {
    name: "GNU Free Documentation License v1.2 only",
    free: true
  },
  "GFDL-1.2-or-later": {
    name: "GNU Free Documentation License v1.2 or later",
    free: true
  },
  "GFDL-1.3-invariants-only": {
    name: "GNU Free Documentation License v1.3 only - invariants"
  },
  "GFDL-1.3-invariants-or-later": {
    name: "GNU Free Documentation License v1.3 or later - invariants"
  },
  "GFDL-1.3-no-invariants-only": {
    name: "GNU Free Documentation License v1.3 only - no invariants"
  },
  "GFDL-1.3-no-invariants-or-later": {
    name: "GNU Free Documentation License v1.3 or later - no invariants"
  },
  "GFDL-1.3-only": {
    name: "GNU Free Documentation License v1.3 only",
    free: true
  },
  "GFDL-1.3-or-later": {
    name: "GNU Free Documentation License v1.3 or later",
    free: true
  },
  Giftware: {
    name: "Giftware License"
  },
  GL2PS: {
    name: "GL2PS License"
  },
  Glide: {
    name: "3dfx Glide License"
  },
  Glulxe: {
    name: "Glulxe License"
  },
  GLWTPL: {
    name: "Good Luck With That Public License"
  },
  gnuplot: {
    name: "gnuplot License",
    free: true
  },
  "GPL-1.0-only": {
    name: "GNU General Public License v1.0 only"
  },
  "GPL-1.0-or-later": {
    name: "GNU General Public License v1.0 or later"
  },
  "GPL-2.0-only": {
    name: "GNU General Public License v2.0 only",
    osi: true,
    free: true
  },
  "GPL-2.0-or-later": {
    name: "GNU General Public License v2.0 or later",
    osi: true,
    free: true
  },
  "GPL-3.0-only": {
    name: "GNU General Public License v3.0 only",
    osi: true,
    free: true
  },
  "GPL-3.0-or-later": {
    name: "GNU General Public License v3.0 or later",
    osi: true,
    free: true
  },
  "Graphics-Gems": {
    name: "Graphics Gems License"
  },
  "gSOAP-1.3b": {
    name: "gSOAP Public License v1.3b"
  },
  gtkbook: {
    name: "gtkbook License"
  },
  Gutmann: {
    name: "Gutmann License"
  },
  HaskellReport: {
    name: "Haskell Language Report License"
  },
  HDF5: {
    name: "HDF5 License"
  },
  hdparm: {
    name: "hdparm License"
  },
  HIDAPI: {
    name: "HIDAPI License"
  },
  "Hippocratic-2.1": {
    name: "Hippocratic License 2.1"
  },
  "HP-1986": {
    name: "Hewlett-Packard 1986 License"
  },
  "HP-1989": {
    name: "Hewlett-Packard 1989 License"
  },
  HPND: {
    name: "Historical Permission Notice and Disclaimer",
    osi: true,
    free: true
  },
  "HPND-DEC": {
    name: "Historical Permission Notice and Disclaimer - DEC variant"
  },
  "HPND-doc": {
    name: "Historical Permission Notice and Disclaimer - documentation variant"
  },
  "HPND-doc-sell": {
    name: "Historical Permission Notice and Disclaimer - documentation sell variant"
  },
  "HPND-export-US": {
    name: "HPND with US Government export control warning"
  },
  "HPND-export-US-acknowledgement": {
    name: "HPND with US Government export control warning and acknowledgment"
  },
  "HPND-export-US-modify": {
    name: "HPND with US Government export control warning and modification rqmt"
  },
  "HPND-export2-US": {
    name: "HPND with US Government export control and 2 disclaimers"
  },
  "HPND-Fenneberg-Livingston": {
    name: "Historical Permission Notice and Disclaimer - Fenneberg-Livingston variant"
  },
  "HPND-INRIA-IMAG": {
    name: "Historical Permission Notice and Disclaimer    - INRIA-IMAG variant"
  },
  "HPND-Intel": {
    name: "Historical Permission Notice and Disclaimer - Intel variant"
  },
  "HPND-Kevlin-Henney": {
    name: "Historical Permission Notice and Disclaimer - Kevlin Henney variant"
  },
  "HPND-Markus-Kuhn": {
    name: "Historical Permission Notice and Disclaimer - Markus Kuhn variant"
  },
  "HPND-merchantability-variant": {
    name: "Historical Permission Notice and Disclaimer - merchantability variant"
  },
  "HPND-MIT-disclaimer": {
    name: "Historical Permission Notice and Disclaimer with MIT disclaimer"
  },
  "HPND-Netrek": {
    name: "Historical Permission Notice and Disclaimer - Netrek variant"
  },
  "HPND-Pbmplus": {
    name: "Historical Permission Notice and Disclaimer - Pbmplus variant"
  },
  "HPND-sell-MIT-disclaimer-xserver": {
    name: "Historical Permission Notice and Disclaimer - sell xserver variant with MIT disclaimer"
  },
  "HPND-sell-regexpr": {
    name: "Historical Permission Notice and Disclaimer - sell regexpr variant"
  },
  "HPND-sell-variant": {
    name: "Historical Permission Notice and Disclaimer - sell variant"
  },
  "HPND-sell-variant-MIT-disclaimer": {
    name: "HPND sell variant with MIT disclaimer"
  },
  "HPND-sell-variant-MIT-disclaimer-rev": {
    name: "HPND sell variant with MIT disclaimer - reverse"
  },
  "HPND-UC": {
    name: "Historical Permission Notice and Disclaimer - University of California variant"
  },
  "HPND-UC-export-US": {
    name: "Historical Permission Notice and Disclaimer - University of California, US export warning"
  },
  HTMLTIDY: {
    name: "HTML Tidy License"
  },
  "IBM-pibs": {
    name: "IBM PowerPC Initialization and Boot Software"
  },
  ICU: {
    name: "ICU License",
    osi: true
  },
  "IEC-Code-Components-EULA": {
    name: "IEC    Code Components End-user licence agreement"
  },
  IJG: {
    name: "Independent JPEG Group License",
    free: true
  },
  "IJG-short": {
    name: "Independent JPEG Group License - short"
  },
  ImageMagick: {
    name: "ImageMagick License"
  },
  iMatix: {
    name: "iMatix Standard Function Library Agreement",
    free: true
  },
  Imlib2: {
    name: "Imlib2 License",
    free: true
  },
  "Info-ZIP": {
    name: "Info-ZIP License"
  },
  "Inner-Net-2.0": {
    name: "Inner Net License v2.0"
  },
  InnoSetup: {
    name: "Inno Setup License"
  },
  Intel: {
    name: "Intel Open Source License",
    osi: true,
    free: true
  },
  "Intel-ACPI": {
    name: "Intel ACPI Software License Agreement"
  },
  "Interbase-1.0": {
    name: "Interbase Public License v1.0"
  },
  IPA: {
    name: "IPA Font License",
    osi: true,
    free: true
  },
  "IPL-1.0": {
    name: "IBM Public License v1.0",
    osi: true,
    free: true
  },
  ISC: {
    name: "ISC License",
    osi: true,
    free: true
  },
  "ISC-Veillard": {
    name: "ISC Veillard variant"
  },
  Jam: {
    name: "Jam License",
    osi: true
  },
  "JasPer-2.0": {
    name: "JasPer License"
  },
  jove: {
    name: "Jove License"
  },
  "JPL-image": {
    name: "JPL Image Use Policy"
  },
  JPNIC: {
    name: "Japan Network Information Center License"
  },
  JSON: {
    name: "JSON License"
  },
  Kastrup: {
    name: "Kastrup License"
  },
  Kazlib: {
    name: "Kazlib License"
  },
  "Knuth-CTAN": {
    name: "Knuth CTAN License"
  },
  "LAL-1.2": {
    name: "Licence Art Libre 1.2"
  },
  "LAL-1.3": {
    name: "Licence Art Libre 1.3"
  },
  Latex2e: {
    name: "Latex2e License"
  },
  "Latex2e-translated-notice": {
    name: "Latex2e with translated notice permission"
  },
  Leptonica: {
    name: "Leptonica License"
  },
  "LGPL-2.0-only": {
    name: "GNU Library General Public License v2 only",
    osi: true
  },
  "LGPL-2.0-or-later": {
    name: "GNU Library General Public License v2 or later",
    osi: true
  },
  "LGPL-2.1-only": {
    name: "GNU Lesser General Public License v2.1 only",
    osi: true,
    free: true
  },
  "LGPL-2.1-or-later": {
    name: "GNU Lesser General Public License v2.1 or later",
    osi: true,
    free: true
  },
  "LGPL-3.0-only": {
    name: "GNU Lesser General Public License v3.0 only",
    osi: true,
    free: true
  },
  "LGPL-3.0-or-later": {
    name: "GNU Lesser General Public License v3.0 or later",
    osi: true,
    free: true
  },
  LGPLLR: {
    name: "Lesser General Public License For Linguistic Resources"
  },
  Libpng: {
    name: "libpng License"
  },
  "libpng-1.6.35": {
    name: "PNG Reference Library License v1 (for libpng 0.5 through 1.6.35)"
  },
  "libpng-2.0": {
    name: "PNG Reference Library version 2"
  },
  "libselinux-1.0": {
    name: "libselinux public domain notice"
  },
  libtiff: {
    name: "libtiff License"
  },
  "libutil-David-Nugent": {
    name: "libutil David Nugent License"
  },
  "LiLiQ-P-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 Permissive version 1.1",
    osi: true
  },
  "LiLiQ-R-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 R\xE9ciprocit\xE9 version 1.1",
    osi: true
  },
  "LiLiQ-Rplus-1.1": {
    name: "Licence Libre du Qu\xE9bec \u2013 R\xE9ciprocit\xE9 forte version 1.1",
    osi: true
  },
  "Linux-man-pages-1-para": {
    name: "Linux man-pages - 1 paragraph"
  },
  "Linux-man-pages-copyleft": {
    name: "Linux man-pages Copyleft"
  },
  "Linux-man-pages-copyleft-2-para": {
    name: "Linux man-pages Copyleft - 2 paragraphs"
  },
  "Linux-man-pages-copyleft-var": {
    name: "Linux man-pages Copyleft Variant"
  },
  "Linux-OpenIB": {
    name: "Linux Kernel Variant of OpenIB.org license"
  },
  LOOP: {
    name: "Common Lisp LOOP License"
  },
  "LPD-document": {
    name: "LPD Documentation License"
  },
  "LPL-1.0": {
    name: "Lucent Public License Version 1.0",
    osi: true
  },
  "LPL-1.02": {
    name: "Lucent Public License v1.02",
    osi: true,
    free: true
  },
  "LPPL-1.0": {
    name: "LaTeX Project Public License v1.0"
  },
  "LPPL-1.1": {
    name: "LaTeX Project Public License v1.1"
  },
  "LPPL-1.2": {
    name: "LaTeX Project Public License v1.2",
    free: true
  },
  "LPPL-1.3a": {
    name: "LaTeX Project Public License v1.3a",
    free: true
  },
  "LPPL-1.3c": {
    name: "LaTeX Project Public License v1.3c",
    osi: true
  },
  lsof: {
    name: "lsof License"
  },
  "Lucida-Bitmap-Fonts": {
    name: "Lucida Bitmap Fonts License"
  },
  "LZMA-SDK-9.11-to-9.20": {
    name: "LZMA SDK License (versions 9.11 to 9.20)"
  },
  "LZMA-SDK-9.22": {
    name: "LZMA SDK License (versions 9.22 and beyond)"
  },
  "Mackerras-3-Clause": {
    name: "Mackerras 3-Clause License"
  },
  "Mackerras-3-Clause-acknowledgment": {
    name: "Mackerras 3-Clause - acknowledgment variant"
  },
  magaz: {
    name: "magaz License"
  },
  mailprio: {
    name: "mailprio License"
  },
  MakeIndex: {
    name: "MakeIndex License"
  },
  man2html: {
    name: "man2html License"
  },
  "Martin-Birgmeier": {
    name: "Martin Birgmeier License"
  },
  "McPhee-slideshow": {
    name: "McPhee Slideshow License"
  },
  metamail: {
    name: "metamail License"
  },
  Minpack: {
    name: "Minpack License"
  },
  MIPS: {
    name: "MIPS License"
  },
  MirOS: {
    name: "The MirOS Licence",
    osi: true
  },
  MIT: {
    name: "MIT License",
    osi: true,
    free: true
  },
  "MIT-0": {
    name: "MIT No Attribution",
    osi: true
  },
  "MIT-advertising": {
    name: "Enlightenment License (e16)"
  },
  "MIT-Click": {
    name: "MIT Click License"
  },
  "MIT-CMU": {
    name: "CMU License"
  },
  "MIT-enna": {
    name: "enna License"
  },
  "MIT-feh": {
    name: "feh License"
  },
  "MIT-Festival": {
    name: "MIT Festival Variant"
  },
  "MIT-Khronos-old": {
    name: "MIT Khronos - old variant"
  },
  "MIT-Modern-Variant": {
    name: "MIT License Modern Variant",
    osi: true
  },
  "MIT-open-group": {
    name: "MIT Open Group variant"
  },
  "MIT-testregex": {
    name: "MIT testregex Variant"
  },
  "MIT-Wu": {
    name: "MIT Tom Wu Variant"
  },
  MITNFA: {
    name: "MIT +no-false-attribs license"
  },
  MMIXware: {
    name: "MMIXware License"
  },
  Motosoto: {
    name: "Motosoto License",
    osi: true
  },
  "MPEG-SSG": {
    name: "MPEG Software Simulation"
  },
  "mpi-permissive": {
    name: "mpi Permissive License"
  },
  mpich2: {
    name: "mpich2 License"
  },
  "MPL-1.0": {
    name: "Mozilla Public License 1.0",
    osi: true
  },
  "MPL-1.1": {
    name: "Mozilla Public License 1.1",
    osi: true,
    free: true
  },
  "MPL-2.0": {
    name: "Mozilla Public License 2.0",
    osi: true,
    free: true
  },
  "MPL-2.0-no-copyleft-exception": {
    name: "Mozilla Public License 2.0 (no copyleft exception)",
    osi: true
  },
  mplus: {
    name: "mplus Font License"
  },
  "MS-LPL": {
    name: "Microsoft Limited Public License"
  },
  "MS-PL": {
    name: "Microsoft Public License",
    osi: true,
    free: true
  },
  "MS-RL": {
    name: "Microsoft Reciprocal License",
    osi: true,
    free: true
  },
  MTLL: {
    name: "Matrix Template Library License"
  },
  "MulanPSL-1.0": {
    name: "Mulan Permissive Software License, Version 1"
  },
  "MulanPSL-2.0": {
    name: "Mulan Permissive Software License, Version 2",
    osi: true
  },
  Multics: {
    name: "Multics License",
    osi: true
  },
  Mup: {
    name: "Mup License"
  },
  "NAIST-2003": {
    name: "Nara Institute of Science and Technology License (2003)"
  },
  "NASA-1.3": {
    name: "NASA Open Source Agreement 1.3",
    osi: true
  },
  Naumen: {
    name: "Naumen Public License",
    osi: true
  },
  "NBPL-1.0": {
    name: "Net Boolean Public License v1"
  },
  "NCBI-PD": {
    name: "NCBI Public Domain Notice"
  },
  "NCGL-UK-2.0": {
    name: "Non-Commercial Government Licence"
  },
  NCL: {
    name: "NCL Source Code License"
  },
  NCSA: {
    name: "University of Illinois/NCSA Open Source License",
    osi: true,
    free: true
  },
  NetCDF: {
    name: "NetCDF license"
  },
  Newsletr: {
    name: "Newsletr License"
  },
  NGPL: {
    name: "Nethack General Public License",
    osi: true
  },
  ngrep: {
    name: "ngrep License"
  },
  "NICTA-1.0": {
    name: "NICTA Public Software License, Version 1.0"
  },
  "NIST-PD": {
    name: "NIST Public Domain Notice"
  },
  "NIST-PD-fallback": {
    name: "NIST Public Domain Notice with license fallback"
  },
  "NIST-Software": {
    name: "NIST Software License"
  },
  "NLOD-1.0": {
    name: "Norwegian Licence for Open Government Data (NLOD) 1.0"
  },
  "NLOD-2.0": {
    name: "Norwegian Licence for Open Government Data (NLOD) 2.0"
  },
  NLPL: {
    name: "No Limit Public License"
  },
  Nokia: {
    name: "Nokia Open Source License",
    osi: true,
    free: true
  },
  NOSL: {
    name: "Netizen Open Source License",
    free: true
  },
  Noweb: {
    name: "Noweb License"
  },
  "NPL-1.0": {
    name: "Netscape Public License v1.0",
    free: true
  },
  "NPL-1.1": {
    name: "Netscape Public License v1.1",
    free: true
  },
  "NPOSL-3.0": {
    name: "Non-Profit Open Software License 3.0",
    osi: true
  },
  NRL: {
    name: "NRL License"
  },
  "NTIA-PD": {
    name: "NTIA Public Domain Notice"
  },
  NTP: {
    name: "NTP License",
    osi: true
  },
  "NTP-0": {
    name: "NTP No Attribution"
  },
  "O-UDA-1.0": {
    name: "Open Use of Data Agreement v1.0"
  },
  OAR: {
    name: "OAR License"
  },
  "OCCT-PL": {
    name: "Open CASCADE Technology Public License"
  },
  "OCLC-2.0": {
    name: "OCLC Research Public License 2.0",
    osi: true
  },
  "ODbL-1.0": {
    name: "Open Data Commons Open Database License v1.0",
    free: true
  },
  "ODC-By-1.0": {
    name: "Open Data Commons Attribution License v1.0"
  },
  OFFIS: {
    name: "OFFIS License"
  },
  "OFL-1.0": {
    name: "SIL Open Font License 1.0",
    free: true
  },
  "OFL-1.0-no-RFN": {
    name: "SIL Open Font License 1.0 with no Reserved Font Name"
  },
  "OFL-1.0-RFN": {
    name: "SIL Open Font License 1.0 with Reserved Font Name"
  },
  "OFL-1.1": {
    name: "SIL Open Font License 1.1",
    osi: true,
    free: true
  },
  "OFL-1.1-no-RFN": {
    name: "SIL Open Font License 1.1 with no Reserved Font Name",
    osi: true
  },
  "OFL-1.1-RFN": {
    name: "SIL Open Font License 1.1 with Reserved Font Name",
    osi: true
  },
  "OGC-1.0": {
    name: "OGC Software License, Version 1.0"
  },
  "OGDL-Taiwan-1.0": {
    name: "Taiwan Open Government Data License, version 1.0"
  },
  "OGL-Canada-2.0": {
    name: "Open Government Licence - Canada"
  },
  "OGL-UK-1.0": {
    name: "Open Government Licence v1.0"
  },
  "OGL-UK-2.0": {
    name: "Open Government Licence v2.0"
  },
  "OGL-UK-3.0": {
    name: "Open Government Licence v3.0"
  },
  OGTSL: {
    name: "Open Group Test Suite License",
    osi: true
  },
  "OLDAP-1.1": {
    name: "Open LDAP Public License v1.1"
  },
  "OLDAP-1.2": {
    name: "Open LDAP Public License v1.2"
  },
  "OLDAP-1.3": {
    name: "Open LDAP Public License v1.3"
  },
  "OLDAP-1.4": {
    name: "Open LDAP Public License v1.4"
  },
  "OLDAP-2.0": {
    name: "Open LDAP Public License v2.0 (or possibly 2.0A and 2.0B)"
  },
  "OLDAP-2.0.1": {
    name: "Open LDAP Public License v2.0.1"
  },
  "OLDAP-2.1": {
    name: "Open LDAP Public License v2.1"
  },
  "OLDAP-2.2": {
    name: "Open LDAP Public License v2.2"
  },
  "OLDAP-2.2.1": {
    name: "Open LDAP Public License v2.2.1"
  },
  "OLDAP-2.2.2": {
    name: "Open LDAP Public License 2.2.2"
  },
  "OLDAP-2.3": {
    name: "Open LDAP Public License v2.3",
    free: true
  },
  "OLDAP-2.4": {
    name: "Open LDAP Public License v2.4"
  },
  "OLDAP-2.5": {
    name: "Open LDAP Public License v2.5"
  },
  "OLDAP-2.6": {
    name: "Open LDAP Public License v2.6"
  },
  "OLDAP-2.7": {
    name: "Open LDAP Public License v2.7",
    free: true
  },
  "OLDAP-2.8": {
    name: "Open LDAP Public License v2.8",
    osi: true
  },
  "OLFL-1.3": {
    name: "Open Logistics Foundation License Version 1.3",
    osi: true
  },
  OML: {
    name: "Open Market License"
  },
  "OpenPBS-2.3": {
    name: "OpenPBS v2.3 Software License"
  },
  OpenSSL: {
    name: "OpenSSL License",
    free: true
  },
  "OpenSSL-standalone": {
    name: "OpenSSL License - standalone"
  },
  OpenVision: {
    name: "OpenVision License"
  },
  "OPL-1.0": {
    name: "Open Public License v1.0"
  },
  "OPL-UK-3.0": {
    name: "United    Kingdom Open Parliament Licence v3.0"
  },
  "OPUBL-1.0": {
    name: "Open Publication License v1.0"
  },
  "OSET-PL-2.1": {
    name: "OSET Public License version 2.1",
    osi: true
  },
  "OSL-1.0": {
    name: "Open Software License 1.0",
    osi: true,
    free: true
  },
  "OSL-1.1": {
    name: "Open Software License 1.1",
    free: true
  },
  "OSL-2.0": {
    name: "Open Software License 2.0",
    osi: true,
    free: true
  },
  "OSL-2.1": {
    name: "Open Software License 2.1",
    osi: true,
    free: true
  },
  "OSL-3.0": {
    name: "Open Software License 3.0",
    osi: true,
    free: true
  },
  PADL: {
    name: "PADL License"
  },
  "Parity-6.0.0": {
    name: "The Parity Public License 6.0.0"
  },
  "Parity-7.0.0": {
    name: "The Parity Public License 7.0.0"
  },
  "PDDL-1.0": {
    name: "Open Data Commons Public Domain Dedication & License 1.0"
  },
  "PHP-3.0": {
    name: "PHP License v3.0",
    osi: true
  },
  "PHP-3.01": {
    name: "PHP License v3.01",
    osi: true,
    free: true
  },
  Pixar: {
    name: "Pixar License"
  },
  pkgconf: {
    name: "pkgconf License"
  },
  Plexus: {
    name: "Plexus Classworlds License"
  },
  pnmstitch: {
    name: "pnmstitch License"
  },
  "PolyForm-Noncommercial-1.0.0": {
    name: "PolyForm Noncommercial License 1.0.0"
  },
  "PolyForm-Small-Business-1.0.0": {
    name: "PolyForm Small Business License 1.0.0"
  },
  PostgreSQL: {
    name: "PostgreSQL License",
    osi: true
  },
  PPL: {
    name: "Peer Production License"
  },
  "PSF-2.0": {
    name: "Python Software Foundation License 2.0"
  },
  psfrag: {
    name: "psfrag License"
  },
  psutils: {
    name: "psutils License"
  },
  "Python-2.0": {
    name: "Python License 2.0",
    osi: true,
    free: true
  },
  "Python-2.0.1": {
    name: "Python License 2.0.1"
  },
  "python-ldap": {
    name: "Python ldap License"
  },
  Qhull: {
    name: "Qhull License"
  },
  "QPL-1.0": {
    name: "Q Public License 1.0",
    osi: true,
    free: true
  },
  "QPL-1.0-INRIA-2004": {
    name: "Q Public License 1.0 - INRIA 2004 variant"
  },
  radvd: {
    name: "radvd License"
  },
  Rdisc: {
    name: "Rdisc License"
  },
  "RHeCos-1.1": {
    name: "Red Hat eCos Public License v1.1"
  },
  "RPL-1.1": {
    name: "Reciprocal Public License 1.1",
    osi: true
  },
  "RPL-1.5": {
    name: "Reciprocal Public License 1.5",
    osi: true
  },
  "RPSL-1.0": {
    name: "RealNetworks Public Source License v1.0",
    osi: true,
    free: true
  },
  "RSA-MD": {
    name: "RSA Message-Digest License"
  },
  RSCPL: {
    name: "Ricoh Source Code Public License",
    osi: true
  },
  Ruby: {
    name: "Ruby License",
    free: true
  },
  "Ruby-pty": {
    name: "Ruby pty extension license"
  },
  "SAX-PD": {
    name: "Sax Public Domain Notice"
  },
  "SAX-PD-2.0": {
    name: "Sax Public Domain Notice 2.0"
  },
  Saxpath: {
    name: "Saxpath License"
  },
  SCEA: {
    name: "SCEA Shared Source License"
  },
  SchemeReport: {
    name: "Scheme Language Report License"
  },
  Sendmail: {
    name: "Sendmail License"
  },
  "Sendmail-8.23": {
    name: "Sendmail License 8.23"
  },
  "Sendmail-Open-Source-1.1": {
    name: "Sendmail Open Source License v1.1"
  },
  "SGI-B-1.0": {
    name: "SGI Free Software License B v1.0"
  },
  "SGI-B-1.1": {
    name: "SGI Free Software License B v1.1"
  },
  "SGI-B-2.0": {
    name: "SGI Free Software License B v2.0",
    free: true
  },
  "SGI-OpenGL": {
    name: "SGI OpenGL License"
  },
  SGP4: {
    name: "SGP4 Permission Notice"
  },
  "SHL-0.5": {
    name: "Solderpad Hardware License v0.5"
  },
  "SHL-0.51": {
    name: "Solderpad Hardware License, Version 0.51"
  },
  "SimPL-2.0": {
    name: "Simple Public License 2.0",
    osi: true
  },
  SISSL: {
    name: "Sun Industry Standards Source License v1.1",
    osi: true,
    free: true
  },
  "SISSL-1.2": {
    name: "Sun Industry Standards Source License v1.2"
  },
  SL: {
    name: "SL License"
  },
  Sleepycat: {
    name: "Sleepycat License",
    osi: true,
    free: true
  },
  "SMAIL-GPL": {
    name: "SMAIL General Public License"
  },
  SMLNJ: {
    name: "Standard ML of New Jersey License",
    free: true
  },
  SMPPL: {
    name: "Secure Messaging Protocol Public License"
  },
  SNIA: {
    name: "SNIA Public License 1.1"
  },
  snprintf: {
    name: "snprintf License"
  },
  SOFA: {
    name: "SOFA Software License"
  },
  softSurfer: {
    name: "softSurfer License"
  },
  Soundex: {
    name: "Soundex License"
  },
  "Spencer-86": {
    name: "Spencer License 86"
  },
  "Spencer-94": {
    name: "Spencer License 94"
  },
  "Spencer-99": {
    name: "Spencer License 99"
  },
  "SPL-1.0": {
    name: "Sun Public License v1.0",
    osi: true,
    free: true
  },
  "ssh-keyscan": {
    name: "ssh-keyscan License"
  },
  "SSH-OpenSSH": {
    name: "SSH OpenSSH license"
  },
  "SSH-short": {
    name: "SSH short notice"
  },
  "SSLeay-standalone": {
    name: "SSLeay License - standalone"
  },
  "SSPL-1.0": {
    name: "Server Side Public License, v 1"
  },
  "SugarCRM-1.1.3": {
    name: "SugarCRM Public License v1.1.3"
  },
  "SUL-1.0": {
    name: "Sustainable Use License v1.0"
  },
  "Sun-PPP": {
    name: "Sun PPP License"
  },
  "Sun-PPP-2000": {
    name: "Sun PPP License (2000)"
  },
  SunPro: {
    name: "SunPro License"
  },
  SWL: {
    name: "Scheme Widget Library (SWL) Software License Agreement"
  },
  swrule: {
    name: "swrule License"
  },
  Symlinks: {
    name: "Symlinks License"
  },
  "TAPR-OHL-1.0": {
    name: "TAPR Open Hardware License v1.0"
  },
  TCL: {
    name: "TCL/TK License"
  },
  "TCP-wrappers": {
    name: "TCP Wrappers License"
  },
  TermReadKey: {
    name: "TermReadKey License"
  },
  "TGPPL-1.0": {
    name: "Transitive Grace Period Public Licence 1.0"
  },
  ThirdEye: {
    name: "ThirdEye License"
  },
  threeparttable: {
    name: "threeparttable License"
  },
  TMate: {
    name: "TMate Open Source License"
  },
  "TORQUE-1.1": {
    name: "TORQUE v2.5+ Software License v1.1"
  },
  TOSL: {
    name: "Trusster Open Source License"
  },
  TPDL: {
    name: "Time::ParseDate License"
  },
  "TPL-1.0": {
    name: "THOR Public License 1.0"
  },
  TrustedQSL: {
    name: "TrustedQSL License"
  },
  TTWL: {
    name: "Text-Tabs+Wrap License"
  },
  TTYP0: {
    name: "TTYP0 License"
  },
  "TU-Berlin-1.0": {
    name: "Technische Universitaet Berlin License 1.0"
  },
  "TU-Berlin-2.0": {
    name: "Technische Universitaet Berlin License 2.0"
  },
  "Ubuntu-font-1.0": {
    name: "Ubuntu Font Licence v1.0"
  },
  UCAR: {
    name: "UCAR License"
  },
  "UCL-1.0": {
    name: "Upstream Compatibility License v1.0",
    osi: true
  },
  ulem: {
    name: "ulem License"
  },
  "UMich-Merit": {
    name: "Michigan/Merit Networks License"
  },
  "Unicode-3.0": {
    name: "Unicode License v3",
    osi: true
  },
  "Unicode-DFS-2015": {
    name: "Unicode License Agreement - Data Files and Software (2015)"
  },
  "Unicode-DFS-2016": {
    name: "Unicode License Agreement - Data Files and Software (2016)",
    osi: true
  },
  "Unicode-TOU": {
    name: "Unicode Terms of Use"
  },
  UnixCrypt: {
    name: "UnixCrypt License"
  },
  Unlicense: {
    name: "The Unlicense",
    osi: true,
    free: true
  },
  "Unlicense-libtelnet": {
    name: "Unlicense - libtelnet variant"
  },
  "Unlicense-libwhirlpool": {
    name: "Unlicense - libwhirlpool variant"
  },
  "UPL-1.0": {
    name: "Universal Permissive License v1.0",
    osi: true,
    free: true
  },
  "URT-RLE": {
    name: "Utah Raster Toolkit Run Length Encoded License"
  },
  Vim: {
    name: "Vim License",
    free: true
  },
  VOSTROM: {
    name: "VOSTROM Public License for Open Source"
  },
  "VSL-1.0": {
    name: "Vovida Software License v1.0",
    osi: true
  },
  W3C: {
    name: "W3C Software Notice and License (2002-12-31)",
    osi: true,
    free: true
  },
  "W3C-19980720": {
    name: "W3C Software Notice and License (1998-07-20)"
  },
  "W3C-20150513": {
    name: "W3C Software Notice and Document License (2015-05-13)",
    osi: true
  },
  w3m: {
    name: "w3m License"
  },
  "Watcom-1.0": {
    name: "Sybase Open Watcom Public License 1.0",
    osi: true
  },
  "Widget-Workshop": {
    name: "Widget Workshop License"
  },
  Wsuipa: {
    name: "Wsuipa License"
  },
  WTFPL: {
    name: "Do What The F*ck You Want To Public License",
    free: true
  },
  wwl: {
    name: "WWL License"
  },
  X11: {
    name: "X11 License",
    free: true
  },
  "X11-distribute-modifications-variant": {
    name: "X11 License Distribution Modification Variant"
  },
  "X11-swapped": {
    name: "X11 swapped final paragraphs"
  },
  "Xdebug-1.03": {
    name: "Xdebug License v 1.03"
  },
  Xerox: {
    name: "Xerox License"
  },
  Xfig: {
    name: "Xfig License"
  },
  "XFree86-1.1": {
    name: "XFree86 License 1.1",
    free: true
  },
  xinetd: {
    name: "xinetd License",
    free: true
  },
  "xkeyboard-config-Zinoviev": {
    name: "xkeyboard-config Zinoviev License"
  },
  xlock: {
    name: "xlock License"
  },
  Xnet: {
    name: "X.Net License",
    osi: true
  },
  xpp: {
    name: "XPP License"
  },
  XSkat: {
    name: "XSkat License"
  },
  xzoom: {
    name: "xzoom License"
  },
  "YPL-1.0": {
    name: "Yahoo! Public License v1.0"
  },
  "YPL-1.1": {
    name: "Yahoo! Public License v1.1",
    free: true
  },
  Zed: {
    name: "Zed License"
  },
  Zeeff: {
    name: "Zeeff License"
  },
  "Zend-2.0": {
    name: "Zend License v2.0",
    free: true
  },
  "Zimbra-1.3": {
    name: "Zimbra Public License v1.3",
    free: true
  },
  "Zimbra-1.4": {
    name: "Zimbra Public License v1.4"
  },
  Zlib: {
    name: "zlib License",
    osi: true,
    free: true
  },
  "zlib-acknowledgement": {
    name: "zlib/libpng License with Acknowledgement"
  },
  "ZPL-1.1": {
    name: "Zope Public License 1.1"
  },
  "ZPL-2.0": {
    name: "Zope Public License 2.0",
    osi: true,
    free: true
  },
  "ZPL-2.1": {
    name: "Zope Public License 2.1",
    osi: true,
    free: true
  }
};
var licenses_default = licenses;

// ../../node_modules/myst-frontmatter/dist/licenses/validators.js
function correctLicense(license) {
  if (!license)
    return void 0;
  const value = (0, import_spdx_correct.default)(license);
  if (value)
    return value;
  if (license.toUpperCase() === "CC-BY")
    return "CC-BY-4.0";
  return void 0;
}
function createURL(id, cc, osi) {
  var _a, _b;
  if (cc) {
    const match = /^([CBYSAND0ZEROPDM-]+)(?:(?:-)([0-9].[0-9]))?(?:(?:-)([A-Z]{2,3}))?$/.exec(id);
    if (!match) {
      throw new Error("Creative Commons license not found");
    }
    const kind = match[1].toUpperCase();
    const version = (_a = match[2]) !== null && _a !== void 0 ? _a : "4.0";
    const extra = (_b = match[3]) !== null && _b !== void 0 ? _b : "";
    let link = "";
    switch (kind) {
      case "CC-BY":
        link = `/by/${version}/`;
        break;
      case "CC-BY-SA":
        link = `/by-sa/${version}/`;
        break;
      case "CC-BY-NC":
        link = `/by-nc/${version}/`;
        break;
      case "CC-BY-NC-SA":
        link = `/by-nc-sa/${version}/`;
        break;
      case "CC-BY-ND":
        link = `/by-nd/${version}/`;
        break;
      case "CC-BY-NC-ND":
        link = `/by-nc-nd/${version}/`;
        break;
      case "CC-ZERO":
      case "CC-0":
      case "CC0":
        link = "/zero/1.0/";
        break;
      case "CC-PDDC":
        link = "/publicdomain/";
        break;
      case "CC-PDM":
        link = "/publicdomain/mark/1.0/";
        break;
      default:
        break;
    }
    if (extra)
      link += `${extra}/`;
    return `https://creativecommons.org/licenses${link}`;
  }
  if (osi) {
    return `https://opensource.org/licenses/${id.replace(/(-or-later)|(-only)$/, "")}`;
  }
  return `https://spdx.org/licenses/${id}`;
}
function cleanUrl(url) {
  return url.replace(/^http:/, "https:").replace(/\/$/, "");
}
function isUrl(url) {
  try {
    const parsed = new URL(url);
    return parsed.protocol.includes("http");
  } catch (error) {
    return false;
  }
}
var ID_LICENSE_LOOKUP = Object.fromEntries(Object.entries(licenses_default).map(([key, value]) => {
  return [key, { id: key, ...value, url: createURL(key, value.CC, value.osi) }];
}));
var URL_ID_LOOKUP = Object.fromEntries(Object.values(ID_LICENSE_LOOKUP).filter((value) => !!value.url && !!value.id).map((value) => {
  return [cleanUrl(value.url), value.id];
}));
function validateLicense(input, opts) {
  var _a;
  if (typeof input === "string") {
    const value2 = validateString(input, opts);
    if (value2 === void 0)
      return void 0;
    const valueSpdx = value2.length < 15 ? correctLicense(value2) : void 0;
    if (URL_ID_LOOKUP[cleanUrl(value2)]) {
      input = { id: URL_ID_LOOKUP[cleanUrl(value2)] };
    } else if (isUrl(value2)) {
      input = { url: value2 };
    } else if (valueSpdx) {
      input = { id: value2 };
    } else if (value2.match(/^[^\s]*$/)) {
      input = { id: value2 };
    } else if (value2.length < 100) {
      input = { name: value2 };
    } else {
      input = { note: value2 };
    }
  }
  const value = validateObjectKeys(input, {
    optional: ["id", "name", "url", "note", "free", "CC", "osi"],
    alias: { cc: "CC" }
  }, opts);
  if (!value)
    return void 0;
  const output = {};
  if (value.id != null) {
    const id = validateString(value.id, incrementOptions("id", opts));
    const idSpdx = correctLicense(id);
    if (!idSpdx) {
      validationWarning(`unknown license ID "${id}" - using a SPDX license ID is recommended, see https://spdx.org/licenses/`, opts);
    } else if (idSpdx !== id) {
      validationWarning(`The SPDX ID for the license is "${idSpdx}". Corrected from "${id}".`, opts);
    }
    output.id = idSpdx !== null && idSpdx !== void 0 ? idSpdx : id;
  } else {
    if (value.url) {
      const url = (_a = validateUrl(value.url, { property: "", messages: {} })) !== null && _a !== void 0 ? _a : "";
      const idFromUrl = URL_ID_LOOKUP[cleanUrl(url)];
      if (idFromUrl) {
        output.id = idFromUrl;
        value.url = ID_LICENSE_LOOKUP[idFromUrl].url;
      }
    }
    if (!output.id) {
      validationWarning(`no license ID - using a SPDX license ID is recommended, see https://spdx.org/licenses/`, opts);
    }
  }
  const expected = output.id ? ID_LICENSE_LOOKUP[output.id] : void 0;
  if (value.url != null) {
    const urlOpts = incrementOptions("url", opts);
    const url = validateUrl(value.url, urlOpts);
    if (url && (expected === null || expected === void 0 ? void 0 : expected.url) && cleanUrl(url) !== cleanUrl(expected.url)) {
      validationWarning(`incorrect URL for SPDX license ${expected.id} - "${url}"`, urlOpts);
    }
    output.url = url;
  } else if (expected === null || expected === void 0 ? void 0 : expected.url) {
    output.url = expected.url;
  }
  if (value.name != null) {
    const nameOpts = incrementOptions("name", opts);
    const name = validateString(value.name, nameOpts);
    if (name && (expected === null || expected === void 0 ? void 0 : expected.name) && name !== expected.name) {
      validationWarning(`incorrect name for SPDX license ${expected.id} - "${name}"`, nameOpts);
    }
    output.name = name;
  } else if (expected === null || expected === void 0 ? void 0 : expected.name) {
    output.name = expected.name;
  }
  if (value.note != null) {
    output.note = validateString(value.note, incrementOptions("note", opts));
  }
  if (value.free != null) {
    const freeOpts = incrementOptions("free", opts);
    const free = validateBoolean(value.free, freeOpts);
    if (free && !(expected === null || expected === void 0 ? void 0 : expected.free)) {
      validationWarning('only SPDX licenses may specify they are "free" as listed by the FSF', freeOpts);
    } else {
      output.free = free;
    }
  } else if ((expected === null || expected === void 0 ? void 0 : expected.free) != null) {
    output.free = expected.free;
  }
  if (value.CC != null) {
    const ccOpts = incrementOptions("CC", opts);
    const cc = validateBoolean(value.CC, ccOpts);
    if (cc && !((expected === null || expected === void 0 ? void 0 : expected.CC) || output.url && new URL(output.url).host === "creativecommons.org")) {
      validationWarning('only licenses that link to creativecommons.org may specify that they are "CC"', ccOpts);
    } else {
      output.CC = cc;
    }
  } else if ((expected === null || expected === void 0 ? void 0 : expected.CC) != null) {
    output.CC = expected.CC;
  }
  if (value.osi != null) {
    const osiOpts = incrementOptions("osi", opts);
    const osi = validateBoolean(value.osi, osiOpts);
    if (osi && !(expected === null || expected === void 0 ? void 0 : expected.osi)) {
      validationWarning('only SPDX licenses may specify they are "OSI approved"', osiOpts);
    } else {
      output.osi = osi;
    }
  } else if ((expected === null || expected === void 0 ? void 0 : expected.osi) != null) {
    output.osi = expected.osi;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}
function validateLicenses(input, opts) {
  let contentOpts;
  if (typeof input === "string" || typeof input === "object" && input.content == null && input.code == null) {
    input = { content: input };
    contentOpts = opts;
  } else {
    contentOpts = incrementOptions("content", opts);
  }
  const value = validateObjectKeys(input, { optional: ["content", "code"] }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.content)) {
    const content = validateLicense(value.content, contentOpts);
    if (content)
      output.content = content;
  }
  if (defined(value.code) && value.code !== value.content) {
    const code = validateLicense(value.code, incrementOptions("code", opts));
    if (code)
      output.code = code;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/socials/types.js
var SOCIAL_LINKS_KEYS = [
  "url",
  "github",
  "bluesky",
  "mastodon",
  "linkedin",
  "threads",
  "twitter",
  // Change to 'x' in future
  "youtube",
  "discourse",
  "discord",
  "slack",
  "facebook",
  "telegram"
];
var SOCIAL_LINKS_ALIASES = {
  website: "url",
  x: "twitter",
  // Can change this in a future release to be the other way
  bsky: "bluesky",
  instagram: "threads"
  // This is the same username
};

// ../../node_modules/myst-frontmatter/dist/socials/validators.js
var MASTODON_REGEX = /^@?([a-zA-Z0-9_]+)@([^@]+\.[^@]*[^.])$/;
var BLUESKY_REGEX = /^@?([^/:]+\..*[^.])$/;
var BLUESKY_URL_REGEX = /^https:\/\/bsky\.app\/profile\/@?(.+\..*[^.])$/;
var YOUTUBE_REGEX = /^@?([a-zA-Z0-9.]+)$/;
var THREADS_REGEX = /^[a-zA-Z0-9_.]+$/;
var TWITTER_REGEX = /^@?([a-zA-Z0-9_]{4,15})$/;
var TWITTER_URL_REGEX = /^https:\/\/(?:twitter\.com|x\.com)\/@?([a-zA-Z0-9_]{4,15})$/;
var GITHUB_USERNAME_REGEX = /^@?([a-zA-Z0-9_.-]+)$/;
var GITHUB_ORG_URL_REGEX = /^https:\/\/github\.com\/orgs\/[a-zA-Z0-9_.-]+$/;
var TELEGRAM_REGEX = /^@?([a-zA-Z0-9_]{5,})$/;
var TELEGRAM_URL_REGEX = /^https:\/\/(?:t\.me|telegram\.me)\/?([a-zA-Z0-9_]{5,})$/;
function validateMastodon(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return void 0;
  const match = value.match(MASTODON_REGEX);
  if (match === null)
    return validationError(`must be a user ID of the form @username@server e.g. @mystmarkdown@fosstodon.org`, opts);
  const username = match[1];
  const host = validateDomain(match[2], opts);
  if (host === void 0)
    return void 0;
  return `@${username}@${host}`;
}
function validateBluesky(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return void 0;
  let match;
  if (match = value.match(BLUESKY_REGEX)) {
    const domain = validateDomain(match[1], opts);
    if (domain === void 0)
      return void 0;
    return `@${domain}`;
  } else {
    const result = validateUrl(value, opts);
    if (result === void 0)
      return void 0;
    match = result.match(BLUESKY_URL_REGEX);
    if (match === null) {
      return validationError(`Bluesky profile URL must be a valid URL starting with https://bsky.app/profile/: ${value}`, opts);
    }
    const domain = validateDomain(match[1], opts);
    if (domain === void 0)
      return void 0;
    return `@${domain}`;
  }
}
function validateTwitter(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return void 0;
  let match;
  if (match = value.match(TWITTER_URL_REGEX)) {
    return match[1];
  } else if (match = value.match(TWITTER_REGEX)) {
    return match[1];
  } else {
    return validationError(`Twitter social identity must be a valid URL starting with https://twitter.com/, https://x.com/, or a valid username: ${value}`, opts);
  }
}
function validateTelegram(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return void 0;
  let match;
  if (match = value.match(TELEGRAM_URL_REGEX)) {
    return match[1];
  } else if (match = value.match(TELEGRAM_REGEX)) {
    return match[1];
  } else {
    return validationError(`Telegram social identity must be a valid URL starting with either https://t.me/ or https://telegram.me/, or a valid username: ${value}`, opts);
  }
}
function validateYouTube(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return void 0;
  if (/^https?:\/\//.test(value)) {
    return validateUrl(input, { ...opts, includes: "youtube.com" });
  }
  let match;
  if (match = value.match(YOUTUBE_REGEX)) {
    return match[1];
  } else {
    return validationError(`YouTube social identity must be a valid URL starting with https://youtube.com/ or a valid handle: ${value}`, opts);
  }
}
function validateGitHub(input, opts) {
  const value = validateString(input, opts);
  if (value === void 0)
    return void 0;
  let match;
  if (match = value.match(GITHUB_USERNAME_REGEX)) {
    return match[1];
  } else if (match = value.match(GITHUB_USERNAME_REPO_REGEX)) {
    return match[0];
  } else if (match = value.match(GITHUB_ORG_URL_REGEX)) {
    return match[0];
  } else {
    return validationError(`GitHub social identity must be a valid username, org/repo, or org URL: ${value}`, opts);
  }
}
function validateSocialLinks(input, opts, output) {
  const value = output ? input : validateObjectKeys(input, { optional: SOCIAL_LINKS_KEYS, alias: SOCIAL_LINKS_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  const result = output !== null && output !== void 0 ? output : {};
  if (defined(value.url)) {
    result.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  if (defined(value.github)) {
    result.github = validateGitHub(value.github, incrementOptions("github", opts));
  }
  if (defined(value.bluesky)) {
    result.bluesky = validateBluesky(value.bluesky, incrementOptions("bluesky", opts));
  }
  if (defined(value.mastodon)) {
    result.mastodon = validateMastodon(value.mastodon, incrementOptions("mastodon", opts));
  }
  if (defined(value.linkedin)) {
    result.linkedin = validateUrl(value.linkedin, {
      ...incrementOptions("linkedin", opts),
      includes: "linkedin.com"
    });
  }
  if (defined(value.threads)) {
    result.threads = validateString(value.threads, {
      ...incrementOptions("threads", opts),
      regex: THREADS_REGEX
    });
  }
  if (defined(value.twitter)) {
    result.twitter = validateTwitter(value.twitter, incrementOptions("twitter", opts));
  }
  if (defined(value.telegram)) {
    result.telegram = validateTelegram(value.telegram, incrementOptions("telegram", opts));
  }
  if (defined(value.youtube)) {
    result.youtube = validateYouTube(value.youtube, incrementOptions("youtube", opts));
  }
  if (defined(value.discourse)) {
    result.discourse = validateUrl(value.discourse, incrementOptions("discourse", opts));
  }
  if (defined(value.discord)) {
    result.discord = validateUrl(value.discord, {
      ...incrementOptions("discord", opts),
      includes: "discord"
    });
  }
  if (defined(value.slack)) {
    result.slack = validateUrl(value.slack, {
      ...incrementOptions("slack", opts),
      includes: "slack.com"
    });
  }
  if (defined(value.facebook)) {
    result.facebook = validateUrl(value.facebook, {
      ...incrementOptions("facebook", opts),
      includes: "facebook.com"
    });
  }
  return result;
}

// ../../node_modules/myst-frontmatter/dist/affiliations/validators.js
var AFFILIATION_KEYS = [
  "id",
  "address",
  "city",
  "state",
  "postal_code",
  "country",
  "name",
  "department",
  "collaboration",
  "isni",
  "ringgold",
  "ror",
  "doi",
  "email",
  "phone",
  "fax",
  ...SOCIAL_LINKS_KEYS
];
var AFFILIATION_ALIASES = {
  ref: "id",
  // Used in QMD to reference an affiliation
  region: "state",
  province: "state",
  zipcode: "postal_code",
  zip_code: "postal_code",
  institution: "name",
  ...SOCIAL_LINKS_ALIASES
};
function validateAffiliation(input, opts) {
  if (typeof input === "string") {
    input = stashPlaceholder(input);
  }
  const value = validateObjectKeys(input, { optional: AFFILIATION_KEYS, alias: AFFILIATION_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  if (Object.keys(value).length === 1 && value.id) {
    value.name = value.id;
  }
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  } else {
    validationWarning("affiliation should include name/institution", opts);
  }
  if (defined(value.department)) {
    output.department = validateString(value.department, incrementOptions("department", opts));
  }
  if (defined(value.address)) {
    output.address = validateString(value.address, incrementOptions("address", opts));
  }
  if (defined(value.city)) {
    output.city = validateString(value.city, incrementOptions("city", opts));
  }
  if (defined(value.state)) {
    output.state = validateString(value.state, incrementOptions("state", opts));
  }
  if (defined(value.postal_code)) {
    output.postal_code = validateString(value.postal_code, {
      coerceNumber: true,
      ...incrementOptions("postal_code", opts)
    });
  }
  if (defined(value.country)) {
    output.country = validateString(value.country, incrementOptions("country", opts));
  }
  if (defined(value.isni)) {
    output.isni = validateString(value.isni, incrementOptions("isni", opts));
  }
  if (defined(value.ror)) {
    output.ror = validateString(value.ror, incrementOptions("ror", opts));
  }
  if (defined(value.ringgold)) {
    output.ringgold = validateNumber(value.ringgold, {
      min: 1e3,
      max: 999999,
      ...incrementOptions("ringgold", opts)
    });
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.collaboration)) {
    output.collaboration = validateBoolean(value.collaboration, incrementOptions("collaboration", opts));
  }
  if (defined(value.email)) {
    output.email = validateEmail(value.email, incrementOptions("email", opts));
  }
  validateSocialLinks(value, opts, output);
  if (defined(value.phone)) {
    output.phone = validateString(value.phone, incrementOptions("phone", opts));
  }
  if (defined(value.fax)) {
    output.fax = validateString(value.fax, incrementOptions("fax", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/utils/parseName.js
function startsWithUpperCase(word) {
  for (const letter of word) {
    if (letter.toLowerCase() === letter.toUpperCase())
      continue;
    return letter === letter.toUpperCase();
  }
  return true;
}
function parseName(literal) {
  var _a, _b;
  const displayParts = literal.split(",");
  if (displayParts.length === 1) {
    return { literal, ...parseGivenParticleFamily(literal) };
  }
  const lastPart = (_a = displayParts.pop()) === null || _a === void 0 ? void 0 : _a.trim();
  const givenAndParticle = parseGivenParticle(lastPart);
  if (displayParts.length === 1) {
    return { literal, ...givenAndParticle, ...parseParticleFamily(displayParts[0]) };
  }
  const suffix = (_b = displayParts.pop()) === null || _b === void 0 ? void 0 : _b.trim();
  const particleAndFamily = parseParticleFamily(displayParts.join(","));
  if (!suffix)
    return { literal, ...givenAndParticle, ...particleAndFamily };
  return { literal, ...givenAndParticle, ...particleAndFamily, suffix };
}
function parseGivenParticle(name) {
  const nameParts = name === null || name === void 0 ? void 0 : name.trim().split(/\s+/);
  if (!(nameParts === null || nameParts === void 0 ? void 0 : nameParts.length))
    return {};
  let given = nameParts.shift();
  if (!given)
    return {};
  while (nameParts.length && startsWithUpperCase(nameParts[0])) {
    given = `${given} ${nameParts.shift()}`;
  }
  if (!nameParts.length)
    return { given };
  return { given, dropping_particle: nameParts.join(" ") };
}
function parseParticleFamily(name) {
  const nameParts = name.trim().split(/\s+/);
  if (!nameParts.length)
    return {};
  let family = nameParts.pop();
  if (!family)
    return {};
  if (nameParts.length && startsWithUpperCase(nameParts[0])) {
    return { family: [...nameParts, family].join(" ") };
  }
  while (nameParts.length && startsWithUpperCase(nameParts[nameParts.length - 1])) {
    family = `${nameParts.pop()} ${family}`;
  }
  if (!nameParts.length)
    return { family };
  return { non_dropping_particle: nameParts.join(" "), family };
}
function parseGivenParticleFamily(name) {
  const nameParts = name.trim().split(/\s+/);
  if (!nameParts.length)
    return {};
  let family = nameParts.pop();
  if (!family)
    return {};
  if (!nameParts.length)
    return { family };
  let given = nameParts.shift();
  while (nameParts.length && startsWithUpperCase(nameParts[0])) {
    given = `${given} ${nameParts.shift()}`;
  }
  while (nameParts.length && startsWithUpperCase(nameParts[nameParts.length - 1])) {
    family = `${nameParts.pop()} ${family}`;
  }
  if (!nameParts.length)
    return { given, family };
  return { given, non_dropping_particle: nameParts.join(" "), family };
}
function formatName(name, alwaysReversed = false) {
  const { literal, given, dropping_particle, non_dropping_particle, family, suffix } = name;
  if (literal)
    return literal;
  const hasCommas = [given, dropping_particle, non_dropping_particle, family, suffix].join("").includes(",");
  if (!alwaysReversed && !hasCommas && !dropping_particle && !suffix) {
    const formattedName = [given, non_dropping_particle, family].filter(Boolean).join(" ");
    const reParsedName = parseName(formattedName);
    delete reParsedName.literal;
    const serializedParsedName = JSON.stringify(Object.entries(reParsedName).sort());
    const serializedSourceName = JSON.stringify(Object.entries(name).sort());
    if (serializedParsedName === serializedSourceName) {
      return formattedName;
    }
  }
  let output = ",";
  if (suffix || hasCommas)
    output = `${output}${suffix ? " " : ""}${suffix !== null && suffix !== void 0 ? suffix : ""},`;
  if (given)
    output = `${output} ${given}`;
  if (family)
    output = `${family}${output}`;
  if (dropping_particle)
    output = `${output} ${dropping_particle}`;
  if (non_dropping_particle)
    output = `${non_dropping_particle} ${output}`;
  if (output === ",")
    return "";
  return output;
}

// ../../node_modules/myst-frontmatter/dist/contributors/validators.js
var PERSON_KEYS = [
  "id",
  "userId",
  "name",
  "nameParsed",
  "orcid",
  "corresponding",
  "equal_contributor",
  "deceased",
  "email",
  "roles",
  "affiliations",
  "collaborations",
  "note",
  "phone",
  "fax",
  ...SOCIAL_LINKS_KEYS
];
var PERSON_ALIASES = {
  ref: "id",
  // Used in QMD to reference a contributor
  role: "roles",
  "equal-contributor": "equal_contributor",
  affiliation: "affiliations",
  ...SOCIAL_LINKS_ALIASES
};
var NAME_KEYS = [
  "literal",
  "given",
  "family",
  "suffix",
  "non_dropping_particle",
  "dropping_particle"
];
var NAME_ALIASES = {
  surname: "family",
  last: "family",
  forename: "given",
  first: "given",
  particle: "non_dropping_particle",
  "non-dropping-particle": "non_dropping_particle",
  "dropping-particle": "dropping_particle"
};
function validateName(input, opts) {
  let output;
  let raiseCommaWarnings = false;
  if (typeof input === "string") {
    output = parseName(input);
    raiseCommaWarnings = true;
  } else {
    const value = validateObjectKeys(input, { optional: NAME_KEYS, alias: NAME_ALIASES }, opts);
    if (value === void 0)
      return void 0;
    output = {};
    if (defined(value.literal)) {
      output.literal = validateString(value.literal, incrementOptions("literal", opts));
    }
    if (defined(value.given)) {
      output.given = validateString(value.given, incrementOptions("given", opts));
    }
    if (defined(value.non_dropping_particle)) {
      output.non_dropping_particle = validateString(value.non_dropping_particle, incrementOptions("non_dropping_particle", opts));
    }
    if (defined(value.dropping_particle)) {
      output.dropping_particle = validateString(value.dropping_particle, incrementOptions("dropping_particle", opts));
    }
    if (defined(value.family)) {
      output.family = validateString(value.family, incrementOptions("family", opts));
    }
    if (defined(value.suffix)) {
      output.suffix = validateString(value.suffix, incrementOptions("suffix", opts));
    }
    if (Object.keys(output).length === 1 && output.literal) {
      output = { ...output, ...parseName(output.literal) };
      raiseCommaWarnings = true;
    } else if (!output.literal) {
      output.literal = formatName(output);
      if (output.literal.startsWith(",")) {
        validationWarning(`unexpected comma at beginning of name: ${output.literal} - you may need to define 'name.literal' explicitly`, opts);
      }
    }
  }
  if (raiseCommaWarnings) {
    const warnOnComma = (part, o) => {
      if (part && part.includes(",")) {
        validationWarning(`unexpected comma in name part: ${part} - you may need to define 'name' explicitly as an object`, o);
      }
    };
    warnOnComma(output.given, incrementOptions("given", opts));
    warnOnComma(output.family, incrementOptions("family", opts));
    warnOnComma(output.non_dropping_particle, incrementOptions("non_dropping_particle", opts));
    warnOnComma(output.dropping_particle, incrementOptions("dropping_particle", opts));
    warnOnComma(output.suffix, incrementOptions("suffix", opts));
  }
  return output;
}
function validateContributor(input, stash, opts) {
  var _a, _b, _c;
  const inputAff = validateObjectKeys(input, { optional: AFFILIATION_KEYS, alias: AFFILIATION_ALIASES }, {
    ...opts,
    suppressErrors: true,
    suppressWarnings: true
  });
  if ((inputAff === null || inputAff === void 0 ? void 0 : inputAff.collaboration) === true) {
    return validateAffiliation(input, opts);
  }
  if (typeof input === "string") {
    input = stashPlaceholder(input);
  }
  const value = validateObjectKeys(input, { optional: PERSON_KEYS, alias: PERSON_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  if (inputAff && Object.keys(inputAff).length > Object.keys(value).length) {
    validationWarning('contributor may be a collaboration, not a person - if so, add "collaboration: true"', opts);
  }
  if (Object.keys(value).length === 1 && value.id) {
    value.name = value.id;
  }
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, incrementOptions("id", opts));
  }
  if (defined(value.userId)) {
    output.userId = validateString(value.userId, incrementOptions("userId", opts));
  }
  if (defined(value.nameParsed)) {
    output.nameParsed = validateName(value.nameParsed, incrementOptions("nameParsed", opts));
    output.name = value.name ? validateString(value.name, incrementOptions("name", opts)) : (_a = output.nameParsed) === null || _a === void 0 ? void 0 : _a.literal;
    if (output.name !== ((_b = output.nameParsed) === null || _b === void 0 ? void 0 : _b.literal)) {
      validationWarning(`"name" and "parsedName.literal" should match`, opts);
    }
  } else if (defined(value.name)) {
    output.nameParsed = validateName(value.name, incrementOptions("name", opts));
    output.name = (_c = output.nameParsed) === null || _c === void 0 ? void 0 : _c.literal;
  } else {
    validationWarning("contributor should include name", opts);
  }
  if (defined(value.orcid)) {
    const orcidOpts = incrementOptions("orcid", opts);
    const id = orcid.normalize(value.orcid);
    if (id) {
      output.orcid = id;
    } else {
      validationError(`ORCID "${value.orcid}" is not valid, try an ID of the form "0000-0000-0000-0000"`, orcidOpts);
    }
  }
  if (defined(value.corresponding)) {
    const correspondingOpts = incrementOptions("corresponding", opts);
    output.corresponding = validateBoolean(value.corresponding, correspondingOpts);
    if (value.corresponding && !defined(value.email)) {
      validationError(`must include email for corresponding author`, correspondingOpts);
      output.corresponding = false;
    }
  }
  if (defined(value.equal_contributor)) {
    output.equal_contributor = validateBoolean(value.equal_contributor, incrementOptions("equal_contributor", opts));
  }
  if (defined(value.deceased)) {
    output.deceased = validateBoolean(value.deceased, incrementOptions("deceased", opts));
  }
  if (defined(value.email)) {
    output.email = validateEmail(value.email, incrementOptions("email", opts));
  }
  if (defined(value.roles)) {
    const rolesOpts = incrementOptions("roles", opts);
    let roles = value.roles;
    if (typeof roles === "string") {
      roles = roles.split(/[,;]/);
    }
    output.roles = validateList(roles, rolesOpts, (r) => {
      const roleString = validateString(r, rolesOpts);
      if (roleString === void 0)
        return void 0;
      const role = credit.normalize(roleString);
      if (!role) {
        validationWarning(`unknown value "${roleString}" - should be a CRediT role - see https://credit.niso.org/`, rolesOpts);
        return roleString.trim();
      }
      return role;
    });
  }
  if (defined(value.collaborations)) {
    validationError('collaborations must be defined in frontmatter as affiliations with "collaboration: true"', incrementOptions("collaborations", opts));
  }
  if (defined(value.affiliations)) {
    const affiliationsOpts = incrementOptions("affiliations", opts);
    let affiliations = value.affiliations;
    if (typeof affiliations === "string") {
      affiliations = affiliations.split(";").map((aff) => aff.trim());
    }
    if (!Array.isArray(affiliations)) {
      affiliations = [affiliations];
    }
    output.affiliations = validateList(affiliations, affiliationsOpts, (aff) => {
      return validateAndStashObject(aff, stash, "affiliations", validateAffiliation, affiliationsOpts);
    });
  }
  validateSocialLinks(value, opts, output);
  if (defined(value.phone)) {
    output.phone = validateString(value.phone, incrementOptions("phone", opts));
  }
  if (defined(value.fax)) {
    output.fax = validateString(value.fax, incrementOptions("fax", opts));
  }
  if (defined(value.note)) {
    output.note = validateString(value.note, incrementOptions("note", opts));
  }
  if (isStashPlaceholder(output) || !output.nameParsed)
    return output;
  if (value.nameParsed || value.name && typeof value.name !== "string")
    return output;
  const suffix = " - if this is intended, you may define 'name' explicitly as an object";
  if (!output.nameParsed.given) {
    validationWarning(`No given name for name '${output.nameParsed.literal}'${suffix}`, opts);
  }
  if (!output.nameParsed.family) {
    validationWarning(`No family name for name '${output.nameParsed.literal}'${suffix}`, opts);
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/funding/validators.js
var AWARD_KEYS = ["id", "name", "description", "sources", "recipients", "investigators"];
var AWARD_ALIASES = { source: "sources", recipient: "recipients", investigator: "investigators" };
var FUNDING_KEYS = ["statement", "open_access", "awards"];
var FUNDING_ALIASES = { award: "awards" };
function validateAward(input, stash, opts) {
  const value = validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.id)) {
    output.id = validateString(value.id, { ...incrementOptions("id", opts), coerceNumber: true });
  }
  if (defined(value.name)) {
    output.name = validateString(value.name, incrementOptions("name", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  if (defined(value.sources)) {
    output.sources = validateList(value.sources, { coerce: true, ...incrementOptions("sources", opts) }, (source, index) => {
      return validateAndStashObject(source, stash, "affiliations", validateAffiliation, incrementOptions(`sources.${index}`, opts));
    });
  }
  if (defined(value.recipients)) {
    output.recipients = validateList(value.recipients, { coerce: true, ...incrementOptions("recipients", opts) }, (recipient, index) => {
      return validateAndStashObject(recipient, stash, "contributors", (v, o) => validateContributor(v, stash, o), incrementOptions(`recipients.${index}`, opts));
    });
  }
  if (defined(value.investigators)) {
    output.investigators = validateList(value.investigators, { coerce: true, ...incrementOptions("investigators", opts) }, (investigator, index) => {
      return validateAndStashObject(investigator, stash, "contributors", (v, o) => validateContributor(v, stash, o), incrementOptions(`investigators.${index}`, opts));
    });
  }
  return output;
}
function validateFunding(input, stash, opts) {
  if (typeof input === "string") {
    input = { statement: input };
  }
  const valueAsObj = validateObject(input, opts);
  if (valueAsObj === void 0)
    return void 0;
  const value = validateKeys(valueAsObj, { optional: FUNDING_KEYS, alias: FUNDING_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true });
  if (value === void 0)
    return void 0;
  if (!value.awards) {
    validateKeys(valueAsObj, {
      optional: [...FUNDING_KEYS, ...AWARD_KEYS],
      alias: { ...FUNDING_ALIASES, ...AWARD_ALIASES }
    }, opts);
    const valueAsAward = validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true });
    if (valueAsAward && Object.keys(valueAsAward).length > 0) {
      value.awards = [
        validateObjectKeys(input, { optional: AWARD_KEYS, alias: AWARD_ALIASES }, { ...opts, suppressErrors: true, suppressWarnings: true })
      ];
    }
  } else {
    validateKeys(valueAsObj, { optional: FUNDING_KEYS, alias: FUNDING_ALIASES }, opts);
  }
  const output = {};
  if (defined(value.statement)) {
    output.statement = validateString(value.statement, incrementOptions("statement", opts));
  }
  if (defined(value.open_access)) {
    output.open_access = validateString(value.open_access, incrementOptions("open_access", opts));
  }
  if (defined(value.awards)) {
    output.awards = validateList(value.awards, { coerce: true, ...incrementOptions("awards", opts) }, (award, index) => {
      return validateAward(award, stash, incrementOptions(`awards.${index}`, opts));
    });
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/venues/validators.js
function validateVenue(input, opts) {
  let titleOpts;
  if (typeof input === "string") {
    input = { title: input };
    titleOpts = opts;
  } else {
    titleOpts = incrementOptions("title", opts);
  }
  const value = validateObjectKeys(input, {
    optional: [
      "title",
      "short_title",
      "url",
      "doi",
      "number",
      "location",
      "date",
      "series",
      "issn",
      "publisher"
    ]
  }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.title)) {
    output.title = validateString(value.title, titleOpts);
  }
  if (defined(value.short_title)) {
    output.short_title = validateString(value.short_title, incrementOptions("short_title", opts));
  }
  if (defined(value.url)) {
    output.url = validateUrl(value.url, incrementOptions("url", opts));
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.number)) {
    output.number = validateStringOrNumber(value.number, incrementOptions("number", opts));
  }
  if (defined(value.location)) {
    output.location = validateString(value.location, incrementOptions("location", opts));
  }
  if (defined(value.date)) {
    output.date = validateString(value.date, incrementOptions("date", opts));
  }
  if (defined(value.series)) {
    output.series = validateString(value.series, incrementOptions("series", opts));
  }
  if (defined(value.issn)) {
    output.issn = validateString(value.issn, incrementOptions("issn", opts));
  }
  if (defined(value.publisher)) {
    output.publisher = validateString(value.publisher, incrementOptions("publisher", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/site/validators.js
function validateSiteFrontmatterKeys(value, opts) {
  var _a, _b, _c, _d, _e;
  const output = {};
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  if (defined(value.short_title)) {
    output.short_title = validateString(value.short_title, incrementOptions("short_title", opts));
  }
  if (defined(value.subtitle)) {
    output.subtitle = validateString(value.subtitle, incrementOptions("subtitle", opts));
  }
  if (value.banner === null) {
    output.banner = null;
  } else if (defined(value.banner)) {
    output.banner = validateString(value.banner, incrementOptions("banner", opts));
  }
  if (defined(value.bannerOptimized)) {
    output.bannerOptimized = value.bannerOptimized;
  }
  if (defined(value.tags)) {
    output.tags = validateList(value.tags, incrementOptions("tags", opts), (file, index) => {
      return validateString(file, incrementOptions(`tags.${index}`, opts));
    });
  }
  const stash = {};
  if (defined(value.affiliations)) {
    const affiliationsOpts = incrementOptions("affiliations", opts);
    let affiliations = value.affiliations;
    if (typeof affiliations === "string") {
      affiliations = affiliations.split(";").map((aff) => aff.trim());
    }
    validateList(affiliations, affiliationsOpts, (aff) => {
      return validateAndStashObject(aff, stash, "affiliations", validateAffiliation, affiliationsOpts);
    });
  }
  if (defined(value.authors)) {
    stash.authorIds = validateList(value.authors, { coerce: true, ...incrementOptions("authors", opts) }, (author, index) => {
      return validateAndStashObject(author, stash, "contributors", (v, o) => validateContributor(v, stash, o), incrementOptions(`authors.${index}`, opts));
    });
  }
  if (defined(value.contributors)) {
    validateList(value.contributors, { coerce: true, ...incrementOptions("contributors", opts) }, (contributor, index) => {
      return validateAndStashObject(contributor, stash, "contributors", (v, o) => validateContributor(v, stash, o), incrementOptions(`contributors.${index}`, opts));
    });
  }
  if (defined(value.reviewers)) {
    output.reviewers = validateList(value.reviewers, { coerce: true, ...incrementOptions("reviewers", opts) }, (reviewer, ind) => {
      return validateAndStashObject(reviewer, stash, "contributors", (v, o) => validateContributor(v, stash, o), incrementOptions(`reviewers.${ind}`, opts));
    });
  }
  if (defined(value.editors)) {
    output.editors = validateList(value.editors, { coerce: true, ...incrementOptions("editors", opts) }, (editor, ind) => {
      return validateAndStashObject(editor, stash, "contributors", (v, o) => validateContributor(v, stash, o), incrementOptions(`editors.${ind}`, opts));
    });
  }
  if (defined(value.venue)) {
    output.venue = validateVenue(value.venue, incrementOptions("venue", opts));
  }
  if (defined(value.github)) {
    output.github = validateGithubUrl(value.github, incrementOptions("github", opts));
  }
  if (defined(value.keywords)) {
    let keywords = value.keywords;
    if (typeof keywords === "string") {
      keywords = keywords.split(/[,;]/).map((k) => k.trim());
    }
    output.keywords = validateList(keywords, incrementOptions("keywords", opts), (word, ind) => {
      return validateString(word, incrementOptions(`keywords.${ind}`, opts));
    });
  }
  if (defined(value.funding)) {
    output.funding = validateList(value.funding, { coerce: true, ...incrementOptions("funding", opts) }, (fund, index) => {
      return validateFunding(fund, stash, incrementOptions(`funding.${index}`, opts));
    });
  }
  if (defined(value.copyright)) {
    output.copyright = validateString(value.copyright, incrementOptions("copyright", opts));
  }
  if (defined(value.options)) {
    const optionsOptions = incrementOptions("options", opts);
    const options = validateObject(value.options, optionsOptions);
    if (options) {
      Object.entries(options).forEach(([key, val]) => {
        var _a2;
        if (RESERVED_EXPORT_KEYS.includes(key)) {
          validationError(`options cannot include reserved key ${key}`, optionsOptions);
        } else {
          ((_a2 = output.options) !== null && _a2 !== void 0 ? _a2 : output.options = {})[key] = val;
        }
      });
    }
  }
  const partsOptions = incrementOptions("parts", opts);
  let parts;
  if (defined(value.parts)) {
    parts = validateObjectKeys(value.parts, { optional: PAGE_KNOWN_PARTS, alias: FRONTMATTER_ALIASES }, { keepExtraKeys: true, suppressWarnings: true, ...partsOptions });
  }
  PAGE_KNOWN_PARTS.forEach((partKey) => {
    if (defined(value[partKey])) {
      parts !== null && parts !== void 0 ? parts : parts = {};
      if (parts[partKey]) {
        validationError(`duplicate value for part ${partKey}`, partsOptions);
      } else {
        parts[partKey] = value[partKey];
      }
    }
  });
  if (parts) {
    const partsEntries = Object.entries(parts).map(([k, v]) => {
      return [
        k,
        validateList(v, { coerce: true, ...incrementOptions(k, partsOptions) }, (item, index) => {
          return validateString(item, incrementOptions(`${k}.${index}`, partsOptions));
        })
      ];
    }).filter((entry) => {
      var _a2;
      return !!((_a2 = entry[1]) === null || _a2 === void 0 ? void 0 : _a2.length);
    });
    if (partsEntries.length > 0) {
      output.parts = Object.fromEntries(partsEntries);
    }
  }
  const stashContribAuthors = (_a = stash.contributors) === null || _a === void 0 ? void 0 : _a.filter((contrib) => {
    var _a2;
    return (_a2 = stash.authorIds) === null || _a2 === void 0 ? void 0 : _a2.includes(contrib.id);
  });
  const stashContribNonAuthors = (_b = stash.contributors) === null || _b === void 0 ? void 0 : _b.filter((contrib) => {
    var _a2;
    return !((_a2 = stash.authorIds) === null || _a2 === void 0 ? void 0 : _a2.includes(contrib.id));
  });
  if (stashContribAuthors === null || stashContribAuthors === void 0 ? void 0 : stashContribAuthors.length) {
    output.authors = stashContribAuthors;
    const correspondingAuthor = (_c = output.authors) === null || _c === void 0 ? void 0 : _c.find((a) => a.corresponding);
    const personWithEmail = (_d = output.authors) === null || _d === void 0 ? void 0 : _d.find((a) => a.email && !a.collaboration && a.corresponding === void 0);
    if (!correspondingAuthor && personWithEmail) {
      personWithEmail.corresponding = true;
    }
  }
  if (stashContribNonAuthors === null || stashContribNonAuthors === void 0 ? void 0 : stashContribNonAuthors.length) {
    output.contributors = stashContribNonAuthors;
  }
  if ((_e = stash.affiliations) === null || _e === void 0 ? void 0 : _e.length) {
    output.affiliations = stash.affiliations;
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/settings/validatorsMystToTex.js
var MYST_TO_TEX_SETTINGS = ["codeStyle", "beamer"];
var MYST_TO_TEX_SETTINGS_ALIAS = {
  code_style: "codeStyle"
};
function validateMystToTexSettings(value, opts) {
  const output = {};
  const settings = validateObjectKeys(value, { optional: MYST_TO_TEX_SETTINGS, alias: MYST_TO_TEX_SETTINGS_ALIAS }, opts);
  if (!settings)
    return void 0;
  if (defined(settings.codeStyle)) {
    const codeStyle = validateChoice(settings.codeStyle, {
      ...incrementOptions("codeStyle", opts),
      choices: ["verbatim", "minted", "listings"]
    });
    if (codeStyle)
      output.codeStyle = codeStyle;
  }
  if (defined(settings.beamer)) {
    const beamer = validateBoolean(settings.beamer, incrementOptions("beamer", opts));
    if (beamer != null)
      output.beamer = beamer;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/settings/validators.js
var OUTPUT_REMOVAL_OPTIONS = [
  "show",
  "remove",
  "remove-warn",
  "remove-error",
  "warn",
  "error"
];
var PROJECT_SETTINGS = [
  "output_stderr",
  "output_stdout",
  "output_matplotlib_strings",
  "myst_to_tex"
];
var PROJECT_SETTINGS_ALIAS = {
  stderr_output: "output_stderr",
  stdout_output: "output_stdout",
  mystToTex: "myst_to_tex",
  tex: "myst_to_tex"
  // The default is the renderer, not the parser
};
function validateProjectAndPageSettings(value, opts) {
  const output = {};
  const settings = validateObjectKeys(value, { optional: PROJECT_SETTINGS, alias: PROJECT_SETTINGS_ALIAS }, opts);
  if (!settings)
    return void 0;
  if (defined(settings.output_stderr)) {
    const output_stderr = validateChoice(settings.output_stderr, {
      ...incrementOptions("output_stderr", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_stderr)
      output.output_stderr = output_stderr;
  }
  if (defined(settings.output_stdout)) {
    const output_stdout = validateChoice(settings.output_stdout, {
      ...incrementOptions("output_stdout", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_stdout)
      output.output_stdout = output_stdout;
  }
  if (defined(settings.output_matplotlib_strings)) {
    const output_matplotlib_strings = validateChoice(settings.output_matplotlib_strings, {
      ...incrementOptions("output_matplotlib_strings", opts),
      choices: OUTPUT_REMOVAL_OPTIONS
    });
    if (output_matplotlib_strings)
      output.output_matplotlib_strings = output_matplotlib_strings;
  }
  if (defined(settings.myst_to_tex)) {
    const myst_to_tex = validateMystToTexSettings(settings.myst_to_tex, incrementOptions("myst_to_tex", opts));
    if (myst_to_tex)
      output.myst_to_tex = myst_to_tex;
  }
  if (Object.keys(output).length === 0)
    return void 0;
  return output;
}

// ../../node_modules/myst-frontmatter/dist/math/validators.js
function validateMathMacro(input, opts) {
  if (typeof input === "string") {
    input = { macro: input };
  }
  const value = validateObjectKeys(input, { required: ["macro"], optional: ["title", "description"] }, opts);
  if (!value)
    return;
  const macro = validateString(value.macro, incrementOptions("macro", opts));
  if (!macro)
    return;
  const output = { macro };
  if (defined(value.title)) {
    output.title = validateString(value.title, incrementOptions("title", opts));
  }
  if (defined(value.description)) {
    output.description = validateString(value.description, incrementOptions("description", opts));
  }
  return output;
}
function validateMathMacroObject(input, opts) {
  const value = validateObject(input, opts);
  if (!value)
    return;
  const validMacros = Object.entries(value).map(([key, val]) => {
    const macro = validateMathMacro(val, incrementOptions(key, opts));
    if (!macro)
      return false;
    return [key, macro];
  }).filter((valid) => !!valid);
  return Object.fromEntries(validMacros);
}

// ../../node_modules/myst-frontmatter/dist/project/validators.js
function getExternalIdentifierValidator(key) {
  if (key === "arxiv") {
    return (value, opts) => {
      return validateUrl(value, {
        ...incrementOptions("arxiv", opts),
        includes: "arxiv.org"
      });
    };
  }
  if (key === "pmid") {
    return (value, opts) => {
      return validateNumber(value, {
        ...incrementOptions("pmid", opts),
        integer: true,
        min: 1
      });
    };
  }
  if (key === "pmcid") {
    return (value, opts) => {
      return validateString(value, {
        ...incrementOptions("pmcid", opts),
        regex: "^PMC[0-9]+$"
      });
    };
  }
  if (key === "zenodo") {
    return (value, opts) => {
      return validateUrl(value, {
        ...incrementOptions("zenodo", opts),
        includes: "zenodo.org"
      });
    };
  }
  return (value, opts) => {
    return validateStringOrNumber(value, incrementOptions(key, opts));
  };
}
function validateProjectAndPageFrontmatterKeys(value, opts) {
  var _a;
  const output = validateSiteFrontmatterKeys(value, opts);
  if (defined(value.date)) {
    output.date = validateDate(value.date, incrementOptions("date", opts));
  }
  const identifiersOpts = incrementOptions("identifiers", opts);
  let identifiers;
  if (defined(value.identifiers)) {
    identifiers = validateObjectKeys(value.identifiers, { optional: KNOWN_EXTERNAL_IDENTIFIERS }, { keepExtraKeys: true, suppressWarnings: true, ...identifiersOpts });
  }
  KNOWN_EXTERNAL_IDENTIFIERS.forEach((identifierKey) => {
    if (defined(value[identifierKey])) {
      identifiers !== null && identifiers !== void 0 ? identifiers : identifiers = {};
      if (identifiers[identifierKey]) {
        validationError(`duplicate value for identifier ${identifierKey}`, identifiersOpts);
      } else {
        identifiers[identifierKey] = value[identifierKey];
      }
    }
  });
  if (identifiers === null || identifiers === void 0 ? void 0 : identifiers.doi) {
    if (defined(value.doi)) {
      validationError(`duplicate value for DOI`, identifiersOpts);
    } else {
      value.doi = identifiers.doi;
      validationWarning("DOI should be defined directly on the project frontmatter, not under 'identifiers'", identifiersOpts);
    }
    delete identifiers.doi;
  }
  if (identifiers) {
    const identifiersEntries = Object.entries(identifiers).map(([k, v]) => {
      const validator = getExternalIdentifierValidator(k);
      return [k, validator(v, identifiersOpts)];
    }).filter((entry) => entry[1] != null);
    if (identifiersEntries.length > 0) {
      output.identifiers = Object.fromEntries(identifiersEntries);
    }
  }
  if (defined(value.doi)) {
    output.doi = validateDoi(value.doi, incrementOptions("doi", opts));
  }
  if (defined(value.open_access)) {
    output.open_access = validateBoolean(value.open_access, incrementOptions("open_access", opts));
  }
  if (defined(value.license)) {
    output.license = validateLicenses(value.license, incrementOptions("license", opts));
  }
  if (defined(value.binder)) {
    output.binder = validateUrl(value.binder, incrementOptions("binder", opts));
  }
  if (defined(value.source)) {
    output.source = validateUrl(value.source, incrementOptions("source", opts));
  }
  if (defined(value.subject)) {
    output.subject = validateString(value.subject, {
      ...incrementOptions("subject", opts),
      maxLength: 40
    });
  }
  if (defined(value.bibliography)) {
    output.bibliography = validateList(value.bibliography, { coerce: true, ...incrementOptions("bibliography", opts) }, (req, index) => {
      return validateString(req, incrementOptions(`bibliography.${index}`, opts));
    });
  }
  if (defined(value.volume)) {
    output.volume = validatePublicationMeta(value.volume, incrementOptions("volume", opts));
  }
  if (defined(value.issue)) {
    output.issue = validatePublicationMeta(value.issue, incrementOptions("issue", opts));
  }
  if (defined(value.first_page)) {
    output.first_page = validateStringOrNumber(value.first_page, incrementOptions("first_page", opts));
  }
  if (defined(value.last_page)) {
    output.last_page = validateStringOrNumber(value.last_page, incrementOptions("last_page", opts));
  }
  if (defined(value.oxa)) {
    output.oxa = validateString(value.oxa, incrementOptions("oxa", opts));
  }
  if (defined(value.numbering)) {
    output.numbering = validateNumbering(value.numbering, incrementOptions("numbering", opts));
  }
  if (defined(value.math)) {
    output.math = validateMathMacroObject(value.math, incrementOptions("math", opts));
  }
  if (defined(value.abbreviations)) {
    const abbreviationsOpts = incrementOptions("abbreviations", opts);
    const abbreviations = Object.fromEntries(Object.entries((_a = validateObject(value.abbreviations, abbreviationsOpts)) !== null && _a !== void 0 ? _a : {}).map(([k, v]) => {
      if (v === null || v === false)
        return [k, null];
      const title = validateString(v, incrementOptions(k, abbreviationsOpts));
      const key = validateString(k, {
        ...incrementOptions(k, abbreviationsOpts),
        minLength: 2
      });
      if (!(key && title))
        return null;
      return [k, title];
    }).filter((v) => !!v));
    if (abbreviations && Object.keys(abbreviations).length > 0) {
      output.abbreviations = abbreviations;
    }
  }
  if (defined(value.exports)) {
    const exports = validateExportsList(value.exports, opts);
    if (exports)
      output.exports = exports;
  }
  if (defined(value.downloads)) {
    const downloads = validateDownloadsList(value.downloads, opts);
    if (downloads)
      output.downloads = downloads;
  }
  if (value.thumbnail === null) {
    output.thumbnail = null;
  } else if (defined(value.thumbnail)) {
    output.thumbnail = validateString(value.thumbnail, incrementOptions("thumbnail", opts));
  }
  if (defined(value.thumbnailOptimized)) {
    output.thumbnailOptimized = value.thumbnailOptimized;
  }
  if (value.banner === null) {
    output.banner = null;
  } else if (defined(value.banner)) {
    output.banner = validateString(value.banner, incrementOptions("banner", opts));
  }
  if (defined(value.bannerOptimized)) {
    output.bannerOptimized = value.bannerOptimized;
  }
  if (defined(value.settings)) {
    const settings = validateProjectAndPageSettings(value.settings, incrementOptions("settings", opts));
    if (settings)
      output.settings = settings;
  }
  if (value.edit_url === null) {
    output.edit_url = null;
  } else if (defined(value.edit_url)) {
    output.edit_url = validateUrl(value.edit_url, incrementOptions("edit_url", opts));
  }
  if (value.source_url === null) {
    output.source_url = null;
  } else if (defined(value.source_url)) {
    output.source_url = validateUrl(value.source_url, incrementOptions("source_url", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/kernelspec/validators.js
var KERNELSPEC_KEYS = ["name", "display_name", "language", "argv", "env"];
function validateKernelSpec(input, opts) {
  const value = validateObjectKeys(input, { optional: KERNELSPEC_KEYS }, opts);
  if (value === void 0)
    return void 0;
  let name;
  if (defined(value.name)) {
    const validatedName = validateString(value.name, incrementOptions("name", opts));
    if (validatedName === void 0)
      return void 0;
    name = validatedName;
  } else {
    name = "python3";
    validationWarning(`"name" key is required; using '${name}' as placeholder value`, opts);
  }
  let displayName;
  if (defined(value.display_name)) {
    const validatedDisplayName = validateString(value.display_name, incrementOptions("display_name", opts));
    if (validatedDisplayName === void 0)
      return void 0;
    displayName = validatedDisplayName;
  } else {
    displayName = `${name} Kernel`;
    validationWarning(`"display_name" key is required; using '${displayName}' as placeholder value`, opts);
  }
  const output = { name, display_name: displayName };
  if (defined(value.language)) {
    output.language = validateString(value.language, incrementOptions("language", opts));
  }
  if (defined(value.env)) {
    output.env = validateObject(value.env, incrementOptions("env", opts));
  }
  if (defined(value.argv)) {
    output.argv = validateList(value.argv, incrementOptions("argv", opts), (arg, index) => {
      return validateString(arg, incrementOptions(`argv.${index}`, opts));
    });
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/execute/validators.js
var EXECUTE_KEYS = ["skip", "depends_on_env", "cache"];
function validateExecute(input, opts) {
  const value = validateObjectKeys(input, { optional: EXECUTE_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.skip)) {
    output.skip = validateBoolean(value.skip, incrementOptions("skip", opts));
  }
  if (defined(value.depends_on_env)) {
    output.depends_on_env = validateList(value.depends_on_env, incrementOptions("depends_on_env", opts), (item, index) => validateString(item, incrementOptions(`depends_on_env.${index}`, opts)));
  }
  if (defined(value.cache)) {
    output.cache = validateBoolean(value.cache, incrementOptions("cache", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/jupytext/validators.js
var TEXT_REPRESENTATION_KEYS = ["extension", "format_name", "format_version", "jupytext_version"];
var JUPYTEXT_KEYS = ["formats", "text_representation"];
function validateTextRepresentation(input, opts) {
  const value = validateObjectKeys(input, { optional: TEXT_REPRESENTATION_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.extension)) {
    output.extension = validateString(value.extension, incrementOptions("extension", opts));
  }
  if (defined(value.format_name)) {
    output.format_name = validateString(value.format_name, incrementOptions("format_name", opts));
  }
  if (defined(value.format_version)) {
    const format_version = typeof value.format_version === "number" ? String(value.format_version) : value.format_version;
    output.format_version = validateString(format_version, incrementOptions("format_version", opts));
  }
  if (defined(value.jupytext_version)) {
    output.jupytext_version = validateString(value.jupytext_version, incrementOptions("jupytext_version", opts));
  }
  return output;
}
function validateJupytext(input, opts) {
  const value = validateObjectKeys(input, { optional: JUPYTEXT_KEYS }, opts);
  if (value === void 0)
    return void 0;
  const output = {};
  if (defined(value.formats)) {
    output.formats = validateString(value.formats, incrementOptions("formats", opts));
  }
  if (defined(value.text_representation)) {
    output.text_representation = validateTextRepresentation(value.text_representation, incrementOptions("text_representation", opts));
  }
  return output;
}

// ../../node_modules/myst-frontmatter/dist/page/validators.js
function validatePageFrontmatterKeys(value, opts) {
  var _a;
  const output = validateProjectAndPageFrontmatterKeys(value, opts);
  if (defined(value.label)) {
    output.label = validateString(value.label, incrementOptions("label", opts));
  }
  if (defined(value.kernelspec)) {
    output.kernelspec = validateKernelSpec(value.kernelspec, incrementOptions("kernelspec", opts));
  }
  if (defined(value.jupytext)) {
    output.jupytext = validateJupytext(value.jupytext, incrementOptions("jupytext", opts));
  }
  if (defined(value.execute)) {
    output.execute = validateExecute(value.execute, incrementOptions("execute", opts));
  }
  if (defined(value.skip_execution)) {
    (_a = output.execute) !== null && _a !== void 0 ? _a : output.execute = {};
    if (defined(output.execute.skip)) {
      validationWarning(`both execute.skip and deprecated skip_execution are defined, taking execute.skip`, opts);
    } else {
      validationWarning(`skip_execution is deprecated in favour of execute.skip`, opts);
      output.execute.skip = validateBoolean(value.skip_execution, incrementOptions("skip_execution", opts));
    }
  }
  if (defined(value.enumerator)) {
    output.enumerator = validateString(value.enumerator, incrementOptions("enumerator", opts));
  }
  if (defined(value.content_includes_title)) {
    output.content_includes_title = validateBoolean(value.content_includes_title, incrementOptions("content_includes_title", opts));
  }
  if (defined(value.site)) {
    output.site = validateObject(value.site, incrementOptions("site", opts));
  }
  return output;
}
function validatePageFrontmatter(input, opts) {
  const value = validateObjectKeys(input, { optional: PAGE_FRONTMATTER_KEYS, alias: { ...FRONTMATTER_ALIASES, name: "label" } }, opts) || {};
  return validatePageFrontmatterKeys(value, opts);
}

export {
  incrementOptions,
  validationWarning,
  fillMissingKeys,
  normalizeJsonToString,
  stashPlaceholder,
  isStashPlaceholder,
  doi,
  CREDIT_URL,
  normalize2 as normalize,
  validate2 as validate,
  buildUrl2 as buildUrl,
  orcid,
  fillNumbering,
  validatePageFrontmatter
};
//# sourceMappingURL=/build/_shared/chunk-7SI5XUIQ.js.map
